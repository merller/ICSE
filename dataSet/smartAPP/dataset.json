[
    {
        "code": "initialize()\n}\n\ndef updated()\n{\n\tlog.debug \"Updated with settings: ${settings}.\"\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize()\n{\n\tsubscribe(motionSensor, \"motion\", motionHandler)\n    if (lights != null && lights != \"\" && dimmers != null && dimmers != \"\")\n    \t{\n        log.debug \"$lights subscribing...\"\n    \tsubscribe(lights, \"switch\", lightsHandler)\n        log.debug \"$dimmers subscribing...\"\n    \tsubscribe(dimmers, \"switch\", dimmersHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$lights and $dimmers will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$lights and $dimmers will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$lights and $dimmers will turn ON when movement detected...\"\n            }\n    \t}\n    else if (lights != null && lights != \"\")\n    \t{\n        log.debug \"$lights subscribing...\"\n    \tsubscribe(lights, \"switch\", lightsHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$lights will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$lights will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$lights will turn ON when movement detected...\"\n            }\n    \t}\n\telse if (dimmers != null && dimmers != \"\")\n    \t{\n        log.debug \"$dimmers subscribing...\"\n    \tsubscribe(dimmers, \"switch\", dimmersHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$dimmers will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$dimmers will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$dimmers will turn ON when movement detected...\"\n            }\n    \t}\n        log.debug \"Determinating lights and dimmers current value...\"\n        if (lights != null && lights != \"\")\n        \t{\n            if (lights.currentValue(\"switch\").toString().contains(\"on\"))\n                {\n                state.lightsState = \"on\"\n                log.debug \"Lights $state.lightsState.\"\n                }\n            else if (lights.currentValue(\"switch\").toString().contains(\"off\"))\n                {\n                state.lightsState = \"off\"\n                log.debug \"Lights $state.lightsState.\"\n                }\n            else\n                {\n                log.debug \"ERROR!\"\n                }\n\t\t\t}\n\t\tif (dimmers != null && dimmers != \"\")\n        \t{\n            if (dimmers.currentValue(\"switch\").toString().contains(\"on\"))\n                {\n                state.dimmersState = \"on\"\n                log.debug \"Dimmers $state.dimmersState.\"\n                }\n            else if (dimmers.currentValue(\"switch\").toString().contains(\"off\"))\n                {\n                state.dimmersState = \"off\"\n                log.debug \"Dimmers $state.dimmersState.\"\n                }\n            else\n                {\n                log.debug \"ERROR!\"\n                }\n\t\t\t}\n}",
        "docstring": "Turn ON light(s) and/or dimmer(s) when there's movement and the room is dark with illuminance threshold and/or between sunset and sunrise. Then turn OFF after X minute(s) when the brightness of the room is above the illuminance threshold or turn OFF after X minute(s) when there is no movement."
    },
    {
        "code": "def appTouch(evt) {\n\tlog.debug \"changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes\"\n    if (location.mode != newMode) {\n   \t\t\tsetLocationMode(newMode)\n\t\t\tlog.debug \"Changed the mode to '${newMode}'\"\n    }\telse {\n    \tlog.debug \"New mode is the same as the old mode, leaving it be\"\n    \t}\n    log.debug \"appTouch: $evt\"\n    lock1.lock()\n    switcheson.on()\n    def delay = (waitfor != null && waitfor != \"\") ? waitfor * 1000 : 120000\n\tswitchesoff.off(delay: delay)\n}",
        "docstring": "Some on, some off with delay for bedtime, Lock The Doors"
    },
    {
        "code": "def switchOnHandler(evt) {\n    log.debug \"trigger turned on!\"\n    \n    def timeDelay = minutes * 60\t\t\t\t\t\t\t\t\t// convert minutes to seconds.\n    runIn (timeDelay, lightsOut)\t\t\t\t\t\t\t\t\t// schedule the lights out procedure\n\n\tdef phrase = \"\"\t\t\t\t\t\t\t\t\t\t\t\t\t// Make sure Phrase is empty at the start of each run.\n\n    doors.each { doorOpen ->\t\t\t\t\t\t\t\t\t\t// cycles through all contact sensor devices selected\n    \tif (doorOpen.currentContact == \"open\") {\t\t\t\t\t// if the current selected device is open, then:\n            log.debug \"$doorOpen.displayName\"\t\t\t\t\t\t// echo to the simulator the device's name\n    \t\tdef toReplace = doorOpen.displayName\t\t\t\t\t// make variable 'toReplace' = the devices name.\n\t\t\tdef replaced = toReplace.replaceAll(' ', '%20')\t\t\t// make variable 'replaced' = 'toReplace' with all the space changed to %20\n\t\t\tlog.debug replaced\t\t\t\t\t\t\t\t\t\t// echo to the simulator the new name.\n            \n            phrase = phrase.replaceAll('%20And%20', '%20')\t\t\t// Remove any previously added \"and's\" to make it sound natural.\n\n\t\t\tif (phrase == \"\") {\t\t\t\t\t\t\t\t\t\t// If Phrase is empty (ie, this is the first name to be added)...\n            \tphrase = \"The%20\" + replaced \t\t\t\t\t\t// ...then add \"The%20\" plus the device name.\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t// If Phrase isn't empty...\n            \tphrase = phrase + \",%20And%20The%20\" + replaced\t\t// ...then add \",%20And%20The%20\".\n\t\t\t}\n            \n            log.debug phrase  \t\t\t\t\t\t\t\t\t\t// Echo the current version of 'Phrase'            \n        }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Closes the IF statement.\n    }    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Closes the doors.each cycle\n    \t\n    if (phrase == \"\") {\n    \tphrase = \"The%20house%20is%20ready%20for%20night.\"\n    \t}\n    else {\n    \tphrase = \"You%20have%20left%20\" + phrase + \"open\"\n    }\n    \n    httpGet(\"https://portal.theubi.com/webapi/behaviour?access_token=${behaviorToken}&variable=${phrase}\")\n          \t\t\t\t// send the http request and push the device name (replaced) as the variable.\n\t\t\t\t\t\t// On the Ubi side you need to setup a custom behavior (which you've already done to get the token)\n                        // and have say something like: \"Hold on!  The ${variable} is open!\"  Ubi will then take 'replaced'\n                        // from this http request and insert it into the phrase that it says.\n    \t    \n\tif (sayPhrase == \"Yes\") {\t\t\t\t\t\t\t\t\t\t// If the user selected to say Goodnight...\n        location.helloHome.execute(\"Good Night!\")\t\t\t\t\t// ...say goodnight to Hello Home.\n    }",
        "docstring": "An app to coordinate bedtime activities between Ubi and SmartThings.  This app will activate when a Virtual Tile is triggers (Setup custom behavior in Ubi to turn on this tile when you say goodnight to ubi).  This app will then turn off selected lights after a specified number of minutes.  It will also check if any doors or windows are open.  If they are, Ubi will tell you which ones are open.  Finally, the app will say goodnight to hello home if requested."
    },
    {
        "code": "def checkServer() {\n    log.debug \"Checking Server Now\"\n\n\tdef successColor = state.successColor\n    def failColor = state.failColor\n\n    def basicCredentials = \"${jenkinsUsername}:${jenkinsPassword}\"\n    def encodedCredentials = basicCredentials.encodeAsBase64().toString()\n    def basicAuth = \"Basic ${encodedCredentials}\"\n\n    def head = [\"Authorization\": basicAuth]\n\n    log.debug \"Auth ${head}\"\n\n\tdef host = jenkinsUrl.contains(\"lastBuild/api/json\") ? jenkinsUrl : \"${jenkinsUrl}/lastBuild/api/json\"\n\n    httpGet(uri: host, headers: [\"Authorization\": \"${basicAuth}\"]) { resp ->\n    \tdef buildError = (resp.data.result == \"FAILURE\")\n        def buildSuccess = (resp.data.result == \"SUCCESS\")\n        log.debug \"Build Success? ${buildSuccess}\"\n        if (buildError) {\n            switches?.on()\n            hues?.setColor(failColor)\n        } else if (buildSuccess) {\n            switches?.off()\n            hues?.setColor(successColor)\n        } // else in some other state, probably building, do nothing.\n\n    }\n}",
        "docstring": "Turn off and on devices based on the state that your Jenkins Build is in."
    },
    {
        "code": "def helloActions() {\n\tdef actions = location.helloHome?.getPhrases()*.label\n    if(!actions) {\n    \treturn []\n    }\n\treturn actions\n}\ndef executeAction() {\n    def actions = location.helloHome?.getPhrases()*.label\n    def a = actions?.find() { it == params.label }\n    if (!a) {\n        httpError(400, \"invalid label $params.label\")\n        return\n    }\n    location.helloHome?.execute(params.label)\n}\n/*  this is the primary function called to query at the structure and its devices */\ndef structureInfo() { //list all devices\n\tdef list = [:]\n    def currId = location.id\n    list[currId] = [:]\n    list[currId].name = location.name\n    list[currId].id = location.id\n    list[currId].temperatureScale = location.temperatureScale\n    list[currId].devices = [:]\n  \n    def setValues = {\n   \t\tif (params.brief) {\n            return [id: it.id, name: it.displayName]\n        }\n        def newList = [id: it.id, name: it.displayName, suppCapab: it.capabilities.collect {\n            \"$it.name\"\n        }, suppAttributes: it.supportedAttributes.collect {\n            \"$it.name\"      \n        }, suppCommands: it.supportedCommands.collect {\n            \"$it.name\"      \n        }]\n\n        return newList\n    }\n    switches?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n    thermostats?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n    windowShades?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n\n    return list\n\n}\n/*  This function returns all of the current values of the specified Devices attributes */\ndef acquiredata() {\n\tdef resp = [:]\n    if (!params.id) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def dev = switches.find() { it.id == params.id } ?: windowShades.find() { it.id == params.id } ?:\n    \tthermostats.find() { it.id == params.id }    \n   \n    if (!dev) {\n    \thttpError(400, \"invalid id $params.id\")\n        return    \n    }\n    def att = dev.supportedAttributes\n    att.each {\n    \tresp[it.name] = dev.currentValue(\"$it.name\")\n    }\n    return resp\n}\n\nvoid updateSwitch() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef sw = switches.find() { it.id == params.id }\n    if (!sw) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    switch(command) {\n        case \"on\":\n        \tif ( sw.currentSwitch != \"on\" ) {\n            \tsw.on()\n            }\n            break\n        case \"off\":\n        \tif ( sw.currentSwitch != \"off\" ) {\n            \tsw.off()\n            }\n            break\n        default:\n            httpError(400, \"$command is not a valid\")\n    }\n}\n\n\nvoid updateThermostat() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef therm = thermostats.find() { it.id == params.id }\n    if (!therm || !command) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def passComm = [\n        \"off\",\n        \"heat\",\n        \"emergencyHeat\",\n        \"cool\",\n        \"fanOn\",\n        \"fanAuto\",\n        \"fanCirculate\",\n        \"auto\"\n\n\t]\n    def passNumParamComm = [\n    \t\"setHeatingSetpoint\",\n    \t\"setCoolingSetpoint\",   \n    ]\n    def passStringParamComm = [\n        \"setThermostatMode\",\n        \"setThermostatFanMode\",\n\t]\n    if (command in passComm) {\n    \ttherm.\"$command\"()\t\n    } else if (command in passNumParamComm && params.p1 && params.p1.isFloat()) {\n    \ttherm.\"$command\"(Float.parseFloat(params.p1))\t\n    } else if (command in passStringParamComm && params.p1) {\n    \ttherm.\"$command\"(params.p1)\t\n    } else {\n    \thttpError(400, \"$command is not a valid command\")\n    }\n}\n\nvoid updateWindowShade() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef ws = windowShades.find() { it.id == params.id }\n    if (!ws || !command) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def passComm = [\n\t\t\"open\",\n        \"close\",\n        \"presetPosition\",\n\t]\n    if (command in passComm) {\n    \tws.\"$command\"()\t\t\n    } else {\n    \thttpError(400, \"$command is not a valid command\")\n    }\n}\n// TODO: implement event handlers",
        "docstring": "Act as an endpoint so user's of Gidjit can quickly access and control their devices and execute routines. Users can do this quickly as Gidjit filters these actions  based on their environment"
    },
    {
        "code": "void clearBeacons() {\n  removeChildDevices(getChildDevices())\n}\n\nvoid addBeacon() {\n  def beacon = request.JSON?.beacon\n  if (beacon) {\n    def beaconId = \"BeaconThings\"\n    if (beacon.major) {\n      beaconId = \"$beaconId-${beacon.major}\"\n      if (beacon.minor) {\n        beaconId = \"$beaconId-${beacon.minor}\"\n      }\n    }\n    log.debug \"adding beacon $beaconId\"\n    def d = addChildDevice(\"com.obycode\", \"BeaconThing\", beaconId,  null, [label:beacon.name, name:\"BeaconThing\", completedSetup: true])\n    log.debug \"addChildDevice returned $d\"\n\n    if (beacon.present) {\n      d.arrive(beacon.present)\n    }\n    else if (beacon.presence) {\n      d.setPresence(beacon.presence)\n    }\n  }\n}\n\nvoid updateBeacon() {\n  log.debug \"updating beacon ${params.id}\"\n  def beaconDevice = getChildDevice(params.id)\n  // def children = getChildDevices()\n  // def beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n  if (!beaconDevice) {\n    log.debug \"Beacon not found directly\"\n    def children = getChildDevices()\n    beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n    if (!beaconDevice) {\n      log.debug \"Beacon not found in list either\"\n      return\n    }\n  }\n\n  // This could be just updating the presence\n  def presence = request.JSON?.presence\n  if (presence) {\n    log.debug \"Setting ${beaconDevice.label} to $presence\"\n    beaconDevice.setPresence(presence)\n  }\n\n  // It could be someone arriving\n  def arrived = request.JSON?.arrived\n  if (arrived) {\n    log.debug \"$arrived arrived at ${beaconDevice.label}\"\n    beaconDevice.arrived(arrived)\n  }\n\n  // It could be someone left\n  def left = request.JSON?.left\n  if (left) {\n    log.debug \"$left left ${beaconDevice.label}\"\n    beaconDevice.left(left)\n  }\n\n  // or it could be updating the name\n  def beacon = request.JSON?.beacon\n  if (beacon) {\n    beaconDevice.label = beacon.name\n  }\n}\n\nvoid deleteBeacon() {\n  log.debug \"deleting beacon ${params.id}\"\n  deleteChildDevice(params.id)\n  // def children = getChildDevices()\n  // def beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n  // if (beaconDevice) {\n  //   deleteChildDevice(beaconDevice.deviceNetworkId)\n  // }\n}\n\nprivate removeChildDevices(delete) {\n  delete.each {\n    deleteChildDevice(it.deviceNetworkId)\n  }\n}",
        "docstring": "SmartApp to interact with the BeaconThings iOS app. Use this app to integrate iBeacons into your smart home."
    },
    {
        "code": "private String convertIPtoHex(ipAddress) {\n    String hex = ipAddress.tokenize( '.' ).collect {  String.format( '%02X', it.toInteger() ) }.join()\n    return hex\n\n}\n\nprivate String convertPortToHex(port) {\n    String hexport = port.toString().format( '%04X', port.toInteger() )\n    return hexport\n}",
        "docstring": "Use this free SmartApp in conjunction with the ObyThing Music app for your Mac to control and automate music and more with iTunes and SmartThings."
    },
    {
        "code": "def initialize() {\n    schedule(timeToday(timeOfDay, location?.timeZone), \"checkPresence\")\n    if (customName) {\n      app.setTitle(customName)\n    }\n}\n\ndef checkPresence() {\n    if (daysOk && modeOk) {\n        if (person.latestValue(\"presence\") == \"present\") {\n            log.debug \"${person} is present, triggering WFH action.\"\n            location.helloHome.execute(settings.wfhPhrase)\n            def message = \"${location.name} executed '${settings.wfhPhrase}' because ${person} is home.\"\n            send(message)\n        }\n    }\n}\n\nprivate send(msg) {\n    if (sendPushMessage != \"No\") {\n        sendPush(msg)\n    }\n\n    if (phone) {\n        sendSms(phone, msg)\n    }\n\n    log.debug msg\n}\n\nprivate getModeOk() {\n    def result = !modes || modes.contains(location.mode)\n    result\n}\n\nprivate getDaysOk() {\n    def result = true\n    if (days) {\n        def df = new java.text.SimpleDateFormat(\"EEEE\")\n        if (location.timeZone) {\n            df.setTimeZone(location.timeZone)\n        }\n        else {\n            df.setTimeZone(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n        }\n        def day = df.format(new Date())\n        result = days.contains(day)\n    }\n    result\n}\n\nprivate hideOptions() {\n    (days || modes)? false: true\n}",
        "docstring": "If after a particular time of day a certain person is still at home, trigger a 'Working From Home' action."
    },
    {
        "code": "def listAllDevices() {\n   \tdef resp = []\n   \tswitches.each {\n      resp << [name: it.name, label: it.label, value: it.currentValue(\"switch\"), type: \"switch\", id: it.id, hub: it.hub?.name]\n    }\n    \n    locks.each {\n      resp << [name: it.name, label: it.label, value: it.currentValue(\"lock\"), type: \"lock\", id: it.id, hub: it.hub?.name]\n    }\n    return resp\n}\n \n// returns a list like\n// [[name: \"kitchen lamp\", value: \"off\"], [name: \"bathroom\", value: \"on\"]]\ndef listSwitches() {\n    def resp = []\n    switches.each {\n      resp << [name: it.displayName, value: it.currentValue(\"switch\"), type: \"switch\", id: it.id]\n    }\n    return resp\n}\n\nvoid updateLocks() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\n    if (command) {\n\n        // check that the switch supports the specified command\n        // If not, return an error using httpError, providing a HTTP status code.\n        locks.each {\n            if (!it.hasCommand(command)) {\n                httpError(501, \"$command is not a valid command for all switches specified\")\n            } \n        }\n        \n        // all switches have the comand\n        // execute the command on all switches\n        // (note we can do this on the array - the command will be invoked on every element\n        locks.\"$command\"()\n    }\n}\n\nvoid updateLock() {\n    def command = params.command\n    \n    locks.each {\n      \tif (!it.hasCommand(command)) {\n            httpError(400, \"$command is not a valid command for all lock specified\")\n        }\n        \n        if (it.id == params.id) {\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid updateSwitch() {\n    def command = params.command\n    \n    switches.each {\n      \tif (!it.hasCommand(command)) {\n            httpError(400, \"$command is not a valid command for all switches specified\")\n        }\n        \n        if (it.id == params.id) {\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid commandDevice() {\n    def command = params.command\n    def devices = []\n    \n    switches.each {\n    \tdevices << it\n    }\n    \n    locks.each {\n    \tdevices << it\n    }\n    \n    devices.each {\n        if (it.id == params.id) {\n            if (!it.hasCommand(command)) {\n                httpError(400, \"$command is not a valid command for specified device\")\n            }\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid updateSwitches() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\n    if (command) {\n\n        // check that the switch supports the specified command\n        // If not, return an error using httpError, providing a HTTP status code.\n        switches.each {\n            if (!it.hasCommand(command)) {\n                httpError(400, \"$command is not a valid command for all switches specified\")\n            } \n        }\n        \n        // all switches have the comand\n        // execute the command on all switches\n        // (note we can do this on the array - the command will be invoked on every element\n        switches.\"$command\"()\n    }\n}\n\n def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n}",
        "docstring": "Allows Vinli users to connect their car to SmartThings"
    },
    {
        "code": "def installed() {}\n\ndef updated() {}\n\ndef index(){\n    [[url: \"/switches\"]]\n}\n\ndef listSwitches() {\n  switches.collect { device(it,\"switch\") }\n}\nvoid updateSwitches() {\n  updateAll(switches)\n}\ndef showSwitch() {\n  show(switches, \"switch\")\n}\nvoid updateSwitch() {\n  update(switches)\n}\n\nprivate void updateAll(devices) {\n  def command = request.JSON?.command\n  if (command) {\n    switch(command) {\n      case \"on\":\n      devices*.on()\n      break\n      case \"off\":\n      devices*.off()\n      break\n      default:\n      httpError(403, \"Access denied. This command is not supported by current capability.\")\n    }\n  }\n}\n\nprivate void update(devices) {\n  log.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n  def command = request.JSON?.command\n  if (command) {\n  def device = devices.find { it.id == params.id }\n  if (!device) {\n  httpError(404, \"Device not found\")\n  } else {\n  switch(command) {\n  case \"on\":\n  device.on()\n  break\n  case \"off\":\n  device.off()\n  break\n  default:\n  httpError(403, \"Access denied. This command is not supported by current capability.\")\n  }\n  }\n  }\n}\n\nprivate show(devices, name) {\n  def d = devices.find { it.id == params.id }\n  if (!d) {\n  httpError(404, \"Device not found\")\n  }\n  else {\n        device(d, name)\n  }\n}\n\nprivate device(it, name){\n    if(it) {\n  def s = it.currentState(name)\n  [id: it.id, label: it.displayName, name: it.displayName, state: s]\n    }\n}",
        "docstring": "This SmartApp allows you to interact with the switches in your physical graph through Curb."
    },
    {
        "code": "def installed() {\n  resetClocking();\n  initialize();\n}\n\ndef updated() {\n  runAutomation();\n  unsubscribe();\n  initialize();\n}\n\ndef initialize() {\n  subscribe(meter, \"power\", checkEnergyMonitor);\n  runEvery1Minute(runAutomation);\n}\n\n// Returns true if we are in a selected automation time\ndef checkRunning() {\n  def df = new java.text.SimpleDateFormat(\"EEEE\");\n  df.setTimeZone(location.timeZone);\n\n  if (weekdays.contains( df.format(new Date()) )) {\n    // We're in an enabled weekday\n    def hf = new java.text.SimpleDateFormat(\"H\");\n    hf.setTimeZone(location.timeZone);\n\n    if (hours.contains(hf.format(new Date()).toString())) {\n      // We're in an enabled hour\n      return true\n    }\n  }\n  return false\n}\n\n// Creates the message and sends the push notification\ndef sendNotifications() {\n  def devlist = []\n  def count = 0\n  def currentTotal = Float.parseFloat(meter.currentState(\"power\").value)\n  def message = \"Curb Alert: Energy usage is projected to go over selected threshold.\"\n\n  for(c in circuits) {\n    try {\n      if (c.toString() == \"Total Power Usage\") { continue }\n      if (c.toString() == \"Total Power Grid Impact\") { continue }\n      devlist.add([ pct: ((Float.parseFloat(c.currentState(\"power\").value) / currentTotal) * 100).round(), name: c.toString() ])\n      count += count\n    } catch (e) {\n      // sometimes we get circuits with no power value\n      log.debug(e);\n    }\n  }\n  if (devlist.size() > 3) {\n      def sorted = devlist.sort { a, b -> b.pct <=> a.pct }\n      message += \"Your biggest consumers currently are: ${sorted[0].name} ${sorted[0].pct}%, ${sorted[1].name} ${sorted[1].pct}%, and ${sorted[2].name} ${sorted[2].pct}%\"\n  }\n  sendPush(message)\n}\n\n// Resets the absolute time window\ndef resetClocking() {\n  state.readings = []\n  state.usage = 0\n  if (state.throttling == true) {\n    stopThrottlingUsage()\n  }\n}\n\n//\ndef runAutomation() {\n  if ( !enabled ) { return }\n  if ( !checkRunning() ) { return }\n\n  def mf = new java.text.SimpleDateFormat(\"m\")\n  def minute = Integer.parseInt(mf.format(new Date())) % Integer.parseInt(timeInterval)\n  def samples = 0.0\n  state.usage = 0.0\n\n  if (minute == 0) {\n    // This is the first minute of the process, reset variables\n    resetClocking()\n  }\n\n  if (minute < Float.parseFloat(timeInterval) * (Float.parseFloat(projectionPeriod) / 100) ) {\n    //We're in the projection period. Do not throttle\n    return\n  }\n\n  for (int i = 0; i < Integer.parseInt(timeInterval); i++) {\n    if (state.readings[i] != null) {\n      samples = samples + 1.0\n      log.debug(samples)\n      state.usage = state.usage + (state.readings[i] / 1000)\n      log.debug(state.usage)\n    }\n  }\n\n  if (samples != 0.0) {\n    def avgedUsage = minute * ( state.usage / samples ) / Float.parseFloat(timeInterval)\n    log.debug(\"minute: \" + minute)\n    log.debug(\"usage: \" + avgedUsage)\n    def safetyThreshold = ( Float.parseFloat(kwhThreshold) * ( 1 - (Float.parseFloat(safetyMargin) / 100)))\n    log.debug(safetyThreshold)\n    if (avgedUsage > safetyThreshold) {\n      throttleUsage()\n    }\n  }\n\n}\n\n// Saves power reading in circular buffer\ndef checkEnergyMonitor(evt) {\n  def mf = new java.text.SimpleDateFormat(\"m\")\n  def minute = Integer.parseInt(mf.format(new Date())) % Integer.parseInt(timeInterval)\n\n  def power = meter.currentState(\"power\").value\n  state.readings[minute] = Float.parseFloat(power)\n}\n\n// Gets and saves the current controller state for use during state restore\ndef captureContollerStates() {\n  if (!state.throttling) {\n    for (t in thermostats) {\n      state[t.id] = t.currentState(\"thermostatMode\").value\n    }\n    for (s in switches) {\n      state[s.id] = s.currentState(\"switch\").value\n    }\n  }\n}\n\n// Sets thermostats\ndef throttleUsage() {\n  if (state.throttling) {\n    return\n  }\n  captureContollerStates()\n  sendNotifications()\n  state.throttling = true\n\n  for (t in thermostats) {\n    t.off()\n  }\n\n  for (s in switches) {\n    s.off()\n  }\n}\n\n// Restores controller states to previously stored values\ndef stopThrottlingUsage() {\n    state.throttling = false\n    for (t in thermostats) {\n      if (!state[t.id]) {\n        continue\n      }\n      t.setThermostatMode(state[t.id])\n    }\n\n    for (s in switches) {\n      if (!state[s.id]) {\n        continue\n      }\n      state[s.id] == \"on\" ? s.on() : s.off()\n    }\n}",
        "docstring": "Maximize your energy savings with CURB"
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    removeChildDevices(getChildDevices())\n\n    initialize()\n}\n\ndef initialize() {\n    log.debug \"Initializing\"\n    unschedule()\n\n    def curbCircuits = getCurbCircuits()\n    log.debug \"Found devices: ${curbCircuits}\"\n    log.debug settings\n    runEvery1Minute(getPowerData)\n    if (settings.energyInterval==\"Hour\" || settings.energyInterval == \"Half Hour\" || settings.energyInterval == \"Fifteen Minutes\")\n    {\n      runEvery1Minute(getKwhData)\n    } else {\n      runEvery1Hour(getKwhData)\n    }\n}\n\ndef uninstalled() {\n    log.debug \"Uninstalling\"\n    removeChildDevices(getChildDevices())\n}\n\ndef authPage() {\n\n    if (!state.accessToken) {\n        state.accessToken = createAccessToken()\n    }\n\n    if (state.authToken) {\n    \tgetCurbLocations()\n        return dynamicPage(name: \"auth\", title: \"Login Successful\", nextPage: \"\", install: true, uninstall: true) {\n            section() {\n                paragraph(\"Select your CURB Location\")\n                input(\n                    name: \"curbLocation\",\n                    type: \"enum\",\n                    title: \"CURB Location\",\n                    options: state.locations\n\n                )\n                input(\n                  name: \"energyInterval\",\n                  type: \"enum\",\n                  title: \"Energy Interval\",\n                  options: [\"Billing Period\", \"Day\", \"Hour\", \"Half Hour\", \"Fifteen Minutes\"],\n                  defaultValue: \"Hour\"\n                  )\n            }\n        }\n    } else {\n        return dynamicPage(name: \"auth\", title: \"Login\", nextPage: \"\", uninstall: false) {\n            section() {\n                paragraph(\"Tap below to log in to the CURB service and authorize SmartThings access\")\n                href url: buildRedirectUrl, style: \"embedded\", required: true, title: \"CURB\", description: \"Click to enter CURB Credentials\"\n            }\n        }\n    }\n}\n\ndef oauthInitUrl() {\n\n    log.debug \"Initializing oauth\"\n    state.oauthInitState = UUID.randomUUID().toString()\n    def oauthParams = [\n        response_type: \"code\",\n        scope: \"offline_access\",\n        audience: \"app.energycurb.com/api\",\n        client_id: appSettings.clientId,\n        connection: \"Users\",\n\n        state: state.oauthInitState,\n        redirect_uri: callbackUrl\n    ]\n    redirect(location: \"${curbLoginUrl}?${toQueryString(oauthParams)}\")\n}\n\ndef callback() {\n\n    log.debug \"Oauth callback: ${params}\"\n    def code = params.code\n    def oauthState = params.state\n    if (oauthState == state.oauthInitState) {\n        def tokenParams = [\n            grant_type: \"authorization_code\",\n            code: code,\n            client_id: appSettings.clientId,\n            client_secret: appSettings.clientSecret,\n            redirect_uri: callbackUrl\n        ]\n\n        asynchttp_v1.post(handleTokenResponse, [uri: curbTokenUrl, body: tokenParams])\n        success()\n    } else {\n        log.error \"callback() failed oauthState != state.oauthInitState\"\n    }\n}\n\ndef handleTokenResponse(resp, data){\n\tstate.refreshToken = resp.json.refresh_token\n    state.authToken = resp.json.access_token\n}\n\nprivate removeChildDevices(delete) {\n    delete.each {\n        deleteChildDevice(it.deviceNetworkId)\n    }\n}\n\ndef updateChildDevice(dni, value) {\n    try {\n        def existingDevice = getChildDevice(dni)\n        existingDevice?.handlePower(value)\n    } catch (e) {\n        log.error \"Error updating device: ${e}\"\n    }\n}\n\ndef createChildDevice(dni, label) {\n    log.debug \"Creating child device with DNI ${dni} and name ${label}\"\n    return addChildDevice(\"curb\", \"CURB Power Meter\", dni, null, [name: \"${dni}\", label: \"${label}\"])\n}\n\ndef getCurbCircuits() {\n    getPowerData(true)\n}\n\ndef getCurbLocations() {\n    log.debug \"Getting curb locations\"\n    def params = [\n        uri: \"http://app.energycurb.com\",\n        path: \"/api/locations\",\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"]\n    ]\n    def allLocations = [:]\n    try {\n        httpGet(params) {\n            resp ->\n            resp.data.each {\n                log.debug \"Found location: ${it}\"\n                allLocations[it.id] = it.label\n            }\n            state.locations = allLocations\n        }\n    } catch (e) {\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef getPowerData(create=false) {\n  log.debug \"Getting data at ${settings.curbLocation} with token: ${state.authToken}\"\n    def params = [\n        uri: \"https://app.energycurb.com\",\n        path: \"/api/aggregate/${settings.curbLocation}/2m/s\",\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"],\n        requestContentType: 'application/json'\n    ]\n    try {\n    \thttpGet(params) { resp ->\n            processData(resp, null, create, false)\n            return resp.data.circuits\n        }\n    } catch (e) {\n    \trefreshAuthToken()\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef getKwhData() {\n  log.debug \"Getting kwh data at ${settings.curbLocation} with token: ${state.authToken}\"\n  def url = \"/api/aggregate/${settings.curbLocation}/\"\n\n  if (settings.energyInterval == \"Hour\"){ url = url + \"1h/m\"}\n  if (settings.energyInterval == \"Billing Period\"){ url = url + \"billing/h\"}\n  if (settings.energyInterval == \"Half Hour\"){ url = url + \"30m/m\"}\n  if (settings.energyInterval == \"Day\"){ url = url + \"24h/h\"}\n  if (settings.energyInterval == \"Fifteen Minutes\"){ url = url + \"15m/m\"}\n\tlog.debug \"KWH FOR: ${url}\"\n    def params = [\n        uri: \"https://app.energycurb.com\",\n        path: url,\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"],\n        requestContentType: 'application/json'\n    ]\n    try {\n    \thttpGet(params) { resp ->\n            processData(resp, null, false, true)\n            return\n        }\n    } catch (e) {\n    \trefreshAuthToken()\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef processData(resp, data, create=false, energy=false)\n{\n    log.debug \"Processing usage data: ${resp.data}\"\n    if (!isOK(resp)) {\n\n        refreshAuthToken()\n        log.error \"Usage Response Error: ${resp.getErrorMessage()}\"\n        return\n    }\n    def main = 0.0\n    def production = 0.0\n    def all = 0.0\n    def hasProduction = false\n    def hasMains = false\n    if (resp.data) {\n        resp.data.each {\n        \tdef numValue = 0.0\n        \tif(energy){\n            \tnumValue=it.kwhr.floatValue()\n            } else {\n            \tnumValue=it.avg\n            }\n        \tall += numValue\n            if (!it.main && !it.production && it.label != null && it.label != \"\") {\n            \tif (create) { createChildDevice(\"${it.id}\", \"${it.label}\") }\n                energy ?  getChildDevice(\"${it.id}\")?.handleKwhBilling(numValue.floatValue()) : updateChildDevice(\"${it.id}\", numValue)\n            }\n            if (it.grid) {\n              hasMains = true\n              main += numValue\n            }\n            if (it.production) {\n              hasProduction = true\n              production += numValue\n            }\n        }\n\n        if (create) { createChildDevice(\"__NET__\", \"Net Grid Impact\") }\n\n        if (!hasMains) {\n        \tmain = all\n        }\n\n        energy ? getChildDevice(\"__NET__\")?.handleKwhBilling(main) : updateChildDevice(\"__NET__\", main)\n        if (hasProduction) {\n          if (create) { createChildDevice(\"__PRODUCTION__\", \"Production\") }\n          if (create) { createChildDevice(\"__CONSUMPTION__\", \"Consumption\") }\n          energy ? getChildDevice(\"__PRODUCTION__\")?.handleKwhBilling(production) : updateChildDevice(\"__PRODUCTION__\", production)\n          energy ? getChildDevice(\"__CONSUMPTION__\")?.handleKwhBilling(main-production) : updateChildDevice(\"__CONSUMPTION__\", main-production)\n        }\n    }\n    if ( create && !energy){\n    \tgetKwhData()\n    }\n\n}\n\ndef toQueryString(Map m) {\n    return m.collect {\n        k, v -> \"${k}=${URLEncoder.encode(v.toString())}\"\n    }.sort().join(\"&\")\n}\n\ndef refreshAuthToken() {\n\n    log.debug \"Refreshing auth token\"\n    if (!state.refreshToken) {\n\n        log.warn \"Can not refresh OAuth token since there is no refreshToken stored\"\n    } else {\n        def tokenParams = [\n            grant_type: \"refresh_token\",\n            client_id: appSettings.clientId,\n            client_secret: appSettings.clientSecret,\n            refresh_token: state.refreshToken\n\n        ]\n\n        httpPostJson([uri: curbTokenUrl, body: tokenParams]) {\n            resp ->\n                state.authToken = resp.data.access_token\n                log.debug \"Got authToken: ${state.authToken}\"\n        }\n    }\n}\n\n//THIS DEFINES THE SCREEN AFTER AUTHORIZATION:\n\ndef success() {\n  def message = \"\"\"\n        <p>Your Curb account is now connected to SmartThings!</p>\n        <p>Click 'Done' to finish setup.</p>\n    \"\"\"\n  connectionStatus(message)\n}\n\ndef fail() {\n  def message = \"\"\"\n        <p>The connection could not be established!</p>\n        <p>Click 'Done' to return to the menu.</p>\n    \"\"\"\n  connectionStatus(message)\n}\n\ndef connectionStatus(message, redirectUrl = null) {\n  def redirectHtml = \"\"\n  if (redirectUrl) {\n    redirectHtml = \"\"\"\n      <meta http-equiv=\"refresh\" content=\"3; url=${redirectUrl}\" />\n    \"\"\"\n  }\n\n  def isOK(response) {\n  response.status in [200, 201]\n}",
        "docstring": "Gain insight into energy usage throughout your home."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    state.active = false;\n    subscribe(sensor, \"carbonDioxide\", 'handleLevel')\n}\n\ndef handleLevel(evt) {\n    def co2 = sensor.currentValue(\"carbonDioxide\").toInteger()\n    log.debug \"CO2 Level: ${co2} / ${settings.level} Active: ${state.active}\"\n\n    if(co2 >= settings.level && !state.active) {\n        log.debug \"Turning on\"\n        switches.each { it.on(); }\n        state.active = true;\n    } else if(co2 < settings.level && state.active) {\n        log.debug \"Turning off\"\n        state.active = false;\n        switches.each { it.off(); }\n    }\n}",
        "docstring": "Turn on a switch when CO2 levels are too high"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.debug \"Initialized with settings: ${settings}\"\n    \n\t// Pull the latest device info into state\n\tgetDeviceList()\n\n\tsettings.devices.each {\n\t\tdef deviceId = it\n\t\tdef detail = state?.deviceDetail[deviceId]\n\n\t\ttry {\n\t\t\tswitch(detail?.type) {\n\t\t\t\tcase 'NAMain':\n\t\t\t\t\tlog.debug \"Base station\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Basestation\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule1':\n\t\t\t\t\tlog.debug \"Outdoor module\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Outdoor Module\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule3':\n\t\t\t\t\tlog.debug \"Rain Gauge\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Rain\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule4':\n\t\t\t\t\tlog.debug \"Additional module\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Additional Module\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.error \"Error creating device: ${e}\"\n\t\t}\n\t}\n\n\t// Cleanup any other devices that need to go away\n\tdef delete = getChildDevices().findAll { !settings.devices.contains(it.deviceNetworkId) }\n\tlog.debug \"Delete: $delete\"\n\tdelete.each { deleteChildDevice(it.deviceNetworkId) }\n    \n\t// Run initial poll and schedule future polls\n\tpoll()\n\trunEvery5Minutes(\"poll\")\n}\n\ndef uninstalled() {\n\tlog.debug \"Uninstalling\"\n\tremoveChildDevices(getChildDevices())\n}\n\ndef getDeviceList() {\n\tif (atomicState.authToken) {\n    \n        log.debug \"Getting stations data\"\n\n        def deviceList = [:]\n        state.deviceDetail = [:]\n        state.deviceState = [:]\n\n        apiGet(\"/api/getstationsdata\") { resp ->\n            resp.data.body.devices.each { value ->\n                def key = value._id\n                deviceList[key] = \"${value.station_name}: ${value.module_name}\"\n                state.deviceDetail[key] = value\n                state.deviceState[key] = value.dashboard_data\n                value.modules.each { value2 ->            \n                    def key2 = value2._id\n                    deviceList[key2] = \"${value.station_name}: ${value2.module_name}\"\n                    state.deviceDetail[key2] = value2\n                    state.deviceState[key2] = value2.dashboard_data            \n                }\n            }\n        }\n        \n        return deviceList.sort() { it.value.toLowerCase() }\n        \n\t} else {\n    \treturn null\n  }\n}\n\nprivate removeChildDevices(delete) {\n\tlog.debug \"Removing ${delete.size()} devices\"\n\tdelete.each {\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t}\n}\n\ndef createChildDevice(deviceFile, dni, name, label) {\n\ttry {\n\t\tdef existingDevice = getChildDevice(dni)\n\t\tif(!existingDevice) {\n\t\t\tlog.debug \"Creating child\"\n\t\t\tdef childDevice = addChildDevice(\"dianoga\", deviceFile, dni, null, [name: name, label: label, completedSetup: true])\n\t\t} else {\n\t\t\tlog.debug \"Device $dni already exists\"\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"Error creating device: ${e}\"\n\t}\n}\n\ndef listDevices() {\n\tlog.debug \"Listing devices\"\n\n\tdef devices = getDeviceList()\n\n\tdynamicPage(name: \"listDevices\", title: \"Choose Devices\", install: true) {\n\t\tsection(\"Devices\") {\n\t\t\tinput \"devices\", \"enum\", title: \"Select Devices\", required: false, multiple: true, options: devices\n\t\t}\n\n        section(\"Preferences\") {\n        \tinput \"rainUnits\", \"enum\", title: \"Rain Units\", description: \"Millimeters (mm) or Inches (in)\", required: true, options: [mm:'Millimeters', in:'Inches']\n        }\n\t}\n}\n\ndef apiGet(String path, Map query, Closure callback) {\n\tlog.debug \"running apiGet()\"\n    \n    // If the current time is over the expiration time, request a new token\n\tif(now() >= atomicState.tokenExpires) {\n    \tatomicState.authToken = null\n\t\trefreshToken()\n\t}\n\n\tdef queryParam = [\n    \taccess_token: atomicState.authToken\n    ]\n    \n\tdef apiGetParams = [\n\t\turi: getApiUrl(),\n\t\tpath: path,\n\t\tquery: queryParam\n\t]\n    \n\t// log.debug \"apiGet(): $apiGetParams\"\n\n\ttry {\n\t\thttpGet(apiGetParams) { resp ->\n\t\t\tcallback.call(resp)\n\t\t}\n\t} catch (e) {\n\t\tlog.debug \"apiGet() failed: $e\"\n        // Netatmo API has rate limits so a failure here doesn't necessarily mean our token has expired, but we will check anyways\n        if(now() >= atomicState.tokenExpires) {\n    \t\tatomicState.authToken = null\n\t\t\trefreshToken()\n\t\t}\n\t}\n}\n\ndef apiGet(String path, Closure callback) {\n\tapiGet(path, [:], callback);\n}\n\ndef poll() {\n\tlog.debug \"Polling...\"\n    \n\tgetDeviceList()\n    \n\tdef children = getChildDevices()\n    //log.debug \"State: ${state.deviceState}\"\n\n\tsettings.devices.each { deviceId ->\n\t\tdef detail = state?.deviceDetail[deviceId]\n\t\tdef data = state?.deviceState[deviceId]\n\t\tdef child = children?.find { it.deviceNetworkId == deviceId }\n\n\t\tlog.debug \"Update: $child\";\n\t\tswitch(detail?.type) {\n\t\t\tcase 'NAMain':\n\t\t\t\tlog.debug \"Updating NAMain $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'carbonDioxide', value: data['CO2'])\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tchild?.sendEvent(name: 'pressure', value: data['Pressure'])\n\t\t\t\tchild?.sendEvent(name: 'noise', value: data['Noise'])\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule1':\n\t\t\t\tlog.debug \"Updating NAModule1 $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule3':\n\t\t\t\tlog.debug \"Updating NAModule3 $data\"\n\t\t\t\tchild?.sendEvent(name: 'rain', value: rainToPref(data['Rain']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'rainSumHour', value: rainToPref(data['sum_rain_1']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'rainSumDay', value: rainToPref(data['sum_rain_24']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'units', value: settings.rainUnits)\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule4':\n\t\t\t\tlog.debug \"Updating NAModule4 $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'carbonDioxide', value: data['CO2'])\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\ndef cToPref(temp) {\n\tif(getTemperatureScale() == 'C') {\n    \treturn temp\n    } else {\n\t\treturn temp * 1.8 + 32\n    }\n}\n\ndef rainToPref(rain) {\n\tif(settings.rainUnits == 'mm') {\n    \treturn rain\n    } else {\n    \treturn rain * 0.039370\n    }\n}\n\ndef debugEvent(message, displayEvent) {\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent(results)\n}\n\nprivate Boolean canInstallLabs() {\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware) {\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions() {\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate your Netatmo devices with SmartThings"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n    unschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.changed = false\n\tsubscribe(sensors, 'contact', \"sensorChange\")\n}\n\ndef sensorChange(evt) {\n\tlog.debug \"Desc: $evt.value , $state\"\n    if(evt.value == 'open' && !state.changed) {\n    \tunschedule()\n        runIn(delay, 'turnOff')\n    } else if(evt.value == 'closed' && state.changed) {\n    \t// All closed?\n        def isOpen = false\n        for(sensor in sensors) {\n        \tif(sensor.id != evt.deviceId && sensor.currentValue('contact') == 'open') {\n        \t\tisOpen = true\n            }\n        }\n        \n        if(!isOpen) {\n        \tunschedule()\n        \trunIn(delay, 'restore')\n        }\n    }\n}\n\ndef turnOff() {\n\tlog.debug \"Turning off thermostat due to contact open\"\n\tstate.thermostatMode = thermostat.currentValue(\"thermostatMode\")\n\tthermostat.off()\n    state.changed = true\n    log.debug \"State: $state\"\n}\n\ndef restore() {\n    log.debug \"Setting thermostat to $state.thermostatMode\"\n    thermostat.setThermostatMode(state.thermostatMode)\n    state.changed = false\n}",
        "docstring": "Automatically turn off thermostat when windows/doors open. Turn it back on when everything is closed up."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.fanRunning = false;\n    \n    subscribe(outTemp, \"temperature\", \"checkThings\");\n    subscribe(inTemp, \"temperature\", \"checkThings\");\n    subscribe(thermostat, \"thermostatMode\", \"checkThings\");\n    subscribe(contacts, \"contact\", \"checkThings\");\n}\n\ndef checkThings(evt) {\n\tdef outsideTemp = settings.outTemp.currentTemperature\n    def insideTemp = settings.inTemp.currentTemperature\n    def thermostatMode = settings.thermostat.currentThermostatMode\n    def somethingOpen = settings.checkContacts == 'No' || settings.contacts?.find { it.currentContact == 'open' }\n    \n    log.debug \"Inside: $insideTemp, Outside: $outsideTemp, Thermostat: $thermostatMode, Something Open: $somethingOpen\"\n    \n    def shouldRun = true;\n    \n    if(thermostatMode != 'off') {\n    \tlog.debug \"Not running due to thermostat mode\"\n    \tshouldRun = false;\n    }\n    \n    if(insideTemp < outsideTemp) {\n    \tlog.debug \"Not running due to insideTemp > outdoorTemp\"\n    \tshouldRun = false;\n    }\n    \n    if(insideTemp < settings.minTemp) {\n    \tlog.debug \"Not running due to insideTemp < minTemp\"\n    \tshouldRun = false;\n    }\n    \n    if(!somethingOpen) {\n    \tlog.debug \"Not running due to nothing open\"\n        shouldRun = false\n    }\n    \n    if(shouldRun && !state.fanRunning) {\n    \tfans.on();\n        state.fanRunning = true;\n    } else if(!shouldRun && state.fanRunning) {\n    \tfans.off();\n        state.fanRunning = false;\n    }\n}",
        "docstring": "Toggle a whole house fan (switch) when: Outside is cooler than inside, Inside is above x temp, Thermostat is off"
    },
    {
        "code": "def installed() {\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef humidityHandler(evt) {\n\tlog.trace \"humidity: ${evt.value}\"\n    log.trace \"set point: ${humidity1}\"\n\n\tdef currentHumidity = Double.parseDouble(evt.value.replace(\"%\", \"\"))\n\tdef tooHumid = humidity1 \n    def notHumidEnough = humidity2\n\tdef mySwitch = settings.switch1\n\tdef deltaMinutes = 10 \n    \n    def timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last ${deltaMinutes} minutes\"\n\tdef alreadySentSms = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) >= tooHumid } > 1 || recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) <= notHumidEnough } > 1\n    \n\tif (currentHumidity >= tooHumid) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting >= ${tooHumid}\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\t\n\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"Notification already sent within the last ${deltaMinutes} minutes\"\n\t\t\t\n\t\t} else {\n\t\t\tlog.debug \"Humidity Rose Above ${tooHumid}:  sending SMS and activating ${mySwitch}\"\n\t\t\tsend(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n\n    if (currentHumidity <= notHumidEnough) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting <= ${notHumidEnough}\"\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"Notification already sent within the last ${deltaMinutes} minutes\"\n\t\t\t\n\t\t} else {\n\t\t\tlog.debug \"Humidity Fell Below ${notHumidEnough}:  sending SMS and activating ${mySwitch}\"\n\t\t\tsend(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}\")\n\t\t\tswitch1?.off()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n    }\n\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n\n    log.debug msg\n}",
        "docstring": "Notify me when the humidity rises above or falls below the given threshold. It will turn on a switch when it rises above the first threshold and off when it falls below the second threshold."
    },
    {
        "code": "def installed() {\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"$evt.value\"\n\tif (evt.value == \"open\") {\n        state.wasOn = switch1.currentValue(\"switch\") == \"on\"\n\t\tswitch1.off()\n}\t\n\nif (evt.value == \"closed\") {\n\tif(state.wasOn)switch1.on()\n}\n}",
        "docstring": "Turn your lights off when a Contact Sensor is opened and turn them back on when it is closed, ONLY if the Lights were previouly on"
    },
    {
        "code": "def installed() {\n    log.debug \"Installed: $settings\"\n    subscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef updated() {\n    log.debug \"Updated: $settings\"\n    unsubscribe()\n    subscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef temperatureHandler(evt) {\n    def currentOutTemp = null\n    if ( outTemp ) {\n        currentOutTemp = outTemp.latestValue(\"temperature\")\n    } else {\n        log.debug \"No external temperature device set. Checking The Weather Company...\"\n        currentOutTemp = weatherCheck()\n    }\n\n    def currentInTemp = evt.doubleValue\n    def openWindows = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\n    log.trace \"Temp event: $evt\"\n    log.info \"In: $currentInTemp; Out: $currentOutTemp\"\n\n    // Don't spam notifications\n    // *TODO* use state.foo from Severe Weather Alert to do this better\n    if (!retryPeriod) {\n        def retryPeriod = 30\n    }\n    def timeAgo = new Date(now() - (1000 * 60 * retryPeriod).toLong())\n    def recentEvents = inTemp.eventsSince(timeAgo)\n    log.trace \"Found ${recentEvents?.size() ?: 0} events in the last $retryPeriod minutes\"\n\n    // Figure out if we should notify\n    if ( currentInTemp > minTemp && currentInTemp < maxTemp ) {\n        log.info \"In comfort zone: $currentInTemp is between $minTemp and $maxTemp.\"\n        log.debug \"No notifications sent.\"\n    } else if ( currentInTemp > maxTemp ) {\n        // Too warm. Can we do anything?\n\n        def alreadyNotified = recentEvents.count { it.doubleValue > currentOutTemp } > 1\n\n        if ( !alreadyNotified ) {\n            if ( currentOutTemp < maxTemp && !openWindows ) {\n                send( \"Open some windows to cool down the house! Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n            } else if ( currentOutTemp > maxTemp && openWindows ) {\n                send( \"It's gotten warmer outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n            } else {\n                log.debug \"No notifications sent. Everything is in the right place.\"\n            }\n        } else {\n            log.debug \"Already notified! No notifications sent.\"\n        }\n    } else if ( currentInTemp < minTemp ) {\n        // Too cold! Is it warmer outside?\n        def alreadyNotified = recentEvents.count { it.doubleValue < currentOutTemp } > 1\n        if ( !alreadyNotified ) {\n            if ( currentOutTemp > minTemp && !openWindows ) {\n                send( \"Open some windows to warm up the house! Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n            } else if ( currentOutTemp < minTemp && openWindows ) {\n                send( \"It's gotten colder outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n            } else {\n                log.debug \"No notifications sent. Everything is in the right place.\"\n            }\n        } else {\n            log.debug \"Already notified! No notifications sent.\"\n        }\n    }\n}\n\ndef weatherCheck() {\n    def obs = getTwcConditions(zipCode)\n    def currentTemp = obs.temperature\n    if ( currentTemp ) {\n        log.trace \"Temp: $currentTemp (The Weather Company)\"\n        return currentTemp\n    } else {\n        log.warn \"Did not get a temp: $obs\"\n        return false\n    }\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n        sendEvent(linkText:app.label, descriptionText:msg, eventType:\"SOLUTION_EVENT\", displayed: true, name:\"summary\")\n    }\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n    log.info msg\n}",
        "docstring": "Compares two temperatures \u2013 indoor vs outdoor, for example \u2013 then sends an alert if windows are open (or closed!). If you don't use an external temperature device, your location will be used instead."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed: $settings\"\n\tsubscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef updated() {\n\tlog.debug \"Updated: $settings\"\n\tunsubscribe()\n\tsubscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\n\ndef temperatureHandler(evt) {\n\tdef currentOutTemp = null\n\tif ( outTemp ) {\n\t\tcurrentOutTemp = outTemp.latestValue(\"temperature\")\n\t} else {\n\t\tlog.debug \"No external temperature device set. Checking WUnderground....\"\n\t\tcurrentOutTemp = weatherCheck()\n\t}\n\n\tdef currentInTemp = evt.doubleValue\n\tdef openWindows = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\n\tlog.trace \"Temp event: $evt\"\n\tlog.info \"In: $currentInTemp; Out: $currentOutTemp\"\n\n\t// Don't spam notifications\n\t// *TODO* use state.foo from Severe Weather Alert to do this better\n\tdef retryPeriodInMinutes = retryPeriod ?: 30\n\tdef timeAgo = new Date(now() - (1000 * 60 * retryPeriodInMinutes).toLong())\n\tdef recentEvents = inTemp.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $retryPeriodInMinutes minutes\"\n\n\t// Figure out if we should notify\n\tif ( currentInTemp > minTemp && currentInTemp < maxTemp ) {\n\t\tlog.info \"In comfort zone: $currentInTemp is between $minTemp and $maxTemp.\"\n\t\tlog.debug \"No notifications sent.\"\n\t} else if ( currentInTemp > maxTemp ) {\n\t\t// Too warm. Can we do anything?\n\n\t\tdef alreadyNotified = recentEvents.count { it.doubleValue > currentOutTemp } > 1\n\n\t\tif ( !alreadyNotified ) {\n\t\t\tif ( currentOutTemp < maxTemp && !openWindows ) {\n\t\t\t\tsend( \"Open some windows to cool down the house! Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n\t\t\t} else if ( currentOutTemp > maxTemp && openWindows ) {\n\t\t\t\tsend( \"It's gotten warmer outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n\t\t\t} else {\n\t\t\t\tlog.debug \"No notifications sent. Everything is in the right place.\"\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Already notified! No notifications sent.\"\n\t\t}\n\t} else if ( currentInTemp < minTemp ) {\n\t\t// Too cold! Is it warmer outside?\n\n\t\tdef alreadyNotified = recentEvents.count { it.doubleValue < currentOutTemp } > 1\n\n\t\tif ( !alreadyNotified ) {\n\t\t\tif ( currentOutTemp > minTemp && !openWindows ) {\n\t\t\t\tsend( \"Open some windows to warm up the house! Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n\t\t\t} else if ( currentOutTemp < minTemp && openWindows ) {\n\t\t\t\tsend( \"It's gotten colder outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}\u00b0F inside and ${currentOutTemp}\u00b0F outside.\" )\n\t\t\t} else {\n\t\t\t\tlog.debug \"No notifications sent. Everything is in the right place.\"\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Already notified! No notifications sent.\"\n\t\t}\n\t}\n}\n\ndef weatherCheck() {\n\tdef json = getWeatherFeature(\"conditions\", zipCode)\n\tdef currentTemp = json?.current_observation?.temp_f\n\n\tif ( currentTemp ) {\n    \tlog.trace \"Temp: $currentTemp (WeatherUnderground)\"\n\t\treturn currentTemp\n\t} else {\n\t\tlog.warn \"Did not get a temp: $json\"\n\t\treturn false\n\t}\n}\n\nprivate send(msg) {\n\tif ( sendPushMessage != \"No\" ) {\n\t\tlog.debug( \"sending push message\" )\n\t\tsendPush( msg )\n        sendEvent(linkText:app.label, descriptionText:msg, eventType:\"SOLUTION_EVENT\", displayed: true, name:\"summary\")\n\t}\n\n\tif ( phone1 ) {\n\t\tlog.debug( \"sending text message\" )\n\t\tsendSms( phone1, msg )\n\t}\n\n\tlog.info msg\n}",
        "docstring": "Compares two temperatures \u2013 indoor vs outdoor, for example \u2013 then sends an alert if windows are open (or closed!). If you don't use an external temperature device, your zipcode will be used instead."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\t\n    /* Make sure uuid is there. */\n    getUUID()\n    \n   \t/* Check uuid and if it does not exist then don't update.*/\n    if (!atomicState.notPaired) {  \n        def theDay = 1\n\n        for(def i=1; i < 28; i++) {\n        \t\n            /* set user choosen option to apropriate value. */\n            if (atomicState.language == \"en\") {\n                if (\"${i}st day of the month\" == settings.meteringDate || \n                    \"${i}nd day of the month\" == settings.meteringDate || \n                    \"${i}rd day of the month\" == settings.meteringDate || \n                    \"${i}th day of the month\" == settings.meteringDate) {\n\n                    theDay = i\n                    i = 28\n\n                } else if (\"Rest of the month\" == settings.meteringDate) {\n                    theDay = 27\n                    i = 28\n                }\n            } else {\n\n                if (settings.meteringDate == \"\ub9e4\uc6d4 ${i}\uc77c\") {\n\n                    theDay = i\n                    i = 28\n\n                } else if (\"\ub9d0\uc77c\" == settings.meteringDate) {\n                    theDay = 27\n                    i = 28\n                }\n            }\n\n        }\n\t\t\n        /* Set choosen contract to apropriate variable. */\n        def contract = 1\n        if (settings.contractType == \"High voltage\" || settings.contractType == \"\uc8fc\ud0dd\uc6a9 \uace0\uc555\") {\n            contract = 2\n          \t\n            if (settings.energyPlan < 460) {\n            \tsettings.energyPlan = 490\n            }\n        } else {\n        \t\n        \tif (settings.energyPlan < 1130) {\n            \tsettings.energyPlan = 1130\n            }\n        }\n\t\t\n        \n        /* convert bill to milliwatts */\n        def changeToUsageParam = makeGetParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/bill/expectedUsage?bill=${settings.energyPlan}\",\n                                      [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n       def energyPlanUsage = getHttpGetJson(changeToUsageParam, 'CheckEnergyPlanUsage')\n        def epUsage = 0\n        if (energyPlanUsage) {\n            epUsage = energyPlanUsage.usage\n        } \n        \n\t\t/* update the the information depends on the option choosen */\n        def configurationParam = makePostParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/me\",\n                                          [Authorization     : \"Bearer ${atomicState.encoredAccessToken}\"],\n                                          [contractType      : contract, \n                                           meteringDay       : theDay,\n                                           maxLimitUsage     : epUsage])\n        getHttpPutJson(configurationParam)\n    }\n\t\n}\n\ndef initialize() {\n\tlog.debug \"Initializing Application\"\n    \n    def EATValidation = checkEncoreAccessTokenValidation()\n    \n    /* if token exist get user's device id, uuid */\n    if (EATValidation) {\n    \tgetUUID()\n        if (atomicState.uuid) {\n        \t\n            def pushParams = makePostParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/events/push\",\n                                        [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"],\n                                        [type: \"REST\", regId:\"${state.accessToken}__${app.id}\"])\n            getHttpPostJson(pushParams)\n\t\t}\n        \n    } else {\n    \tlog.warning \"Ecored Access Token did not get refreshed!\"\n    }\n        \n    \n    /* add device Type Handler */\n    atomicState.dni = \"EncoredDTH01\"\n    def d = getChildDevice(atomicState.dni)\n    if(!d) {\n        log.debug \"Creating Device Type Handler.\"\n        \n        d = addChildDevice(\"Encored Technologies\", \"EnerTalk Energy Meter\", atomicState.dni, null, [name:\"EnerTalk Energy Meter\", label:name])\n\n    } else {\n        log.debug \"Device already created\"\n    }\n    \n    setSummary()    \n}\n\ndef setSummary() {\n    \n    log.debug \"in setSummary\"\n    def text = \"Successfully installed.\"\n    sendEvent(linkText:count.toString(), descriptionText: app.label,\n              eventType:\"SOLUTION_SUMMARY\",\n              name: \"summary\",\n              value: text,\n              data: [[\"icon\":\"indicator-dot-gray\",\"iconColor\":\"#878787\",\"value\":text]],\n              displayed: false)\n}\n\n// TODO: implement event handlers\n\n/* \tCheck the validation of Encored Access Token (EAT)\n*\tIf it's not valid try refresh Access Token.\n*\tIf the token gets refreshed, it will refresh the value of Encored Access Token\n*\tIf it doesn't get refreshed, then it returns null\n*/\nprivate checkEncoreAccessTokenValidation() {\n\t/* make a parameter to check the validation of Encored access token */\n    def verifyParam = makeGetParams(\"https://enertalk-auth.encoredtech.com/verify\", \n    \t\t\t\t\t\t\t[Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n    /* check the validation */\n    def verified = getHttpGetJson(verifyParam, 'verifyToken')\n\n    log.debug \"verified : ${verified}\"\n\n    /* if Encored Access Token need to be renewed. */\n    if (!verified) {\n        try {\n            refreshAuthToken()\n\n            /* Recheck the renewed Encored access token. */\n            verifyParam.headers = [Authorization: \"Bearer ${atomicState.encoredAccessToken}\"]\n            verified = getHttpGetJson(verifyParam, 'CheckRefresh')\n\n        } catch (groovyx.net.http.HttpResponseException e) {\n            /* If refreshing token raises an error  */\n            log.warn \"Refresh Token Error :  ${e}\"\n        }\n    }\n    \n    return verified\n}\n\n/* Get device UUID, if it does not exist, return false. true otherwise.*/\nprivate getUUID() {\n\tatomicState.uuid = null\n    atomicState.notPaired = true\n    /* Make a parameter to get device id (uuid)*/\n    def uuidParams = makeGetParams( \"https://enertalk-auth.encoredtech.com/uuid\",\n                                   [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n    def deviceUUID = getHttpGetJson(uuidParams, 'UUID')\n    log.debug \"device uuid is : ${deviceUUID}\"\n    if (!deviceUUID) {\n    \treturn false\n    }\n    log.debug \"got here even tho\"\n    atomicState.uuid = deviceUUID.uuid\n    atomicState.notPaired = false\n    return true\n}\n\nprivate createLocaleStrings() {\n   state.domains = [\n   \t\ttest : \"http://api.encoredtech.com\",\n        prod : \"https://api.encoredtech.com:8082/\"\n   ]\n   state.languageString = \n   [\n   \t\tenergyPlan : 30000,\n    \ten : [\n                desc1 : \"Tab below to sign in or sign up to Encored EnerTalk smart energy service and authorize SmartThings access.\",\n                desc2 : \"Click to proceed authorization.\",\n                main : \"EnerTalk\",\n                defaultValues : [\n                                default1 : \"kWh\",\n                                default2 : \"1st day of the month\",\n                                default3 : \"Low voltage\"\n                \t\t\t\t],\n                meteringDays : [\n                            \"1st day of the month\", \n                            \"2nd day of the month\", \n                            \"3rd day of the month\",\n                            \"4th day of the month\",\n                            \"5th day of the month\",\n                            \"6th day of the month\",\n                            \"7th day of the month\",\n                            \"8th day of the month\",\n                            \"9th day of the month\",\n                            \"10th day of the month\",\n                            \"11th day of the month\",\n                            \"12th day of the month\",\n                            \"13th day of the month\",\n                            \"14th day of the month\",\n                            \"15th day of the month\",\n                            \"16th day of the month\",\n                            \"17th day of the month\",\n                            \"18th day of the month\",\n                            \"19th day of the month\",\n                            \"20st day of the month\",\n                            \"21st day of the month\",\n                            \"22nd day of the month\",\n                            \"23rd day of the month\",\n                            \"24th day of the month\",\n                            \"25th day of the month\",\n                            \"26th day of the month\",\n                            \"Rest of the month\"\n                            ],\n                displayUnits : [\"WON(\u20a9)\", \"kWh\"],\n                contractTypes : [\"Low voltage\", \"High voltage\"],\n                title1 : \"Send push notification\",\n                title2 : \"Energy Plan\",\n                subTitle1 : \"Setup your energy plan by won\",\n                title3 : \"Display Unit\",\n                title4 : \"Metering Date\",\n                title5 : \"Contract Type\",\n                title6 : \"User & Notifications\",\n                message1 : \"\"\" <p>Your Encored Account is now connected to SmartThings!</p> <p>Click 'Done' to finish setup.</p> \"\"\",\n                message2 : \"\"\" <p>The connection could not be established!</p> <p>Click 'Done' to return to the menu.</p> \"\"\",\n                message3 : [\n                \t\theader : \"Device is not installed\",\n                        body1 : \"You need to install EnerTalk device at first,\",\n                        body2 : \"and proceed setup and register device.\",\n                        button1 : \"Setup device\",\n                        button2 : \"Not Installed\"\n                \t   ],\n            \tmessage4 : [\n                \t\t\theader : \"Device is not connected.\",\n                            body1 : \"Please check the Wi-Fi network connection\",\n                            body2 : \"and EnerTalk device status.\",\n                            body3 : \"Select \u2018Setup Device\u2019 to reset the device.\"\n                \t\t\t]\n            ],\n        ko :[\n                desc1 : \"\uc2a4\ub9c8\ud2b8 \uc5d0\ub108\uc9c0 \uc11c\ube44\uc2a4\ub97c \uc774\uc6a9\ud558\uc2dc\ub824\uba74 EnerTalk \uc11c\ube44\uc2a4 \uac00\uc785\uacfc SmartThings \uc811\uadfc \uad8c\ud55c\uc774 \ud544\uc694\ud569\ub2c8\ub2e4.\",\n                desc2 : \"\uc544\ub798 \ubc84\ud2bc\uc744 \ub204\ub974\uba74 \uc778\uc99d\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4\",\n                main : \"EnerTalk \uc778\uc99d\",\n                defaultValues : [\n                                default1 : \"kWh\",\n                                default2 : \"\ub9e4\uc6d4 1\uc77c\",\n                                default3 : \"\uc8fc\ud0dd\uc6a9 \uc800\uc555\"\n                \t\t\t\t],\n                meteringDays : [\n                            \"\ub9e4\uc6d4 1\uc77c\", \n                            \"\ub9e4\uc6d4 2\uc77c\", \n                            \"\ub9e4\uc6d4 3\uc77c\",\n                            \"\ub9e4\uc6d4 4\uc77c\",\n                            \"\ub9e4\uc6d4 5\uc77c\",\n                            \"\ub9e4\uc6d4 6\uc77c\",\n                            \"\ub9e4\uc6d4 7\uc77c\",\n                            \"\ub9e4\uc6d4 8\uc77c\",\n                            \"\ub9e4\uc6d4 9\uc77c\",\n                            \"\ub9e4\uc6d4 10\uc77c\",\n                            \"\ub9e4\uc6d4 11\uc77c\",\n                            \"\ub9e4\uc6d4 12\uc77c\",\n                            \"\ub9e4\uc6d4 13\uc77c\",\n                            \"\ub9e4\uc6d4 14\uc77c\",\n                            \"\ub9e4\uc6d4 15\uc77c\",\n                            \"\ub9e4\uc6d4 16\uc77c\",\n                            \"\ub9e4\uc6d4 17\uc77c\",\n                            \"\ub9e4\uc6d4 18\uc77c\",\n                            \"\ub9e4\uc6d4 19\uc77c\",\n                            \"\ub9e4\uc6d4 20\uc77c\",\n                            \"\ub9e4\uc6d4 21\uc77c\",\n                            \"\ub9e4\uc6d4 22\uc77c\",\n                            \"\ub9e4\uc6d4 23\uc77c\",\n                            \"\ub9e4\uc6d4 24\uc77c\",\n                            \"\ub9e4\uc6d4 25\uc77c\",\n                            \"\ub9e4\uc6d4 26\uc77c\",\n                            \"\ub9d0\uc77c\"\n                            ],\n                displayUnits : [\"\uc6d0(\u20a9)\", \"kWh\"],\n                contractTypes : [\"\uc8fc\ud0dd\uc6a9 \uc800\uc555\", \"\uc8fc\ud0dd\uc6a9 \uace0\uc555\"],\n                title1 : \"\uc54c\ub78c \uc124\uc815\",\n                title2 : \"\uc0ac\uc6a9 \uacc4\ud68d (\uc6d0)\",\n                subTitle1 : \"\uc6d4\uac04 \uacc4\ud68d\uc744 \uae08\uc561\uc73c\ub85c \uc785\ub825\ud558\uc138\uc694\",\n                title3 : \"\ud45c\uc2dc \ub2e8\uc704\",\n                title4 : \"\uc815\uae30\uac80\uce68\uc77c\",\n                title5 : \"\uacc4\uc57d\uc885\ubcc4\",\n                title6 : \"\uc0ac\uc6a9\uc790 & \uc54c\ub78c \uc124\uc815\",\n                message1 : \"\"\" <p>EnerTalk \uacc4\uc815\uc774 SmartThings\uc640 \uc5f0\uacb0 \ub418\uc5c8\uc2b5\ub2c8\ub2e4!</p> <p>Done\uc744 \ub20c\ub7ec \uacc4\uc18d \uc9c4\ud589\ud574 \uc8fc\uc138\uc694.</p> \"\"\",\n                message2 : \"\"\" <p>\uacc4\uc815 \uc5f0\uacb0\uc774 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4.</p> <p>Done \ubc84\ud2bc\uc744 \ub20c\ub7ec \ub2e4\uc2dc \uc2dc\ub3c4\ud574\uc8fc\uc138\uc694.</p> \"\"\",\n                message3 : [\n                \t\theader : \"\uae30\uae30 \uc124\uce58\uac00 \ud544\uc694\ud569\ub2c8\ub2e4.\",\n                        body1 : \"\uac00\uc815 \ub0b4 \ubd84\uc804\ubc18\uc5d0 EnerTalk \uae30\uae30\ub97c \uba3c\uc800 \uc124\uce58\ud558\uace0,\",\n                        body2 : \"\uc544\ub798 \ubc84\ud2bc\uc744 \ub20c\ub7ec \uae30\uae30\ub4f1\ub85d \ubc0f \uc5f0\uacb0\uc744 \uc9c4\ud589\ud558\uc138\uc694.\",\n                        button1 : \"\uae30\uae30 \uc124\uc815\",\n                        button2 : \"\uc124\uce58\ud544\uc694\"\n                \t   ],\n            \tmessage4 : [\n                \t\t\theader : \"Device is not connected.\",\n                            body1 : \"Please check the Wi-Fi network connection\",\n                            body2 : \"and EnerTalk device status.\",\n                            body3 : \"Select \u2018Setup Device\u2019 to reset the device.\"\n                \t\t\t]\n                \n            ]\n    ]\n\n}\n\n/* This method makes a redirect url with a given endpoint */\nprivate buildRedirectUrl(mappingPath) {\n\tlog.debug \"Start : Starting to making a redirect URL with endpoint : /${mappingPath}\"\n    def url = \"https://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/${mappingPath}\"\n    log.debug \"Done : Finished to make a URL : ${url}\"\n    url\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\n/* make a success message. */\nprivate success() {\n\tdef lang = clientLocale?.language\n   \n    if (\"${lang}\" == \"ko\") {\n   \t\tlog.debug \"I was here at first.\"\n    \tatomicState.language = \"ko\"\n    } else {\n  \n    \tatomicState.language = \"en\"\n    }\n\tlog.debug atomicState.language\n\tdef message = atomicState.languageString.\"${atomicState.language}\".message1\n\tconnectionStatus(message)\n}\n\n/* make a failure message. */\nprivate fail() {\n\tdef lang = clientLocale?.language\n   \n    if (\"${lang}\" == \"ko\") {\n   \t\tlog.debug \"I was here at first.\"\n    \tatomicState.language = \"ko\"\n    } else {\n  \n    \tatomicState.language = \"en\"\n    }\n    def message = atomicState.languageString.\"${atomicState.language}\".message2\n    connectionStatus(message)\n}\n\nprivate connectionStatus(message) {\n    def html = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width height=device-height\">\n       \n        <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\n        <title>SmartThings Connection</title>\n        <style type=\"text/css\">\n            @font-face {\n                font-family: 'Swiss 721 W01 Thin';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'Swiss 721 W01 Light';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            body {\n            \tmargin: 0;\n            \twidth : 100%;\n            }\n            .container {\n                width: 100%;\n            \n                /*background: #eee;*/\n                text-align: center;\n            }\n            img {\n                vertical-align: middle;\n                margin-top:20.3125vw;\n               \n            }\n            \n            .encored{\n            \twidth: 25vw;\n                height: 25vw;\n                margin-right : 8.75vw;\n            }\n            .chain {\n            \twidth:6.25vw;\n                height: 6.25vw;\n            }\n            .smartt {\n            \twidth: 25vw;\n                height: 25vw;\n                margin-left: 8.75vw\n            }\n           \t\n            p {\n                font-size: 21px;\n                font-weight: 300;\n                font-family: Roboto;\n                text-align: center;\n                color: #4c4c4e;\n                \n                margin-bottom: 0;\n            }\n        /*\n            p:last-child {\n                margin-top: 0px;\n            }\n        */\n            span {\n                font-family: 'Swiss 721 W01 Light';\n            }\n        </style>\n  \n        </head>\n        <body>\n            <div class=\"container\">\n                <img class=\"encored\" src=\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/appicon_enertalk.png\" alt=\"Encored icon\" />\n                <img class=\"chain\" src=\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/icon_link.svg\" alt=\"connected device icon\" />\n                <img class=\"smartt\" src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n                <p>${message}</p>\n                \n            </div>\n            \n        </body>\n        </html>\n\t\"\"\"\n\trender contentType: 'text/html', data: html\n}\n\nprivate refreshAuthToken() {\n\t/*Refreshing Encored Access Token*/\n    \n    log.debug \"Refreshing Encored Access Token\"\n\tif(!atomicState.encoredRefreshToken) {\n\t\tlog.error \"Encored Refresh Token does not exist!\"\n\t} else {\n    \n    \tdef authorization = \"Basic \" + \"${appSettings.clientId}:${appSettings.clientSecret}\".bytes.encodeBase64()\n    \tdef refreshParam = makePostParams(\"https://enertalk-auth.encoredtech.com/token\",\n        \t\t\t\t\t\t\t\t\t[Authorization: authorization],\n                                            [grant_type: 'refresh_token', refresh_token: \"${atomicState.encoredRefreshToken}\"])\n        \n        def newAccessToken = getHttpPostJson(refreshParam)\n        \n        if (newAccessToken) {\n        \tatomicState.encoredAccessToken = newAccessToken.access_token\n            log.debug \"Successfully got new Encored Access Token.\\n\"\n        } else {\n        \tlog.error \"Was unable to renew Encored Access Token.\\n\"\n        }\n    }\n}\n\nprivate getHttpPutJson(param) {\n\t\n    log.debug \"Put URI : ${param.uri}\"\n\ttry {\n       httpPut(param) { resp ->\n \t\t\tlog.debug \"HTTP Put Success\"\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Put Error : ${e}\"\n    }\n}\n\nprivate getHttpPostJson(param) {\n\tlog.debug \"Post URI : ${param.uri}\"\n   def jsonMap = null\n   try {\n       httpPost(param) { resp ->\n           jsonMap = resp.data\n           log.debug resp.data\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Post Error : ${e}\"\n    }\n    \n    return jsonMap\n}\n\nprivate getHttpGetJson(param, testLog) {\n\tlog.debug \"Get URI : ${param.uri}\"\n   def jsonMap = null\n   try {\n       httpGet(param) { resp ->\n           jsonMap = resp.data\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Get Error : ${e}\"\n    }\n    \n    return jsonMap\n\n}\n\nprivate makePostParams(uri, header, body=[]) {\n\treturn [\n    \turi : uri,\n        headers : header,\n        body : body\n    ]\n}\n\nprivate makeGetParams(uri, headers, path=\"\") {\n\treturn [\n    \turi : uri,\n        path : path,\n        headers : headers\n    ]\n}\n\ndef getInitialData() {\n\tdef lang = clientLocale?.language\n    if (\"${lang}\" == \"ko\") {\n    \tlang = \"ko\"\n    } else {\n        lang = \"en\"\n    }\n    atomicState.solutionModuleSettings.language = lang\n\tatomicState.solutionModuleSettings\n}\n\ndef consoleLog() {\n    log.debug \"console log: ${request.JSON.str}\"\n}\n\ndef getHtml() {\n\t\n    /* initializing variables */\n\tdef deviceStatusData = \"\", standbyData = \"\", meData = \"\", meteringData = \"\", rankingData = \"\", lastMonth = \"\", deviceId = \"\"\n\tdef standby = \"\", plan = \"\", start = \"\", end = \"\", meteringDay = \"\", meteringUsage = \"\", percent = \"\", tier = \"\", meteringPeriodBill = \"\"\n    def maxLimitUsageBill, maxLimitUsage = 0\n    def deviceStatus = false\n    def displayUnit = \"watt\"\n    \n    def meteringPeriodBillShow = \"\", meteringPeriodBillFalse = \"collecting data\"\n    def standbyShow = \"\", standbyFalse = \"collecting data\" \n    def rankingShow = \"collecting data\"\n    def tierShow = \"collecting data\"\n    def lastMonthShow = \"\", lastMonthFalse = \"no records\"\n    def planShow = \"\", planFalse = \"set up plan\"\n    \n    def thisMonthUnitOne =\"\", thisMonthUnitTwo = \"\", planUnitOne = \"\", planUnitTwo = \"\", lastMonthUnit = \"\", standbyUnit = \"\"\n    def thisMonthTitle = \"This Month\", tierTitle = \"Billing Tier\", planTitle = \"Energy Goal\", \n    lastMonthTitle = \"Last Month\", rankingTitle = \"Ranking\", standbyTitle = \"Always on\", energyMonitorDeviceTitle = \"EnerTalk Device\" , realtimeTitle = \"Realtime\"\n    def onOff = \"OFF\", rankImage = \"\", tierImage = \"\"\n    \n    def htmlBody = \"\"\n    \n    /* Get the language setting on device. */\n    def lang = clientLocale?.language\n    if (\"${lang}\" == \"ko\") {\n    \tatomicState.language = \"ko\"\n    } else {\n        atomicState.language = \"en\"\n    }\n    \n    if (atomicState.language == \"ko\") {\n        rankingShow = \"\ub370\uc774\ud130 \uc218\uc9d1 \uc911\"\n        meteringPeriodBillFalse = \"\ub370\uc774\ud130 \uc218\uc9d1 \uc911\" \n        lastMonthFalse = \"\uc815\ubcf4\uac00 \uc5c6\uc2b5\ub2c8\ub2e4\" \n        standbyFalse = \"\ub370\uc774\ud130 \uc218\uc9d1 \uc911\"\n        planFalse = \"\uacc4\ud68d\uc744 \uc785\ub825\ud558\uc138\uc694\"\n        thisMonthTitle = \"\uc774\ubc88 \ub2ec\" \n        tierTitle = \"\ub204\uc9c4\ub2e8\uacc4\" \n        planTitle = \"\uc0ac\uc6a9 \uacc4\ud68d\" \n        lastMonthTitle = \"\uc9c0\ub09c\ub2ec\" \n        rankingTitle = \"\ub7ad\ud0b9\" \n        standbyTitle = \"\ub300\uae30\uc804\ub825\" \n        energyMonitorDeviceTitle = \"\uc2a4\ub9c8\ud2b8\ubbf8\ud130 \uc0c1\ud0dc\"\n        realtimeTitle = \"\uc2e4\uc2dc\uac04\"\n    }\n    \n    /* check Encored Access Token */\n    def EATValidation = checkEncoreAccessTokenValidation()\n    log.debug EATValidation\n    /* check if uuid already exist or not.*/\n    if (EATValidation && atomicState.notPaired) {\n    \tgetUUID()\n    }\n    \n    /* If token has been verified or refreshed and if uuid exist, call other apis */\n    log.debug atomicState.notPaired\n    if (!atomicState.notPaired) {\n\n        if(EATValidation) {\n            /* make a parameter to get device status */\n            def deviceStatusParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/status\",\n                                                    [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n            /* get device status. */\n            deviceStatusData = getHttpGetJson(deviceStatusParam, 'CheckDeviceStatus')\n            \n\n            /* make a parameter to get standby value.*/\n            def standbyParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/standbyPower\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n            \n            /* get standby value */\n            standbyData = getHttpGetJson(standbyParam, 'CheckStandbyPower')\n            \n            \n\n            /* make a parameter to get user's info. */\n            def meParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/me\",\n                                        [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\t\t\t\n            /* Get user's info */\n            meData = getHttpGetJson(meParam, 'CheckMe')\n\t\t\t\n\t\t\n            /* make a parameter to get energy used since metering date */\n            def meteringParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/meteringUsage\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n            \n            /* Get the value of energy used since metering date. */\n            meteringData = getHttpGetJson(meteringParam, 'CheckMeteringUsage')\n\t\t\t\n            \n            /* make a parameter to get the energy usage ranking of a user. */\n            def rankingParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/ranking/usages/${atomicState.uuid}?state=current&period=monthly\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\t\t\t\n            /* Get user's energy usage rank */\n            rankingData = getHttpGetJson(rankingParam, 'CheckingRanking')\n\t\t\t\n            /* Parse the values from the returned value of api calls. Then use these values to inform user how much they have used or will use. */\n\n            /* parse device status. */\n            if (deviceStatusData) {\n                if (deviceStatusData.status == \"NORMAL\") {\n                    deviceStatus = true\n                }\n            }\n            \n            log.debug \"deiceStatusData : ${deviceStatus} || ${deviceStatusData}\"\n\n            /* Parse standby power. */\n            if (standbyData) {\n                if (standbyData.standbyPower) {\n                    standby = (standbyData.standbyPower / 1000)\n                }\n            }\n\n            /* Parse max limit usage and it's bill from user's info. */\n            if (meData) {\n                if (meData.maxLimitUsageBill) {\n                    maxLimitUsageBill = meData.maxLimitUsageBill\n                    maxLimitUsage = meData.maxLimitUsage\n                }\n            }\n\n            /* Parse the values which have been used since metering date.\n            * The list is :\n            *\tmeteringPeriodBill : A bill for energy usage.\n            *\tplan  : The left amount of bill until it reaches limit.\n            *\tstart : metering date in millisecond e.g. if the metering started on june and 1st, 2015,06,01\n            * \tend\t  : Today's date in millisecond\n            *\tmeteringDay : The day of the metering date. e.g. if the metering date is June 1st, then it will return 1.\n            *\tmeteringUSage : The amount of energy that user has used.\n            * \ttier : the level of energy use, tier exits from 1 to 6.\n            */\t\n            if (meteringData) {\n                if (meteringData.meteringPeriodBill) {\n                    meteringPeriodBill = meteringData.meteringPeriodBill\n                    plan = maxLimitUsageBill - meteringData.meteringPeriodBill\n                    start = meteringData.meteringStart\n                    end = meteringData.meteringEnd\n                    meteringDay = meteringData.meteringDay\n                    meteringUsage = meteringData.meteringPeriodUsage\n                    tier = ((int) (meteringData.meteringPeriodUsage / 100000000) + 1)\n                    if(tier > 6) {\n                        tier = 6\n                    }\n\n                } \n            }\n\n            /* Get ranking data of a user and the percent */\n            if (rankingData) {\n                if (rankingData.user.ranking) {\n                    percent = ((int)((rankingData.user.ranking / rankingData.user.population) * 10))\n                    if (percent > 10) {\n                        percent = 10\n                    }\n                }\n            }\n\n            /* if the start value exist, get last month energy usage. */\n            if (start) {\n                def lastMonthParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/meteringUsages?period=monthly&start=${start}&end=${end}\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n                lastMonth = getHttpGetJson(lastMonthParam, 'ChecklastMonth')\n\n            }\n\n            /* I decided to set values to device type handler, on loading solution module. \n            So, users may need to go back to solution module to update their device type handler. */\n            def d = getChildDevice(atomicState.dni)\n            def kWhMonth = Math.round(meteringUsage / 10000) / 100 /* milliwatt to kilowatt*/\n            def planUsed = 0\n            if ( maxLimitUsage > 0 ) {\n                planUsed = Math.round((meteringUsage / maxLimitUsage) * 100) /* get the pecent of used amount against max usage */\n            } else {\n                planUsed = Math.round((meteringUsage/ 1000000) * 100) /* if max was not decided let the used value be percent. e.g. 1kWh = 100% */\n            }\n\n            /* get realtime usage of user's device.*/\n            def realTimeParam = makeGetParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/realtimeUsage\",\n                                              [Authorization: \"Bearer ${atomicState.encoredAccessToken}\"])\n            def realTimeInfo = getHttpGetJson(realTimeParam, 'CheckRealtimeinfo')\n\n            if (!realTimeInfo) {\n                realTimeInfo = 0\n            } else {\n                realTimeInfo = Math.round(realTimeInfo.activePower / 1000 )\n            }\n\t\t\t\n            \n            \n            /* inserting values to device type handler */\n            \n            d?.sendEvent(name: \"view\", value : \"${kWhMonth}\")\n            if (deviceStatus) {\n\n            \td?.sendEvent(name: \"month\", value : \"${thisMonthTitle} \\n ${kWhMonth} \\n kWh\")\n            } else { \n\n            \td?.sendEvent(name: \"month\", value : \"\\n ${state.languageString.\"${atomicState.language}\".message4.header} \\n\\n \" + \n                \t\t\t\t\t\t\t\t\t\"${state.languageString.\"${atomicState.language}\".message4.body1} \\n \" +\n               \t\t\t\t\t\t\t\t\t\t\"${state.languageString.\"${atomicState.language}\".message4.body2} \\n \" +\n                                                    \"${state.languageString.\"${atomicState.language}\".message4.body3}\")\t\n            }\n            \n            d?.sendEvent(name: \"real\", value : \"${realTimeInfo}w \\n\\n ${realtimeTitle}\")\n            d?.sendEvent(name: \"tier\", value : \"${tier} \\n\\n ${tierTitle}\")\n            d?.sendEvent(name: \"plan\", value : \"${planUsed}% \\n\\n ${planTitle}\")\n          \n            deviceId = d.id\n\n        } else {\n            /* If it finally couldn't get Encored access token. */\n            log.error \"Could not get Encored Access Token. Please try later.\"\n        }\n\n        /* change the display uinit to bill from kWh if user want. */\n        if (settings.displayUnit == \"WON(\u20a9)\" || settings.displayUnit == \"\uc6d0(\u20a9)\") {\n            displayUnit = \"bill\"\n        }\n\n        if (meteringPeriodBill) {\n            /* reform the value of the bill with the , separator */\n            meteringPeriodBillShow = formatMoney(\"${meteringPeriodBill}\")\n            meteringPeriodBillFalse = \"\"\n            thisMonthUnitOne = \"&#x20A9;\"\n\n            def dayPassed = getDayPassed(start, end, meteringDay)\n            if (atomicState.language == 'ko') {\n                thisMonthUnitTwo = \"/ ${dayPassed}\uc77c\"\n            } else {\n                if (dayPassed == 1) {\n                    thisMonthUnitTwo = \"/${dayPassed} day\"\n                } else {\n                    thisMonthUnitTwo = \"/${dayPassed} days\"\n                }\n            }\n        }\n\n        if (plan) {\n            planShow = plan\n            if (plan >= 1000) {planShow = formatMoney(\"${plan}\") }\n            planFalse = \"\"\n            planUnitOne = \"&#x20A9;\"\n\n            if (atomicState.language == 'ko') {\n                planUnitTwo = \"\ub0a8\uc74c\"\n            } else {\n                planUnitTwo = \"left\"\n            }\n\n        }\n\n        /*set the showing units for html.*/\n        log.debug lastMonth\n        if (lastMonth.usages) {\n            lastMonthShow = formatMoney(\"${lastMonth.usages[0].meteringPeriodBill}\")\n            lastMonthFalse = \"\"\n            lastMonthUnit = \"&#x20A9;\"\n       \n        }\n\n        if (standby) {\n            standbyShow = standby\n            standbyFalse = \"\"\n            standbyUnit = \"W\"\n        }\n\n        if (percent) {\n            rankImage = \"<img id=\\\"image-rank\\\" src=\\\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/ranking_${percent}.svg\\\" />\"\n            rankingShow = \"\"\n        }\n\n        if (tier) {\n            tierImage = \"<img id=\\\"image-tier\\\" src=\\\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/tier_${tier}.svg\\\" />\"\n            tierShow = \"\"\n        }\n\n        if (deviceStatus) {\n            onOff = \"ON\"\n        }\n\n        atomicState.solutionModuleSettings = [\n           auth           : atomicState.encoredAccessToken, \n           deviceState    : deviceStatus, \n           percent        : percent,\n           displayUnit    : displayUnit,\n           language\t\t  : atomicState.language,\n           deviceId\t      : deviceId,\n           pairing\t\t  : true\n        ]\n        \n        htmlBody = \"\"\"\n         <div id=\"real-time\">\n         \t\n            <!-- real-time card -->\n            <div id=\"my-card\"></div>\n            \n            <!-- this month section -->\n            <div class=\"contents head\" id=\"content1\">\n              <p class=\"key\" id=\"korean-this\">${thisMonthTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-this\">${thisMonthUnitOne}</p>\n                <p class=\"value\" id=\"value-this\">${meteringPeriodBillShow}</p>\n                <p class=\"value\" id=\"value-fail\">${meteringPeriodBillFalse}</p>\n                <p class=\"unit second\" id=\"unit-second-this\">${thisMonthUnitTwo}</p>\n              </span> \n            </div>\n            \n            <!-- Billing Tier section -->\n            <div class=\"contents tail\" id=\"content2\">\n              <p class=\"key\" id=\"korean-tier\">${tierTitle}</p>\n              <span class=\"value-block\">\n              \t<div id=\"value-block-tier\">${tierImage}</div>\n                <p class=\"value\" id=\"value-fail\">${tierShow}</p>\n              </span>\n            </div> \n            \n            <!-- Plan section -->\n            <div class=\"contents tail\" id=\"content3\">\n              <p class=\"key\" id=\"korean-plan\">${planTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-plan\">${planUnitOne}</p>\n                <p class=\"value\" id=\"value-plan\">${planShow}</p>\n                <p class=\"value\" id=\"value-fail\">${planFalse}</p>\n                <p class=\"unit second\" id=\"unit-second-plan\"> ${planUnitTwo}</p> \n              </span>\n            </div>\n            \n            <!-- Last Month section -->\n            <div class=\"contents tail\" id=\"content4\">\n              <p class=\"key\" id=\"korean-last\">${lastMonthTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-last\">${lastMonthUnit}</p>\n                <p class=\"value\" id=\"value-last\">${lastMonthShow}</p>\n                <p class=\"value\" id=\"value-fail\">${lastMonthFalse}</p>\n              </span>\n            </div>\n\n            <!-- Ranking section -->\n            <div class=\"contents tail\" id=\"content5\">\n              <p class=\"key\" id=\"korean-ranking\">${rankingTitle}</p>\n              <span class=\"value-block\">\n              <div id=\"value-block-rank\">${rankImage}</div>\n              <p class=\"value\" id=\"value-fail\">${rankingShow}</p>\n              </span>\n            </div> \n            \n            <!-- Standby section -->\n            <div class=\"contents tail\" id=\"content6\">\n              <p class=\"key\" id=\"korean-standby\">${standbyTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"value\" id=\"value-standby\">${standbyShow}</p>\n                <p class=\"value\" id=\"value-fail\">${standbyFalse}</p>\n                <p class=\"unit third\" id=\"unit-third-standby\">${standbyUnit}<p>\n              </span>\n            </div>\n            \n            <!-- Device status section -->\n            <div class=\"contents tail\" id=\"content7\">\n              <p class=\"key\" id=\"korean-device\">${energyMonitorDeviceTitle}</p>\n              <span class=\"value-block\">\n                <div class=\"circle\"></div>\n                <p class=\"value last\" id=\"value-ON-OFF\">${onOff}</p>\n              </span>\n            </div>\n            \n          </div>\n          \n          <!-- hidden section -->\n          \n\t\t  <div id=\"this-month\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-this\">${thisMonthTitle}</p>\n              <button class=\"st-show\" id=\"show\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card2\"></div>\n            <div class=\"cards\" id=\"my-card3\"></div>\n          </div>\n          \n          <div id=\"last-month\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-last\">${lastMonthTitle}</p>\n              <button class=\"st-show\" id=\"show2\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card4\"></div>\n          </div>\n          \n          <div id=\"progressive-step\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-tier\">${tierTitle}</p>\n              <button class=\"st-show\" id=\"show3\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card5\"></div>\n          </div>\n          \n          <div id=\"ranking\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-ranking\">${rankingTitle}</p>\n              <button class=\"st-show\" id=\"show4\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card6\"></div>\n          </div>\n          \n          <div id=\"plan\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-plan\">${planTitle}</p>\n              <button class=\"st-show\" id=\"show5\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card7\"></div>\n          </div>\n          \n          <div id=\"standby\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-standby\">${standbyTitle}</p>\n              <button class=\"st-show\" id=\"show6\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card8\"></div>\n          </div>\n          <script>\n          \t     \\$(\"#this-month\").slideUp();\n                \\$(\"#last-month\").slideUp();\n                \\$(\"#progressive-step\").slideUp();\n                \\$(\"#ranking\").slideUp();\n                \\$(\"#plan\").slideUp();\n                \\$(\"#standby\").slideUp();\n\n                var UI = new Encored.UI({\n        \n                });\n                UI.renderCard({\n            \t   'cards': [{\n                \t'id': 'ui:h:strealtime:v1', \n                    'params': {\n                                'lang': '${atomicState.language}', \n                                'useDemoLabel': 1, \n                                'displayUnit': '${displayUnit}'\n\t\t\t\t\t}\n\t\t\t\t    }], \n                    'accessToken': '${atomicState.encoredAccessToken}', \n                    'target': document.getElementById(\"my-card\")\n\t\t\t     });\n          </script>\n        <script src=\"${buildResourceUrl('javascript/app.js')}\"></script>\n        \n        \"\"\"\n    } else {\n\t\tlog.debug \"abotu to ask device connection\"\n    \tdef d = getChildDevice(atomicState.dni)\n        /* inserting values to device type handler */ \n\n        d?.sendEvent(name: \"month\", value : \"\\n ${state.languageString.\"${atomicState.language}\".message3.header} \\n\\n ${state.languageString.\"${atomicState.language}\".message3.body1} \\n ${state.languageString.\"${atomicState.language}\".message3.body2}\")\n        deviceId = d.id\n\t\t\n        if (state.language == \"ko\") {\n        \tenergyMonitorDeviceTitle = \"\uc2a4\ub9c8\ud2b8\ubbf8\ud130 \uc0c1\ud0dc\"\t\n        }\n    \t/* need device pairing */\n        atomicState.solutionModuleSettings = [\n        \tdId\t\t: deviceId,\n            pairing\t: false\n        ]\n  \n        htmlBody = \"\"\"\n        \n         \t<div id=\"real-time\">\n        \n            \t<!-- real-time card -->\n                <div id=\"st-pairing-card\">\n                \t<p class=\"st-pairing-card-header\" align=\"center\">${state.languageString.\"${atomicState.language}\".message3.header}</p>\n                \t<p class=\"st-pairing-card-body\" align=\"center\"> ${state.languageString.\"${atomicState.language}\".message3.body1} <br/> ${state.languageString.\"${atomicState.language}\".message3.body2}</p>\n                \t<div id=\"st-deep-link-container\"></div>\n                </div>\n\n\n\n                <!-- Device status section -->\n                <div class=\"contents tail\" id=\"content7\">\n                  <p class=\"key\">${energyMonitorDeviceTitle}</p>\n                  <span class=\"value-block\">\n                    <p class=\"value last\">${state.languageString.\"${atomicState.language}\".message3.button2}</p>\n                  </span>\n                </div>\n            \n          \t</div>\n\t\t  \n          \t<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js\"></script>\n            <script src=\"${buildResourceUrl('javascript/app.js')}\"></script>\n            <script>\n                var ua = navigator.userAgent.toLowerCase();\n                var isAndroid = ua.indexOf(\"android\") > -1; //&& ua.indexOf(\"mobile\");\n                if(!isAndroid) { \n                \t\\$(\"#st-deep-link-container\").html(\"<a id=\\'st-deep-link\\' href=\\'https://itunes.apple.com/kr/app/enertalk-for-home/id1024660780?mt=8\\'><p class=\\'st-deep-text\\'>${state.languageString.\"${state.language}\".message3.button1}</p></a>\");\n\t\t\t\t} else {\n                \t\\$(\"#st-deep-link-container\").html(\"<a id=\\'st-deep-link\\' href=\\'market://details?id=com.ionicframework.enertalkhome874425\\'><p class=\\'st-deep-text\\'>${state.languageString.\"${state.language}\".message3.button1}</p></a>\");\n                };\n            </script>\n        \"\"\"\n    }\n\n    renderHTML() {\n        head {\n        \"\"\"\n        \t<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, height=device-height\">\n            <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\n            <link rel=\"stylesheet\" href=\"${buildResourceUrl('css/app.css')}\" type=\"text/css\">\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/0.7.18/webcomponents-lite.min.js\"></script>\n            <script src=\"https://enertalk-card.encoredtech.com/sdk.js\"></script>\n            <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js\"></script>\n        \"\"\"\n        }\n        body {\n        \thtmlBody\n        }\n    }\n}\n\n\n/* put commas for money or if there are things that need to have a comma separator.*/\nprivate formatMoney(money) {\n\tdef i = money.length()-1\n    def ret = \"\"\n    def commas = ((int) Math.floor(i/3))\n\n    def j = 0\n    def counter = 0\n \n    while (i >= 0) {\n\n        if (counter > 0 && (counter % 3) == 0) {\n        \tret = \"${money[i]},${ret}\"\n            j++\n        } else {\n        \tret = \"${money[i]}${ret}\"\n        }\n        \n        counter++\n\t\ti--\n\t}\n    \n    ret\n}\n\n/* Count how many days have been passed since metering day:\n* \tif metering day < today, it returns today - metering day\n*\telse if metering day > today, it calcualtes how many days have been passed since meterin day and return calculated value.\n*\telse return 1 (today).\n*/\nprivate getDayPassed(start, end, meteringDay){\n    \n    def day = 1\n    def today = new Date(end)\n    def tzDifference = 9 * 60 + today.getTimezoneOffset()\n\ttoday = new Date(today.getTime() + tzDifference * 60 * 1000).getDate();\n    \n    if (today > meteringDay) {\n        day += today - meteringDay;\n       \n    }\n    if (today < meteringDay) {\n        def startDate = new Date(start);\n        def month = startDate.getMonth();\n        def year = startDate.getYear();\n        def lastDate = new Date(year, month, 31).getDate();\n \n        if (lastDate == 1) {\n            day += 30;\n        } else {\n            day += 31;\n        }\n        \n        day = day - meteringDay + today;\n    }\n    \n    day\n}\n\n/* Get Encored push and send the notification. */\ndef getEncoredPush() {\n\n\tbyte[] decoded = \"${params.msg}\".decodeBase64()\n\tdef decodedString = new String(decoded)\n\n    if (settings.notification == \"true\") {\n    \tsendNotification(\"${decodedString}\", [method: \"push\"])\n    } else {\n    \tsendNotificationEvent(\"${decodedString}\")\n    }\n    \n}",
        "docstring": "With visible realtime energy usage status, have good energy habits and enrich your life\\r\\n"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n}\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.label, type: type] : null\n}\n\n//API Mapping\nmappings {\n   path(\"/getalldevices\") {\n    action: [\n      \tGET: \"getAllDevices\"\n   ]\n  }\n  /*\n  path(\"/thermostat/setcool/:id/:temp\") {\n    action: [\n      GET: \"setCoolTemp\"\n    ]\n  }\n  path(\"/thermostat/setheat/:id/:temp\") {\n    action: [\n      GET: \"setHeatTemp\"\n    ]\n  }\n  path(\"/thermostat/setfanmode/:id/:mode\") {\n    action: [\n      GET: \"setFanMode\"\n    ]\n  }\n  path(\"/thermostat/setmode/:id/:mode\") {\n    action: [\n      GET: \"setThermostatMode\"\n    ]\n  }\n  path(\"/thermostat/:id\") {\n    action: [\n      GET: \"getThermostatStatus\"\n    ]\n  }\n  */\n  path(\"/light/dim/:id/:dim\") {\n    action: [\n      GET: \"setLevelStatus\"\n    ]\n  }\n  path(\"/light/kelvin/:id/:kelvin\") {\n    action: [\n      GET: \"setKelvin\"\n    ]\n  }\n  path(\"/colorlight/:id/:hue/:sat\") {\n    action: [\n      GET: \"setColor\"\n    ]\n  }\n  path(\"/light/status/:id\") {\n    action: [\n      GET: \"getLightStatus\"\n    ]\n  }\n  path(\"/light/on/:id\") {\n    action: [\n      GET: \"turnOnLight\"\n    ]\n  }\n  path(\"/light/off/:id\") {\n    action: [\n      GET: \"turnOffLight\"\n    ]\n  }\n  path(\"/doorlocks/lock/:id\") {\n    action: [\n      GET: \"lockDoorLock\"\n    ]\n  }\n  path(\"/doorlocks/unlock/:id\") {\n    action: [\n      GET: \"unlockDoorLock\"\n    ]\n  }\n  path(\"/doorlocks/:id\") {\n    action: [\n      GET: \"getDoorLockStatus\"\n    ]\n  }\n  path(\"/contacts/:id\") {\n    action: [\n  \tGET: \"getContactStatus\"\n    ]\n  }\n  path(\"/smoke/:id\") {\n    action: [\n   \tGET: \"getSmokeStatus\"\n\t]\n  }\n    path(\"/shades/open/:id\") {\n    action: [\n      GET: \"openShade\"\n    ]\n  }\n  path(\"/shades/preset/:id\") {\n    action: [\n      GET: \"presetShade\"\n    ]\n  }\n  path(\"/shades/close/:id\") {\n    action: [\n      GET: \"closeShade\"\n    ]\n  }\n  \tpath(\"/shades/:id\") {\n    action: [\n\tGET: \"getShadeStatus\"\n\t]\n}\n    path(\"/garage/open/:id\") {\n    action: [\n      GET: \"openGarage\"\n    ]\n  }\n  path(\"/garage/close/:id\") {\n    action: [\n      GET: \"closeGarage\"\n    ]\n  }\n  \tpath(\"/garage/:id\") {\n    action: [\n  \t\tGET: \"getGarageStatus\"\n  \t]\n  }\n    path(\"/watersensors/:id\") {\n    action: [\n      \t\tGET: \"getWaterSensorStatus\"\n    \t]\n  }\n  \tpath(\"/tempsensors/:id\") {\n    action: [\n      GET: \"getTempSensorsStatus\"\n    ]\n  }\n  path(\"/meters/:id\") {\n    action: [\n      GET: \"getMeterStatus\"\n    ]\n  }\n  path(\"/batteries/:id\") {\n    action: [\n      GET: \"getBatteryStatus\"\n    ]\n  }\n  \tpath(\"/presences/:id\") {\n    action: [\n      GET: \"getPresenceStatus\"\n    ]\n  }\n  \tpath(\"/motions/:id\") {\n    action: [\n      GET: \"getMotionStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id\") {\n    action: [\n      GET: \"getOutletStatus\"\n    ]\n  }\n  \tpath(\"/outlets/turnon/:id\") {\n    action: [\n      GET: \"turnOnOutlet\"\n    ]\n  }\n  path(\"/outlets/turnoff/:id\") {\n    action: [\n      GET: \"turnOffOutlet\"\n    ]\n  }\n  path(\"/switches/turnon/:id\") {\n    action: [\n      GET: \"turnOnSwitch\"\n    ]\n  }\n  path(\"/switches/turnoff/:id\") {\n    action: [\n      GET: \"turnOffSwitch\"\n    ]\n  }\n  path(\"/switches/:id\") {\n    action: [\n      GET: \"getSwitchStatus\"\n    ]\n  }\n}\n\n//API Methods\ndef getAllDevices() {\n    def locks_list = locks.collect{device(it,\"Lock\")}\n    /*def thermo_list = thermostats.collect{device(it,\"Thermostat\")}*/\n    def colors_list = colors.collect{device(it,\"Color\")}\n    def kelvin_list = kelvin.collect{device(it,\"Kelvin\")}\n    def contact_list = contact.collect{device(it,\"Contact Sensor\")}\n    def smokes_list = smoke_alarms.collect{device(it,\"Smoke Alarm\")}\n    def shades_list = shades.collect{device(it,\"Window Shade\")}\n    def garage_list = garage.collect{device(it,\"Garage Door\")}\n    def water_sensors_list = water_sensors.collect{device(it,\"Water Sensor\")}\n    def presences_list = presence_sensors.collect{device(it,\"Presence\")}\n    def motions_list = motions.collect{device(it,\"Motion\")}\n\tdef outlets_list = outlets.collect{device(it,\"Outlet\")}\n    def switches_list = switches.collect{device(it,\"Switch\")}\n    def switchlevels_list = switchlevels.collect{device(it,\"Switch Level\")}\n    def temp_list = temperature_sensors.collect{device(it,\"Temperature\")}\n    def meters_list = meters.collect{device(it,\"Power Meters\")}\n    def battery_list = batteries.collect{device(it,\"Batteries\")}\n    return outlets_list + kelvin_list + colors_list + switchlevels_list + smokes_list + contact_list + water_sensors_list + shades_list + garage_list + locks_list + presences_list + motions_list + switches_list + temp_list + meters_list + battery_list\n}\n\n//thermostat\n/*\ndef setCoolTemp() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(device.hasCommand(\"setCoolingSetpoint\")) {\n            \tdevice.setCoolingSetpoint(params.temp.toInteger());\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setHeatTemp() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(device.hasCommand(\"setHeatingSetpoint\")) {\n            \tdevice.setHeatingSetpoint(params.temp.toInteger());\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setFanMode() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        if(device.hasCommand(\"setThermostatFanMode\")) {\n            \tdevice.setThermostatFanMode(params.mode);\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setThermostatMode() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        if(device.hasCommand(\"setThermostatMode\")) {\n            \tdevice.setThermostatMode(params.mode);\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef getThermostatStatus() {\n\tdef device = thermostats.find{ it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [ThermostatOperatingState: device.currentValue('thermostatOperatingState'), ThermostatSetpoint: device.currentValue('thermostatSetpoint'), \n            \t\t\tThermostatFanMode: device.currentValue('thermostatFanMode'), ThermostatMode: device.currentValue('thermostatMode')]\n       \t}\n}\n*/\n//light\ndef turnOnLight() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            device.on();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n    }\n\ndef turnOffLight() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            device.off();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\ndef getLightStatus() {\n\tdef device = switches.find{ it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Status: device.currentValue('switch'), Dim: getLevelStatus(params.id), Color: getColorStatus(params.id), Kelvin: getKelvinStatus(params.id)]\n        }\n}\n\n//color control\ndef setColor() {\n    def device = colors.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \t\n            def map = [hue:params.hue.toInteger(), saturation:params.sat.toInteger()]\n            \n            device.setColor(map);\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n    }\n}\n\ndef getColorStatus(id) {\n\tdef device = colors.find { it.id == id }\n    if (!device) {\n            return [Color: \"none\"]\n        } else {\n        \treturn [hue: device.currentValue('hue'), saturation: device.currentValue('saturation')]\n        }\n}\n\n//kelvin control\ndef setKelvin() {\n    def device = kelvin.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \n            device.setColorTemperature(params.kelvin.toInteger());\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n    }\n}\n\ndef getKelvinStatus(id) {\n\tdef device = kelvin.find { it.id == id }\n    if (!device) {\n            return [kelvin: \"none\"]\n        } else {\n        \treturn [kelvin: device.currentValue('colorTemperature')]\n        }\n}\n\n//switch level\ndef getLevelStatus() {\n\tdef device = switchlevels.find { it.id == params.id }\n    if (!device) {\n            [Level: \"No dimmer\"]\n        } else {\n        \treturn [Level: device.currentValue('level')]\n        }\n}\n\ndef getLevelStatus(id) {\n\tdef device = switchlevels.find { it.id == id }\n    if (!device) {\n            [Level: \"No dimmer\"]\n        } else {\n        \treturn [Level: device.currentValue('level')]\n        }\n}\n\n\ndef setLevelStatus() {\n\tdef device = switchlevels.find { it.id == params.id }\n    def level = params.dim\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdevice.setLevel(level.toInteger())\n        \treturn [result_action: \"200\", Level: device.currentValue('level')]\n        }\n}\n\n\n//contact sensors\ndef getContactStatus() {\n\tdef device = contact.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef args = getTempSensorsStatus(device.id)\n        \treturn [Device_state: device.currentValue('contact')] + args\n        }\n}\n\n//smoke detectors\ndef getSmokeStatus() {\n\tdef device = smoke_alarms.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        def bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('smoke')] + bat\n        }\n}\n\n//garage\ndef getGarageStatus() {\n\tdef device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('door')]\n        }\n}\n\ndef openGarage() {\n    def device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.open();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef closeGarage() {\n\tdef device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.close();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n//shades\ndef getShadeStatus() {\n\tdef device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('windowShade')]\n        }\n}\n\ndef openShade() {\n    def device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.open();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n    \ndef presetShade() {\n    def device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.presetPosition();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef closeShade() {\n\tdef device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.close();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\n//water sensor\ndef getWaterSensorStatus() {\n\tdef device = water_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('water')] + bat\n        }\n}\n//batteries\ndef getBatteryStatus() {\n\tdef device = batteries.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.latestValue(\"battery\")]\n        }\n}\n\ndef getBatteryStatus(id) {\n\tdef device = batteries.find { it.id == id }\n    if (!device) {\n            return []\n        } else {\n        \treturn [battery_state: device.latestValue(\"battery\")]\n        }\n}\n\n//LOCKS\ndef getDoorLockStatus() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('lock')] + bat\n        }\n}\n\ndef lockDoorLock() {\n    def device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.lock();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef unlockDoorLock() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.unlock();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n//PRESENCE\ndef getPresenceStatus() {\n\n\tdef device = presence_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        def bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('presence')] + bat\n   }\n}\n\n//MOTION\ndef getMotionStatus() {\n\n\tdef device = motions.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef args = getTempSensorsStatus(device.id)\n        \treturn [Device_state: device.currentValue('motion')] + args\n   }\n}\n\n//OUTLET\ndef getOutletStatus() {\n\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n     def watt = getMeterStatus(device.id)\n       \t\n     return [Device_state: device.currentValue('switch')] + watt\n}\n\ndef getMeterStatus() {\n\n    def device = meters.find { it.id == params.id }\n   \tif (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_id: device.id, Device_type: device.type, Current_watt: device.currentValue(\"power\")]\n  }\n}\n\ndef getMeterStatus(id) {\n\n    def device = meters.find { it.id == id }\n   \tif (!device) {\n            return []\n        } else {\n        \treturn [Current_watt: device.currentValue(\"power\")]\n  }\n}\n\n\ndef turnOnOutlet() {\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n     \n     device.on();\n                  \n     return [Device_id: params.id, result_action: \"200\"]\n}\n\ndef turnOffOutlet() {\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n            \n     device.off();\n                  \n     return [Device_id: params.id, result_action: \"200\"]\n}\n\n//SWITCH\ndef getSwitchStatus() {\n\tdef device = switches.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('switch'), Dim: getLevelStatus(params.id)]\n\t}\n}\n\ndef turnOnSwitch() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.on();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\ndef turnOffSwitch() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.off();\n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\n\n//TEMPERATURE\ndef getTempSensorsStatus() {\n    def device = temperature_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n            def scale = [Scale: location.temperatureScale]\n        \treturn [Device_state: device.currentValue('temperature')] + scale + bat\n   }\n}\n\ndef getTempSensorsStatus(id) {\t\n    def device = temperature_sensors.find { it.id == id }\n    if (!device) {\n            return []\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n            def scale = [Scale: location.temperatureScale]\n        \treturn [temperature: device.currentValue('temperature')] + bat + scale\n   \t\t}\n   }",
        "docstring": "Gideon Smart Home SmartApp allows you to connect and control all of your SmartThings devices through the Gideon app, making your SmartThings devices even smarter."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n    subscribe(outlet, \"energy\", outletHandler)\n  \tsubscribe(outlet, \"switch\", outletHandler)\n}\n\n// TODO: implement event handlers\ndef outletHandler(evt) {\n\tlog.debug \"$outlet.currentEnergy\"\n\t//TODO call G API  \n}\n\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.label, type: type] : null\n}\n\n//API Mapping\nmappings {\n\tpath(\"/getalldevices\") {\n    action: [\n      \t\t\tGET: \"getAllDevices\"\n    \t\t]\n  \t}\n\tpath(\"/doorlocks/:id/:command\") {\n    action: [\n      GET: \"updateDoorLock\"\n    ]\n  }\n  \tpath(\"/doorlocks/:id\") {\n    action: [\n      \t\t\tGET: \"getDoorLockStatus\"\n    \t\t]\n  \t}\n  \tpath(\"/tempsensors/:id\") {\n    action: [\n      GET: \"getTempSensorsStatus\"\n    ]\n  }\n  \tpath(\"/presences/:id\") {\n    action: [\n      GET: \"getPresenceStatus\"\n    ]\n  }\n  \tpath(\"/motions/:id\") {\n    action: [\n      GET: \"getMotionStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id\") {\n    action: [\n      GET: \"getOutletStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id/:command\") {\n    action: [\n      GET: \"updateOutlet\"\n    ]\n  }\n  \tpath(\"/switches/:command\") {\n    action: [\n      PUT: \"updateSwitch\"\n    ]\n  }\n}\n\n//API Methods\ndef getAllDevices() {\n\tdef locks_list = locks.collect{device(it,\"Lock\")}\n    def presences_list = presence_sensors.collect{device(it,\"Presence\")}\n    def motions_list = motions.collect{device(it,\"Motion\")}\n    def outlets_list = outlets.collect{device(it,\"Outlet\")}\n    def switches_list = switches.collect{device(it,\"Switch\")}\n    def temp_list = temperature_sensors.collect{device(it,\"Temperature\")}\n    return [Locks: locks_list, Presences: presences_list, Motions: motions_list, Outlets: outlets_list, Switches: switches_list, Temperatures: temp_list]\n}\n\n//LOCKS\ndef getDoorLockStatus() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('lock')]\n        }\n}\n\ndef updateDoorLock() {\n\tdef command = params.command\n    def device = locks.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentValue('lock') == \"locked\")\n                  device.unlock();\n                else\n                  device.lock();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}\n\n//PRESENCE\ndef getPresenceStatus() {\n\n\tdef device = presence_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('presence')]\n   }\n}\n\n//MOTION\ndef getMotionStatus() {\n\n\tdef device = motions.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('motion')]\n   }\n}\n\n//OUTLET\ndef getOutletStatus() {\n\t\n    def device = outlets.find { it.id == params.id }\n   \tif (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentSwitch, Current_watt: device.currentValue(\"energy\")]\n  }\n}\n\ndef updateOutlet() {\n\t\n    def command = params.command\n    def device = outlets.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentSwitch == \"on\")\n                  device.off();\n                else\n                  device.on();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}                \n\n//SWITCH\ndef updateSwitch() {\n    def command = params.command\n    def device = switches.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentSwitch == \"on\")\n                  device.off();\n                else\n                  device.on();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}\n\n//TEMPERATURE\ndef getTempSensorsStatus() {\n\t\n    def device = temperature_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('temperature')]\n   }\n}",
        "docstring": "Gideon AI Smart app allows you to connect and control all of your SmartThings devices through the Gideon AI app, making your SmartThings devices even smarter."
    },
    {
        "code": "def installed() {\n\tsubscribe(bathroom, \"humidity\", coffeeMaker)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(bathroom, \"humidity\", coffeeMaker)\n}\n\ndef coffeeMaker(shower) {\n\tlog.info \"Humidity value: $shower.value\"\n\tif (shower.value.toInteger() > relHum) {\n\t\tcoffee.on()\n    } \n}",
        "docstring": "This app is designed simply to turn on your coffee machine while you are taking a shower."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastClosed = 0\n  subscribe(knockSensor, \"acceleration.active\", handleEvent)\n  subscribe(openSensor, \"contact.closed\", doorClosed)\n}\n\ndef doorClosed(evt) {\n  state.lastClosed = now()\n}\n\ndef doorKnock() {\n  if((openSensor.latestValue(\"contact\") == \"closed\") &&\n    (now() - (60 * 1000) > state.lastClosed)) {\n    def kSensor = knockSensor.label ?: knockSensor.name\n    log.debug(\"${kSensor} detected a knock.\")\n    send(kSensor)\n  }\n\n  else {\n    log.debug(\"${knockSensor.label ?: knockSensor.name} knocked, but looks like it was just someone opening the door.\")\n  }\n}\n\ndef handleEvent(evt) {\n  def delay = knockDelay ?: 5\n  runIn(delay, \"doorKnock\")\n}\n\nprivate send(kSensor) {\n  // Pabal translation code and params\n  String code = 'SmartApps_DoorKnocker_V_0001'\n  List params = [\n    [\n      'n': '${knockSensor.name}',\n      'value': kSensor\n    ]\n  ]\n\n  // Legacy push/SMS message and args\n  String msg = \"{{kSensor}} detected a knock.\"\n  Map msgArgs = [kSensor: kSensor]\n\n  Map options = [\n    code: code,\n    params: params,\n    messageArgs: msgArgs,\n    translatable: true\n  ]\n\n  Boolean pushNotification = (sendPushMessage != \"No\")\n\n  if (pushNotification || phone) {\n    log.debug \"Sending Notification\"\n    options += [\n      method: (pushNotification && phone) ? \"both\" : (pushNotification ? \"push\" : \"sms\"),\n      phone: phone\n    ]\n    sendNotification(msg, options)\n  }\n}",
        "docstring": "Alert if door is knocked, but not opened."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastTrigger    = now()\n  state.deviceTriggers = []\n  subscribe(contacts, \"contact.open\",  triggerAlarm)\n  subscribe(motions,  \"motion.active\", triggerAlarm)\n}\n\ndef triggerAlarm(evt) {\n  def presenceDelay = presenceDelay ?: 15\n\n  if(now() - (presenceDelay * 1000) > state.lastTrigger) {\n    log.warn(\"Stale event - ignoring\")\n\n    state.deviceTriggers = []\n  }\n\n  state.deviceTriggers.add(evt.displayName)\n  state.triggerMode = location.mode\n  state.lastTrigger = now()\n\n  log.info(evt.displayName + \" triggered an alarm.  Waiting for presence lag.\")\n  runIn(presenceDelay, \"fireAlarm\")\n}\n\ndef fireAlarm() {\n  if(state.deviceTriggers.size() > 0) {\n    def devices = state.deviceTriggers.unique().join(\", \")\n\n    if(location.mode == state.triggerMode) {\n      log.info(devices + \" alarm triggered and mode hasn't changed.\")\n      send(devices + \" alarm has been triggered!\")\n      lights?.on()\n      alarms?.both()\n    }\n\n    else {\n      log.info(devices + \" alarm triggered, but it looks like you were just coming home.  Ignoring.\")\n    }\n  }\n\n  state.deviceTriggers = []\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}",
        "docstring": "Alerts you if something happens while you're away.  Has a settable grace period to compensate for presence sensors that may take a few seconds to be noticed."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastClosed = now()\n  subscribe(people, \"presence.present\", presence)\n  subscribe(sensors, \"contact.open\", doorOpened)\n}\n\ndef presence(evt) {\n  def delay = contactDelay ?: 10\n\n  state.lastPresence = now()\n\n  if(now() - (delay * 1000) < state.lastContact) {\n    log.info('Presence was delayed, but you probably still want the light on.')\n    lights?.on()\n  }\n}\n\ndef doorOpened(evt) {\n  def delay = presenceDelay ?: 30\n\n  state.lastContact = now()\n\n  if(now() - (delay * 1000) < state.lastPresence) {\n    log.info('Welcome home!  Let me get that light for you.')\n    lights?.on()\n  }\n}",
        "docstring": "Turn on the hall light if someone comes home (presence) and the door opens."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  subscribe(people,   \"presence\", presence)\n  subscribe(location, \"sunrise\",  setSunrise)\n  subscribe(location, \"sunset\",   setSunset)\n\n  state.sunMode = location.mode\n}\n\ndef setSunrise(evt) {\n  changeSunMode(newSunriseMode)\n}\n\ndef setSunset(evt) {\n  changeSunMode(newSunsetMode)\n}\n\ndef changeSunMode(newMode) {\n  state.sunMode = newMode\n\n  if(everyoneIsAway() && (location.mode == newAwayMode)) {\n    log.debug(\"Mode is away, not evaluating\")\n  }\n\n  else if(location.mode != newMode) {\n    def message = \"${app.label} changed your mode to '${newMode}'\"\n    send(message)\n    setLocationMode(newMode)\n  }\n\n  else {\n    log.debug(\"Mode is the same, not evaluating\")\n  }\n}\n\ndef presence(evt) {\n  if(evt.value == \"not present\") {\n    log.debug(\"Checking if everyone is away\")\n\n    if(everyoneIsAway()) {\n      log.info(\"Starting ${newAwayMode} sequence\")\n      def delay = (awayThreshold != null && awayThreshold != \"\") ? awayThreshold * 60 : 10 * 60\n      runIn(delay, \"setAway\")\n    }\n  }\n\n  else {\n    if(location.mode != state.sunMode) {\n      log.debug(\"Checking if anyone is home\")\n\n      if(anyoneIsHome()) {\n        log.info(\"Starting ${state.sunMode} sequence\")\n\n        changeSunMode(state.sunMode)\n      }\n    }\n\n    else {\n      log.debug(\"Mode is the same, not evaluating\")\n    }\n  }\n}\n\ndef setAway() {\n  if(everyoneIsAway()) {\n    if(location.mode != newAwayMode) {\n      def message = \"${app.label} changed your mode to '${newAwayMode}' because everyone left home\"\n      log.info(message)\n      send(message)\n      setLocationMode(newAwayMode)\n    }\n\n    else {\n      log.debug(\"Mode is the same, not evaluating\")\n    }\n  }\n\n  else {\n    log.info(\"Somebody returned home before we set to '${newAwayMode}'\")\n  }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\nprivate send(msg) {\n  if(sendPushMessage != \"No\") {\n    log.debug(\"Sending push message\")\n    sendPush(msg)\n  }\n\n  log.debug(msg)\n}",
        "docstring": "When everyone leaves, change mode.  If at least one person home, switch mode based on sun position."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  unschedule()\n  init()\n}\n\ndef init() {\n  state.lastMessage = 0\n  state.lastCheck = [\"time\": 0, \"result\": false]\n  schedule(\"0 0,30 * * * ?\", scheduleCheck) // Check at top and half-past of every hour\n  subscribe(sensors, \"contact.open\", scheduleCheck)\n}\n\ndef scheduleCheck(evt) {\n  def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n  def plural = open.size() > 1 ? \"are\" : \"is\"\n\n  // Only need to poll if we haven't checked in a while - and if something is left open.\n  if((now() - (30 * 60 * 1000) > state.lastCheck[\"time\"]) && open) {\n    log.info(\"Something's open - let's check the weather.\")\n    def response = getTwcForecast(zipCode)\n    def weather  = isStormy(response)\n    if(weather) {\n      send(\"${open.join(', ')} ${plural} open and ${weather} coming.\")\n    }\n  }\n\n  else if(((now() - (30 * 60 * 1000) <= state.lastCheck[\"time\"]) && state.lastCheck[\"result\"]) && open) {\n    log.info(\"We have fresh weather data, no need to poll.\")\n    send(\"${open.join(', ')} ${plural} open and ${state.lastCheck[\"result\"]} coming.\")\n  }\n\n  else {\n    log.info(\"Everything looks closed, no reason to check weather.\")\n  }\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}\n\nprivate isStormy(forecast) {\n    def result = false\n    if(forecast) {\n        def text = forecast.daypart?.precipType[0][0]\n        if(text) {\n            log.info(\"We got ${text}\")\n            result = text\n        } else {\n            log.info(\"Got forecast, nothing coming soon.\")\n        }\n    } else {\n        log.warn(\"Did not get a forecast: ${forecast}\")\n    }\n    state.lastCheck = [\"time\": now(), \"result\": result]\n    return result\n}",
        "docstring": "Warn if doors or windows are open when inclement weather is approaching."
    },
    {
        "code": "def installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  subscribe(contact, \"contact.open\",         triggerContact)\n  subscribe(motion,  \"motion.active\",        triggerMotion)\n  subscribe(knock,   \"acceleration.active\",  triggerKnock)\n  subscribe(temp,    \"temperature\",          triggerTemp)\n  subscribe(axis,    \"threeAxis\",            triggerAxis)\n}\n\ndef triggerContact(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${contact.label ?: contact.name} was opened!\")\n  }\n}\n\ndef triggerMotion(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${motion.label ?: motion.name} sensed motion!\")\n  }\n}\n\ndef triggerKnock(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${knock.label ?: knock.name} was knocked!\")\n  }\n}\n\ndef triggerTemp(evt) {\n  def temperature = evt.doubleValue\n\n  if((maxTemp && maxTemp < temperature) ||\n     (minTemp && minTemp > temperature)) {\n    send(\"Safe Watch: ${temp.label ?: temp.name} is ${temperature}\")\n  }\n}\n\ndef triggerAxis(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${axis.label ?: axis.name} was tilted!\")\n  }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}",
        "docstring": "Watch a series of sensors for any anomalies for securing a safe."
    },
    {
        "code": "def installed() {\n  subscribe(thermostats, \"thermostatMode\", thermoChange);\n  subscribe(sensors, \"contact.open\", windowChange);\n}\n\ndef updated() {\n  unsubscribe()\n  subscribe(thermostats, \"thermostatMode\", thermoChange);\n  subscribe(sensors, \"contact.open\", windowChange);\n}\n\ndef thermoChange(evt) {\n  if(evt.value == \"heat\" ||\n     evt.value == \"cool\") {\n    def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n\n    if(open) {\n      def plural = open.size() > 1 ? \"are\" : \"is\"\n      send(\"${open.join(', ')} ${plural} still open and the thermostat just came on.\")\n\n      thermoShutOffTrigger()\n    }\n\n    else {\n      log.info(\"Thermostat came on and nothing is open.\");\n    }\n  }\n}\n\ndef windowChange(evt) {\n  def heating = thermostats.findAll { it?.latestValue(\"thermostatMode\") == \"heat\" }\n  def cooling = thermostats.findAll { it?.latestValue(\"thermostatMode\") == \"cool\" }\n\n  if(heating || cooling) {\n    def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n    def tempDirection = heating ? \"heating\" : \"cooling\"\n    def plural = open.size() > 1 ? \"were\" : \"was\"\n    send(\"${open.join(', ')} ${plural} opened and the thermostat is still ${tempDirection}.\")\n\n    thermoShutOffTrigger()\n  }\n}\n\ndef thermoShutOffTrigger() {\n  if(turnOffTherm == \"Yes\") {\n    log.info(\"Starting timer to turn off thermostat\")\n    def delay = (turnOffDelay != null && turnOffDelay != \"\") ? turnOffDelay * 60 : 60\n    state.turnOffTime = now()\n\n    runIn(delay, \"thermoShutOff\")\n  }\n}\n\ndef thermoShutOff() {\n  def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n  def tempDirection = heating ? \"heating\" : \"cooling\"\n  def plural = open.size() > 1 ? \"are\" : \"is\"\n\n  log.info(\"Checking if we need to turn thermostats off\")\n\n  if(open.size()) {\n    send(\"Thermostats turned off: ${open.join(', ')} ${plural} open and thermostats ${tempDirection}.\")\n    log.info(\"Windows still open, turning thermostats off\")\n    thermostats?.off()\n  }\n\n  else {\n    log.info(\"Looks like everything is shut now - no need to turn off thermostats\")\n  }\n}\n\nprivate send(msg) {\n  if(sendPushMessage != \"No\") {\n    log.debug(\"Sending push message\")\n    sendPush(msg)\n  }\n\n  if(phone) {\n    log.debug(\"Sending text message\")\n    sendSms(phone, msg)\n  }\n\n  log.debug(msg)\n}",
        "docstring": "If your heating or cooling system come on, it gives you notice if there are any windows or doors left open, preventing the system from working optimally."
    },
    {
        "code": "def installed() {\n\tatomicState.version = \"1.1.0\"\n\n\tatomicState.isBucketCreated = false\n\tatomicState.grokerSubdomain = \"groker\"\n\n\tsubscribeToEvents()\n\n\tatomicState.isBucketCreated = false\n\tatomicState.grokerSubdomain = \"groker\"\n\n\tlog.debug \"installed (version $atomicState.version)\"\n}\n\ndef updated() {\n\tatomicState.version = \"1.1.0\"\n\tunsubscribe()\n\n\tif (atomicState.bucketKey != null && atomicState.accessKey != null) {\n\t\tatomicState.isBucketCreated = false\n\t}\n\tif (atomicState.grokerSubdomain == null || atomicState.grokerSubdomain == \"\") {\n\t\tatomicState.grokerSubdomain = \"groker\"\n\t}\n\n\tsubscribeToEvents()\n\n\tlog.debug \"updated (version $atomicState.version)\"\n}\n\ndef uninstalled() {\n\tlog.debug \"uninstalled (version $atomicState.version)\"\n}\n\ndef tryCreateBucket() {\n\n\t// can't ship events if there is no grokerSubdomain\n\tif (atomicState.grokerSubdomain == null || atomicState.grokerSubdomain == \"\") {\n\t\tlog.error \"streaming url is currently null\"\n\t\treturn\n\t}\n\n\t// if the bucket has already been created, no need to continue\n\tif (atomicState.isBucketCreated) {\n\t\treturn\n\t}\n\n\tif (!atomicState.bucketName) {\n    \tatomicState.bucketName = atomicState.bucketKey\n    }\n    if (!atomicState.accessKey) {\n    \treturn\n    }\n\tdef bucketName = \"${atomicState.bucketName}\"\n\tdef bucketKey = \"${atomicState.bucketKey}\"\n\tdef accessKey = \"${atomicState.accessKey}\"\n\n\tdef bucketCreateBody = new JsonSlurper().parseText(\"{\\\"bucketKey\\\": \\\"$bucketKey\\\", \\\"bucketName\\\": \\\"$bucketName\\\"}\")\n\n\tdef bucketCreatePost = [\n\t\turi: \"https://${atomicState.grokerSubdomain}.initialstate.com/api/buckets\",\n\t\theaders: [\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"X-IS-AccessKey\": accessKey\n\t\t],\n\t\tbody: bucketCreateBody\n\t]\n\n\tlog.debug bucketCreatePost\n\n\ttry {\n\t\t// Create a bucket on Initial State so the data has a logical grouping\n\t\thttpPostJson(bucketCreatePost) { resp ->\n\t\t\tlog.debug \"bucket posted\"\n\t\t\tif (resp.status >= 400) {\n\t\t\t\tlog.error \"bucket not created successfully\"\n\t\t\t} else {\n\t\t\t\tatomicState.isBucketCreated = true\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"bucket creation error: $e\"\n\t}\n\n}\n\ndef genericHandler(evt) {\n\tlog.trace \"$evt.displayName($evt.name:$evt.unit) $evt.value\"\n\n\tdef key = \"$evt.displayName($evt.name)\"\n\tif (evt.unit != null) {\n\t\tkey = \"$evt.displayName(${evt.name}_$evt.unit)\"\n\t}\n\tdef value = \"$evt.value\"\n\n\ttryCreateBucket()\n\n\teventHandler(key, value)\n}\n\ndef eventHandler(name, value) {\n\tdef epoch = now() / 1000\n\n\tdef event = new JsonSlurper().parseText(\"{\\\"key\\\": \\\"$name\\\", \\\"value\\\": \\\"$value\\\", \\\"epoch\\\": \\\"$epoch\\\"}\")\n\n\ttryShipEvents(event)\n\t\n\tlog.debug \"Shipped Event: \" + event\n}\n\ndef tryShipEvents(event) {\n\n\tdef grokerSubdomain = atomicState.grokerSubdomain\n\t// can't ship events if there is no grokerSubdomain\n\tif (grokerSubdomain == null || grokerSubdomain == \"\") {\n\t\tlog.error \"streaming url is currently null\"\n\t\treturn\n\t}\n\tdef accessKey = atomicState.accessKey\n\tdef bucketKey = atomicState.bucketKey\n\t// can't ship if access key and bucket key are null, so finish trying\n\tif (accessKey == null || bucketKey == null) {\n\t\treturn\n\t}\n\n\tdef eventPost = [\n\t\turi: \"https://${grokerSubdomain}.initialstate.com/api/events\",\n\t\theaders: [\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"X-IS-BucketKey\": \"${bucketKey}\",\n\t\t\t\"X-IS-AccessKey\": \"${accessKey}\",\n\t\t\t\"Accept-Version\": \"0.0.2\"\n\t\t],\n\t\tbody: event\n\t]\n\n\ttry {\n\t\t// post the events to initial state\n\t\thttpPostJson(eventPost) { resp ->\n\t\t\tlog.debug \"shipped events and got ${resp.status}\"\n\t\t\tif (resp.status >= 400) {\n\t\t\t\tlog.error \"shipping failed... ${resp.data}\"\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"shipping events failed: $e\"\n\t}\n\n}",
        "docstring": "A SmartThings SmartApp to allow SmartThings events to be viewable inside an Initial State Event Bucket in your https://www.initialstate.com account."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(motionToggler, \"motion\", toggleSwitches)\n}\n\n\ndef toggleSwitches(evt) {\n\tlog.debug \"$evt.value\"\n  \n\tif (evt.value == \"active\" && masterToggle.currentSwitch == \"off\") {\n//    \tfor (thisSwitch in switchesToToggle) {\n//        \tlog.debug \"$thisSwitch.label\"\n//  \t\t\tthisSwitch.on()\n\t\tswitchesToToggle.on()\n        masterToggle.on()\n    } else if (evt.value == \"active\" && masterToggle.currentSwitch == \"on\") {\n//    \tfor (thisSwitch in switchesToToggle) {\n//        \tlog.debug \"$thisSwitch.label\"\n//        \tthisSwitch.off()\n\t\tswitchesToToggle.off()\n        masterToggle.off()\n        }\n\n}",
        "docstring": "Toggle lights on/off with a motion sensor"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(doorSensor, \"doorState\", coopDoorStateHandler)\n}\n\ndef coopDoorStateHandler(evt) {\n\tif (evt.value == \"jammed\"){\n        def msg = \"WARNING ${doorSensor.displayName} door is jammed and did not close!\"\n        log.debug \"WARNING ${doorSensor.displayName} door is jammed and did not close, texting $phone\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(msg, recipients)\n        }\n        else {\n            sendPush(msg)\n            if (phone) {\n                sendSms(phone, msg)\n            }\n        }\n\t}        \n}",
        "docstring": "Sends a SmartThings notification and text messages when your CoopBoss detects a door jam."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(doorSensor, \"doorState\", coopDoorStateHandler)\n}\n\ndef coopDoorStateHandler(evt) {\n    log.debug \"${evt.descriptionText}, $evt.value\"\n\tdef color = \"White\"\n    def hueColor = 100\n    def saturation = 100\n    Map hClr = [:]\n    hClr.hex = \"#FFFFFF\"\n\n\tswitch(evt.value) {\n    \tcase \"open\":\n        \tcolor = \"Blue\"\n            break;\n        case \"opening\":\n        \tcolor = \"Purple\"\n            break;\n        case \"closed\":\n        \tcolor = \"Green\"\n            break;\n    \tcase \"closing\":\n        \tcolor = \"Pink\"\n            break;\n        case \"jammed\":\n        \tcolor = \"Red\"\n            break;\n        case \"forced close\":\n        \tcolor = \"Orange\"\n            break;\n        case \"unknown\":\n        \tcolor = \"White\"\n            break;        \n    }   \n       \n\tswitch(color) {\n\t\tcase \"White\":\n\t\t\thueColor = 52\n\t\t\tsaturation = 19\n\t\t\tbreak;\n\t\tcase \"Daylight\":\n\t\t\thueColor = 53\n\t\t\tsaturation = 91\n\t\t\tbreak;\n\t\tcase \"Soft White\":\n\t\t\thueColor = 23\n\t\t\tsaturation = 56\n\t\t\tbreak;\n\t\tcase \"Warm White\":\n\t\t\thueColor = 20\n\t\t\tsaturation = 80 //83\n\t\t\tbreak;\n\t\tcase \"Blue\":\n\t\t\thueColor = 70\n            hClr.hex = \"#0000FF\"\n\t\t\tbreak;\n\t\tcase \"Green\":\n\t\t\thueColor = 39\n            hClr.hex = \"#00FF00\"\n\t\t\tbreak;\n\t\tcase \"Yellow\":\n\t\t\thueColor = 25\n            hClr.hex = \"#FFFF00\"            \n\t\t\tbreak;\n\t\tcase \"Orange\":\n\t\t\thueColor = 10\n            hClr.hex = \"#FF6000\"\n\t\t\tbreak;\n\t\tcase \"Purple\":\n\t\t\thueColor = 75\n            hClr.hex = \"#BF7FBF\"\n\t\t\tbreak;\n\t\tcase \"Pink\":\n\t\t\thueColor = 83\n            hClr.hex = \"#FF5F5F\"\n\t\t\tbreak;\n\t\tcase \"Red\":\n\t\t\thueColor = 100\n            hClr.hex = \"#FF0000\"\n\t\t\tbreak;\n\t}    \n    \n    //bulbs*.on()\n    bulbs*.setHue(hueColor)\n\tbulbs*.setSaturation(saturation)   \n    bulbs*.setColor(hClr)\n    \n    //bulbs.each{\n    \t//it.on()  // Turn the bulb on when open (this method does not come directly from the colorControl capability)\n    \t//it.setLevel(100)  // Make sure the light brightness is 100%       \n    \t//it.setHue(hueColor)\n\t\t//it.setSaturation(saturation) \n        //}        \n}",
        "docstring": "Change the color of your Hue bulbs based on your coop's door status."
    },
    {
        "code": "def installed() {\n\n\tlog.debug \"${app.label} installed with settings: ${settings}\"\n\n\tstate.app_enabled = false\n\tstate.fan_control_enabled = false\n\n\tstate.fansOn = false\n\tstate.fansOnTime = now()\n\tstate.fansLastRunTime = 0\n\n\tinitialize()\n\n}\n\n\ndef uninstalled()\n{\n\n   \tsend(\"${app.label} uninstalled.\")\n    \n\tstate.app_enabled = false\n\n\tset_fans(false)\n\n\tstate.fan_control_enabled = false\n\n}\n\n\ndef updated() {\n\n\tlog.debug \"${app.label} updated with settings: ${settings}\"\n\n\tunsubscribe()\n\n\tinitialize()\n\n}\n\n\ndef initialize() {\n\n\tif (settings.fan_control_enabled) {\n\t\tif(state.fan_control_enabled == false) {\n\t\t\tsend(\"Vent Fan Control Enabled.\")\n        } else {\n        \tlog.debug \"Vent Fan Control Enabled.\"\n        }\n\n\t\tstate.fan_control_enabled = true\n\t} else {\n\t\tif(state.fan_control_enabled == true) {\n\t\t\tsend(\"Vent Fan Control Disabled.\")\n        } else {\n        \tlog.debug \"Vent Fan Control Disabled.\"\n        }\n\n\t\tstate.fan_control_enabled = false\n\t}\n\n\tif (settings.app_enabled) {\n\t\tif(state.app_enabled == false) {\n\t\t\tsend(\"${app.label} Enabled.\")\n        } else {\n        \tlog.debug \"${app.label} Enabled.\"\n        }\n\n\t\tsubscribe(humidity_sensor, \"humidity\", \"handleThings\")\n\n\t\tstate.app_enabled = true\n\t} else {\n\t\tif(state.app_enabled == true) {\n\t\t\tsend(\"${app.label} Disabled.\")\n        } else {\n        \tlog.debug \"${app.label} Disabled.\"\n        }\n\n\t\tstate.app_enabled = false\n    }\n\n    handleThings()\n\n}\n\n\ndef handleThings(evt) {\n\n\n\tlog.debug \"handleThings()\"\n\n\tif(evt) {\n\t\tlog.debug \"$evt.descriptionText\"\n    }\n        \n\tdef h = 0.0 as BigDecimal\n\tif (settings.app_enabled) {\n\t    h = settings.humidity_sensor.currentValue('humidity')\n/*\n\t\t//Simulator is broken and requires this work around for testing.\t\n\t\tif (settings.humidity_sensor.latestState('humidity')) {\n        \tlog.debug settings.humidity_sensor.latestState('humidity').stringValue[0..-2]\n        \th = settings.humidity_sensor.latestState('humidity').stringValue[0..-2].toBigDecimal()\n        } else {\n        \th = 20\n        }        \n*/\n\t}\n\n\tlog.debug \"Humidity: $h%, Activate: $humidity_a%, Deactivate: $humidity_d%\"\n\n    def activateFans = false\n    def deactivateFans = false\n    \n\tif (settings.app_enabled) {\n        \n\t\tif (state.fansOn) {\n            if (h > humidity_d) {\n                log.debug \"Humidity not sufficient to deactivate vent fans: $h > $humidity_d\"\n            } else {\n                log.debug \"Humidity sufficient to deactivate vent fans: $h <= $humidity_d\"\n                deactivateFans = true\n            }\n        } else {\n            if (h < humidity_a) {\n                log.debug \"Humidity not sufficient to activate vent fans: $h < $humidity_a\"\n            } else {\n                log.debug \"Humidity sufficient to activate vent fans: $h >= $humidity_a\"\n                activateFans = true\n            }\n        }\n\t}\n\n\tif(activateFans) {\n\t\tset_fans(true)\n    }\n\tif(deactivateFans) {\n\t\tset_fans(false)\n    }\n\n}\n\n\ndef set_fans(fan_state) {\n\n\tif (fan_state) {\n    \tif (state.fansOn == false) {\n            send(\"${app.label} fans On.\")\n            state.fansOnTime = now()\n            if (settings.fan_control_enabled) {\n                if (emeters) {\n                    emeters.reset()\n                }\n                fans.on()\n            } else {\n                send(\"${app.label} fan control is disabled.\")\n            }\n            state.fansOn = true\n\t\t} else {\n            log.debug \"${app.label} fans already On.\"\n\t\t}        \n    } else {\n    \tif (state.fansOn == true) {\n\t    \tsend(\"${app.label} fans Off.\")\n            state.fansLastRunTime = (now() - state.fansOnTime)\n\n\t\t    BigInteger ms = new java.math.BigInteger(state.fansLastRunTime)\n\t\t\tint seconds = (BigInteger) (((BigInteger) ms / (1000I))                  % 60I)\n\t\t\tint minutes = (BigInteger) (((BigInteger) ms / (1000I * 60I))            % 60I)\n\t\t\tint hours   = (BigInteger) (((BigInteger) ms / (1000I * 60I * 60I))      % 24I)\n\t\t\tint days    = (BigInteger)  ((BigInteger) ms / (1000I * 60I * 60I * 24I))\n\n\t\t\tdef sb = String.format(\"${app.label} cycle: %d:%02d:%02d:%02d\", days, hours, minutes, seconds)\n\t\t\t\n\t\t    send(sb)\n\n\t\t\tif (settings.fan_control_enabled) {\n    \t    \tfans.off()\n                if (emeters) {\n                    log.debug emeters.currentValue('energy')\n                    //TODO: How to ensure latest (most accurate) energy reading?\n                    emeters.poll() //[configure, refresh, on, off, poll, reset]\n//                    emeters.refresh() //[configure, refresh, on, off, poll, reset]\n                    state.fansLastRunEnergy = emeters.currentValue('energy').sum()\n                    state.fansLastRunCost = ((state.fansLastRunEnergy * price_kwh) / 100.0) \n                    send(\"${app.label} cycle: ${state.fansLastRunEnergy}kWh @ \\$${state.fansLastRunCost}\")\n                }\n\t        } else {\n    \t    \tsend(\"${app.label} fan control is disabled.\")\n            }\n\t        state.fansOn = false\n            state.fansHoldoff = now()\n        } else {\n            log.debug \"${app.label} fans already Off.\"\n        }\n    }\n\n}\n\n\nprivate send(msg) {\n\n\tif (sendPushMessage) {\n        sendPush(msg)\n    }\n\n    if (phone) {\n        sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n}",
        "docstring": "When the humidity reaches a specified level, activate one or more vent fans until the humidity is reduced to a specified level."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(jawbone, \"sleeping\", sendit)\n}\n\ndef sendit(evt) {\n\tlog.debug \"$evt.value: $evt\"\n\tsendMessage()\n}\n\ndef sendMessage() {\n\tlog.debug \"Sending Message\"\n\tdef msg = warnMessage\n    log.info msg\n    if (phone1) {\n        sendSms phone1, msg\n    }\n    if (phone2) {\n        sendSms phone2, msg\n    }\n    if (phone3) {\n        sendSms phone3, msg\n    }\n    if (!phone1 && !phone2 && !phone3) {\n    \tsendPush msg\n    }\n}",
        "docstring": "Send push notifications or text messages with your Jawbone Up when you hold the button."
    },
    {
        "code": "def installed() {\n\n\tif (!state.accessToken) {\n\t\tlog.debug \"About to create access token\"\n\t\tcreateAccessToken()\n\t}\n\n\tif (state.JawboneAccessToken) {\n\t\tsetup()\n\t}\n}\n\ndef updated() {\n\n\tif (!state.accessToken) {\n\t\tlog.debug \"About to create access token\"\n\t\tcreateAccessToken()\n\t}\n\n\tif (state.JawboneAccessToken) {\n\t\tsetup()\n\t}\n}\n\ndef uninstalled() {\n\tif (state.JawboneAccessToken) {\n\t\ttry {\n\t\t\thttpDelete(uri: \"https://jawbone.com/nudge/api/v.1.0/users/@me/PartnerAppMembership\", headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) { response ->\n\t\t\t\tlog.debug \"Success disconnecting Jawbone from SmartThings\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tlog.error \"Error disconnecting Jawbone from SmartThings: ${e.statusCode}\"\n\t\t}\n\t}\n}\n\ndef pollChild(childDevice) {\n\t\tdef childMap = [ value: \"$childDevice.device.deviceNetworkId}\"]\n\n\t\tdef params = [\n\t\t\t\turi: 'https://jawbone.com',\n\t\t\t\tpath: '/nudge/api/users/@me/goals',\n\t\t\t\theaders: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ],\n\t\t\t\tcontentType: 'application/json'\n\t\t]\n\n\t\tasynchttp_v1.get('responseGoals', params, childMap)\n\n\t\tdef params2 = [\n\t\t\t\turi: 'https://jawbone.com',\n\t\t\t\tpath: '/nudge/api/users/@me/moves',\n\t\t\t\theaders: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ],\n\t\t\t\tcontentType: 'application/json'\n\t\t]\n\n\t\tasynchttp_v1.get('responseMoves', params2, childMap)\n}\n\ndef responseGoals(response, dni) {\n\tif (response.hasError()) {\n\t\t\tlog.error \"response has error: $response.errorMessage\"\n\t} else {\n\t\t\tdef goals\n\t\t\ttry {\n\t\t\t\t\t// json response already parsed into JSONElement object\n\t\t\t\t\tgoals = response.json.data\n\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"error parsing json from response: $e\"\n\t\t\t}\n\t\t\tif (goals) {\n\t\t\t\tdef childDevice = getChildDevice(dni.value)\n\t\t\t\tlog.debug \"Goal = ${goals.move_steps} Steps\"\n\t\t\t\tchildDevice?.sendEvent(name:\"goal\", value: goals.move_steps)\n\t\t\t} else {\n\t\t\t\t\tlog.debug \"did not get json results from response body: $response.data\"\n\t\t\t}\n\t}\n}\n\ndef responseMoves(response, dni) {\n\tif (response.hasError()) {\n\t\t\tlog.error \"response has error: $response.errorMessage\"\n\t} else {\n\t\t\tdef moves\n\t\t\ttry {\n\t\t\t\t\t// json response already parsed into JSONElement object\n\t\t\t\t\tmoves = response.json.data.items[0]\n\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"error parsing json from response: $e\"\n\t\t\t}\n\t\t\tif (moves) {\n\t\t\t\tdef childDevice = getChildDevice(dni.value)\n\t\t\t\tlog.debug \"Moves = ${moves.details.steps} Steps\"\n\t\t\t\tchildDevice?.sendEvent(name:\"steps\", value: moves.details.steps)\n\t\t\t} else {\n\t\t\t\t\tlog.debug \"did not get json results from response body: $response.data\"\n\t\t\t}\n\t}\n}\n\ndef setColor (steps,goal,childDevice) {\n    def result = steps * 100 / goal\n    if (result < 25)\n    \tchildDevice?.sendEvent(name:\"steps\", value: \"steps\", label: steps)\n    else if ((result >= 25) && (result < 50))\n        childDevice?.sendEvent(name:\"steps\", value: \"steps1\", label: steps)\n    else if ((result >= 50) && (result < 75))\n        childDevice?.sendEvent(name:\"steps\", value: \"steps1\", label: steps)\n    else if (result >= 75)\n        childDevice?.sendEvent(name:\"steps\", value: \"stepsgoal\", label: steps)\n}\n\ndef hookEventHandler() {\n    // log.debug \"In hookEventHandler method.\"\n    log.debug \"request = ${request}\"\n\n    def json = request.JSON\n\n    // get some stuff we need\n    def userId = json.events.user_xid[0]\n    def\tjson_type = json.events.type[0]\n\t  def json_action = json.events.action[0]\n\n    //log.debug json\n    log.debug \"Userid = ${userId}\"\n    log.debug \"Notification Type: \" + json_type\n    log.debug \"Notification Action: \" + json_action\n\n    // find the appropriate child device based on my app id and the device network id\n    def externalId = \"${app.id}.${userId}\"\n    def childDevice = getChildDevice(\"${externalId}\")\n\n    if (childDevice) {\n    \tswitch (json_action) {\n\t        case \"enter_sleep_mode\":\n            \tchildDevice?.generateSleepingEvent(true)\n                break\n            case \"exit_sleep_mode\":\n            \tchildDevice?.generateSleepingEvent(false)\n                break\n            case \"creation\":\n                childDevice?.sendEvent(name:\"steps\", value: 0)\n          \t\tbreak\n            case \"updation\":\n                def urlgoals = \"https://jawbone.com/nudge/api/users/@me/goals\"\n                def urlmoves = \"https://jawbone.com/nudge/api/users/@me/moves\"\n                def goals = null\n                def moves = null\n                httpGet(uri: urlgoals, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) {response ->\n \t               goals = response.data.data\n                }\n                httpGet(uri: urlmoves, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) {response ->\n                   moves = response.data.data.items[0]\n                }\n                log.debug \"Goal = ${goals.move_steps} Steps\"\n        \t\t\t\tlog.debug \"Steps = ${moves.details.steps} Steps\"\n                childDevice?.sendEvent(name:\"steps\", value: moves.details.steps)\n                childDevice?.sendEvent(name:\"goal\", value: goals.move_steps)\n                //setColor(moves.details.steps,goals.move_steps,childDevice)\n                break\n\t\t\tcase \"deletion\":\n\t\t\t\tapp.delete()\n\t\t\t\tbreak\n\t\t}\n    }\n    else {\n            log.debug \"Couldn't find child device associated with Jawbone.\"\n    }\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}",
        "docstring": "Connect your Jawbone UP to SmartThings"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(motion1, \"motion\", motionHandler)\n\tschedule(\"0 * * * * ?\", \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion\", motionHandler)\n\tunschedule()\n\tschedule(\"0 * * * * ?\", \"scheduleCheck\")\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"turning on lights\"\n\t\tswitches.off()\n\t\tstate.inactiveAt = null\n\t} else if (evt.value == \"inactive\") {\n\t\tif (!state.inactiveAt) {\n\t\t\tstate.inactiveAt = now()\n\t\t}\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check, ts = ${state.inactiveAt}\"\n\tif (state.inactiveAt) {\n\t\tdef elapsed = now() - state.inactiveAt\n\t\tdef threshold = 1000 * 60 * minutes1\n\t\tif (elapsed >= threshold) {\n\t\t\tlog.debug \"turning off lights\"\n\t\t\tswitches.on()\n\t\t\tstate.inactiveAt = null\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"${elapsed / 1000} sec since motion stopped\"\n\t\t}\n\t}\n}",
        "docstring": "Turns off a device if there is motion"
    },
    {
        "code": "def installed(){\n    initialize()\n}\n\ndef updated(){\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize(){\n    log.debug \"Settings: ${settings}\"\n    subscribe(lock1, \"lock\", doorHandler, [filterEvents: false])\n    subscribe(lock1, \"unlock\", doorHandler, [filterEvents: false])  \n    subscribe(contact, \"contact.open\", doorHandler)\n    subscribe(contact, \"contact.closed\", doorHandler)\n}\n\ndef lockDoor(){\n    log.debug \"Locking the door.\"\n    lock1.lock()\n    if(location.contactBookEnabled) {\n        if ( recipients ) {\n            log.debug ( \"Sending Push Notification...\" ) \n            sendNotificationToContacts( \"${lock1} locked after ${contact} was closed for ${minutesLater} minutes!\", recipients)\n        }\n    }\n    if (phoneNumber) {\n        log.debug(\"Sending text message...\")\n        sendSms( phoneNumber, \"${lock1} locked after ${contact} was closed for ${minutesLater} minutes!\")\n    }\n}\n\ndef unlockDoor(){\n    log.debug \"Unlocking the door.\"\n    lock1.unlock()\n    if(location.contactBookEnabled) {\n        if ( recipients ) {\n            log.debug ( \"Sending Push Notification...\" ) \n            sendNotificationToContacts( \"${lock1} unlocked after ${contact} was opened for ${secondsLater} seconds!\", recipients)\n        }\n    }\n    if ( phoneNumber ) {\n        log.debug(\"Sending text message...\")\n        sendSms( phoneNumber, \"${lock1} unlocked after ${contact} was opened for ${secondsLater} seconds!\")\n    }\n}\n\ndef doorHandler(evt){\n    if ((contact.latestValue(\"contact\") == \"open\") && (evt.value == \"locked\")) { // If the door is open and a person locks the door then...  \n        //def delay = (secondsLater) // runIn uses seconds\n        runIn( secondsLater, unlockDoor )   // ...schedule (in minutes) to unlock...  We don't want the door to be closed while the lock is engaged. \n    }\n    else if ((contact.latestValue(\"contact\") == \"open\") && (evt.value == \"unlocked\")) { // If the door is open and a person unlocks it then...\n        unschedule( unlockDoor ) // ...we don't need to unlock it later.\n    }\n    else if ((contact.latestValue(\"contact\") == \"closed\") && (evt.value == \"locked\")) { // If the door is closed and a person manually locks it then...\n        unschedule( lockDoor ) // ...we don't need to lock it later.\n    }   \n    else if ((contact.latestValue(\"contact\") == \"closed\") && (evt.value == \"unlocked\")) { // If the door is closed and a person unlocks it then...\n       //def delay = (minutesLater * 60) // runIn uses seconds\n        runIn( (minutesLater * 60), lockDoor ) // ...schedule (in minutes) to lock.\n    }\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"open\")) { // If a person opens an unlocked door...\n        unschedule( lockDoor ) // ...we don't need to lock it later.\n    }\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"closed\")) { // If a person closes an unlocked door...\n        //def delay = (minutesLater * 60) // runIn uses seconds\n        runIn( (minutesLater * 60), lockDoor ) // ...schedule (in minutes) to lock.\n    }\n    else { //Opening or Closing door when locked (in case you have a handle lock)\n        log.debug \"Unlocking the door.\"\n        lock1.unlock()\n        if(location.contactBookEnabled) {\n            if ( recipients ) {\n                log.debug ( \"Sending Push Notification...\" ) \n                sendNotificationToContacts( \"${lock1} unlocked after ${contact} was opened or closed when ${lock1} was locked!\", recipients)\n            }\n        }\n        if ( phoneNumber ) {\n            log.debug(\"Sending text message...\")\n            sendSms( phoneNumber, \"${lock1} unlocked after ${contact} was opened or closed when ${lock1} was locked!\")\n        }\n    }\n}",
        "docstring": "Automatically locks a specific door after X minutes when closed  and unlocks it when open after X seconds."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\n\ndef initialize() {\n\n    /*\n      Check to see if the sensor is reporting temperature, then run the updateCurrentWeather\n      every 10 minutes\n    */\n    if (temp.currentTemperature) {\n        runEvery5Minutes(updateCurrentWeather)\n    }\n}\n\n\n/*\n  Updates the Weather Underground Personal Weather Station (PWS) Upload Protocol\n  Reference: http://wiki.wunderground.com/index.php/PWS_-_Upload_Protocol\n*/\ndef updateCurrentWeather() {\n\n    // Logs of the current data from the sensor\n    log.trace \"Temp: \" + temp.currentTemperature\n    log.trace \"Humidity: \" + humidity.currentHumidity\n    log.trace \"Dew Point: \" + calculateDewPoint(temp.currentTemperature, humidity.currentHumidity)\n\n    // Builds the URL that will be sent to Weather Underground to update your PWS\n    def params = [\n        uri: \"http://weatherstation.wunderground.com\",\n        path: \"/weatherstation/updateweatherstation.php\",\n        query: [\n            \"ID\": weatherID,\n            \"PASSWORD\": password,\n            \"dateutc\": \"now\",\n            \"tempf\": temp.currentTemperature,\n            \"humidity\": humidity.currentHumidity,\n            \"dewptf\": calculateDewPoint(temp.currentTemperature, humidity.currentHumidity),\n            \"action\": \"updateraw\",\n            \"softwaretype\": \"SmartThings\"\n        ]\n    ]\n    \n    try {\n        // Make the HTTP request using httpGet()\n        httpGet(params) { resp -> // This is how we define the \"return data\". Can also use $it.\n            log.debug \"response data: ${resp.data}\"\n        }\n    } catch (e) {\n        log.error \"something went wrong: $e\"\n    }\n\n}\n\n// Calculates dewpoint based on temperature and humidity\ndef calculateDewPoint(t, rh) {\n    def dp = 243.04 * ( Math.log(rh / 100) + ( (17.625 * t) / (243.04 + t) ) ) / (17.625 - Math.log(rh / 100) - ( (17.625 * t) / (243.04 + t) ) ) \n    // Format the response for Weather Underground\n    return new DecimalFormat(\"##.##\").format(dp)\n}",
        "docstring": "Connect your SmartSense Temp/Humidity sensor to your Weather Underground Personal Weather Station."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n        \n\tinitialize()\n}\n\ndef initialize() {\n\n    // will stop LED notification incase it was set by med reminder\n    subscribe(deviceContactSensor, \"contact\", contactHandler)\n\n    // how many minutes to look in the past from the reminder time, for an open draw\n    state.minutesToCheckOpenDraw = 60\n    \n    // is true when LED notification is set after exceeding 10 minutes past reminder time\n    state.ledNotificationTriggered = false\n    \n    // Set a timer to run once a day to notify if draw wasn't opened yet\n    schedule(reminderTime, checkOpenDrawInPast)\n   \n}\n\n// Should turn off any LED notification on OPEN state\ndef contactHandler(evt){\n\tif (evt.value == \"open\") {\n        // if LED notification triggered, reset it.\n        log.debug \"Cabinet opened\"\n        if (state.ledNotificationTriggered) {\n            resetLEDNotification()\n        }\n\t}\n}\n\n// If the draw was NOT opened within 60 minutes of the timer send notification out.\ndef checkOpenDrawInPast(){\n\tlog.debug \"Checking past 60 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 60 minutes for any OPENED status\n    def cabinetOpened = isOpened(state.minutesToCheckOpenDraw)\n\tlog.debug \"Cabinet found opened: $cabinetOpened\"\n    \n    // if it's opened, then do nothing and assume they took their meds\n    if (!cabinetOpened) {    \n    \tsendNotification(\"Hi, please remember to take your meds in the cabinet\")\n       \n       // if no open activity, send out notification and set new reminder    \n        def reminderTimePlus10 = new Date(now() + (10 * 60000))\n\n        // needs to be scheduled if draw wasn't already opened\n        runOnce(reminderTimePlus10, checkOpenDrawAfterReminder)\n    }\n}\n\n// If the draw was NOT opened after 10 minutes past reminder, use LED notification\ndef checkOpenDrawAfterReminder(){\n\tlog.debug \"Checking additional 10 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 10 minutes for any OPENED status\n    def cabinetOpened = isOpened(10)    \n    \n   \tlog.debug \"Cabinet found opened: $cabinetOpened\"\n        \n    // if no open activity, blink lights\n    if (!cabinetOpened) {\n    \tlog.debug \"Set LED to Notification color\"\n        setLEDNotification()\n    }\n    \n}\n\n// Helper function for sending out an app notification\ndef sendNotification(msg){\n        log.debug \"Message Sent: $msg\"\n        sendPush(msg)\n}\n\n// Check if the sensor has been opened since the minutes entered\n// Return true if opened found, else false.\ndef isOpened(minutes){\n    // query last X minutes of activity log    \n    def previousDateTime = new Date(now() - (minutes * 60000))\n    \n    // capture all events recorded\n    def evts = deviceContactSensor.eventsSince(previousDateTime)   \n    def cabinetOpened = false\n    if (evts.size() > 0) {\n        evts.each{\n            if(it.value == \"open\") {\n                cabinetOpened = true \n            }\n        }\n\t}\n    \n    return cabinetOpened\n}\n\n// Saves current color and sets the light to RED\ndef setLEDNotification(){\n\n\tstate.ledNotificationTriggered = true\n    \n\t// turn light back off when reset is called if it was originally off\n \tstate.ledState = deviceLight.currentValue(\"switch\")\n\n\t// set light to RED and store original color until stopped    \n    state.origColor = deviceLight.currentValue(\"hue\")\n    deviceLight.on()\n    deviceLight.setHue(100)\n    \n    log.debug \"LED set to RED. Original color stored: $state.origColor\"\n\n}\n\n// Sets the color back to the original saved color\ndef resetLEDNotification(){\n\n\tstate.ledNotificationTriggered = false\n    \n    // return color to original\n    log.debug \"Reset LED color to: $state.origColor\"\n    if (state.origColor != null) {\n    \tdeviceLight.setHue(state.origColor)\n    }\n    \n    // if the light was turned on just for the notification, turn it back off now\n    if (state.ledState == \"off\") {\n    \tdeviceLight.off()\n    }\n\n}",
        "docstring": "This supports devices with capabilities of ContactSensor and ColorControl (LED). It sends an in-app and ambient light notification if you forget to open the drawer or cabinet where meds are stored. A reminder will be set to a single time per day. If the draw or cabinet isn't opened within 60 minutes of that reminder, an in-app message will be sent. If the draw or cabinet still isn't opened after an additional 10 minutes, then an LED light turns red until the draw or cabinet is opened"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n        \n\tinitialize()\n}\n\ndef initialize() {\n\t// will notify when temp exceeds max\n    subscribe(deviceTemperatureMeasurement, \"temperature\", tempHandler)\n\n    // will stop LED notification incase it was set by med reminder\n    subscribe(deviceAccelerationSensor, \"acceleration.active\", motionHandler)\n    \n    // how many minutes to look in the past from the reminder time\n    state.minutesToCheckPriorToReminder = 60\n    \n    // Set a timer to run once a day to notify if draw wasn't opened yet\n    schedule(reminderTime, checkMotionInPast)\n}\n\n\n// If temp > 39 then send an app notification out.\ndef tempHandler(evt){\n\tif (evt.doubleValue > tempThreshold) {\n    \tlog.debug \"Fridge temp of $evt.value exceeded threshold\"\n   \t\tsendNotification(\"WARNING: Fridge temp is $evt.value with threshold of $tempThreshold\")\n\t}\n}\n\n// Should turn off any LED notification once motion detected\ndef motionHandler(evt){\n    // always call out to stop any possible LED notification\n\tlog.debug \"Medication moved. Send stop LED notification\"\n    resetLEDNotification()\n}\n\n// If no motion detected within 60 minutes of the timer send notification out.\ndef checkMotionInPast(){\n\tlog.debug \"Checking past 60 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 60 minutes for any OPENED status\n    def movement = isMoved(state.minutesToCheckPriorToReminder)\n\tlog.debug \"Motion found: $movement\"\n    \n    // if there was movement, then do nothing and assume they took their meds\n    if (!movement) {    \n    \tsendNotification(\"Hi, please remember to take your meds in the fridge\")\n    \n        // if no movement, send out notification and set new reminder    \n        def reminderTimePlus10 = new Date(now() + (10 * 60000))\n\n        // needs to be scheduled if draw wasn't already opened\n        runOnce(reminderTimePlus10, checkMotionAfterReminder)\n    }\n}\n\n// If still no movement after 10 minutes past reminder, use LED notification\ndef checkMotionAfterReminder(){\n\tlog.debug \"Checking additional 10 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 10 minutes for any OPENED status\n    def movement = isMoved(10)    \n    \n   \tlog.debug \"Motion found: $movement\"\n        \n    // if no open activity, blink lights\n    if (!movement) {\n    \tlog.debug \"Notify LED API\"\n        setLEDNotification()\n    }\n    \n}\n\n// Helper function for sending out an app notification\ndef sendNotification(msg){\n        log.debug \"Message Sent: $msg\"\n        sendPush(msg)\n}\n\n// Check if the accelerometer has been activated since the minutes entered\n// Return true if active, else false.\ndef isMoved(minutes){\n    // query last X minutes of activity log    \n    def previousDateTime = new Date(now() - (minutes * 60000))\n    \n    // capture all events recorded\n    def evts = deviceAccelerationSensor.eventsSince(previousDateTime)   \n    def motion = false\n    if (evts.size() > 0) {\n        evts.each{\n            if(it.value == \"active\") {\n                motion = true \n            }\n        }\n\t}\n    \n    return motion\n}\n\n// Saves current color and sets the light to RED\ndef setLEDNotification(){\n\n\t// turn light back off when reset is called if it was originally off\n \tstate.ledState = deviceLight.currentValue(\"switch\")\n\n\t// set light to RED and store original color until stopped    \n    state.origColor = deviceLight.currentValue(\"hue\")\n    deviceLight.on()\n    deviceLight.setHue(100)\n    \n    log.debug \"LED set to RED. Original color stored: $state.origColor\"\n\n}\n\n// Sets the color back to the original saved color\ndef resetLEDNotification(){\n\n    // return color to original\n    log.debug \"Reset LED color to: $state.origColor\"\n    deviceLight.setHue(state.origColor)\n    \n    // if the light was turned on just for the notification, turn it back off now\n    if (state.ledState == \"off\") {\n    \tdeviceLight.off()\n    }\n}",
        "docstring": "This only supports devices with capabilities TemperatureMeasurement, AccelerationSensor and ColorControl (LED). Supports two use cases. First, will notifies via in-app if the fridge where meds are stored exceeds a temperature threshold set in degrees. Secondly, sends an in-app and ambient light notification if you forget to take your meds by sensing movement of the medicine box in the fridge. A reminder will be set to a single time per day. If the box isn't moved within 60 minutes of that reminder, an in-app message will be sent. If the box still isn't moved after an additional 10 minutes, then an LED light turns red until the box is moved"
    },
    {
        "code": "def installed() {\n\tinit()\n}\n\ndef updated(){\n\tunsubscribe()\n    init()\n}\n\ndef init() {\n\tsubscribe(master, \"switch\", onOffHandler)\n\tsubscribe(master, \"level\", colorHandler)\n    subscribe(master, \"hue\", colorHandler)\n    subscribe(master, \"saturation\", colorHandler)\n    subscribe(master, \"colorTemperature\", tempHandler)\n}\n//-----------------------------------\ndef onOffHandler(evt){\n\tif (slaves && master) {\n\t\tif (!slaves?.id.find{it==master?.id}){\n\t\tif (master?.currentValue(\"switch\") == \"on\"){\n\t\t    if (randomYes) getRandomColorMaster()\n\t\t\t\telse slaves?.on()\n\t\t}\n\t\telse {\n\t\t    slaves?.off()\n\t\t}\n\t\t}\n\t}\n}\n\ndef colorHandler(evt) {\n\tif (slaves && master) {\n\t\tif (!slaves?.id?.find{it==master?.id} && master?.currentValue(\"switch\") == \"on\"){\n\t\t\tlog.debug \"Changing Slave units H,S,L\"\n\t\t\tdef dimLevel = master?.currentValue(\"level\")\n\t\t\tdef hueLevel = master?.currentValue(\"hue\")\n\t\t\tdef saturationLevel = master.currentValue(\"saturation\")\n\t\t\tdef newValue = [hue: hueLevel, saturation: saturationLevel, level: dimLevel as Integer]\n\t\t\tslaves?.setColor(newValue)\n\t\t}\n\t}\n}\n\ndef getRandomColorMaster(){\n    def hueLevel = Math.floor(Math.random() *1000)\n    def saturationLevel = Math.floor(Math.random() * 100)\n    def dimLevel = master?.currentValue(\"level\")\n\tdef newValue = [hue: hueLevel, saturation: saturationLevel, level: dimLevel as Integer]\n    log.debug hueLevel\n    log.debug saturationLevel\n    master.setColor(newValue)\n    slaves?.setColor(newValue)\n}\n\ndef tempHandler(evt){\n\tif (slaves && master) {\n\t    if (!slaves?.id?.find{it==master?.id} && master?.currentValue(\"switch\") == \"on\"){\n\t\tif (evt.value != \"--\") {\n\t\t    log.debug \"Changing Slave color temp based on Master change\"\n\t\t    def tempLevel = master.currentValue(\"colorTemperature\")\n\t\t    slaves?.setColorTemperature(tempLevel)\n\t\t}\n\t\t}\n\t}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Color Coordinator\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 1.1.2 (4/27/2018)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright \u00a9 2018 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"This application will allow you to control the settings of multiple colored lights with one control. \" +\n        \"Simply choose a master control light, and then choose the lights that will follow the settings of the master, \"+\n        \"including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.\"\n}",
        "docstring": "Ties multiple colored lights to one specific light's settings"
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    init()\n}\n\ndef updated() {\n    unschedule()\n    turnOffSwitch() //Turn off all switches if the schedules are changed while in mid-schedule\n    unsubscribe()\n    log.debug \"Updated with settings: ${settings}\"\n    init()\n}\n\ndef init() {\n\tdef midnightTime = timeToday(\"2000-01-01T00:01:00.999-0000\", location.timeZone)\n    schedule (midnightTime, midNight)\n\tsubscribe(location, \"mode\", locationHandler)\n    startProcess()\n}\n\n// Common methods\n\ndef startProcess () {\n    createDayArray()\n\tstate.dayCount=state.data.size()\n    if (state.dayCount){\n\t\tstate.counter = 0\n        startDay()\n    }\n}\n\ndef startDay() {\n\tdef start = convertEpoch(state.data[state.counter].start)\n\tdef stop = convertEpoch(state.data[state.counter].stop)\n\n    runOnce(start, turnOnSwitch, [overwrite: true])\n    runOnce(stop, incDay, [overwrite: true])\n}\n\ndef incDay() {\n    turnOffSwitch()\n    if (state.modeChange) {\n    \tstartProcess()\n    }\n    else {\n    \tstate.counter = state.counter + 1\n    \tif (state.counter < state.dayCount) {\n    \t\tstartDay()\n    \t}\n    }\n}\n\ndef locationHandler(evt) {\n\tdef result = false\n    state.modeChange = true\n    switches.each {\n    \tif (it.currentValue(\"switch\")==\"on\"){\n           result = true\n        }\n    }\n\tif (!result) {\n    \tstartProcess()\n    }\n}\n\ndef midNight(){\n    startProcess()\n}\n\ndef turnOnSwitch() {\n    switches.on()\n    log.debug \"Home ventilation switches are on.\"\n}\n\ndef turnOffSwitch() {\n    switches.each {\n    \tif (it.currentValue(\"switch\")==\"on\"){\n\t\t\tit.off()\n        }\n    }\n    log.debug \"Home ventilation switches are off.\"\n}\n\ndef schedDesc(on1, off1, on2, off2, on3, off3, on4, off4, modeList, dayList) {\n\tdef title = \"\"\n\tdef dayListClean = \"On \"\n    def modeListClean =\"Scenario runs in \"\n    if (dayList && dayList.size() < 7) {\n    \tdef dayListSize = dayList.size()\n        for (dayName in dayList) {\n        \tdayListClean = \"${dayListClean}\"+\"${dayName}\"\n    \t\tdayListSize = dayListSize -1\n            if (dayListSize) {\n            \tdayListClean = \"${dayListClean}, \"\n            }\n        }\n\t}\n    else {\n    \tdayListClean = \"Every day\"\n    }\n    if (modeList) {\n    \tdef modeListSize = modeList.size()\n        def modePrefix =\"modes\"\n        if (modeListSize == 1) {\n        \tmodePrefix = \"mode\"\n        }\n        for (modeName in modeList) {\n        \tmodeListClean = \"${modeListClean}\"+\"'${modeName}'\"\n    \t\tmodeListSize = modeListSize -1\n            if (modeListSize) {\n            \tmodeListClean = \"${modeListClean}, \"\n            }\n            else {\n            \tmodeListClean = \"${modeListClean} ${modePrefix}\"\n        \t}\n        }\n\t}\n    else {\n    \tmodeListClean = \"${modeListClean}all modes\"\n    }\n    if (on1 && off1){\n    \ttitle += \"Schedule 1: ${humanReadableTime(on1)} to ${humanReadableTime(off1)}\"\n    }\n    if (on2 && off2) {\n    \ttitle += \"\\nSchedule 2: ${humanReadableTime(on2)} to ${humanReadableTime(off2)}\"\n    }\n    if (on3 && off3) {\n    \ttitle += \"\\nSchedule 3: ${humanReadableTime(on3)} to ${humanReadableTime(off3)}\"\n    }\n    if (on4 && off4) {\n    \ttitle += \"\\nSchedule 4: ${humanReadableTime(on4)} to ${humanReadableTime(off4)}\"\n    }\n    if (on1 || on2 || on3 || on4) {\n    \ttitle += \"\\n$modeListClean\"\n    \ttitle += \"\\n$dayListClean\"\n    }\n\n    if (!on1 && !on2 && !on3 && !on4) {\n    \ttitle=\"Click to configure scenario\"\n    }\n    title\n}\n\ndef greyOut(on1, on2, on3, on4){\n    def result = on1 || on2 || on3 || on4 ? \"complete\" : \"\"\n}\n\npublic humanReadableTime(dateTxt) {\n\tnew Date().parse(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", dateTxt).format(\"h:mm a\", timeZone(dateTxt))\n}\n\npublic convertEpoch(epochDate) {\n    new Date(epochDate).format(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", location.timeZone)\n}\n\nprivate getTitle(txt, scenario) {\n    def title = txt ? txt : \"Scenario ${scenario}\"\n}\n\nprivate daysOk(dayList) {\n\tdef result = true\n    if (dayList) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = dayList.contains(day)\n\t}\n    result\n}\n\nprivate timeOk(starting, ending) {\n    if (starting && ending) {\n        def currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n        if (start < stop && start >= currTime && stop>=currTime) {\n        \tstate.data << [start:start, stop:stop]\n        }\n    }\n}\n\ndef createDayArray() {\n\tstate.modeChange = false\n    state.data = []\n    if (modeA && modeA.contains(location.mode)) {\n        if (daysOk(daysA)){\n            timeOk(timeOnA1, timeOffA1)\n\t\t\ttimeOk(timeOnA2, timeOffA2)\n\t\t\ttimeOk(timeOnA3, timeOffA3)\n\t\t\ttimeOk(timeOnA4, timeOffA4)\n        }\n    }\n    if (modeB && modeB.contains(location.mode)) {\n        if (daysOk(daysB)){\n\t\t\ttimeOk(timeOnB1, timeOffB1)\n            timeOk(timeOnB2, timeOffB2)\n            timeOk(timeOnB3, timeOffB3)\n            timeOk(timeOnB4, timeOffB4)\n        }\n    }\n    if (modeC && modeC.contains(location.mode)) {\n        if (daysOk(daysC)){\n            timeOk(timeOnC1, timeOffC1)\n            timeOk(timeOnC2, timeOffC2)\n            timeOk(timeOnC3, timeOffC3)\n            timeOk(timeOnC4, timeOffC4)\n        }\n    }\n    if (modeD && modeD.contains(location.mode)) {\n        if (daysOk(daysD)){\n           timeOk(timeOnD1, timeOffD1)\n           timeOk(timeOnD2, timeOffD2)\n           timeOk(timeOnD3, timeOffD3)\n           timeOk(timeOnD4, timeOffD4)\n        }\n    }\n    state.data.sort{it.start}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Smart Home Ventilation\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 2.1.2 (05/31/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright \u00a9 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different \" +\n        \"venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended \"+\n        \"that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  \" +\n        \"avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule \" +\n        \"at 12:15 am or later.\"\n}",
        "docstring": "Allows for setting up various schedule scenarios for turning on and off home ventilation switches."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\" && (phrase_on || onMode)) {\n    \tif (phrase_on){\n        \tlocation.helloHome.execute(settings.phrase_on)\n        }\n        if (onMode) {\n        \tchangeMode(onMode)\n        }\n    } \n    else if (evt.value == \"off\" && (phrase_off || offMode)) {\n    \tif (phrase_off){\n        \tlocation.helloHome.execute(settings.phrase_off)\n    \t}\n        if (offMode) {\n        \tchangeMode(offMode)\n        }\n    }\n}\n\ndef changeMode(newMode) {\n\tif (location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t} else {\n\t\t\tlog.debug \"Unable to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Switch Activates Home Phrase or Mode\"\n}\t\n\nprivate def textVersion() {\n    def text = \"Version 1.0.1 (06/20/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright \u00a9 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT. \"+\n\t\t\"Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. \"+\n\t\t\"Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.\" \n}",
        "docstring": "Ties a Hello, Home phrase or mode to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\") {\n    \tlocation.helloHome.execute(settings.phrase_on)\n    } else {\n    \tlocation.helloHome.execute(settings.phrase_off)\n    }\n}",
        "docstring": "Ties a Hello, Home phrase to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\") {\n    \tchangeMode(onMode)\n    } else {\n    \tchangeMode(offMode)\n    }\n}\n\ndef changeMode(newMode) {\n\n\tif (newMode && location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t}\n\t\telse {\n\t\tlog.debug \"Unable to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}",
        "docstring": "Ties a mode to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "def installed() {\n    initialize()\n}\n\ndef updated() {\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    if (A_alarmType ==\"1\"){\n        alarmSoundUri(A_soundAlarm, A_soundLength, 1)\n    }\n    if (B_alarmType ==\"1\"){\n        alarmSoundUri(B_soundAlarm, B_soundLength, 2)\n    }\n    if (C_alarmType ==\"1\"){\n        alarmSoundUri(C_soundAlarm, C_soundLength, 3)\n    }\n    if (D_alarmType ==\"1\"){\n        alarmSoundUri(D_soundAlarm, D_soundLength, 4)\n    }\n\n    if (alarmSummary && summarySonos) {\n        subscribe(app, appTouchHandler)\n    }\n    if (ScenarioNameA && A_timeStart && A_sonos && A_alarmOn && A_alarmType){\n        schedule (A_timeStart, alarm_A)\n        if (A_musicTrack){\n            saveSelectedSong(A_sonos, A_musicTrack, 1)\n        }\n    }\n    if (ScenarioNameB && B_timeStart && B_sonos &&B_alarmOn && B_alarmType){\n        schedule (B_timeStart, alarm_B)\n        if (B_musicTrack){\n            saveSelectedSong(B_sonos, B_musicTrack, 2)\n        }\n    }\n    if (ScenarioNameC && C_timeStart && C_sonos && C_alarmOn && C_alarmType){\n        schedule (C_timeStart, alarm_C)\n        if (C_musicTrack){\n            saveSelectedSong(C_sonos, C_musicTrack, 3)\n        }\n    }\n    if (ScenarioNameD && D_timeStart && D_sonos && D_alarmOn && D_alarmType){\n        schedule (D_timeStart, alarm_D)\n        if (D_musicTrack){\n            saveSelectedSong(D_sonos, D_musicTrack, 4)\n        }\n    }\n}\n\n//--------------------------------------\n\ndef alarm_A() {\n    if ((!A_mode || A_mode.contains(location.mode)) && getDayOk(A_day)) {\n        if (A_switches || A_dimmers || A_thermostats) {\n            def dimLevel = A_level as Integer\n            A_switches?.on()\n            A_dimmers?.setLevel(dimLevel)\n            if (A_thermostats) {\n                def thermostatState = A_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    A_thermostats.setHeatingSetpoint(A_temperatureH)\n                    A_thermostats.setCoolingSetpoint(A_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    A_thermostats.setHeatingSetpoint(A_temperatureH)\n                    log.info \"Set $A_thermostats Heat $A_temperatureH\u00b0\"\n                }\n                else {\n                    A_thermostats.setCoolingSetpoint(A_temperatureC)\n                    log.info \"Set $A_thermostats Cool $A_temperatureC\u00b0\"\n                }\n               }\n        }\n        if (A_phrase) {\n            location.helloHome.execute(A_phrase)\n        }\n\n        if (A_triggerMode && location.mode != A_triggerMode) {\n            if (location.modes?.find{it.name == A_triggerMode}) {\n                setLocationMode(A_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${A_triggerMode}'\"\n            }\n        }\n\n        if (A_volume) {\n                A_sonos.setLevel(A_volume)\n        }\n\n        if (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\")) {\n            state.fullMsgA = \"\"\n            if (A_wakeMsg) {\n                   getGreeting(A_wakeMsg, 1)\n            }\n\n            if (A_weatherReport || A_humidity || A_includeTemp || A_localTemp) {\n                getWeatherReport(1, A_weatherReport, A_humidity, A_includeTemp, A_localTemp)\n            }\n\n            if (A_includeSunrise || A_includeSunset) {\n                getSunriseSunset(1, A_includeSunrise, A_includeSunset)\n            }\n\n            if ((A_switches || A_dimmers || A_thermostats) && A_confirmSwitches) {\n                getOnConfimation(A_switches, A_dimmers, A_thermostats, 1)\n               }\n\n            if (A_phrase && A_confirmPhrase) {\n                getPhraseConfirmation(1, A_phrase)\n            }\n\n            if (A_triggerMode && A_confirmMode){\n                getModeConfirmation(A_triggerMode, 1)\n            }\n\n            state.soundA = textToSpeech(state.fullMsgA, true)\n        }\n\n        if (A_alarmType == \"1\"){\n            if (A_secondAlarm == \"1\" && state.soundAlarmA){\n                A_sonos.playSoundAndTrack (state.soundAlarmA.uri, state.soundAlarmA.duration, state.soundA.uri)\n            }\n            if (A_secondAlarm == \"2\" && state.selectedSongA && state.soundAlarmA){\n                A_sonos.playSoundAndTrack (state.soundAlarmA.uri, state.soundAlarmA.duration, state.selectedSongA)\n            }\n            if (!A_secondAlarm){\n                A_sonos.playTrack(state.soundAlarmA.uri)\n            }\n        }\n\n        if (A_alarmType == \"2\") {\n            if (A_secondAlarmMusic && state.selectedSongA){\n                A_sonos.playSoundAndTrack (state.soundA.uri, state.soundA.duration, state.selectedSongA)\n            }\n            else {\n                A_sonos.playTrack(state.soundA.uri)\n            }\n        }\n\n        if (A_alarmType == \"3\") {\n               A_sonos.playTrack(state.selectedSongA)\n        }\n    }\n}\n\ndef alarm_B() {\n    if ((!B_mode || B_mode.contains(location.mode)) && getDayOk(B_day)) {\n        if (B_switches || B_dimmers || B_thermostats) {\n            def dimLevel = B_level as Integer\n            B_switches?.on()\n            B_dimmers?.setLevel(dimLevel)\n            if (B_thermostats) {\n                def thermostatState = B_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    B_thermostats.setHeatingSetpoint(B_temperatureH)\n                    B_thermostats.setCoolingSetpoint(B_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    B_thermostats.setHeatingSetpoint(B_temperatureH)\n                    log.info \"Set $B_thermostats Heat $B_temperatureH\u00b0\"\n                }\n                else {\n                    B_thermostats.setCoolingSetpoint(B_temperatureC)\n                    log.info \"Set $B_thermostats Cool $B_temperatureC\u00b0\"\n                }\n               }\n        }\n        if (B_phrase) {\n            location.helloHome.execute(B_phrase)\n        }\n\n        if (B_triggerMode && location.mode != B_triggerMode) {\n            if (location.modes?.find{it.name == B_triggerMode}) {\n                setLocationMode(B_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${B_triggerMode}'\"\n            }\n        }\n\n        if (B_volume) {\n                B_sonos.setLevel(B_volume)\n        }\n\n        if (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\")) {\n            state.fullMsgB = \"\"\n            if (B_wakeMsg) {\n                   getGreeting(B_wakeMsg, 2)\n            }\n\n            if (B_weatherReport || B_humidity || B_includeTemp || B_localTemp) {\n                getWeatherReport(2, B_weatherReport, B_humidity, B_includeTemp, B_localTemp)\n            }\n\n            if (B_includeSunrise || B_includeSunset) {\n                getSunriseSunset(2, B_includeSunrise, B_includeSunset)\n            }\n\n            if ((B_switches || B_dimmers || B_thermostats) && B_confirmSwitches) {\n                getOnConfimation(B_switches, B_dimmers, B_thermostats, 2)\n               }\n\n            if (B_phrase && B_confirmPhrase) {\n                getPhraseConfirmation(2, B_phrase)\n            }\n\n            if (B_triggerMode && B_confirmMode){\n                getModeConfirmation(B_triggerMode, 2)\n            }\n\n            state.soundB = textToSpeech(state.fullMsgB, true)\n        }\n\n        if (B_alarmType == \"1\"){\n            if (B_secondAlarm == \"1\" && state.soundAlarmB) {\n                B_sonos.playSoundAndTrack (state.soundAlarmB.uri, state.soundAlarmB.duration, state.soundB.uri)\n            }\n            if (B_secondAlarm == \"2\" && state.selectedSongB && state.soundAlarmB){\n                B_sonos.playSoundAndTrack (state.soundAlarmB.uri, state.soundAlarmB.duration, state.selectedSongB)\n            }\n            if (!B_secondAlarm){\n                B_sonos.playTrack(state.soundAlarmB.uri)\n            }\n        }\n\n        if (B_alarmType == \"2\") {\n            if (B_secondAlarmMusic && state.selectedSongB){\n                B_sonos.playSoundAndTrack (state.soundB.uri, state.soundB.duration, state.selectedSongB)\n            }\n            else {\n                B_sonos.playTrack(state.soundB.uri)\n            }\n        }\n\n        if (B_alarmType == \"3\") {\n               B_sonos.playTrack(state.selectedSongB)\n        }\n    }\n}\n\ndef alarm_C() {\n    if ((!C_mode || C_mode.contains(location.mode)) && getDayOk(C_day)) {\n        if (C_switches || C_dimmers || C_thermostats) {\n            def dimLevel = C_level as Integer\n            C_switches?.on()\n            C_dimmers?.setLevel(dimLevel)\n            if (C_thermostats) {\n                def thermostatState = C_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    C_thermostats.setHeatingSetpoint(C_temperatureH)\n                    C_thermostats.setCoolingSetpoint(C_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    C_thermostats.setHeatingSetpoint(C_temperatureH)\n                    log.info \"Set $C_thermostats Heat $C_temperatureH\u00b0\"\n                }\n                else {\n                    C_thermostats.setCoolingSetpoint(C_temperatureC)\n                    log.info \"Set $C_thermostats Cool $C_temperatureC\u00b0\"\n                }\n               }\n        }\n        if (C_phrase) {\n            location.helloHome.execute(C_phrase)\n        }\n\n        if (C_triggerMode && location.mode != C_triggerMode) {\n            if (location.modes?.find{it.name == C_triggerMode}) {\n                setLocationMode(C_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${C_triggerMode}'\"\n            }\n        }\n\n        if (C_volume) {\n                C_sonos.setLevel(C_volume)\n        }\n\n        if (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\")) {\n            state.fullMsgC = \"\"\n            if (C_wakeMsg) {\n                   getGreeting(C_wakeMsg, 3)\n            }\n\n            if (C_weatherReport || C_humidity || C_includeTemp || C_localTemp) {\n                getWeatherReport(3, C_weatherReport, C_humidity, C_includeTemp, C_localTemp)\n            }\n\n            if (C_includeSunrise || C_includeSunset) {\n                getSunriseSunset(3, C_includeSunrise, C_includeSunset)\n            }\n\n            if ((C_switches || C_dimmers || C_thermostats) && C_confirmSwitches) {\n                getOnConfimation(C_switches, C_dimmers, C_thermostats, 3)\n               }\n\n            if (C_phrase && C_confirmPhrase) {\n                getPhraseConfirmation(3, C_phrase)\n            }\n\n            if (C_triggerMode && C_confirmMode){\n                getModeConfirmation(C_triggerMode, 3)\n            }\n\n            state.soundC = textToSpeech(state.fullMsgC, true)\n        }\n\n        if (C_alarmType == \"1\"){\n            if (C_secondAlarm == \"1\" && state.soundAlarmC){\n                C_sonos.playSoundAndTrack (state.soundAlarmC.uri, state.soundAlarmC.duration, state.soundC.uri)\n            }\n            if (C_secondAlarm == \"2\" && state.selectedSongC && state.soundAlarmC){\n                C_sonos.playSoundAndTrack (state.soundAlarmC.uri, state.soundAlarmC.duration, state.selectedSongC)\n            }\n            if (!C_secondAlarm){\n                C_sonos.playTrack(state.soundAlarmC.uri)\n            }\n        }\n\n        if (C_alarmType == \"2\") {\n            if (C_secondAlarmMusic && state.selectedSongC){\n                C_sonos.playSoundAndTrack (state.soundC.uri, state.soundC.duration, state.selectedSongC)\n            }\n            else {\n                C_sonos.playTrack(state.soundC.uri)\n            }\n        }\n\n        if (C_alarmType == \"3\") {\n               C_sonos.playTrack(state.selectedSongC)\n        }\n    }\n}\n\ndef alarm_D() {\n    if ((!D_mode || D_mode.contains(location.mode)) && getDayOk(D_day)) {\n        if (D_switches || D_dimmers || D_thermostats) {\n            def dimLevel = D_level as Integer\n            D_switches?.on()\n            D_dimmers?.setLevel(dimLevel)\n            if (D_thermostats) {\n                def thermostatState = D_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    D_thermostats.setHeatingSetpoint(D_temperatureH)\n                    D_thermostats.setCoolingSetpoint(D_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    D_thermostats.setHeatingSetpoint(D_temperatureH)\n                    log.info \"Set $D_thermostats Heat $D_temperatureH\u00b0\"\n                }\n                else {\n                    D_thermostats.setCoolingSetpoint(D_temperatureC)\n                    log.info \"Set $D_thermostats Cool $D_temperatureC\u00b0\"\n                }\n               }\n        }\n        if (D_phrase) {\n            location.helloHome.execute(D_phrase)\n        }\n\n        if (D_triggerMode && location.mode != D_triggerMode) {\n            if (location.modes?.find{it.name == D_triggerMode}) {\n                setLocationMode(D_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${D_triggerMode}'\"\n            }\n        }\n\n        if (D_volume) {\n                D_sonos.setLevel(D_volume)\n        }\n\n        if (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\")) {\n            state.fullMsgD = \"\"\n            if (D_wakeMsg) {\n                   getGreeting(D_wakeMsg, 4)\n            }\n\n            if (D_weatherReport || D_humidity || D_includeTemp || D_localTemp) {\n                getWeatherReport(4, D_weatherReport, D_humidity, D_includeTemp, D_localTemp)\n            }\n\n            if (D_includeSunrise || D_includeSunset) {\n                getSunriseSunset(4, D_includeSunrise, D_includeSunset)\n            }\n\n            if ((D_switches || D_dimmers || D_thermostats) && D_confirmSwitches) {\n                getOnConfimation(D_switches, D_dimmers, D_thermostats, 4)\n               }\n\n            if (D_phrase && D_confirmPhrase) {\n                getPhraseConfirmation(4, D_phrase)\n            }\n\n            if (D_triggerMode && D_confirmMode){\n                getModeConfirmation(D_triggerMode, 4)\n            }\n\n            state.soundD = textToSpeech(state.fullMsgD, true)\n        }\n\n        if (D_alarmType == \"1\"){\n            if (D_secondAlarm == \"1\" && state.soundAlarmD){\n                D_sonos.playSoundAndTrack (state.soundAlarmD.uri, state.soundAlarmD.duration, state.soundD.uri)\n            }\n            if (D_secondAlarm == \"2\" && state.selectedSongD && state.soundAlarmD){\n                D_sonos.playSoundAndTrack (state.soundAlarmD.uri, state.soundAlarmD.duration, state.selectedSongD)\n            }\n            if (!D_secondAlarm){\n                D_sonos.playTrack(state.soundAlarmD.uri)\n            }\n        }\n\n        if (D_alarmType == \"2\") {\n            if (D_secondAlarmMusic && state.selectedSongD){\n                D_sonos.playSoundAndTrack (state.soundD.uri, state.soundD.duration, state.selectedSongD)\n            }\n            else {\n                D_sonos.playTrack(state.soundD.uri)\n            }\n        }\n\n        if (D_alarmType == \"3\") {\n               D_sonos.playTrack(state.selectedSongD)\n        }\n    }\n}\n\ndef appTouchHandler(evt){\n    if (!summaryMode || summaryMode.contains(location.mode)) {\n        state.summaryMsg = \"The following is a summary of the alarm settings. \"\n        getSummary (A_alarmOn, ScenarioNameA, A_timeStart, 1)\n        getSummary (B_alarmOn, ScenarioNameB, B_timeStart, 2)\n        getSummary (C_alarmOn, ScenarioNameC, C_timeStart, 3)\n        getSummary (D_alarmOn, ScenarioNameD, D_timeStart, 4)\n\n        log.debug \"Summary message = ${state.summaryMsg}\"\n        def summarySound = textToSpeech(state.summaryMsg, true)\n        if (summaryVolume) {\n            summarySonos.setLevel(summaryVolume)\n        }\n        summarySonos.playTrack(summarySound.uri)\n    }\n}\n\ndef getSummary (alarmOn, scenarioName, timeStart, num){\n    if (alarmOn && scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num}, ${scenarioName}, set for ${parseDate(timeStart,\"\", \"h:mm a\" )}, is enabled. \"\n    }\n    else if (summaryDisabled && !alarmOn && scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num}, ${scenarioName}, set for ${parseDate(timeStart,\"\", \"h:mm a\")}, is disabled. \"\n    }\n    else if (summaryDisabled && !scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num} is not configured. \"\n    }\n}\n\n//--------------------------------------\n\ndef getDesc(timeStart, sonos, day, mode) {\n    def desc = \"Tap to set alarm\"\n    if (timeStart) {\n        desc = \"Alarm set to \" + parseDate(timeStart,\"\", \"h:mm a\") +\" on ${sonos}\"\n\n        def dayListSize = day ? day.size() : 7\n\n        if (day && dayListSize < 7) {\n            desc = desc + \" on\"\n            for (dayName in day) {\n                 desc = desc + \" ${dayName}\"\n                dayListSize = dayListSize -1\n                if (dayListSize) {\n                    desc = \"${desc}, \"\n                }\n            }\n        }\n        else {\n            desc = desc + \" every day\"\n        }\n\n        if (mode) {\n            def modeListSize = mode.size()\n            def modePrefix =\" in the following modes: \"\n            if (modeListSize == 1) {\n                modePrefix = \" in the following mode: \"\n            }\n            desc = desc + \"${modePrefix}\"\n               for (modeName in mode) {\n                desc = desc + \"'${modeName}'\"\n                modeListSize = modeListSize -1\n                if (modeListSize) {\n                    desc = \"${desc}, \"\n                }\n                else {\n                    desc = \"${desc}\"\n                }\n            }\n        }\n         else {\n            desc = desc + \" in all modes\"\n        }\n    }\n    desc\n}\ndef greyOut(scenario, sonos, alarmTime, alarmOn, alarmType){\n    def result = scenario && sonos  && alarmTime && alarmOn && alarmType ? \"complete\" : \"\"\n}\n\ndef greyOut1(param1, param2, param3, param4, param5, param6){\n    def result = param1 || param2 || param3 || param4 || param5 || param6 ? \"complete\" : \"\"\n}\n\ndef getWeatherDesc(param1, param2, param3, param4, param5, param6) {\n    def title = param1 || param2 || param3 || param4 || param5 || param6 ? \"Tap to edit weather reporting options\" : \"Tap to setup weather reporting options\"\n}\n\ndef greyOutOption(param){\n    def result = param ? \"complete\" : \"\"\n}\n\ndef getTitle(scenario, num) {\n    def title = scenario ? scenario : \"Alarm ${num} not configured\"\n}\n\ndef dimmerDesc(dimmer){\n    def desc = dimmer ? \"Tap to edit dimmer settings\" : \"Tap to set dimmer setting\"\n}\n\ndef thermostatDesc(thermostat, heating, cooling){\n    def tempText\n    if (heating || cooling){\n        if (heating){\n            tempText = \"${heating} heat\"\n        }\n        if (cooling){\n            tempText = \"${cooling} cool\"\n        }\n        if (heating && cooling) {\n            tempText =\"${heating} heat / ${cooling} cool\"\n        }\n    }\n    else {\n        tempText=\"Tap to edit thermostat settings\"\n    }\n\n    def desc = thermostat ? \"${tempText}\" : \"Tap to set thermostat settings\"\n    return desc\n}\n\nprivate getDayOk(dayList) {\n    def result = true\n    if (dayList) {\n        result = dayList.contains(getDay())\n    }\n    result\n}\n\nprivate getDay(){\n    def df = new java.text.SimpleDateFormat(\"EEEE\")\n    if (location.timeZone) {\n        df.setTimeZone(location.timeZone)\n    }\n    else {\n        df.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n    }\n    def day = df.format(new Date())\n}\n\nprivate parseDate(date, epoch, type){\n    def parseDate = \"\"\n    if (epoch){\n        long longDate = Long.valueOf(epoch).longValue()\n        parseDate = new Date(longDate).format(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", location.timeZone)\n    }\n    else {\n        parseDate = date\n    }\n    new Date().parse(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", parseDate).format(\"${type}\", timeZone(parseDate))\n}\n\nprivate getSunriseSunset(scenario, includeSunrise, includeSunset){\n    if (location.timeZone || zipCode) {\n        def todayDate = new Date()\n        def s = getSunriseAndSunset(zipcode: zipCode, date: todayDate)\n        def riseTime = parseDate(\"\", s.sunrise.time, \"h:mm a\")\n        def setTime = parseDate (\"\", s.sunset.time, \"h:mm a\")\n           def msg = \"\"\n        def currTime = now()\n        def verb1 = currTime >= s.sunrise.time ? \"rose\" : \"will rise\"\n        def verb2 = currTime >= s.sunset.time ? \"set\" : \"will set\"\n\n        if (includeSunrise && includeSunset) {\n            msg = \"The sun ${verb1} this morning at ${riseTime} and ${verb2} at ${setTime}. \"\n        }\n        else if (includeSunrise && !includeSunset) {\n            msg = \"The sun ${verb1} this morning at ${riseTime}. \"\n        }\n        else if (!includeSunrise && includeSunset) {\n            msg = \"The sun ${verb2} tonight at ${setTime}. \"\n        }\n        compileMsg(msg, scenario)\n    }\n    else {\n        msg = \"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive sunset and sunrise information. \"\n        compileMsg(msg, scenario)\n    }\n}\n\nprivate getGreeting(msg, scenario) {\n    def day = getDay()\n    def time = parseDate(\"\", now(), \"h:mm a\")\n    def month = parseDate(\"\", now(), \"MMMM\")\n    def year = parseDate(\"\", now(), \"yyyy\")\n    def dayNum = parseDate(\"\", now(), \"dd\")\n    msg = msg.replace('%day%', day)\n    msg = msg.replace('%date%', \"${month} ${dayNum}, ${year}\")\n    msg = msg.replace('%time%', \"${time}\")\n    msg = \"${msg} \"\n    compileMsg(msg, scenario)\n}\n\nprivate getWeatherReport(scenario, weatherReport, humidity, includeTemp, localTemp) {\n    if (location.timeZone || zipCode) {\n        def isMetric = location.temperatureScale == \"C\"\n        def sb = new StringBuilder()\n\n        if (includeTemp){\n            def current = getTwcConditions(zipCode)\n            sb << \"The current temperature is ${Math.round(current.temperature)} degrees. \"\n        }\n\n        if (localTemp){\n            sb << \"The local temperature is ${Math.round(localTemp.currentTemperature)} degrees. \"\n        }\n\n        if (humidity) {\n            sb << \"The local relative humidity is ${humidity.currentValue(\"humidity\")}%. \"\n        }\n\n        if (weatherReport) {\n            def weather = getTwcForecast(zipCode)\n            sb << \"Today's forecast is \"\n            sb << weather.daypart[0].narrative[0]\n        }\n\n        def msg = sb.toString()\n        msg = msg.replaceAll(/([0-9]+)C/,'$1 degrees')\n        msg = msg.replaceAll(/([0-9]+)F/,'$1 degrees')\n        compileMsg(msg, scenario)\n    }\n    else {\n        msg = \"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.\"\n        compileMsg(msg, scenario)\n    }\n}\n\nprivate getOnConfimation(switches, dimmers, thermostats, scenario) {\n    def msg = \"\"\n    if ((switches || dimmers) && !thermostats) {\n        msg = \"All switches\"\n    }\n    if (!switches && !dimmers && thermostats) {\n        msg = \"All Thermostats\"\n    }\n    if ((switches || dimmers) && thermostats) {\n        msg = \"All switches and thermostats\"\n    }\n    msg = \"${msg} are now on and set. \"\n    compileMsg(msg, scenario)\n}\n\nprivate getPhraseConfirmation(scenario, phrase) {\n    def msg=\"The Smart Things Hello Home phrase, ${phrase}, has been activated. \"\n    compileMsg(msg, scenario)\n}\n\nprivate getModeConfirmation(mode, scenario) {\n    def msg=\"The Smart Things mode is now being set to, ${mode}. \"\n    compileMsg(msg, scenario)\n}\n\nprivate compileMsg(msg, scenario) {\n    log.debug \"msg = ${msg}\"\n    if (scenario == 1) {state.fullMsgA = state.fullMsgA + \"${msg}\"}\n    if (scenario == 2) {state.fullMsgB = state.fullMsgB + \"${msg}\"}\n    if (scenario == 3) {state.fullMsgC = state.fullMsgC + \"${msg}\"}\n    if (scenario == 4) {state.fullMsgD = state.fullMsgD + \"${msg}\"}\n}\n\nprivate alarmSoundUri(selection, length, scenario){\n    def soundUri = \"\"\n       def soundLength = \"\"\n    switch(selection) {\n        case \"1\":\n            soundLength = length >0 && length < 8 ? length : 8\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmAlien.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"2\":\n            soundLength = length >0 && length < 12 ? length : 12\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmBell.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"3\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmBuzzer.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"4\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmFire.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"5\":\n            soundLength = length >0 && length < 2 ? length : 2\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmRooster.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"6\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmSiren.mp3\", duration: \"${soundLength}\"]\n            break\n    }\n    if (scenario == 1) {state.soundAlarmA = soundUri}\n    if (scenario == 2) {state.soundAlarmB = soundUri}\n    if (scenario == 3) {state.soundAlarmC = soundUri}\n    if (scenario == 4) {state.soundAlarmD = soundUri}\n}\n\n//Sonos Aquire Track from SmartThings code\nprivate songOptions(sonos, scenario) {\n    if (sonos){\n    // Make sure current selection is in the set\n        def options = new LinkedHashSet()\n        if (scenario == 1){\n            if (state.selectedSongA?.station) {\n                options << state.selectedSongA.station\n            }\n            else if (state.selectedSongA?.description) {\n                options << state.selectedSongA.description\n            }\n        }\n        if (scenario == 2){\n            if (state.selectedSongB?.station) {\n                options << state.selectedSongB.station\n            }\n            else if (state.selectedSongB?.description) {\n                options << state.selectedSongB.description\n            }\n        }\n        if (scenario == 3){\n            if (state.selectedSongC?.station) {\n                options << state.selectedSongC.station\n            }\n            else if (state.selectedSongC?.description) {\n                options << state.selectedSongC.description\n            }\n        }\n        if (scenario == 4){\n            if (state.selectedSongD?.station) {\n                options << state.selectedSongD.station\n            }\n            else if (state.selectedSongD?.description) {\n                options << state.selectedSongD.description\n            }\n        }\n        // Query for recent tracks\n        def states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n        def dataMaps = states.collect{it.jsonValue}\n        options.addAll(dataMaps.collect{it.station})\n\n        log.trace \"${options.size()} songs in list\"\n        options.take(20) as List\n    }\n}\n\nprivate saveSelectedSong(sonos, song, scenario) {\n    try {\n        def thisSong = song\n        log.info \"Looking for $thisSong\"\n        def songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n        log.info \"Searching ${songs.size()} records\"\n\n        def data = songs.find {s -> s.station == thisSong}\n        log.info \"Found ${data?.station}\"\n        if (data) {\n            if (scenario == 1) {state.selectedSongA = data}\n            if (scenario == 2) {state.selectedSongB = data}\n            if (scenario == 3) {state.selectedSongC = data}\n            if (scenario == 4) {state.selectedSongD = data}\n            log.debug \"Selected song for Scenario ${scenario} = ${data}\"\n        }\n        else if (song == state.selectedSongA?.station || song == state.selectedSongB?.station || song == state.selectedSongC?.station || song == state.selectedSongD?.station) {\n            log.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n        }\n         else {\n            log.warn \"Selected song '$song' not found\"\n        }\n    }\n    catch (Throwable t) {\n        log.error t\n    }\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n    def text = \"Talking Alarm Clock\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 1.4.5 (06/17/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright \u00a9 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n        \"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n        \"you may not use this file except in compliance with the License. \"+\n        \"You may obtain a copy of the License at\"+\n        \"\\n\\n\"+\n        \"    http://www.apache.org/licenses/LICENSE-2.0\"+\n        \"\\n\\n\"+\n        \"Unless required by applicable law or agreed to in writing, software \"+\n        \"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n        \"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n        \"See the License for the specific language governing permissions and \"+\n        \"limitations under the License.\"\n}\n\nprivate def textHelp() {\n    def text =\n        \"Within each alarm scenario, choose a Sonos speaker, an alarm time and alarm type along with \" +\n        \"switches, dimmers and thermostat to control when the alarm is triggered. Hello, Home phrases and modes can be triggered at alarm time. \"+\n        \"You also have the option of setting up different alarm sounds, tracks and a personalized spoken greeting that can include a weather report. \" +\n        \"Variables that can be used in the voice greeting include %day%, %time% and %date%.\\n\\n\"+\n        \"From the main SmartApp convenience page, tapping the 'Talking Alarm Clock' icon (if enabled within the app) will \"+\n        \"speak a summary of the alarms enabled or disabled without having to go into the application itself. This \" +\n        \"functionality is optional and can be configured from the main setup page.\"\n}",
        "docstring": "Control up to 4 waking schedules using a Sonos speaker as an alarm."
    },
    {
        "code": "def installed() {\n  subscribe(motionSensor, \"motion\", motionHandler)\n  subscribe(presenceSensors, \"presence\", presenceHandler)\n}\n\ndef updated() {\n  unsubscribe()\n  subscribe(motionSensor, \"motion\", motionHandler)\n  subscribe(presenceSensors, \"presence\", presenceHandler)\n}\n\ndef motionHandler(evt) {\n  log.debug \"handler $evt.name: $evt.value\"\n  if (evt.value == \"inactive\") {\n    runIn(delayMins * 60, scheduleCheck, [overwrite: true])\n  }\n}\n\ndef presenceHandler(evt) {\n  log.debug \"handler $evt.name: $evt.value\"\n  if (evt.value == \"not present\") {\n    runIn(delayMins * 60, scheduleCheck, [overwrite: true])\n  }\n}\n\ndef isActivePresence() {\n  // check all the presence sensors, make sure none are present\n  def noPresence = presenceSensors.find{it.currentPresence == \"present\"} == null\n  !noPresence\n}\n\ndef scheduleCheck() {\n  log.debug \"scheduled check\"\n  def motionState = motionSensor.currentState(\"motion\")\n    if (motionState.value == \"inactive\") {\n      def elapsed = now() - motionState.rawDateCreated.time\n      def threshold = 1000 * 60 * delayMins - 1000\n      if (elapsed >= threshold) {\n        if (!isActivePresence()) {\n          log.debug \"Motion has stayed inactive since last check ($elapsed ms) and no presence:  turning lights off\"\n          switches.off()\n        } else {\n          log.debug \"Presence is active: do nothing\"\n        }\n      } else {\n        log.debug \"Motion has not stayed inactive long enough since last check ($elapsed ms): do nothing\"\n      }\n    } else {\n      log.debug \"Motion is active: do nothing\"\n    }\n}",
        "docstring": "Turn lights off when no motion and presence is detected for a set period of time."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installing with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updating with settings: ${settings}\"\n\n\t//Initialize state variables if didn't exist.\n\tif (state.deviceSubscriptionMap == null) {\n\t\tstate.deviceSubscriptionMap = [:]\n\t\tlog.debug \"deviceSubscriptionMap created.\"\n\t}\n\tif (state.locationSubscriptionMap == null) {\n\t\tstate.locationSubscriptionMap = [:]\n\t\tlog.debug \"locationSubscriptionMap created.\"\n\t}\n\tif (state.verificationKeyMap == null) {\n\t\tstate.verificationKeyMap = [:]\n\t\tlog.debug \"verificationKeyMap created.\"\n\t}\n\n\tunsubscribe()\n\tregisterAllDeviceSubscriptions()\n}\n\ndef initialize() {\n\tlog.debug \"Initializing with settings: ${settings}\"\n\tstate.deviceSubscriptionMap = [:]\n\tlog.debug \"deviceSubscriptionMap created.\"\n\tstate.locationSubscriptionMap = [:]\n\tlog.debug \"locationSubscriptionMap created.\"\n\tstate.verificationKeyMap = [:]\n\tlog.debug \"verificationKeyMap created.\"\n\tregisterAllDeviceSubscriptions()\n}\n\n/*** Subscription Functions  ***/\n\n//Subscribe events for all devices\ndef registerAllDeviceSubscriptions() {\n\tregisterChangeHandler(inputs)\n}\n\n//Subscribe to events from a list of devices\ndef registerChangeHandler(myList) {\n\tmyList.each { myDevice ->\n\t\tdef theAtts = myDevice.supportedAttributes\n\t\ttheAtts.each { att ->\n\t\t\tsubscribe(myDevice, att.name, deviceEventHandler)\n\t\t\tlog.info \"Registering for ${myDevice.displayName}.${att.name}\"\n\t\t}\n\t}\n}\n\n//Endpoints function: Subscribe to events from a specific device\ndef registerDeviceChange() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\tdef deviceId = params.deviceId\n\tdef myDevice = findDevice(deviceId)\n\n\tif (myDevice == null) {\n\t\thttpError(404, \"Cannot find device with device ID ${deviceId}.\")\n\t}\n\n\tdef theAtts = myDevice.supportedAttributes\n\ttry {\n\t\ttheAtts.each { att ->\n\t\t\tsubscribe(myDevice, att.name, deviceEventHandler)\n\t\t}\n\t\tlog.info \"Subscribing for ${myDevice.displayName}\"\n\n\t\tif (subscriptionEndpt != null) {\n\t\t\tif (state.deviceSubscriptionMap[deviceId] == null) {\n\t\t\t\tstate.deviceSubscriptionMap.put(deviceId, [subscriptionEndpt])\n\t\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t} else if (!state.deviceSubscriptionMap[deviceId].contains(subscriptionEndpt)) {\n\t\t\t\t// state.deviceSubscriptionMap[deviceId] << subscriptionEndpt\n                // For now, we will only have one subscription endpoint per device\n\t\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\t\tstate.deviceSubscriptionMap.put(deviceId, [subscriptionEndpt])\n\t\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t}\n\n\t\t\tif (params.key != null) {\n\t\t\t\tstate.verificationKeyMap[subscriptionEndpt] = params.key\n\t\t\t\tlog.info \"Added verification key: ${params.key} for ${subscriptionEndpt}\"\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current subscription map is ${state.deviceSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n\treturn [\"succeed\"]\n}\n\n//Endpoints function: Unsubscribe to events from a specific device\ndef unregisterDeviceChange() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\tdef deviceId = params.deviceId\n\tdef myDevice = findDevice(deviceId)\n\n\tif (myDevice == null) {\n\t\thttpError(404, \"Cannot find device with device ID ${deviceId}.\")\n\t}\n\n\ttry {\n\t\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\t\tif (state.deviceSubscriptionMap[deviceId]?.contains(subscriptionEndpt)) {\n\t\t\t\tif (state.deviceSubscriptionMap[deviceId].size() == 1) {\n\t\t\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\t\t} else {\n\t\t\t\t\tstate.deviceSubscriptionMap[deviceId].remove(subscriptionEndpt)\n\t\t\t\t}\n\t\t\t\tstate.verificationKeyMap.remove(subscriptionEndpt)\n\t\t\t\tlog.info \"Removed subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t}\n\t\t} else {\n\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\tlog.info \"Unsubscriping for ${myDevice.displayName}\"\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current subscription map is ${state.deviceSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n}\n\n//Endpoints function: Subscribe to device additiona/removal updated in a location\ndef registerDeviceGraph() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\n\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\tsubscribe(location, \"DeviceCreated\", locationEventHandler, [filterEvents: false])\n\t\tsubscribe(location, \"DeviceUpdated\", locationEventHandler, [filterEvents: false])\n\t\tsubscribe(location, \"DeviceDeleted\", locationEventHandler, [filterEvents: false])\n\n\t\tif (state.locationSubscriptionMap[location.id] == null) {\n\t\t\tstate.locationSubscriptionMap.put(location.id, [subscriptionEndpt])\n\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t} else if (!state.locationSubscriptionMap[location.id].contains(subscriptionEndpt)) {\n\t\t\tstate.locationSubscriptionMap[location.id] << subscriptionEndpt\n\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t}\n\n\t\tif (params.key != null) {\n\t\t\tstate.verificationKeyMap[subscriptionEndpt] = params.key\n\t\t\tlog.info \"Added verification key: ${params.key} for ${subscriptionEndpt}\"\n\t\t}\n\n\t\tlog.info \"Current location subscription map is ${state.locationSubscriptionMap}\"\n\t\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n\t\treturn [\"succeed\"]\n\t} else {\n\t\thttpError(400, \"missing input parameter: subscriptionURL\")\n\t}\n}\n\n//Endpoints function: Unsubscribe to events from a specific device\ndef unregisterDeviceGraph() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\n\ttry {\n\t\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\t\tif (state.locationSubscriptionMap[location.id]?.contains(subscriptionEndpt)) {\n\t\t\t\tif (state.locationSubscriptionMap[location.id].size() == 1) {\n\t\t\t\t\tstate.locationSubscriptionMap.remove(location.id)\n\t\t\t\t} else {\n\t\t\t\t\tstate.locationSubscriptionMap[location.id].remove(subscriptionEndpt)\n\t\t\t\t}\n\t\t\t\tstate.verificationKeyMap.remove(subscriptionEndpt)\n\t\t\t\tlog.info \"Removed subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t\t}\n\t\t} else {\n\t\t\thttpError(400, \"missing input parameter: subscriptionURL\")\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current location subscription map is ${state.locationSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n}\n\n//When events are triggered, send HTTP post to web socket servers\ndef deviceEventHandler(evt) {\n\tdef evtDevice = evt.device\n\tdef evtDeviceType = getDeviceType(evtDevice)\n\tdef deviceData = [];\n\n\tif (evtDeviceType == \"thermostat\") {\n\t\tdeviceData = [name: evtDevice.displayName, id: evtDevice.id, status: evtDevice.status, deviceType: evtDeviceType, manufacturer: evtDevice.manufacturerName, model: evtDevice.modelName, attributes: deviceAttributeList(evtDevice, evtDeviceType), locationMode: getLocationModeInfo(), locationId: location.id]\n\t} else {\n\t\tdeviceData = [name: evtDevice.displayName, id: evtDevice.id, status: evtDevice.status, deviceType: evtDeviceType, manufacturer: evtDevice.manufacturerName, model: evtDevice.modelName, attributes: deviceAttributeList(evtDevice, evtDeviceType), locationId: location.id]\n\t}\n    \n    if(evt.data != null){\n\t\tdef evtData = parseJson(evt.data)\n\t\tlog.info \"Received event for ${evtDevice.displayName}, data: ${evtData},  description: ${evt.descriptionText}\"\n\t}\n\n\tdef params = [body: deviceData]\n\n\t//send event to all subscriptions urls\n\tlog.debug \"Current subscription urls for ${evtDevice.displayName} is ${state.deviceSubscriptionMap[evtDevice.id]}\"\n\tstate.deviceSubscriptionMap[evtDevice.id].each {\n\t\tparams.uri = \"${it}\"\n\t\tif (state.verificationKeyMap[it] != null) {\n\t\t\tdef key = state.verificationKeyMap[it]\n            params.headers = [Signature: ComputHMACValue(key, groovy.json.JsonOutput.toJson(params.body))]\n\t\t}\n\t\tlog.trace \"POST URI: ${params.uri}\"\n        log.trace \"Headers: ${params.headers}\"\n\t\tlog.trace \"Payload: ${params.body}\"\n\t\ttry {\n\t\t\thttpPostJson(params) { resp ->\n\t\t\t\tlog.trace \"response status code: ${resp.status}\"\n\t\t\t\tlog.trace \"response data: ${resp.data}\"\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error \"something went wrong: $e\"\n\t\t}\n\t}\n}\n\ndef locationEventHandler(evt) {\n\tlog.info \"Received event for location ${location.name}/${location.id}, Event: ${evt.name}, description: ${evt.descriptionText}, apiServerUrl: ${apiServerUrl(\"\")}\"\n\tswitch (evt.name) {\n\t\tcase \"DeviceCreated\":\n\t\tcase \"DeviceDeleted\":\n\t\t\tdef evtDevice = evt.device\n\t\t\tdef evtDeviceType = getDeviceType(evtDevice)\n\t\t\tdef params = [body: [eventType: evt.name, deviceId: evtDevice.id, locationId: location.id]]\n\n\t\t\tif (evt.name == \"DeviceDeleted\" && state.deviceSubscriptionMap[deviceId] != null) {\n\t\t\t\tstate.deviceSubscriptionMap.remove(evtDevice.id)\n\t\t\t}\n\n\t\t\tstate.locationSubscriptionMap[location.id].each {\n\t\t\t\tparams.uri = \"${it}\"\n\t\t\t\tif (state.verificationKeyMap[it] != null) {\n\t\t\t\t\tdef key = state.verificationKeyMap[it]\n                    params.headers = [Signature: ComputHMACValue(key, groovy.json.JsonOutput.toJson(params.body))]\n\t\t\t\t}\n\t\t\t\tlog.trace \"POST URI: ${params.uri}\"\n\t\t\t\tlog.trace \"Headers: ${params.headers}\"\n\t\t\t\tlog.trace \"Payload: ${params.body}\"\n\t\t\t\ttry {\n\t\t\t\t\thttpPostJson(params) { resp ->\n\t\t\t\t\t\tlog.trace \"response status code: ${resp.status}\"\n\t\t\t\t\t\tlog.trace \"response data: ${resp.data}\"\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"something went wrong: $e\"\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"DeviceUpdated\":\n\t\tdefault:\n\t\t\tbreak\n\t}\n}\n\nprivate ComputHMACValue(key, data) {\n\ttry {\n    \tlog.debug \"data hased: ${data}\"\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA1\")\n\t\tMac mac = Mac.getInstance(\"HmacSHA1\")\n\t\tmac.init(secretKeySpec)\n\t\tbyte[] digest = mac.doFinal(data.getBytes(\"UTF-8\"))\n\t\treturn byteArrayToString(digest)\n\t} catch (InvalidKeyException e) {\n\t\tlog.error \"Invalid key exception while converting to HMac SHA1\"\n\t}\n}\n\nprivate def byteArrayToString(byte[] data) {\n\tBigInteger bigInteger = new BigInteger(1, data)\n\tString hash = bigInteger.toString(16)\n\treturn hash\n}\n\n/*** Device Query/Update Functions  ***/\n\n//Endpoints function: return all device data in json format\ndef getDevices() {\n\tdef deviceData = []\n\tinputs?.each {\n\t\tdef deviceType = getDeviceType(it)\n\t\tif (deviceType == \"thermostat\") {\n\t\t\tdeviceData << [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType), locationMode: getLocationModeInfo()]\n\t\t} else {\n\t\t\tdeviceData << [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType)]\n\t\t}\n\t}\n\n\tlog.debug \"getDevices, return: ${deviceData}\"\n\treturn deviceData\n}\n\n//Endpoints function: get device data\ndef getDevice() {\n\tdef it = findDevice(params.id)\n\tdef deviceType = getDeviceType(it)\n\tdef device\n\tif (deviceType == \"thermostat\") {\n\t\tdevice = [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType), locationMode: getLocationModeInfo()]\n\t} else {\n\t\tdevice = [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType)]\n\t}\n\n\tlog.debug \"getDevice, return: ${device}\"\n\treturn device\n}\n\n//Endpoints function: update device data\nvoid updateDevice() {\n\tdef device = findDevice(params.id)\n\trequest.JSON.each {\n\t\tdef command = it.key\n\t\tdef value = it.value\n\t\tif (command) {\n\t\t\tdef commandList = mapDeviceCommands(command, value)\n\t\t\tcommand = commandList[0]\n\t\t\tvalue = commandList[1]\n\n\t\t\tif (command == \"setAwayMode\") {\n\t\t\t\tlog.info \"Setting away mode to ${value}\"\n\t\t\t\tif (location.modes?.find { it.name == value }) {\n\t\t\t\t\tlocation.setMode(value)\n\t\t\t\t}\n\t\t\t} else if (command == \"thermostatSetpoint\") {\n\t\t\t\tswitch (device.currentThermostatMode) {\n\t\t\t\t\tcase \"cool\":\n\t\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\t\tdevice.setCoolingSetpoint(value)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase \"heat\":\n\t\t\t\t\tcase \"emergency heat\":\n\t\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\t\tdevice.setHeatingSetpoint(value)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\thttpError(501, \"this mode: ${device.currentThermostatMode} does not allow changing thermostat setpoint.\")\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (!device) {\n\t\t\t\tlog.error \"updateDevice, Device not found\"\n\t\t\t\thttpError(404, \"Device not found\")\n\t\t\t} else if (!device.hasCommand(command)) {\n\t\t\t\tlog.error \"updateDevice, Device does not have the command\"\n\t\t\t\thttpError(404, \"Device does not have such command\")\n\t\t\t} else {\n\t\t\t\tif (command == \"setColor\") {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\tdevice.\"$command\"(hex: value)\n\t\t\t\t} else if (value.isNumber()) {\n\t\t\t\t\tdef intValue = value as Integer\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${intValue}(int)]\"\n\t\t\t\t\tdevice.\"$command\"(intValue)\n\t\t\t\t} else if (value) {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\tdevice.\"$command\"(value)\n\t\t\t\t} else {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}]\"\n\t\t\t\t\tdevice.\"$command\"()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*** Private Functions ***/\n\n//Return current location mode info\nprivate getLocationModeInfo() {\n\treturn [mode: location.mode, supported: location.modes.name]\n}\n\n//Map each device to a type given it's capabilities\nprivate getDeviceType(device) {\n\tdef deviceType\n\tdef capabilities = device.capabilities\n\tlog.debug \"capabilities: [${device}, ${capabilities}]\"\n\tlog.debug \"supported commands: [${device}, ${device.supportedCommands}]\"\n\n\t//Loop through the device capability list to determine the device type.\n\tcapabilities.each { capability ->\n\t\tswitch(capability.name.toLowerCase())\n\t\t{\n\t\t\tcase \"switch\":\n\t\t\t\tdeviceType = \"switch\"\n\n\t\t\t\t//If the device also contains \"Switch Level\" capability, identify it as a \"light\" device.\n\t\t\t\tif (capabilities.any { it.name.toLowerCase() == \"switch level\" }) {\n\n\t\t\t\t\t//If the device also contains \"Power Meter\" capability, identify it as a \"dimmerSwitch\" device.\n\t\t\t\t\tif (capabilities.any { it.name.toLowerCase() == \"power meter\" }) {\n\t\t\t\t\t\tdeviceType = \"dimmerSwitch\"\n\t\t\t\t\t\treturn deviceType\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeviceType = \"light\"\n\t\t\t\t\t\treturn deviceType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"garageDoorControl\":\n\t\t\t\tdeviceType = \"garageDoor\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"lock\":\n\t\t\t\tdeviceType = \"lock\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"video camera\":\n\t\t\t\tdeviceType = \"camera\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"thermostat\":\n\t\t\t\tdeviceType = \"thermostat\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"acceleration sensor\":\n\t\t\tcase \"contact sensor\":\n\t\t\tcase \"motion sensor\":\n\t\t\tcase \"presence sensor\":\n\t\t\tcase \"water sensor\":\n\t\t\t\tdeviceType = \"genericSensor\"\n\t\t\t\treturn deviceType\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn deviceType\n}\n\n//Return a specific device give the device ID.\nprivate findDevice(deviceId) {\n\treturn inputs?.find { it.id == deviceId }\n}\n\n//Return a list of device attributes\nprivate deviceAttributeList(device, deviceType) {\n\tdef attributeList = [:]\n\tdef allAttributes = device.supportedAttributes\n\tallAttributes.each { attribute ->\n\t\ttry {\n\t\t\tdef currentState = device.currentState(attribute.name)\n\t\t\tif (currentState != null) {\n\t\t\t\tswitch (attribute.name) {\n\t\t\t\t\tcase 'temperature':\n\t\t\t\t\t\tattributeList.putAll([(attribute.name): currentState.value, 'temperatureScale': location.temperatureScale])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tattributeList.putAll([(attribute.name): currentState.value])\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (deviceType == \"genericSensor\") {\n\t\t\t\t\tdef key = attribute.name + \"_lastUpdated\"\n\t\t\t\t\tattributeList.putAll([(key): currentState.isoDate])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattributeList.putAll([(attribute.name): null]);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tattributeList.putAll([(attribute.name): null]);\n\t\t}\n\t}\n\treturn attributeList\n}\n\n//Map device command and value. \n//input command and value are from UWP,\n//returns resultCommand and resultValue that corresponds with function and value in SmartApps\nprivate mapDeviceCommands(command, value) {\n\tlog.debug \"mapDeviceCommands: [${command}, ${value}]\"\n\tdef resultCommand = command\n\tdef resultValue = value\n\tswitch (command) {\n\t\tcase \"switch\":\n\t\t\tif (value == 1 || value == \"1\" || value == \"on\") {\n\t\t\t\tresultCommand = \"on\"\n\t\t\t\tresultValue = \"\"\n\t\t\t} else if (value == 0 || value == \"0\" || value == \"off\") {\n\t\t\t\tresultCommand = \"off\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\tbreak\n\t// light attributes\n\t\tcase \"level\":\n\t\t\tresultCommand = \"setLevel\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"hue\":\n\t\t\tresultCommand = \"setHue\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"saturation\":\n\t\t\tresultCommand = \"setSaturation\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"colorTemperature\":\n\t\t\tresultCommand = \"setColorTemperature\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"color\":\n\t\t\tresultCommand = \"setColor\"\n\t\t\tresultValue = value\n\t// thermostat attributes\n\t\tcase \"hvacMode\":\n\t\t\tresultCommand = \"setThermostatMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"fanMode\":\n\t\t\tresultCommand = \"setThermostatFanMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"awayMode\":\n\t\t\tresultCommand = \"setAwayMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"coolingSetpoint\":\n\t\t\tresultCommand = \"setCoolingSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"heatingSetpoint\":\n\t\t\tresultCommand = \"setHeatingSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"thermostatSetpoint\":\n\t\t\tresultCommand = \"thermostatSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t// lock attributes\n\t\tcase \"locked\":\n\t\t\tif (value == 1 || value == \"1\" || value == \"lock\") {\n\t\t\t\tresultCommand = \"lock\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\telse if (value == 0 || value == \"0\" || value == \"unlock\") {\n\t\t\t\tresultCommand = \"unlock\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\tbreak\n\t\tdefault:\n\t\t\tbreak\n\t}\n\n\treturn [resultCommand, resultValue]\n}",
        "docstring": "SmartApp for end to end SmartThings scenarios via OpenT2T"
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef uninstalled() {\n    if (plantlinksensors){\n        plantlinksensors.each{ sensor_device ->\n            sensor_device.setInstallSmartApp(\"needSmartApp\")\n        }\n    }\n}\n\ndef initialize() {\n    atomicState.attached_sensors = [:]\n    if (plantlinksensors){\n        subscribe(plantlinksensors, \"moisture_status\", moistureHandler)\n        subscribe(plantlinksensors, \"battery_status\", batteryHandler)\n        plantlinksensors.each{ sensor_device ->\n            sensor_device.setStatusIcon(\"Waiting on First Measurement\")\n            sensor_device.setInstallSmartApp(\"connectedToSmartApp\")\n        }\n    }\n}\n\ndef dock_sensor(device_serial, expected_plant_name) {\n    def docking_body_json_builder = new JsonBuilder([version: '1c', smartthings_device_id: device_serial])\n    def docking_params = [\n            uri        : appSettings.https_plantLinkServer,\n            path       : \"/api/v1/smartthings/links\",\n            headers    : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n            contentType: \"application/json\",\n            body: docking_body_json_builder.toString()\n    ]\n    def plant_post_body_map = [\n            plant_type_key: 999999,\n            soil_type_key : 1000004\n    ]\n    def plant_post_params = [\n            uri        : appSettings.https_plantLinkServer,\n            path       : \"/api/v1/plants\",\n            headers    : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n            contentType: \"application/json\",\n    ]\n    log.debug \"Creating new plant on myplantlink.com - ${expected_plant_name}\"\n    try {\n        httpPost(docking_params) { docking_response ->\n            if (parse_api_response(docking_response, \"Docking a link\")) {\n                if (docking_response.data.plants.size() == 0) {\n                    log.debug \"creating plant for - ${expected_plant_name}\"\n                    plant_post_body_map[\"name\"] = expected_plant_name\n                    plant_post_body_map['links_key'] = [docking_response.data.key]\n                    def plant_post_body_json_builder = new JsonBuilder(plant_post_body_map)\n                    plant_post_params[\"body\"] = plant_post_body_json_builder.toString()\n                    try {\n                        httpPost(plant_post_params) { plant_post_response ->\n                            if(parse_api_response(plant_post_response, 'creating plant')){\n                                def attached_map = atomicState.attached_sensors\n                                attached_map[device_serial] = plant_post_response.data\n                                atomicState.attached_sensors = attached_map\n                            }\n                        }\n                    } catch (Exception f) {\n                        log.debug \"call failed $f\"\n                    }\n                } else {\n                    def plant = docking_response.data.plants[0]\n                    def attached_map = atomicState.attached_sensors\n                    attached_map[device_serial] = plant\n                    atomicState.attached_sensors = attached_map\n                    checkAndUpdatePlantIfNeeded(plant, expected_plant_name)\n                }\n            }\n        }\n    } catch (Exception e) {\n        log.debug \"call failed $e\"\n    }\n    return true\n}\n\ndef checkAndUpdatePlantIfNeeded(plant, expected_plant_name){\n    def plant_put_params = [\n        uri : appSettings.https_plantLinkServer,\n        headers : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n        contentType : \"application/json\"\n    ]\n    if (plant.name != expected_plant_name) {\n        log.debug \"updating plant for - ${expected_plant_name}\"\n        plant_put_params[\"path\"] = \"/api/v1/plants/${plant.key}\"\n        def plant_put_body_map = [\n            name: expected_plant_name\n        ]\n        def plant_put_body_json_builder = new JsonBuilder(plant_put_body_map)\n        plant_put_params[\"body\"] = plant_put_body_json_builder.toString()\n        try {\n            httpPut(plant_put_params) { plant_put_response ->\n                parse_api_response(plant_put_response, 'updating plant name')\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef moistureHandler(event){\n    def expected_plant_name = \"SmartThings - ${event.displayName}\"\n    def device_serial = getDeviceSerialFromEvent(event)\n    \n    if (!atomicState.attached_sensors.containsKey(device_serial)){\n        dock_sensor(device_serial, expected_plant_name)\n    }else{\n        def measurement_post_params = [\n                uri: appSettings.https_plantLinkServer,\n                path: \"/api/v1/smartthings/links/${device_serial}/measurements\",\n                headers: [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n                contentType: \"application/json\",\n                body: event.value\n        ]\n        try {\n            httpPost(measurement_post_params) { measurement_post_response ->\n                if (parse_api_response(measurement_post_response, 'creating moisture measurement') &&\n                        measurement_post_response.data.size() >0){\n                    def measurement = measurement_post_response.data[0]\n                    def plant =  measurement.plant\n                    log.debug plant\n                    checkAndUpdatePlantIfNeeded(plant, expected_plant_name)\n                    plantlinksensors.each{ sensor_device ->\n                        if (sensor_device.id == event.deviceId){\n                            sensor_device.setStatusIcon(plant.status)\n                            if (plant.last_measurements && plant.last_measurements[0].moisture){\n                                sensor_device.setPlantFuelLevel(plant.last_measurements[0].moisture * 100 as int)\n                            }\n                            if (plant.last_measurements && plant.last_measurements[0].battery){\n                                sensor_device.setBatteryLevel(plant.last_measurements[0].battery * 100 as int)\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef batteryHandler(event){\n    def expected_plant_name = \"SmartThings - ${event.displayName}\"\n    def device_serial = getDeviceSerialFromEvent(event)\n    \n    if (!atomicState.attached_sensors.containsKey(device_serial)){\n        dock_sensor(device_serial, expected_plant_name)\n    }else{\n        def measurement_post_params = [\n                uri: appSettings.https_plantLinkServer,\n                path: \"/api/v1/smartthings/links/${device_serial}/measurements\",\n                headers: [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n                contentType: \"application/json\",\n                body: event.value\n        ]\n        try {\n            httpPost(measurement_post_params) { measurement_post_response ->\n                parse_api_response(measurement_post_response, 'creating battery measurement')\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef getDeviceSerialFromEvent(event){\n    def pattern = /.*\"zigbeedeviceid\"\\s*:\\s*\"(\\w+)\".*/\n    def match_result = (event.value =~ pattern)\n    return match_result[0][1]\n}\n\ndef oauthInitUrl(){\n    atomicState.oauthInitState = UUID.randomUUID().toString()\n    def oauthParams = [\n            response_type: \"code\",\n            client_id: appSettings.client_id,\n            state: atomicState.oauthInitState,\n            redirect_uri: buildRedirectUrl()\n    ]\n    return appSettings.https_plantLinkServer + \"/oauth/oauth2/authorize?\" + toQueryString(oauthParams)\n}\n\ndef buildRedirectUrl(){\n    return getServerUrl() + \"/api/token/${atomicState.accessToken}/smartapps/installations/${app.id}/swapToken\"\n}\n\ndef swapToken(){\n    def code = params.code\n    def oauthState = params.state\n    def stcid = appSettings.client_id\n    def postParams = [\n            method: 'POST',\n            uri: \"https://oso-tech.appspot.com\",\n            path: \"/api/v1/oauth-token\",\n            query: [grant_type:'authorization_code', code:params.code, client_id:stcid,\n                    client_secret:appSettings.client_secret, redirect_uri: buildRedirectUrl()],\n    ]\n\n    def jsonMap\n    try {\n        httpPost(postParams) { resp ->\n            jsonMap = resp.data\n        }\n    } catch (Exception e) {\n        log.debug \"call failed $e\"\n    }\n\n    atomicState.refreshToken = jsonMap.refresh_token\n    atomicState.authToken = jsonMap.access_token\n\n    def html = \"\"\"\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n    .container {\n        padding:25px;\n    }\n    .flex1 {\n        width:33%;\n        float:left;\n        text-align: center;\n    }\n    p {\n        font-size: 2em;\n        font-family: Verdana, Geneva, sans-serif;\n        text-align: center;\n        color: #777;\n    }\n</style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"flex1\"><img src=\"https://dashboard.myplantlink.com/images/PLlogo.png\" alt=\"PlantLink\" height=\"75\"/></div>\n        <div class=\"flex1\"><img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected to\"  height=\"25\" style=\"padding-top:25px;\" /></div>\n        <div class=\"flex1\"><img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings\" height=\"75\"/></div>\n        <br clear=\"all\">\n  </div>\n  <div class=\"container\">\n        <p>Your PlantLink Account is now connected to SmartThings!</p>\n        <p style=\"color:green;\">Click <strong>Done</strong> at the top right to finish setup.</p>\n    </div>\n</body>\n</html>\n\"\"\"\n    render contentType: 'text/html', data: html\n}\n\nprivate refreshAuthToken() {\n    def stcid = appSettings.client_id\n    def refreshParams = [\n            method: 'POST',\n            uri: \"https://hardware-dot-oso-tech.appspot.com\",\n            path: \"/api/v1/oauth-token\",\n            query: [grant_type:'refresh_token', code:\"${atomicState.refreshToken}\", client_id:stcid,\n                    client_secret:appSettings.client_secret],\n    ]\n    try{\n        def jsonMap\n        httpPost(refreshParams) { resp ->\n            if(resp.status == 200){\n                log.debug \"OAuth Token refreshed\"\n                jsonMap = resp.data\n                if (resp.data) {\n                    atomicState.refreshToken = resp?.data?.refresh_token\n                    atomicState.authToken = resp?.data?.access_token\n                    if (data?.action && data?.action != \"\") {\n                        log.debug data.action\n                        \"{data.action}\"()\n                        data.action = \"\"\n                    }\n                }\n                data.action = \"\"\n            }else{\n                log.debug \"refresh failed ${resp.status} : ${resp.status.code}\"\n            }\n        }\n    }\n    catch(Exception e){\n        log.debug \"caught exception refreshing auth token: \" + e\n    }\n}\n\ndef parse_api_response(resp, message) {\n    if (resp.status == 200) {\n        return true\n    } else {\n        log.error \"sent ${message} Json & got http status ${resp.status} - ${resp.status.code}\"\n        if (resp.status == 401) {\n            refreshAuthToken()\n            return false\n        } else {\n            debugEvent(\"Authentication error, invalid authentication method, lack of credentials, etc.\", true)\n            return false\n        }\n    }\n}\n\ndef getServerUrl() { return getApiServerUrl() }\n\ndef debugEvent(message, displayEvent) {\n    def results = [\n            name: \"appdebug\",\n            descriptionText: message,\n            displayed: displayEvent\n    ]\n    log.debug \"Generating AppDebug Event: ${results}\"\n    sendEvent (results)\n}\n\ndef toQueryString(Map m){\n    return m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}",
        "docstring": "This SmartApp connects to myplantlink.com and forwards the device data to it so it can calculate easy to read plant status for your specific plant's needs."
    },
    {
        "code": "def installed() {\n    state.dpwMap =                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    state.tpwMap =                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    state.Rain =                 [0,0,0,0,0,0,0]\n    state.daycount =             [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    atomicState.run =             false                // must be atomic - used to recover from crashes\n    state.pauseTime =             null\n    atomicState.startTime =     null\n    atomicState.finishTime =     null        // must be atomic - used to recover from crashes\n\n    log.debug \"Installed with settings: ${settings}\"\n    installSchedule()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    installSchedule()\n}\n\ndef installSchedule(){\n    if (!state.seasonAdj)             state.seasonAdj = 100.0\n    if (!state.weekseasonAdj)         state.weekseasonAdj = 0\n    if (state.daysAvailable != 0)     state.daysAvailable = 0    // force daysAvailable to be initialized by daysAvailable()\n    state.daysAvailable =             daysAvailable()            // every time we save the schedule\n\n    if (atomicState.run) {\n        attemptRecovery()                                     // clean up if we crashed earlier\n    }\n    else {\n        unsubscribe()                                        //added back in to reset manual subscription\n        resetEverything()\n    }\n    subscribe(app, appTouch)                                // enable the \"play\" button for this schedule\n    Random rand = new Random()\n    long randomOffset = 0\n\n    // always collect rainfall\n    int randomSeconds = rand.nextInt(59)\n    if (settings.isRain || settings.isSeason) schedule(\"${randomSeconds} 57 23 1/1 * ? *\", getRainToday)        // capture today's rainfall just before midnight\n\n    if (settings.switches && settings.startTime && settings.enable){\n\n        randomOffset = rand.nextInt(60000) + 20000\n        def checktime = timeToday(settings.startTime, location.timeZone).getTime() + randomOffset\n        //log.debug \"randomOffset ${randomOffset} checktime ${checktime}\"\n        schedule(checktime, preCheck)    //check weather & Days\n        writeSettings()\n        note('schedule', \"${app.label}: Starts at ${startTimeString()}\", 'i')\n    }\n    else {\n        unschedule( preCheck )\n        note('disable', \"${app.label}: Automatic watering disabled or setup is incomplete\", 'a')\n    }\n}\n\n// Called to find and repair after crashes - called by installSchedule() and busy()\nprivate boolean attemptRecovery() {\n    if (!atomicState.run) {\n        return false                                        // only clean up if we think we are still running\n    }\n    else {                                                    // Hmmm...seems we were running before...\n        def csw = settings.switches.currentSwitch\n        def cst = settings.switches.currentStatus\n        switch (csw) {\n            case 'on':                                        // looks like this schedule is running the controller at the moment\n                if (!atomicState.startTime) {                 // cycleLoop cleared the startTime, but cycleOn() didn't set it\n                    log.debug \"${app.label}: crashed in cycleLoop(), cycleOn() never started, cst is ${cst} - resetting\"\n                    resetEverything()                        // reset and try again...it's probably not us running the controller, though\n                    return false\n                }\n                // We have a startTime...\n                if (!atomicState.finishTime) {                // started, but we don't think we're done yet..so it's probably us!\n                    runIn(15, cycleOn)                        // goose the cycle, just in case\n                    note('active', \"${app.label}: schedule is apparently already running\", 'i')\n                    return true\n                }\n\n                // hmmm...switch is on and we think we're finished...probably somebody else is running...let busy figure it out\n                resetEverything()\n                return false\n                break\n\n            case 'off':                                     // switch is off - did we finish?\n                if (atomicState.finishTime)    {                // off and finished, let's just reset things\n                    resetEverything()\n                    return false\n                }\n\n                if (switches.currentStatus != 'pause') {     // off and not paused - probably another schedule, let's clean up\n                    resetEverything()\n                    return false\n                }\n\n                // off and not finished, and paused, we apparently crashed while paused\n                runIn(15, cycleOn)\n                return true\n                break\n\n            case 'programOn':                    // died while manual program running?\n            case 'programWait':                    // looks like died previously before we got started, let's try to clean things up\n                resetEverything()\n                if (atomicState.finishTime) atomicState.finishTime = null\n                if ((cst == 'active') || atomicState.startTime) {    // if we announced we were in preCheck, or made it all the way to cycleOn before it crashed\n                    settings.switches.programOff()                    // only if we think we actually started (cycleOn() started)\n                    // probably kills manual cycles too, but we'll let that go for now\n                }\n                if (atomicState.startTime) atomicState.startTime = null\n                note ('schedule', \"Looks like ${app.label} crashed recently...cleaning up\", c)\n                return false\n                break\n\n            default:\n                log.debug \"attemptRecovery(): atomicState.run == true, and I've nothing left to do\"\n                return true\n        }\n    }\n}\n\n// reset everything to the initial (not running) state\nprivate def resetEverything() {\n    if (atomicState.run) atomicState.run = false        // we're not running the controller any more\n    unsubAllBut()                                        // release manual, switches, sync, contacts & toggles\n\n    // take care not to unschedule preCheck() or getRainToday()\n    unschedule(cycleOn)\n    unschedule(checkRunMap)\n    unschedule(writeCycles)\n    unschedule(subOff)\n\n    if (settings.enableManual) subscribe(settings.switches, 'switch.programOn', manualStart)\n}\n\n// unsubscribe from ALL events EXCEPT app.touch\nprivate def unsubAllBut() {\n    unsubscribe(settings.switches)\n    unsubWaterStoppers()\n    if (settings.sync) unsubscribe(settings.sync)\n\n}\n\n// enable the \"Play\" button in SmartApp list\ndef appTouch(evt) {\n\n    log.debug \"appTouch(): atomicState.run = ${atomicState.run}\"\n\n    runIn(2, preCheck)                        // run it off a schedule, so we can see how long it takes in the app.state\n}\n\n// true if one of the stoppers is in Stop state\nprivate boolean isWaterStopped() {\n    if (settings.contacts && settings.contacts.currentContact.contains(settings.contactStop)) return true\n\n    if (settings.toggles && settings.toggles.currentSwitch.contains(settings.toggleStop)) return true\n\n    return false\n}\n\n// watch for water stoppers\nprivate def subWaterStop() {\n    if (settings.contacts) {\n        unsubscribe(settings.contacts)\n        subscribe(settings.contacts, \"contact.${settings.contactStop}\", waterStop)\n    }\n    if (settings.toggles) {\n        unsubscribe(settings.toggles)\n        subscribe(settings.toggles, \"switch.${settings.toggleStop}\", waterStop)\n    }\n}\n\n// watch for water starters\nprivate def subWaterStart() {\n    if (settings.contacts) {\n        unsubscribe(settings.contacts)\n        def cond = (settings.contactStop == 'open') ? 'closed' : 'open'\n        subscribe(settings.contacts, \"contact.${cond}\", waterStart)\n    }\n    if (settings.toggles) {\n        unsubscribe(settings.toggles)\n        def cond = (settings.toggleStop == 'on') ? 'off' : 'on'\n        subscribe(settings.toggles, \"switch.${cond}\", waterStart)\n    }\n}\n\n// stop watching water stoppers and starters\nprivate def unsubWaterStoppers() {\n    if (settings.contacts)     unsubscribe(settings.contacts)\n    if (settings.toggles)     unsubscribe(settings.toggles)\n}\n\n// which of the stoppers are in stop mode?\nprivate String getWaterStopList() {\n    String deviceList = ''\n    int i = 1\n    if (settings.contacts) {\n        settings.contacts.each {\n            if (it.currentContact == settings.contactStop) {\n                if (i > 1) deviceList += ', '\n                deviceList = \"${deviceList}${it.displayName} is ${settings.contactStop}\"\n                i++\n            }\n        }\n    }\n    if (settings.toggles) {\n        settings.toggles.each {\n            if (it.currentSwitch == settings.toggleStop) {\n                if (i > 1) deviceList += ', '\n                deviceList = \"${deviceList}${it.displayName} is ${settings.toggleStop}\"\n                i++\n            }\n        }\n    }\n    return deviceList\n}\n\n//write initial zone settings to device at install/update\ndef writeSettings(){\n    if (!state.tpwMap)             state.tpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    if (!state.dpwMap)             state.dpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    if (state.setMoisture)         state.setMoisture = null                            // not using any more\n    if (!state.seasonAdj)         state.seasonAdj = 100.0\n    if (!state.weekseasonAdj)     state.weekseasonAdj = 0\n    setSeason()\n}\n\n//get day of week integer\nint getWeekDay(day)\n{\n    def weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    def mapDay = [Monday:1, Tuesday:2, Wednesday:3, Thursday:4, Friday:5, Saturday:6, Sunday:7]\n    if(day && weekdays.contains(day)) {\n        return mapDay.get(day).toInteger()\n    }\n    def today = new Date().format('EEEE', location.timeZone)\n    return mapDay.get(today).toInteger()\n}\n\n// Get string of run days from dpwMap\nprivate String getRunDays(day1,day2,day3,day4,day5,day6,day7)\n{\n    String str = ''\n    if(day1) str += 'M'\n    if(day2) str += 'T'\n    if(day3) str += 'W'\n    if(day4) str += 'Th'\n    if(day5) str += 'F'\n    if(day6) str += 'Sa'\n    if(day7) str += 'Su'\n    if(str == '') str = '0 Days/week'\n    return str\n}\n\n//start manual schedule\ndef manualStart(evt){\n    boolean running = attemptRecovery()        // clean up if prior run crashed\n\t//isWeather()//use for testing\n    if (settings.enableManual && !running && (settings.switches.currentStatus != 'pause')){\n        if (settings.sync && ( (settings.sync.currentSwitch != 'off') || settings.sync.currentStatus == 'pause') ) {\n            note('skipping', \"${app.label}: Manual run aborted, ${settings.sync.displayName} appears to be busy\", 'a')\n            }\n        else {\n            def runNowMap = []\n            runNowMap = cycleLoop(0)\n\n            if (runNowMap) {\n                atomicState.run = true\n                settings.switches.programWait()\n                subscribe(settings.switches, 'switch.off', cycleOff)\n\n                runIn(60, cycleOn)               // start water program\n\n                                                // note that manual DOES abide by waterStoppers (if configured)\n                String newString = ''\n                int tt = state.totalTime\n                if (tt) {\n                    int hours = tt / 60            // DON'T Math.round this one\n                    int mins = tt - (hours * 60)\n                    String hourString = ''\n                    String s = ''\n                    if (hours > 1) s = 's'\n                    if (hours > 0) hourString = \"${hours} hour${s} & \"\n                    s = 's'\n                    if (mins == 1) s = ''\n                    newString = \"run time: ${hourString}${mins} minute${s}:\\n\"\n                }\n\n                note('active', \"${app.label}: Manual run, watering in 1 minute: ${newString}${runNowMap}\", 'd')\n            }\n            else note('skipping', \"${app.label}: Manual run failed, check configuration\", 'a')\n        }\n    }\n    else note('skipping', \"${app.label}: Manual run aborted, ${settings.switches.displayName} appears to be busy\", 'a')\n}\n\n//true if another schedule is running\nboolean busy(){\n    // Check if we are already running, crashed or somebody changed the schedule time while this schedule is running\n    if (atomicState.run){\n        if (!attemptRecovery()) {        // recovery will clean out any prior crashes and correct state of atomicState.run\n            return false                // (atomicState.run = false)\n        }\n        else {\n            // don't change the current status, in case the currently running schedule is in off/paused mode\n            note(settings.switches.currentStatus, \"${app.label}: Already running, skipping additional start\", 'i')\n            return true\n        }\n    }\n    // Not already running...\n\n    // Moved from cycleOn() - don't even start pre-check until the other controller completes its cycle\n    if (settings.sync) {\n        if ((settings.sync.currentSwitch != 'off') || settings.sync.currentStatus == 'pause') {\n            subscribe(settings.sync, 'switch.off', syncOn)\n\n            note('delayed', \"${app.label}: Waiting for ${settings.sync.displayName} to complete before starting\", 'c')\n            return true\n        }\n    }\n\n    // Check that the controller isn't paused while running some other schedule\n    def csw = settings.switches.currentSwitch\n    def cst = settings.switches.currentStatus\n\n    if ((csw == 'off') && (cst != 'pause')) {                // off && !paused: controller is NOT in use\n        log.debug \"switches ${csw}, status ${cst} (1st)\"\n        resetEverything()                                    // get back to the start state\n        return false\n    }\n\n    if (isDay()) {                                            // Yup, we need to run today, so wait for the other schedule to finish\n        log.debug \"switches ${csw}, status ${cst} (3rd)\"\n        resetEverything()\n        subscribe(settings.switches, 'switch.off', busyOff)\n        note('delayed', \"${app.label}: Waiting for currently running schedule to complete before starting\", 'c')\n           return true\n    }\n\n    // Somthing is running, but we don't need to run today anyway - don't need to do busyOff()\n    // (Probably should never get here, because preCheck() should check isDay() before calling busy()\n    log.debug \"Another schedule is running, but ${app.label} is not scheduled for today anyway\"\n    return true\n}\n\ndef busyOff(evt){\n    def cst = settings.switches.currentStatus\n    if ((settings.switches.currentSwitch == 'off') && (cst != 'pause')) { // double check that prior schedule is done\n        unsubscribe(switches)                            // we don't want any more button pushes until preCheck runs\n        Random rand = new Random()                         // just in case there are multiple schedules waiting on the same controller\n        int randomSeconds = rand.nextInt(120) + 15\n        runIn(randomSeconds, preCheck)                    // no message so we don't clog the system\n        note('active', \"${app.label}: ${settings.switches} finished, starting in ${randomSeconds} seconds\", 'i')\n    }\n}\n\n//run check every day\ndef preCheck() {\n\n    if (!isDay()) {\n        log.debug \"preCheck() Skipping: ${app.label} is not scheduled for today\"                    // silent - no note\n        //if (!atomicState.run && enableManual) subscribe(switches, 'switch.programOn', manualStart)    // only if we aren't running already\n        return\n    }\n\n    if (!busy()) {\n        atomicState.run = true                         // set true before doing anything, atomic in case we crash (busy() set it false if !busy)\n        settings.switches.programWait()                // take over the controller so other schedules don't mess with us\n        runIn(45, checkRunMap)                        // schedule checkRunMap() before doing weather check, gives isWeather 45s to complete\n                                                    // because that seems to be a little more than the max that the ST platform allows\n        unsubAllBut()                                // unsubscribe to everything except appTouch()\n        subscribe(settings.switches, 'switch.off', cycleOff)    // and start setting up for today's cycle\n        def start = now()\n        note('active', \"${app.label}: Starting...\", 'd')  //\n        def end = now()\n        log.debug \"preCheck note active ${end - start}ms\"\n\n           if (isWeather()) {                            // set adjustments and check if we shold skip because of rain\n               resetEverything()                        // if so, clean up our subscriptions\n               switches.programOff()                    // and release the controller\n        }\n        else {\n            log.debug 'preCheck(): running checkRunMap in 2 seconds'    //COOL! We finished before timing out, and we're supposed to water today\n            runIn(2, checkRunMap)    // jack the schedule so it runs sooner!\n        }\n    }\n}\n\n//start water program\ndef cycleOn(){\n    if (atomicState.run) {                            // block if manually stopped during precheck which goes to cycleOff\n\n        if (!isWaterStopped()) {                    // make sure ALL the contacts and toggles aren't paused\n            // All clear, let's start running!\n            subscribe(settings.switches, 'switch.off', cycleOff)\n            subWaterStop()                            // subscribe to all the pause contacts and toggles\n            resume()\n\n            // send the notification AFTER we start the controller (in case note() causes us to run over our execution time limit)\n            String newString = \"${app.label}: Starting...\"\n            if (!atomicState.startTime) {\n                atomicState.startTime = now()                // if we haven't already started\n                if (atomicState.startTime) atomicState.finishTime = null        // so recovery in busy() knows we didn't finish\n                if (state.pauseTime) state.pauseTime = null\n                if (state.totalTime) {\n                    String finishTime = new Date(now() + (60000 * state.totalTime).toLong()).format('EE @ h:mm a', location.timeZone)\n                    newString = \"${app.label}: Starting - ETC: ${finishTime}\"\n                }\n            }\n            else if (state.pauseTime) {        // resuming after a pause\n\n                def elapsedTime = Math.round((now() - state.pauseTime) / 60000)    // convert ms to minutes\n                int tt = state.totalTime + elapsedTime + 1\n                state.totalTime = tt        // keep track of the pauses, and the 1 minute delay above\n                String finishTime = new Date(atomicState.startTime + (60000 * tt).toLong()).format('EE @ h:mm a', location.timeZone)\n                state.pauseTime = null\n                newString = \"${app.label}: Resuming - New ETC: ${finishTime}\"\n            }\n            note('active', newString, 'd')\n        }\n        else {\n            // Ready to run, but one of the control contacts is still open, so we wait\n            subWaterStart()                                        // one of them is paused, let's wait until the are all clear!\n            note('pause', \"${app.label}: Watering paused, ${getWaterStopList()}\", 'c')\n        }\n    }\n}\n\n//when switch reports off, watering program is finished\ndef cycleOff(evt){\n\n    if (atomicState.run) {\n        def ft = new Date()\n        atomicState.finishTime = ft                                    // this is important to reset the schedule after failures in busy()\n        String finishTime = ft.format('h:mm a', location.timeZone)\n        note('finished', \"${app.label}: Finished watering at ${finishTime}\", 'd')\n    }\n    else {\n        log.debug \"${settings.switches} turned off\"        // is this a manual off? perhaps we should send a note?\n    }\n    resetEverything()                            // all done here, back to starting state\n}\n\n//run check each day at scheduled time\ndef checkRunMap(){\n\n    //check if isWeather returned true or false before checking\n    if (atomicState.run) {\n\n        //get & set watering times for today\n        def runNowMap = []\n        runNowMap = cycleLoop(1)        // build the map\n\n        if (runNowMap) {\n            runIn(60, cycleOn)                                            // start water\n            subscribe(settings.switches, 'switch.off', cycleOff)        // allow manual off before cycleOn() starts\n            if (atomicState.startTime) atomicState.startTime = null        // these were already cleared in cycleLoop() above\n            if (state.pauseTime) state.pauseTime = null                    // ditto\n            // leave atomicState.finishTime alone so that recovery in busy() knows we never started if cycleOn() doesn't clear it\n\n            String newString = ''\n            int tt = state.totalTime\n            if (tt) {\n                int hours = tt / 60            // DON'T Math.round this one\n                int mins = tt - (hours * 60)\n                String hourString = ''\n                String s = ''\n                if (hours > 1) s = 's'\n                if (hours > 0) hourString = \"${hours} hour${s} & \"\n                s = 's'\n                if (mins == 1) s = ''\n                newString = \"run time: ${hourString}${mins} minute${s}:\\n\"\n            }\n            note('active', \"${app.label}: Watering in 1 minute, ${newString}${runNowMap}\", 'd')\n        }\n        else {\n            unsubscribe(settings.switches)\n            unsubWaterStoppers()\n            switches.programOff()\n            if (enableManual) subscribe(settings.switches, 'switch.programOn', manualStart)\n            note('skipping', \"${app.label}: No watering today\", 'd')\n            if (atomicState.run) atomicState.run = false         // do this last, so that the above note gets sent to the controller\n        }\n    }\n    else {\n        log.debug 'checkRunMap(): atomicState.run = false'      // isWeather cancelled us out before we got started\n    }\n}\n\n//get todays schedule\ndef cycleLoop(int i)\n{\n    boolean isDebug = false\n    if (isDebug) log.debug \"cycleLoop(${i})\"\n\n    int zone = 1\n    int dpw = 0\n    int tpw = 0\n    int cyc = 0\n    int rtime = 0\n    def timeMap = [:]\n    def pumpMap = \"\"\n    def runNowMap = \"\"\n    String soilString = ''\n    int totalCycles = 0\n    int totalTime = 0\n    if (atomicState.startTime) atomicState.startTime = null                    // haven't started yet\n\n    while(zone <= 16)\n    {\n        rtime = 0\n        def setZ = settings.\"zone${zone}\"\n        if ((setZ && (setZ != 'Off')) && (nozzle(zone) != 4) && zoneActive(zone.toString())) {\n\n              // First check if we run this zone today, use either dpwMap or even/odd date\n              dpw = getDPW(zone)\n              int runToday = 0\n              // if manual, or every day allowed, or zone uses a sensor, then we assume we can today\n              //  - preCheck() has already verified that today isDay()\n              if ((i == 0) || /*(state.daysAvailable == 7) ||*/ (settings.\"sensor${zone}\")) {\n                  runToday = 1\n              }\n              else {\n\n                  dpw = getDPW(zone)                                    // figure out if we need to run (if we don't already know we do)\n                  if (settings.days && (settings.days.contains('Even') || settings.days.contains('Odd'))) {\n                    def daynum = new Date().format('dd', location.timeZone)\n                    int dayint = Integer.parseInt(daynum)\n                    if (settings.days.contains('Odd') && (((dayint +1) % Math.round(31 / (dpw * 4))) == 0)) runToday = 1\n                      else if (settings.days.contains('Even') && ((dayint % Math.round(31 / (dpw * 4))) == 0)) runToday = 1\n                  }\n                  else {\n                    int weekDay = getWeekDay()-1\n                    def dpwMap = getDPWDays(dpw)\n                    runToday = dpwMap[weekDay]  //1 or 0\n                    if (isDebug) log.debug \"Zone: ${zone} dpw: ${dpw} weekDay: ${weekDay} dpwMap: ${dpwMap} runToday: ${runToday}\"\n\n                  }\n              }\n\n            // OK, we're supposed to run (or at least adjust the sensors)\n              if (runToday == 1)\n              {\n                def soil\n                if (i == 0) soil = moisture(0)     // manual\n                else soil = moisture(zone)        // moisture check\n                  soilString = \"${soilString}${soil[1]}\"\n\n                // Run this zone if soil moisture needed\n                if ( soil[0] == 1 )\n                {\n                    cyc = cycles(zone)\n                    tpw = getTPW(zone)\n                    dpw = getDPW(zone)                    // moisture() may have changed DPW\n\n                    rtime = calcRunTime(tpw, dpw)\n                    //daily weather adjust if no sensor\n                    if(settings.isSeason && (!settings.learn || !settings.\"sensor${zone}\")) {\n\n\n                        rtime = Math.round(((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)\n                    }\n                    else {\n                        rtime = Math.round((rtime / cyc) + 0.4)    // let moisture handle the seasonAdjust for Adaptive (learn) zones\n                    }\n                    totalCycles += cyc\n                    totalTime += (rtime * cyc)\n                    runNowMap += \"${settings.\"name${zone}\"}: ${cyc} x ${rtime} min\\n\"\n                    if (isDebug) log.debug \"Zone ${zone} Map: ${cyc} x ${rtime} min - totalTime: ${totalTime}\"\n                }\n            }\n        }\n        if (nozzle(zone) == 4) pumpMap += \"${settings.\"name${zone}\"}: ${settings.\"zone${zone}\"} on\\n\"\n        timeMap.\"${zone+1}\" = \"${rtime}\"\n        zone++\n    }\n\n    if (soilString) {\n        String seasonStr = ''\n        String plus = ''\n        float sa = state.seasonAdj\n        if (settings.isSeason && (sa != 100.0) && (sa != 0.0)) {\n            float sadj = sa - 100.0\n            if (sadj > 0.0) plus = '+'                                            //display once in cycleLoop()\n            int iadj = Math.round(sadj)\n            if (iadj != 0) seasonStr = \"Adjusting ${plus}${iadj}% for weather forecast\\n\"\n        }\n        note('moisture', \"${app.label} Sensor status:\\n${seasonStr}${soilString}\" /* + seasonStr + soilString */,'m')\n    }\n\n    if (!runNowMap) {\n        return runNowMap            // nothing to run today\n    }\n\n    //send settings to Spruce Controller\n    switches.settingsMap(timeMap,4002)\n    runIn(30, writeCycles)\n\n    // meanwhile, calculate our total run time\n    int pDelay = 0\n    if (settings.pumpDelay && settings.pumpDelay.isNumber()) pDelay = settings.pumpDelay.toInteger()\n    totalTime += Math.round(((pDelay * (totalCycles-1)) / 60.0))  // add in the pump startup and inter-zone delays\n    state.totalTime = totalTime\n\n    if (state.pauseTime) state.pauseTime = null                    // and we haven't paused yet\n                                                                // but let cycleOn() reset finishTime\n    return (runNowMap + pumpMap)\n}\n\n//send cycle settings\ndef writeCycles(){\n    //log.trace \"writeCycles()\"\n    def cyclesMap = [:]\n    //add pumpdelay @ 1\n    cyclesMap.\"1\" = pumpDelayString()\n    int zone = 1\n    int cycle = 0\n    while(zone <= 17)\n    {\n        if(nozzle(zone) == 4) cycle = 4\n        else cycle = cycles(zone)\n        //offset by 1, due to pumpdelay @ 1\n        cyclesMap.\"${zone+1}\" = \"${cycle}\"\n        zone++\n    }\n    switches.settingsMap(cyclesMap, 4001)\n}\n\ndef resume(){\n    log.debug 'resume()'\n    settings.switches.zon()\n}\n\ndef syncOn(evt){\n    // double check that the switch is actually finished and not just paused\n    if ((settings.sync.currentSwitch == 'off') && (settings.sync.currentStatus != 'pause')) {\n        resetEverything()                                // back to our known state\n        Random rand = new Random()                         // just in case there are multiple schedules waiting on the same controller\n        int randomSeconds = rand.nextInt(120) + 15\n        runIn(randomSeconds, preCheck)                    // no message so we don't clog the system\n        note('schedule', \"${app.label}: ${settings.sync} finished, starting in ${randomSeconds} seconds\", 'c')\n    } // else, it is just pausing...keep waiting for the next \"off\"\n}\n\n// handle start of pause session\ndef waterStop(evt){\n    log.debug \"waterStop: ${evt.displayName}\"\n\n    unschedule(cycleOn)            // in case we got stopped again before cycleOn starts from the restart\n    unsubscribe(settings.switches)\n    subWaterStart()\n\n    if (!state.pauseTime) {            // only need to do this for the first event if multiple contacts\n        state.pauseTime = now()\n\n        String cond = evt.value\n        switch (cond) {\n            case 'open':\n                cond = 'opened'\n                break\n            case 'on':\n                cond = 'switched on'\n                break\n            case 'off':\n                cond = 'switched off'\n                break\n            //case 'closed':\n            //    cond = 'closed'\n            //    break\n            case null:\n                cond = '????'\n                break\n            default:\n                break\n        }\n        note('pause', \"${app.label}: Watering paused - ${evt.displayName} ${cond}\", 'c') // set to Paused\n    }\n    if (settings.switches.currentSwitch != 'off') {\n        runIn(30, subOff)\n        settings.switches.off()                                // stop the water\n    }\n    else\n        subscribe(settings.switches, 'switch.off', cycleOff)\n}\n\n// This is a hack to work around the delay in response from the controller to the above programOff command...\n// We frequently see the off notification coming a long time after the command is issued, so we try to catch that so that\n// we don't prematurely exit the cycle.\ndef subOff() {\n    subscribe(settings.switches, 'switch.off', offPauseCheck)\n}\n\ndef offPauseCheck( evt ) {\n    unsubscribe(settings.switches)\n    subscribe(settings.switches, 'switch.off', cycleOff)\n    if (/*(switches.currentSwitch != 'off') && */ (settings.switches.currentStatus != 'pause')) { // eat the first off while paused\n        cycleOff(evt)\n    }\n}\n\n// handle end of pause session\ndef waterStart(evt){\n    if (!isWaterStopped()){                     // only if ALL of the selected contacts are not open\n        def cDelay = 10\n        if (settings.contactDelay > 10) cDelay = settings.contactDelay\n        runIn(cDelay, cycleOn)\n\n        unsubscribe(settings.switches)\n        subWaterStop()                            // allow stopping again while we wait for cycleOn to start\n\n        log.debug \"waterStart(): enabling device is ${evt.device} ${evt.value}\"\n\n        String cond = evt.value\n        switch (cond) {\n            case 'open':\n                cond = 'opened'\n                break\n            case 'on':\n                cond = 'switched on'\n                break\n            case 'off':\n                cond = 'switched off'\n                break\n            //case 'closed':\n            //    cond = 'closed'\n            //    break\n            case null:\n                cond = '????'\n                break\n            default:\n                break\n        }\n        // let cycleOn() change the status to Active - keep us paused until then\n\n        note('pause', \"${app.label}: ${evt.displayName} ${cond}, watering in ${cDelay} seconds\", 'c')\n    }\n    else {\n        log.debug \"waterStart(): one down - ${evt.displayName}\"\n    }\n}\n\n//Initialize Days per week, based on TPW, perDay and daysAvailable settings\nint initDPW(int zone){\n    //log.debug \"initDPW(${zone})\"\n    if(!state.dpwMap) state.dpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n    int tpw = getTPW(zone)        // was getTPW -does not update times in scheduler without initTPW\n    int dpw = 0\n\n    if(tpw > 0) {\n        float perDay = 20.0\n        if(settings.\"perDay${zone}\") perDay = settings.\"perDay${zone}\".toFloat()\n\n        dpw = Math.round(tpw.toFloat() / perDay)\n        if(dpw <= 1) dpw = 1\n        // 3 days per week not allowed for even or odd day selection\n        if(dpw == 3 && days && (days.contains('Even') || days.contains('Odd')) && !(days.contains('Even') && days.contains('Odd')))\n            if((tpw.toFloat() / perDay) < 3.0) dpw = 2 else dpw = 4\n        int daycheck = daysAvailable()                        // initialize & optimize daysAvailable\n        if (daycheck < dpw) dpw = daycheck\n    }\n    state.dpwMap[zone-1] = dpw\n    return dpw\n}\n\n// Get current days per week value, calls init if not defined\nint getDPW(int zone) {\n    if (state.dpwMap) return state.dpwMap[zone-1] else return initDPW(zone)\n}\n\n//Initialize Time per Week\nint initTPW(int zone) {\n    //log.trace \"initTPW(${zone})\"\n    if (!state.tpwMap) state.tpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n    int n = nozzle(zone)\n    def zn = settings.\"zone${zone}\"\n    if (!zn || (zn == 'Off') || (n == 0) || (n == 4) || (plant(zone) == 0) || !zoneActive(zone.toString())) return 0\n\n    // apply gain adjustment\n    float gainAdjust = 100.0\n    if (settings.gain && settings.gain != 0) gainAdjust += settings.gain\n\n    // apply seasonal adjustment if enabled and not set to new plants\n    float seasonAdjust = 100.0\n    def wsa = state.weekseasonAdj\n    if (wsa && isSeason && (settings.\"plant${zone}\" != 'New Plants')) seasonAdjust = wsa\n\n    int tpw = 0\n    // Use learned, previous tpw if it is available\n    if ( settings.\"sensor${zone}\" ) {\n        seasonAdjust = 100.0             // no weekly seasonAdjust if this zone uses a sensor\n        if(state.tpwMap && settings.learn) tpw = state.tpwMap[zone-1]\n    }\n\n    // set user-specified minimum time with seasonal adjust\n    int minWeek = 0\n    def mw = settings.\"minWeek${zone}\"\n    if (mw) minWeek = mw.toInteger()\n    if (minWeek != 0) {\n        tpw = Math.round(minWeek * (seasonAdjust / 100.0))\n    }\n    else if (!tpw || (tpw == 0)) { // use calculated tpw\n        tpw = Math.round((plant(zone) * nozzle(zone) * (gainAdjust / 100.0) * (seasonAdjust / 100.0)))\n    }\n    state.tpwMap[zone-1] = tpw\n    return tpw\n}\n\n// Get the current time per week, calls init if not defined\nint getTPW(int zone)\n{\n    if (state.tpwMap) return state.tpwMap[zone-1] else return initTPW(zone)\n}\n\n// Calculate daily run time based on tpw and dpw\nint calcRunTime(int tpw, int dpw)\n{\n    int duration = 0\n    if ((tpw > 0) && (dpw > 0)) duration = Math.round(tpw.toFloat() / dpw.toFloat())\n    return duration\n}\n\n// Check the moisture level of a zone returning dry (1) or wet (0) and adjust tpw if overly dry/wet\ndef moisture(int i)\n{\n    boolean isDebug = false\n    if (isDebug) log.debug \"moisture(${i})\"\n\n    def endMsecs = 0\n    // No Sensor on this zone or manual start skips moisture checking altogether\n    if ((i == 0) || !settings.\"sensor${i}\") {\n        return [1,'']\n    }\n\n    // Ensure that the sensor has reported within last 48 hours\n    int spHum = getDrySp(i)\n    int hours = 48\n    def yesterday = new Date(now() - (/* 1000 * 60 * 60 */ 3600000 * hours).toLong())\n    float latestHum = settings.\"sensor${i}\".latestValue('humidity').toFloat()    // state = 29, value = 29.13\n    def lastHumDate = settings.\"sensor${i}\".latestState('humidity').date\n    if (lastHumDate < yesterday) {\n        note('warning', \"${app.label}: Please check sensor ${settings.\"sensor${i}\"}, no humidity reports in the last ${hours} hours\", 'a')\n\n        if (latestHum < spHum)\n            latestHum = spHum - 1.0             // amke sure we water and do seasonal adjustments, but not tpw adjustments\n        else\n            latestHum = spHum + 0.99            // make sure we don't water, do seasonal adjustments, but not tpw adjustments\n    }\n\n    if (!settings.learn)\n    {\n        // in Delay mode, only looks at target moisture level, doesn't try to adjust tpw\n        // (Temporary) seasonal adjustment WILL be applied in cycleLoop(), as if we didn't have a sensor\n        if (latestHum <= spHum.toFloat()) {\n           //dry soil\n               return [1,\"${settings.\"name${i}\"}, Watering: ${settings.\"sensor${i}\"} reads ${latestHum}%, SP is ${spHum}%\\n\"]\n        }\n        else {\n            //wet soil\n               return [0,\"${settings.\"name${i}\"}, Skipping: ${settings.\"sensor${i}\"} reads ${latestHum}%, SP is ${spHum}%\\n\"]\n        }\n    }\n\n    //in Adaptive mode\n    int tpw = getTPW(i)\n    int dpw = getDPW(i)\n    int cpd = cycles(i)\n\n\n\n\n    if (isDebug) log.debug \"moisture(${i}): tpw: ${tpw}, dpw: ${dpw}, cycles: ${cpd} (before adjustment)\"\n\n    float diffHum = 0.0\n    if (latestHum > 0.0) diffHum = (spHum - latestHum) / 100.0\n    else {\n        diffHum = 0.02 // Safety valve in case sensor is reporting 0% humidity (e.g., somebody pulled it out of the ground or flower pot)\n        note('warning', \"${app.label}: Please check sensor ${settings.\"sensor${i}\"}, it is currently reading 0%\", 'a')\n    }\n\n    int daysA = state.daysAvailable\n    int minimum = cpd * dpw                    // minimum of 1 minute per scheduled days per week (note - can be 1*1=1)\n    if (minimum < daysA) minimum = daysA    // but at least 1 minute per available day\n    int tpwAdjust = 0\n\n    if (diffHum > 0.01) {                                 // only adjust tpw if more than 1% of target SP\n          tpwAdjust = Math.round(((tpw * diffHum) + 0.5) * dpw * cpd)    // Compute adjustment as a function of the current tpw\n        float adjFactor = 2.0 / daysA                    // Limit adjustments to 200% per week - spread over available days\n          if (tpwAdjust > (tpw * adjFactor)) tpwAdjust = Math.round((tpw * adjFactor) + 0.5)         // limit fast rise\n        if (tpwAdjust < minimum) tpwAdjust = minimum    // but we need to move at least 1 minute per cycle per day to actually increase the watering time\n    } else if (diffHum < -0.01) {\n        if (diffHum < -0.05) diffHum = -0.05            // try not to over-compensate for a heavy rainstorm...\n        tpwAdjust = Math.round(((tpw * diffHum) - 0.5) * dpw * cpd)\n        float adjFactor = -0.6667 / daysA                // Limit adjustments to 66% per week\n        if (tpwAdjust < (tpw * adjFactor)) tpwAdjust = Math.round((tpw * adjFactor) - 0.5)    // limit slow decay\n        if (tpwAdjust > (-1 * minimum)) tpwAdjust = -1 * minimum // but we need to move at least 1 minute per cycle per day to actually increase the watering time\n    }\n\n    int seasonAdjust = 0\n    if (isSeason) {\n        float sa = state.seasonAdj\n        if ((sa != 100.0) && (sa != 0.0)) {\n            float sadj = sa - 100.0\n            if (sa > 0.0)\n                seasonAdjust = Math.round(((sadj / 100.0) * tpw) + 0.5)\n            else\n                seasonAdjust = Math.round(((sadj / 100.0) * tpw) - 0.5)\n        }\n    }\n     if (isDebug) log.debug \"moisture(${i}): diffHum: ${diffHum}, tpwAdjust: ${tpwAdjust} seasonAdjust: ${seasonAdjust}\"\n\n     // Now, adjust the tpw.\n     // With seasonal adjustments enabled, tpw can go up or down independent of the difference in the sensor vs SP\n    int newTPW = tpw + tpwAdjust + seasonAdjust\n\n    int perDay = 20\n    def perD = settings.\"perDay${i}\"\n    if (perD) perDay = perD.toInteger()\n    if (perDay == 0) perDay = daysA * cpd                // at least 1 minute per cycle per available day\n      if (newTPW < perDay) newTPW = perDay                // make sure we have always have enough for 1 day of minimum water\n\n    int adjusted = 0\n    if ((tpwAdjust + seasonAdjust) > 0) {                            // needs more water\n           int maxTPW = daysA * 120    // arbitrary maximum of 2 hours per available watering day per week\n           if (newTPW > maxTPW) newTPW = maxTPW    // initDPW() below may spread this across more days\n           if (newTPW > (maxTPW * 0.75)) note('warning', \"${app.label}: Please check ${settings[\"sensor${i}\"]}, ${settings.\"name${i}\"} time per week seems high: ${newTPW} mins/week\",'a')\n         if (state.tpwMap[i-1] != newTPW) {    // are we changing the tpw?\n            state.tpwMap[i-1] = newTPW\n            dpw = initDPW(i)                            // need to recalculate days per week since tpw changed - initDPW() stores the value into dpwMap\n            adjusted = newTPW - tpw     // so that the adjustment note is accurate\n         }\n    }\n    else if ((tpwAdjust + seasonAdjust) < 0) {                         // Needs less water\n        // Find the minimum tpw\n        minimum = cpd * daysA                                        // at least 1 minute per cycle per available day\n        int minLimit = 0\n        def minL = settings.\"minWeek${i}\"\n        if (minL) minLimit = minL.toInteger()                        // unless otherwise specified in configuration\n        if (minLimit > 0) {\n            if (newTPW < minLimit) newTPW = minLimit                // use configured minutes per week as the minimum\n        } else if (newTPW < minimum) {\n            newTPW = minimum                                        // else at least 1 minute per cycle per available day\n            note('warning', \"${app.label}: Please check ${settings.\"sensor${i}\"}, ${settings.\"name${i}\"} time per week is very low: ${newTPW} mins/week\",'a')\n        }\n        if (state.tpwMap[i-1] != newTPW) {    // are we changing the tpw?\n            state.tpwMap[i-1] = newTPW        // store the new tpw\n            dpw = initDPW(i)                // may need to reclac days per week - initDPW() now stores the value into state.dpwMap - avoid doing that twice\n            adjusted = newTPW - tpw     // so that the adjustment note is accurate\n        }\n    }\n    // else no adjustments, or adjustments cancelled each other out.\n\n    String moistureSum = ''\n    String adjStr = ''\n    String plus = ''\n    if (adjusted > 0) plus = '+'\n    if (adjusted != 0) adjStr = \", ${plus}${adjusted} min\"\n    if (Math.abs(adjusted) > 1) adjStr = \"${adjStr}s\"\n    if (diffHum >= 0.0) {                 // water only if ground is drier than SP\n        moistureSum = \"> ${settings.\"name${i}\"}, Water: ${settings.\"sensor${i}\"} @ ${latestHum}% (${spHum}%)${adjStr} (${newTPW} min/wk)\\n\"\n        return [1, moistureSum]\n    }\n    else {                             // not watering\n        moistureSum = \"> ${settings.\"name${i}\"}, Skip: ${settings.\"sensor${i}\"} @ ${latestHum}% (${spHum}%)${adjStr} (${newTPW} min/wk)\\n\"\n        return [0, moistureSum]\n    }\n    return [0, moistureSum]\n}\n\n//get moisture SP\nint getDrySp(int i){\n    if (settings.\"sensorSp${i}\") return settings.\"sensorSp${i}\".toInteger() // configured SP\n\n\n    if (settings.\"plant${i}\" == 'New Plants') return 40                        // New Plants get special care\n\n\n    switch (settings.\"option${i}\") {                                        // else, defaults based off of soil type\n        case 'Sand':\n            return 22\n        case 'Clay':\n            return 38\n        default:\n            return 28\n    }\n}\n\n//notifications to device, pushed if requested\ndef note(String statStr, String msg, String msgType) {\n\n    // send to debug first (near-zero cost)\n    log.debug \"${statStr}: ${msg}\"\n\n    // notify user second (small cost)\n    boolean notifyController = true\n    if(settings.notify || settings.logAll) {\n        String spruceMsg = \"Spruce ${msg}\"\n        switch(msgType) {\n            case 'd':\n                  if (settings.notify && settings.notify.contains('Daily')) {        // always log the daily events to the controller\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'c':\n                  if (settings.notify && settings.notify.contains('Delays')) {\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'i':\n                  if (settings.notify && settings.notify.contains('Events')) {\n                      sendIt(spruceMsg)\n                      //notifyController = false                    // no need to notify controller unless we don't notify the user\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'f':\n                  notifyController = false                        // no need to notify the controller, ever\n                if (settings.notify && settings.notify.contains('Weather')) {\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'a':\n                  notifyController = false                        // no need to notify the controller, ever\n                  if (settings.notify && settings.notify.contains('Warnings')) {\n                      sendIt(spruceMsg)\n                  } else\n                      sendNotificationEvent(spruceMsg)                    // Special case - make sure this goes into the Hello Home log, if not notifying\n                  break\n              case 'm':\n                  if (settings.notify && settings.notify.contains('Moisture')) {\n                      sendIt(spruceMsg)\n                      //notifyController = false                    // no need to notify controller unless we don't notify the user\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              default:\n                  break\n          }\n    }\n    // finally, send to controller DTH, to change the state and to log important stuff in the event log\n    if (notifyController) {        // do we really need to send these to the controller?\n        // only send status updates to the controller if WE are running, or nobody else is\n        if (atomicState.run || ((settings.switches.currentSwitch == 'off') && (settings.switches.currentStatus != 'pause'))) {\n            settings.switches.notify(statStr, msg)\n\n        }\n        else { // we aren't running, so we don't want to change the status of the controller\n            // send the event using the current status of the switch, so we don't change it\n            //log.debug \"note - direct sendEvent()\"\n            settings.switches.notify(settings.switches.currentStatus, msg)\n\n          }\n    }\n}\n\ndef sendIt(String msg) {\n    if (location.contactBookEnabled && settings.recipients) {\n        sendNotificationToContacts(msg, settings.recipients, [event: true])\n    }\n    else {\n        sendPush( msg )\n    }\n}\n\n//days available\nint daysAvailable(){\n\n    // Calculate days available for watering and save in state variable for future use\n    def daysA = state.daysAvailable\n    if (daysA && (daysA > 0)) {                            // state.daysAvailable has already calculated and stored in state.daysAvailable\n        return daysA\n    }\n\n    if (!settings.days)    {                                // settings.days = \"\" --> every day is available\n        state.daysAvailable = 7\n        return 7        // every day is allowed\n    }\n\n    int dayCount = 0                                    // settings.days specified, need to calculate state.davsAvailable (once)\n    if (settings.days.contains('Even') || settings.days.contains('Odd')) {\n        dayCount = 4\n        if(settings.days.contains('Even') && settings.days.contains('Odd')) dayCount = 7\n    }\n    else {\n        if (settings.days.contains('Monday'))         dayCount += 1\n        if (settings.days.contains('Tuesday'))         dayCount += 1\n        if (settings.days.contains('Wednesday'))    dayCount += 1\n        if (settings.days.contains('Thursday'))     dayCount += 1\n        if (settings.days.contains('Friday'))         dayCount += 1\n        if (settings.days.contains('Saturday'))     dayCount += 1\n        if (settings.days.contains('Sunday'))         dayCount += 1\n    }\n\n    state.daysAvailable = dayCount\n    return dayCount\n}\n\n//zone: ['Off', 'Spray', 'rotor', 'Drip', 'Master Valve', 'Pump']\nint nozzle(int i){\n    String getT = settings.\"zone${i}\"\n    if (!getT) return 0\n\n    switch(getT) {\n        case 'Spray':\n            return 1\n        case 'Rotor':\n            return 1.4\n        case 'Drip':\n            return 2.4\n        case 'Master Valve':\n            return 4\n        case 'Pump':\n            return 4\n        default:\n            return 0\n    }\n}\n\n//plant: ['Lawn', 'Garden', 'Flowers', 'Shrubs', 'Trees', 'Xeriscape', 'New Plants']\nint plant(int i){\n    String getP = settings.\"plant${i}\"\n    if(!getP) return 0\n\n    switch(getP) {\n        case 'Lawn':\n            return 60\n        case 'Garden':\n            return 50\n        case 'Flowers':\n            return 40\n        case 'Shrubs':\n            return 30\n        case 'Trees':\n            return 20\n        case 'Xeriscape':\n            return 30\n        case 'New Plants':\n            return 80\n        default:\n            return 0\n    }\n}\n\n//option: ['Slope', 'Sand', 'Clay', 'No Cycle', 'Cycle 2x', 'Cycle 3x']\nint cycles(int i){\n    String getC = settings.\"option${i}\"\n    if(!getC) return 2\n\n    switch(getC) {\n        case 'Slope':\n            return 3\n        case 'Sand':\n            return 1\n        case 'Clay':\n            return 2\n        case 'No Cycle':\n            return 1\n        case 'Cycle 2x':\n            return 2\n        case 'Cycle 3x':\n            return 3\n        default:\n            return 2\n    }\n}\n\n//check if day is allowed\nboolean isDay() {\n\n    if (daysAvailable() == 7) return true                        // every day is allowed\n\n    def daynow = new Date()\n    String today = daynow.format('EEEE', location.timeZone)\n    if (settings.days.contains(today)) return true\n\n    def daynum = daynow.format('dd', location.timeZone)\n    int dayint = Integer.parseInt(daynum)\n    if (settings.days.contains('Even') && (dayint % 2 == 0)) return true\n    if (settings.days.contains('Odd') && (dayint % 2 != 0)) return true\n    return false\n}\n\n//set season adjustment & remove season adjustment\ndef setSeason() {\n    boolean isDebug = false\n    if (isDebug) log.debug 'setSeason()'\n\n    int zone = 1\n    while(zone <= 16) {\n        if ( !settings.learn || !settings.\"sensor${zone}\" || state.tpwMap[zone-1] == 0) {\n\n            int tpw = initTPW(zone)        // now updates state.tpwMap\n            int dpw = initDPW(zone)        // now updates state.dpwMap\n            if (isDebug) {\n                if (!settings.learn && (tpw != 0) && (state.weekseasonAdj != 0)) {\n                    log.debug \"Zone ${zone}: seasonally adjusted by ${state.weekseasonAdj-100}% to ${tpw}\"\n                }\n            }\n        }\n        zone++\n    }\n}\n\n//TWC functions\ndef getCity(){\n\tString wzipcode = zipString()\n    String city\n    try {\n\t\t\tcity = getTwcLocation(wzipcode)?.location?.city ?: wzipcode\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\tcity = \"unknown city\"\n\t\t}\n    \n    return city\n}\n\ndef getConditions(){\n\tString wzipcode = zipString()\n    def conditionsData\n    try {\n\t\t\tconditionsData = getTwcConditions(wzipcode)\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\treturn null\n\t\t}\n    \n    return conditionsData\n}\n\ndef getForecast(){\n\tString wzipcode = zipString()\n    def forecastData\n    try {\n\t\t\tforecastData = getTwcForecast(wzipcode)\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\treturn null\n\t\t}    \n    \n    return forecastData\n}\n\n//capture today's total rainfall - scheduled for just before midnight each day\ndef getRainToday() {\n    //def wzipcode = zipString()\n    //def conditionsData = getTwcConditions(wzipcode)\n    def conditionsData = getConditions()\n    if (!conditionsData) {\n        note('warning', \"${app.label}: Please check Zipcode/PWS setting, error: null\", 'a')\n    } else {\n        float TRain = 0.0\n        if (conditionsData.precip24Hour.isNumber()) {\n            TRain = conditionsData.precip24Hour.toFloat()\n            if (TRain > 25.0) TRain = 25.0\n            else if (TRain < 0.0) TRain = 0.0\n            log.debug \"getRainToday(): ${conditionsData.precip24Hour} / ${TRain}\"\n        }\n        int day = getWeekDay()                        // what day is it today?\n        if (day == 7) day = 0                        // adjust: state.Rain order is Su,Mo,Tu,We,Th,Fr,Sa\n        state.Rain[day] = TRain as Float            // store today's total rainfall\n    }\n}\n\n//check weather, set seasonal adjustment factors, skip today if rainy\nboolean isWeather(){\n    if (!settings.isRain && !settings.isSeason) return false\n    \n    def city = getCity()\n    def forecastData = getForecast() ?: null\n    def conditionsData = getConditions() ?: null\n    //log.debug forecastData\n    //log.debug conditionsData\n    \n    //if data is null, skip weather adjustments\n    if (!forecastData || !conditionsData) {\n        note('warning', \"${app.label}: Please check Zipcode/PWS setting, error: null\", 'a')\n        return false\n    }\n        \n   \t//check if day or night\n    int not_today = 0\n   \tif (forecastData.daypart[0].daypartName[0] != \"Today\") not_today = 1;\n    \n   \t// OK, we have good data, let's start the analysis\n    float qpfTodayIn = 0.0\n    float qpfTomIn = 0.0\n    float popToday = 50.0\n    float popTom = 50.0\n    float TRain = 0.0\n    float YRain = 0.0\n    float weeklyRain = 0.0\n\n    if (settings.isRain) {\n        log.debug 'isWeather(): isRain'\n\n        // Get forecasted rain for today and tomorrow\n        if (!forecastData) {\n            log.debug 'isWeather(): Unable to get weather forecast.'\n            return false\n        }\n        \n        //log.debug \"${forecastData.daypart[0].qpf}\"\n        //log.debug \"${forecastData.daypart[0].precipChance}\"\n        if (forecastData.daypart[0].qpf[not_today]) qpfTodayIn = forecastData.daypart[0].qpf[not_today].toFloat()\n        if (forecastData.daypart[0].precipChance[not_today]) popToday = forecastData.daypart[0].precipChance[not_today].toFloat()\n        if (forecastData.daypart[0].qpf[2]) qpfTomIn = forecastData.daypart[0].qpf[1].toFloat()\n        if (forecastData.daypart[0].precipChance[2]) popTom = forecastData.daypart[0].precipChance[1].toFloat()\n        if (qpfTodayIn > 25.0) qpfTodayIn = 25.0\n        else if (qpfTodayIn < 0.0) qpfTodayIn = 0.0\n        if (qpfTomIn > 25.0) qpfTomIn = 25.0\n        else if (qpfTomIn < 0.0) qpfTomIn = 0.0\n\n        // Get rainfall so far today\n\n        if (!conditionsData) {\n            log.debug 'isWeather(): Unable to get current weather conditions.'\n            return false\n        }\n        if (conditionsData.precip24Hour.isNumber()) {\n               TRain = conditionsData.precip24Hour.toFloat()\n               if (TRain > 25.0) TRain = 25.0            // Ignore runaway weather\n               else if (TRain < 0.0) TRain = 0.0        // WU can return -999 for estimated locations\n        }\n        if (TRain > (qpfTodayIn * (popToday / 100.0))) {  // Not really what PoP means, but use as an adjustment factor of sorts\n            qpfTodayIn = TRain                        // already have more rain than was forecast for today, so use that instead\n            popToday = 100                            // we KNOW this rain happened\n        }\n\n        // Get yesterday's rainfall\n        int day = getWeekDay()\n        YRain = state.Rain[day - 1]\n\n        log.debug \"TRain ${TRain} qpfTodayIn ${qpfTodayIn} @ ${popToday}%, YRain ${YRain}\"\n\n        int i = 0\n        while (i <= 6){                                // calculate (un)weighted average (only heavy rainstorms matter)\n            int factor = 0\n            if ((day - i) > 0) factor = day - i else factor =  day + 7 - i\n            float getrain = state.Rain[i]\n            if (factor != 0) weeklyRain += (getrain / factor)\n            i++\n        }\n\n        log.debug \"isWeather(): weeklyRain ${weeklyRain}\"\n    }\n\n    log.debug 'isWeather(): build report'\n\t//log.debug \"${forecastData.daypart[0].temperature[not_today]}\"\n    //get highs\n       int highToday = 0\n       int highTom = 0\n       if (forecastData.daypart[0].temperature[not_today]) highToday = forecastData.daypart[0].temperature[not_today].toInteger()\n       if (forecastData.daypart[0].temperature[2]) highTom = forecastData.daypart[0].temperature[2].toInteger()\n\n    String weatherString = \"${app.label}: ${city} weather:\\n TDA: ${highToday}F\"\n    if (settings.isRain) weatherString = \"${weatherString}, ${qpfTodayIn}in rain (${Math.round(popToday)}% PoP)\"\n    weatherString = \"${weatherString}\\n TMW: ${highTom}F\"\n    if (settings.isRain) weatherString = \"${weatherString}, ${qpfTomIn}in rain (${Math.round(popTom)}% PoP)\\n YDA: ${YRain}in rain\"\n\n    if (settings.isSeason)\n    {\n        if (!settings.isRain) {                             // we need to verify we have good data first if we didn't do it above\n\n            if (!forecastData) {\n                log.debug 'Unable to get weather forecast'\n                return false\n            }\n        }\n\n        // is the temp going up or down for the next few days?\n        float heatAdjust = 100.0\n        float avgHigh = highToday.toFloat()\n        if (highToday != 0) {\n            // is the temp going up or down for the next few days?\n            int totalHigh = highToday\n            int j = 2\n            int highs = 1            \n            while (j < 6) { // get forecasted high for next 3 days\n                if (forecastData.daypart[0].temperature[j].isNumber()) {\n                    totalHigh += forecastData.daypart[0].temperature[j].toInteger()\n                    highs++\n                }\n                j+=2\n            }\n            if ( highs > 0 ) avgHigh = (totalHigh / highs)\n            heatAdjust = (avgHigh / highToday).round(2)\n        }\n        log.debug \"highToday ${highToday}, avgHigh ${avgHigh}, heatAdjust ${heatAdjust}\"\n        \n        //get humidity\n        int humToday = 0\n        int avehumidity = 0\n        log.debug \"${forecastData.daypart[0].relativeHumidity[not_today]}\"\n        if (forecastData.daypart[0].relativeHumidity[not_today]) humToday = forecastData.daypart[0].relativeHumidity[not_today]\n        \n        float humAdjust = 100.0\n        float avgHum = humToday.toFloat()\n        \n        if (humToday != 0 && avehumidity != 0) {\n            int j = 2\n            int highs = 1\n            int totalHum = humToday\n            while (j < 6) {                     // get forcasted humitidty for today and the next 3 days                \n                if (forecastData.daypart[0].relativeHumidity[j].isNumber()) {\n                    totalHum += forecastData.daypart[0].relativeHumidity[j]\n                    highs++\n                }\n                j+=2\n            }\n            if (highs > 1) avgHum = totalHum / highs\n            humAdjust = 1.5 - ((0.5 * avgHum) / humToday)    // basically, half of the delta % between today and today+3 days\n        }\n        log.debug \"humToday ${humToday}, avgHum ${avgHum}, humAdjust ${humAdjust}\"\n\n        //daily adjustment - average of heat and humidity factors\n        //hotter over next 3 days, more water\n        //cooler over next 3 days, less water\n        //drier  over next 3 days, more water\n        //wetter over next 3 days, less water\n        //\n        //Note: these should never get to be very large, and work best if allowed to cumulate over time (watering amount will change marginally\n        //        as days get warmer/cooler and drier/wetter)\n           def sa = ((heatAdjust + humAdjust) / 2)// * 100.0\n           state.seasonAdj = sa\n           sa = sa - 100.0\n        String plus = ''\n        if (sa > 0) plus = '+'\n        weatherString = \"${weatherString}\\n Adjusting ${plus}${Math.round(sa)}% for weather forecast\"\n\n        // Apply seasonal adjustment on Monday each week or at install\n        if ((getWeekDay() == 1) || (state.weekseasonAdj == 0)) {\n            //get daylight\n             if (conditionsData.sunriseTimeLocal && conditionsData.sunsetTimeLocal) {\n                 def hours = new java.text.SimpleDateFormat(\"HH\");\n                 def minutes = new java.text.SimpleDateFormat(\"mm\");\n                 String nowAsISO = hours.format(new Date());\n\n\t\t\t\tdef sunriseTime = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss-SSSS\", conditionsData.sunriseTimeLocal)\n                def sunsetTime = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss-SSSS\", conditionsData.sunsetTimeLocal)\n                \n                int getsunRH = hours.format(sunriseTime).toInteger()                \n                int getsunRM = minutes.format(sunriseTime).toInteger()\n                int getsunSH = hours.format(sunsetTime).toInteger()\n                int getsunSM = minutes.format(sunsetTime).toInteger()\n\n                int daylight = ((getsunSH * 60) + getsunSM)-((getsunRH * 60) + getsunRM)\n                if (daylight >= 850) daylight = 850\n                \n                //set seasonal adjustment\n                //seasonal q (fudge) factor\n                float qFact = 75.0\n\n                // (Daylight / 11.66 hours) * ( Average of ((Avg Temp / 70F) + ((1/2 of Average Humidity) / 65.46))) * calibration quotient\n                // Longer days = more water        (day length constant = approx USA day length at fall equinox)\n                // Higher temps = more water\n                // Lower humidity = more water    (humidity constant = USA National Average humidity in July)\n                float wa = ((daylight / 700.0) * (((avgHigh / 70.0) + (1.5-((avgHum * 0.5) / 65.46))) / 2.0) * qFact)\n                state.weekseasonAdj = wa\n\n                //apply seasonal time adjustment\n                plus = ''\n                if (wa != 0) {\n                    if (wa > 100.0) plus = '+'\n                    String waStr = String.format('%.2f', (wa - 100.0))\n                    weatherString = \"${weatherString}\\n Seasonal adjustment of ${waStr}% for the week\"\n                }\n                setSeason()\n            }\n            else {\n                log.debug 'isWeather(): Unable to get sunrise/set info for today.'\n            }\n        }\n    }\n    note('season', weatherString , 'f')\n\n    // if only doing seasonal adjustments, we are done\n    if (!settings.isRain) return false\n\n    float setrainDelay = 0.2\n    if (settings.rainDelay) setrainDelay = settings.rainDelay.toFloat()\n\n    // if we have no sensors, rain causes us to skip watering for the day\n    if (!anySensors()) {\n        if (settings.switches.latestValue('rainsensor') == 'rainsensoron'){\n            note('raintoday', \"${app.label}: skipping, rain sensor is on\", 'd')\n            return true\n           }\n           float popRain = qpfTodayIn * (popToday / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintoday', \"${app.label}: skipping, ${rainStr}in of rain is probable today\", 'd')\n            return true\n        }\n        popRain += qpfTomIn * (popTom / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintom', \"${app.label}: skipping, ${rainStr}in of rain is probable today + tomorrow\", 'd')\n            return true\n        }\n        if (weeklyRain > setrainDelay){\n            String rainStr = String.format('%.2f', weeklyRain)\n            note('rainy', \"${app.label}: skipping, ${rainStr}in weighted average rain over the past week\", 'd')\n            return true\n        }\n    }\n    else { // we have at least one sensor in the schedule\n        // Ignore rain sensor & historical rain - only skip if more than setrainDelay is expected before midnight tomorrow\n        float popRain = (qpfTodayIn * (popToday / 100.0)) - TRain    // ignore rain that has already fallen so far today - sensors should already reflect that\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintoday', \"${app.label}: skipping, at least ${rainStr}in of rain is probable later today\", 'd')\n            return true\n        }\n        popRain += qpfTomIn * (popTom / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintom', \"${app.label}: skipping, at least ${rainStr}in of rain is probable later today + tomorrow\", 'd')\n            return true\n        }\n    }\n    if (isDebug) log.debug \"isWeather() ends\"\n    return false\n}\n\n// true if ANY of this schedule's zones are on and using sensors\nprivate boolean anySensors() {\n    int zone=1\n    while (zone <= 16) {\n        def zoneStr = settings.\"zone${zone}\"\n        if (zoneStr && (zoneStr != 'Off') && settings.\"sensor${zone}\") return true\n        zone++\n    }\n    return false\n}\n\ndef getDPWDays(int dpw){\n    if (dpw && (dpw.isNumber()) && (dpw >= 1) && (dpw <= 7)) {\n        return state.\"DPWDays${dpw}\"\n    } else\n          return [0,0,0,0,0,0,0]\n}\n\n// Create a map of what days each possible DPW value will run on\n// Example:  User sets allowed days to Monday Wed and Fri\n// Map would look like: DPWDays1:[1,0,0,0,0,0,0] (run on Monday)\n//                      DPWDays2:[1,0,0,0,1,0,0] (run on Monday and Friday)\n//                      DPWDays3:[1,0,1,0,1,0,0] (run on Monday Wed and Fri)\n// Everything runs on the first day possible, starting with Monday.\ndef createDPWMap() {\n    state.DPWDays1 = []\n    state.DPWDays2 = []\n    state.DPWDays3 = []\n    state.DPWDays4 = []\n    state.DPWDays5 = []\n    state.DPWDays6 = []\n    state.DPWDays7 = []\n    //def NDAYS = 7\n    // day Distance[NDAYS][NDAYS], easier to just define than calculate everytime\n    def int[][] dayDistance = [[0,1,2,3,3,2,1],[1,0,1,2,3,3,2],[2,1,0,1,2,3,3],[3,2,1,0,1,2,3],[3,3,2,1,0,1,2],[2,3,3,2,1,0,1],[1,2,3,3,2,1,0]]\n    def ndaysAvailable = daysAvailable()\n    int i = 0\n\n    // def int[] daysAvailable = [0,1,2,3,4,5,6]\n    def int[] daysAvailable = [0,0,0,0,0,0,0]\n\n    if(settings.days) {\n          if (settings.days.contains('Even') || settings.days.contains('Odd')) {\n              return\n          }\n          if (settings.days.contains('Monday')) {\n            daysAvailable[i] = 0\n            i++\n          }\n        if (settings.days.contains('Tuesday')) {\n            daysAvailable[i] = 1\n            i++\n          }\n          if (settings.days.contains('Wednesday')) {\n            daysAvailable[i] = 2\n            i++\n          }\n          if (settings.days.contains('Thursday')) {\n            daysAvailable[i] = 3\n            i++\n          }\n          if (settings.days.contains('Friday')) {\n            daysAvailable[i] = 4\n            i++\n          }\n          if (settings.days.contains('Saturday')) {\n            daysAvailable[i] = 5\n            i++\n          }\n          if (settings.days.contains('Sunday')) {\n            daysAvailable[i] = 6\n            i++\n          }\n          if(i != ndaysAvailable) {\n            log.debug 'ERROR: days and daysAvailable do not match in setup - overriding'\n            log.debug \"${i} ${ndaysAvailable}\"\n            ndaysAvailable = i                // override incorrect setup execution\n            state.daysAvailable = i\n          }\n    }\n    else {                    // all days are available if settings.days == \"\"\n        daysAvailable = [0,1,2,3,4,5,6]\n    }\n    //log.debug \"Ndays: ${ndaysAvailable} Available Days: ${daysAvailable}\"\n    def maxday = -1\n    def max = -1\n    def dDays = new int[7]\n    def int[][] runDays = [[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]\n\n    for(def a=0; a < ndaysAvailable; a++) {\n          // Figure out next day using the dayDistance map, getting the farthest away day (max value)\n          if(a > 0 && ndaysAvailable >= 2 && a != ndaysAvailable-1) {\n            if(a == 1) {\n                  for(def c=1; c < ndaysAvailable; c++) {\n                    def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                      if(d > max) {\n                          max = d\n                          maxday = daysAvailable[c]\n                    }\n                  }\n                  //log.debug \"max: ${max}  maxday: ${maxday}\"\n                  dDays[0] = maxday\n            }\n\n            // Find successive maxes for the following days\n            if(a > 1) {\n                  def lmax = max\n                  def lmaxday = maxday\n                  max = -1\n                  for(int c = 1; c < ndaysAvailable; c++) {\n                    def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                    def t = d > max\n                    if (a % 2 == 0)    t = d >= max\n                    if(d < lmax && d >= max) {\n                         if(d == max) {\n                              d = dayDistance[lmaxday][daysAvailable[c]]\n                            if(d > dayDistance[lmaxday][maxday]) {\n                                  max = d\n                                  maxday = daysAvailable[c]\n                            }\n                          }\n                          else {\n                            max = d\n                            maxday = daysAvailable[c]\n                          }\n                    }\n                  }\n                  lmax = 5\n                  while(max == -1) {\n                    lmax = lmax -1\n                    for(int c = 1; c < ndaysAvailable; c++) {\n                          def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                          if(d < lmax && d >= max) {\n                            if(d == max) {\n                                    d = dayDistance[lmaxday][daysAvailable[c]]\n                                  if(d > dayDistance[lmaxday][maxday]) {\n                                    max = d\n                                    maxday = daysAvailable[c]\n                                  }\n                            }\n                            else {\n                                  max = d\n                                  maxday = daysAvailable[c]\n                            }\n                          }\n                    }\n                    for (def d=0; d< a-2; d++) {\n                          if(maxday == dDays[d]) max = -1\n                      }\n                  }\n                  //log.debug \"max: ${max} maxday: ${maxday}\"\n                  dDays[a-1] = maxday\n            }\n          }\n\n          // Set the runDays map using the calculated maxdays\n          for(int b=0; b < 7; b++) {\n            // Runs every day available\n            if(a == ndaysAvailable-1) {\n                  runDays[a][b] = 0\n                  for (def c=0; c < ndaysAvailable; c++) {\n                    if(b == daysAvailable[c]) runDays[a][b] = 1\n                  }\n            }\n            else {\n                  // runs weekly, use first available day\n                  if(a == 0) {\n                    if(b == daysAvailable[0])\n                          runDays[a][b] = 1\n                    else\n                          runDays[a][b] = 0\n                  }\n                  else {\n                    // Otherwise, start with first available day\n                    if(b == daysAvailable[0])\n                          runDays[a][b] = 1\n                    else {\n                          runDays[a][b] = 0\n                          for(def c=0; c < a; c++)\n                          if(b == dDays[c])\n                            runDays[a][b] = 1\n                    }\n                  }\n            }\n          }\n    }\n\n      //log.debug \"DPW: ${runDays}\"\n    state.DPWDays1 = runDays[0]\n    state.DPWDays2 = runDays[1]\n    state.DPWDays3 = runDays[2]\n    state.DPWDays4 = runDays[3]\n    state.DPWDays5 = runDays[4]\n    state.DPWDays6 = runDays[5]\n    state.DPWDays7 = runDays[6]\n}\n\n//transition page to populate app state - this is a fix for WP param\ndef zoneSetPage1(){\n    state.app = 1\n    zoneSetPage()\n    }\ndef zoneSetPage2(){\n    state.app = 2\n    zoneSetPage()\n    }\ndef zoneSetPage3(){\n    state.app = 3\n    zoneSetPage()\n    }\ndef zoneSetPage4(){\n    state.app = 4\n    zoneSetPage()\n    }\ndef zoneSetPage5(){\n    state.app = 5\n    zoneSetPage()\n    }\ndef zoneSetPage6(){\n    state.app = 6\n    zoneSetPage()\n    }\ndef zoneSetPage7(){\n    state.app = 7\n    zoneSetPage()\n    }\ndef zoneSetPage8(){\n    state.app = 8\n    zoneSetPage()\n    }\ndef zoneSetPage9(i){\n    state.app = 9\n    zoneSetPage()\n    }\ndef zoneSetPage10(){\n    state.app = 10\n    zoneSetPage()\n    }\ndef zoneSetPage11(){\n    state.app = 11\n    zoneSetPage()\n    }\ndef zoneSetPage12(){\n    state.app = 12\n    zoneSetPage()\n    }\ndef zoneSetPage13(){\n    state.app = 13\n    zoneSetPage()\n    }\ndef zoneSetPage14(){\n    state.app = 14\n    zoneSetPage()\n    }\ndef zoneSetPage15(){\n    state.app = 15\n    zoneSetPage()\n    }\ndef zoneSetPage16(){\n    state.app = 16\n    zoneSetPage()\n    }",
        "docstring": "Setup schedules for Spruce irrigation controller"
    },
    {
        "code": "def installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n\n\tlog.debug \"state: \" + state.myState\n}\n\ndef initialize() {\n\tsubscribe(switches, \"switch\", switchChange)\n\tsubscribe(motions, \"motion\", motionHandler)\n\tsubscribe(contacts, \"contact\", contactHandler)\n\n\trunEvery1Minute(\"scheduleCheck\")\n\tstate.myState = \"ready\"\n}\n\ndef switchChange(evt) {\n\tlog.debug \"SwitchChange: $evt.name: $evt.value\"\n\n    if(evt.value == \"on\") {\n        // Slight change of Race condition between motion or contact turning the switch on,\n        // versus user turning the switch on. Since we can't pass event parameters :-(, we rely\n        // on the state and hope the best.\n        if(state.myState == \"activating\") {\n            // OK, probably an event from Activating something, and not the switch itself. Go to Active mode.\n            state.myState = \"active\"\n        } else if(state.myState != \"active\") {\n    \t\tstate.myState = \"already on\"\n        }\n    } else {\n    \t// If active and switch is turned of manually, then stop the schedule and go to ready state\n    \tif(state.myState == \"active\" || state.myState == \"activating\") {\n    \t\tunschedule()\n        }\n  \t\tstate.myState = \"ready\"\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"contactHandler: $evt.name: $evt.value\"\n\n    if (evt.value == \"open\") {\n        if(state.myState == \"ready\") {\n            log.debug \"Turning on lights by contact opening\"\n            switches.on()\n            state.inactiveAt = null\n            state.myState = \"activating\"\n        }\n    } else if (evt.value == \"closed\") {\n        if (!state.inactiveAt && state.myState == \"active\" || state.myState == \"activating\") {\n\t\t\t// When contact closes, we reset the timer if not already set\n            setActiveAndSchedule()\n        }\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"motionHandler: $evt.name: $evt.value\"\n\n    if (evt.value == \"active\") {\n        if(state.myState == \"ready\" || state.myState == \"active\" || state.myState == \"activating\" ) {\n            log.debug \"turning on lights\"\n            switches.on()\n            state.inactiveAt = null\n            state.myState = \"activating\"\n        }\n    } else if (evt.value == \"inactive\") {\n        if (!state.inactiveAt && state.myState == \"active\" || state.myState == \"activating\") {\n\t\t\t// When Motion ends, we reset the timer if not already set\n           setActiveAndSchedule()\n        }\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef setActiveAndSchedule() {\n    unschedule()\n \tstate.myState = \"active\"\n    state.inactiveAt = now()\n\trunEvery1Minute(\"scheduleCheck\")\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check, ts = ${state.inactiveAt}\"\n    if(state.myState != \"already on\") {\n    \tif(state.inactiveAt != null) {\n\t        def elapsed = now() - state.inactiveAt\n            log.debug \"${elapsed / 1000} sec since motion stopped\"\n\t        def threshold = 1000 * 60 * minutes1\n\t        if (elapsed >= threshold) {\n\t            if (state.myState == \"active\") {\n\t                log.debug \"turning off lights\"\n\t                switches.off()\n\t            }\n\t            state.inactiveAt = null\n\t            state.myState = \"ready\"\n\t        }\n    \t}\n    }\n    log.debug \"state: \" + state.myState\n}",
        "docstring": "Turns on a switch for X minutes, then turns it off. Unless, the switch is already on, in which case it stays on. If the switch is toggled while the timer is running, the timer is canceled."
    },
    {
        "code": "def installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\n\ndef accelerationActiveHandler(evt) {\n\t\tswitch1.on()\n\t}",
        "docstring": "Turn on switch when vibration is sensed"
    },
    {
        "code": "def installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tinitialize()\n}\n\ndef initialize()\n{\n\tif (state.subscribe)\n\t{\n    \tunsubscribe()\n\t\tstate.subscribe = false\n\t}\n    \n    if (selectedAgent)\n    {\n    \taddOrUpdateAgent(state.agents[selectedAgent])\n    }\n}\n\ndef addOrUpdateAgent(agent)\n{\n\tdef children = getChildDevices()\n\tdef dni = agent.ip + \":\" + agent.port\n    def found = false\n\t\n\tchildren.each\n\t{\n\t\tif ((it.getDeviceDataByName(\"mac\") == agent.mac))\n\t\t{\n        \tfound = true\n            \n            if (it.getDeviceNetworkId() != dni)\n            {\n\t\t\t\tit.setDeviceNetworkId(dni)\n\t\t\t}\n\t\t}\n        else if (it.getDeviceNetworkId() == dni)\n        {\n        \tfound = true\n        }\n\t}\n    \n\tif (!found)\n\t{\n        addChildDevice(\"roomieremote-agent\", \"Simple Sync\", dni, agent.hub, [label: \"Simple Sync\"])\n\t}\n}\n\ndef locationHandler(evt)\n{\n    def description = evt?.description\n    def urn = getURN()\n    def hub = evt?.hubId\n    def parsedEvent = parseEventMessage(description)\n    \n    parsedEvent?.putAt(\"hub\", hub)\n    \n    //SSDP DISCOVERY EVENTS\n\tif (parsedEvent?.ssdpTerm?.contains(urn))\n\t{\n        def agent = parsedEvent\n        def ip = convertHexToIP(agent.ip)\n        def agents = getAgents()\n        \n        agent.verified = true\n        agent.name = \"Simple Sync $ip\"\n        \n        if (!agents[agent.uuid])\n        {\n        \tstate.agents[agent.uuid] = agent\n        }\n    }\n}\n\nprivate def parseEventMessage(String description)\n{\n\tdef event = [:]\n\tdef parts = description.split(',')\n    \n\tparts.each\n    { part ->\n\t\tpart = part.trim()\n\t\tif (part.startsWith('devicetype:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tevent.devicetype = valueString\n\t\t}\n\t\telse if (part.startsWith('mac:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.mac = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('networkAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ip = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('deviceAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.port = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpPath:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpPath = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpUSN:'))\n        {\n\t\t\tpart -= \"ssdpUSN:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpUSN = valueString\n                \n                def uuid = getUUIDFromUSN(valueString)\n                \n                if (uuid)\n                {\n                \tevent.uuid = uuid\n                }\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpTerm:'))\n        {\n\t\t\tpart -= \"ssdpTerm:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpTerm = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('headers'))\n        {\n\t\t\tpart -= \"headers:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.headers = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('body'))\n        {\n\t\t\tpart -= \"body:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.body = valueString\n\t\t\t}\n\t\t}\n\t}\n\n\tevent\n}\n\ndef getURN()\n{\n    return \"urn:roomieremote-com:device:roomie:1\"\n}\n\ndef getUUIDFromUSN(usn)\n{\n\tdef parts = usn.split(\":\")\n\t\n\tfor (int i = 0; i < parts.size(); ++i)\n\t{\n\t\tif (parts[i] == \"uuid\")\n\t\t{\n\t\t\treturn parts[i + 1]\n\t\t}\n\t}\n}\n\ndef String convertHexToIP(hex)\n{\n\t[convertHexToInt(hex[0..1]),convertHexToInt(hex[2..3]),convertHexToInt(hex[4..5]),convertHexToInt(hex[6..7])].join(\".\")\n}\n\ndef Integer convertHexToInt(hex)\n{\n\tInteger.parseInt(hex,16)\n}\n\ndef String convertToHexString(n)\n{\n\tString hex = String.format(\"%X\", n.toInteger())\n}\n\ndef String convertIPToHexString(ipString)\n{\n\tString hex = ipString.tokenize(\".\").collect {\n    \tString.format(\"%02X\", it.toInteger())\n    }.join()\n}\n\ndef Boolean canInstallLabs()\n{\n    return hasAllHubsOver(\"000.011.00603\")\n}\n\ndef Boolean hasAllHubsOver(String desiredFirmware)\n{\n    return realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\ndef List getRealHubFirmwareVersions()\n{\n    return location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate SmartThings with your Simple Control activities via Simple Sync."
    },
    {
        "code": "def installed() {\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(motionInactive, \"motion.inactive\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\tstartActivity(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartActivity(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\tstartActivity(evt)\n}\n\nprivate startActivity(evt) {\n\tagent.startActivity(activity)\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}",
        "docstring": "Trigger Simple Control activities when certain actions take place in your home."
    },
    {
        "code": "def installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tinitialize()\n}\n\ndef initialize()\n{\n\tif (state.subscribe)\n\t{\n    \tunsubscribe()\n\t\tstate.subscribe = false\n\t}\n    \n    if (selectedAgent)\n    {\n    \taddOrUpdateAgent(state.agents[selectedAgent])\n    }\n}\n\ndef addOrUpdateAgent(agent)\n{\n\tdef children = getChildDevices()\n\tdef dni = agent.ip + \":\" + agent.port\n    def found = false\n\t\n\tchildren.each\n\t{\n\t\tif ((it.getDeviceDataByName(\"mac\") == agent.mac))\n\t\t{\n        \tfound = true\n            \n            if (it.getDeviceNetworkId() != dni)\n            {\n\t\t\t\tit.setDeviceNetworkId(dni)\n\t\t\t}\n\t\t}\n        else if (it.getDeviceNetworkId() == dni)\n        {\n        \tfound = true\n        }\n\t}\n    \n\tif (!found)\n\t{\n        addChildDevice(\"roomieremote-agent\", \"Simple Sync\", dni, agent.hub, [label: \"Simple Sync\"])\n\t}\n}\n\ndef locationHandler(evt)\n{\n    def description = evt?.description\n    def urn = getURN()\n    def hub = evt?.hubId\n    def parsedEvent = parseEventMessage(description)\n    \n    parsedEvent?.putAt(\"hub\", hub)\n    \n    //SSDP DISCOVERY EVENTS\n\tif (parsedEvent?.ssdpTerm?.contains(urn))\n\t{\n        def agent = parsedEvent\n        def ip = convertHexToIP(agent.ip)\n        def agents = getAgents()\n        \n        agent.verified = true\n        agent.name = \"Simple Sync $ip\"\n        \n        if (!agents[agent.uuid])\n        {\n        \tstate.agents[agent.uuid] = agent\n        }\n    }\n}\n\nprivate def parseEventMessage(String description)\n{\n\tdef event = [:]\n\tdef parts = description.split(',')\n    \n\tparts.each\n    { part ->\n\t\tpart = part.trim()\n\t\tif (part.startsWith('devicetype:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tevent.devicetype = valueString\n\t\t}\n\t\telse if (part.startsWith('mac:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.mac = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('networkAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ip = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('deviceAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.port = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpPath:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpPath = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpUSN:'))\n        {\n\t\t\tpart -= \"ssdpUSN:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpUSN = valueString\n                \n                def uuid = getUUIDFromUSN(valueString)\n                \n                if (uuid)\n                {\n                \tevent.uuid = uuid\n                }\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpTerm:'))\n        {\n\t\t\tpart -= \"ssdpTerm:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpTerm = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('headers'))\n        {\n\t\t\tpart -= \"headers:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.headers = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('body'))\n        {\n\t\t\tpart -= \"body:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.body = valueString\n\t\t\t}\n\t\t}\n\t}\n\n\tevent\n}\n\ndef getURN()\n{\n    return \"urn:roomieremote-com:device:roomie:1\"\n}\n\ndef getUUIDFromUSN(usn)\n{\n\tdef parts = usn.split(\":\")\n\t\n\tfor (int i = 0; i < parts.size(); ++i)\n\t{\n\t\tif (parts[i] == \"uuid\")\n\t\t{\n\t\t\treturn parts[i + 1]\n\t\t}\n\t}\n}\n\ndef String convertHexToIP(hex)\n{\n\t[convertHexToInt(hex[0..1]),convertHexToInt(hex[2..3]),convertHexToInt(hex[4..5]),convertHexToInt(hex[6..7])].join(\".\")\n}\n\ndef Integer convertHexToInt(hex)\n{\n\tInteger.parseInt(hex,16)\n}\n\ndef String convertToHexString(n)\n{\n\tString hex = String.format(\"%X\", n.toInteger())\n}\n\ndef String convertIPToHexString(ipString)\n{\n\tString hex = ipString.tokenize(\".\").collect {\n    \tString.format(\"%02X\", it.toInteger())\n    }.join()\n}\n\ndef Boolean canInstallLabs()\n{\n    return hasAllHubsOver(\"000.011.00603\")\n}\n\ndef Boolean hasAllHubsOver(String desiredFirmware)\n{\n    return realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\ndef List getRealHubFirmwareVersions()\n{\n    return location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate SmartThings with your Simple Control activities."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    poll();\n    schedule(\"0 0 8 1/1 * ? *\", poll)\n}\n\n//Check hebcal for today's candle lighting or havdalah\ndef poll()\n{\n\n    unschedule(\"endChag\")\n    unschedule(\"setChag\")\n    Hebcal_WebRequest()\n\n}//END def poll()\n\n\n\n/**********************************************\n// HEBCAL FUNCTIONS\n-----------------------------------------------*/\n\n//This function is the web request and response parse\ndef Hebcal_WebRequest(){\n\ndef today = new Date().format(\"yyyy-MM-dd\")\n//def today = \"2014-11-14\"\ndef zip = settings.zip as String\ndef locale = getTwcLocation(zipCode).location\ndef timezone = TimeZone.getTimeZone(locale.ianaTimeZone)\ndef hebcal_date\ndef hebcal_category\ndef hebcal_title\ndef candlelighting\ndef candlelightingLocalTime\ndef havdalah\ndef havdalahLocalTime\ndef pushMessage\ndef testmessage\ndef urlRequest = \"http://www.hebcal.com/hebcal/?v=1&cfg=json&nh=off&nx=off&year=now&month=now&mf=off&c=on&zip=${zipcode}&m=${havdalahOffset}&s=off&D=off&d=off&o=off&ss=off\"\nlog.trace \"${urlRequest}\"\n\ndef hebcal = { response ->\n    hebcal_date = response.data.items.date\n    hebcal_category = response.data.items.category\n    hebcal_title = response.data.items.title\n\n    for (int i = 0; i < hebcal_date.size; i++)\n    {\n        if(hebcal_date[i].split(\"T\")[0]==today)\n        {\n            if(hebcal_category[i]==\"candles\")\n            {\n                candlelightingLocalTime = HebCal_GetTime12(hebcal_title[i])\n                pushMessage = \"Candle Lighting is at ${candlelightingLocalTime}\"\n                candlelightingLocalTime = HebCal_GetTime24(hebcal_date[i])\n                candlelighting = timeToday(candlelightingLocalTime, timezone)\n\n                sendMessage(pushMessage)\n                schedule(candlelighting, setChag)\n                log.debug pushMessage\n            }//END if(hebcal_category==\"candles\")\n\n            else if(hebcal_category[i]==\"havdalah\")\n            {\n                havdalahLocalTime = HebCal_GetTime12(hebcal_title[i])\n                pushMessage = \"Havdalah is at ${havdalahLocalTime}\"\n                havdalahLocalTime = HebCal_GetTime24(hebcal_date[i])\n                havdalah = timeToday(havdalahLocalTime, timezone)\n                testmessage = \"Scheduling for ${havdalah}\"\n                schedule(havdalah, endChag)\n                log.debug pushMessage\n                log.debug testmessage\n            }//END if(hebcal_category==\"havdalah\"){\n        }//END if(hebcal_date[i].split(\"T\")[0]==today)\n\n    }//END for (int i = 0; i < hebcal_date.size; i++)\n }//END def hebcal = { response ->\nhttpGet(urlRequest, hebcal);\n}//END def queryHebcal()\n\n\n//This function gets candle lighting time\ndef HebCal_GetTime12(hebcal_title){\ndef returnTime = hebcal_title.split(\":\")[1] + \":\" + hebcal_title.split(\":\")[2] + \" \"\nreturn returnTime\n}//END def HebCal_GetTime12()\n\n//This function gets candle lighting time\ndef HebCal_GetTime24(hebcal_date){\ndef returnTime = hebcal_date.split(\"T\")[1]\nreturnTime = returnTime.split(\"-\")[0]\nreturn returnTime\n}//END def HebCal_GetTime12()\n\n/*-----------------------------------------------\n END OF HEBCAL FUNCTIONS\n-----------------------------------------------*/\ndef setChag()\n{\n\n    if (location.mode != startMode)\n    {\n        if (location.modes?.find{it.name == startMode})\n        {\n            setLocationMode(startMode)\n            //sendMessage(\"Changed the mode to '${startMode}'\")\n            def dayofweek = new Date().format(\"EEE\")\n            if(dayofweek=='Fri'){\n                sendMessage(\"Shabbat Shalom!\")\n            }\n            else{\n                sendMessage(\"Chag Sameach!\")\n            }\n\n        }//END if (location.modes?.find{it.name == startMode})\n        else\n        {\n            sendMessage(\"Tried to change to undefined mode '${startMode}'\")\n        }//END else\n    }//END if (location.mode != newMode)\n\n    unschedule(\"setChag\")\n}//END def setChag()\n\n\ndef endChag()\n{\n\n    if (location.mode != endMode)\n    {\n        if (location.modes?.find{it.name == endMode})\n        {\n            setLocationMode(endMode)\n            sendMessage(\"Changed the mode to '${endMode}'\")\n        }//END if (location.modes?.find{it.name == endMode})\n        else\n        {\n            sendMessage(\"Tried to change to undefined mode '${endMode}'\")\n        }//END else\n    }//END if (location.mode != endMode)\n\n    //sendMessage(\"Shavuah Tov!\")\n    unschedule(\"endChag\")\n}//END def setChag()\n\ndef sendMessage(msg){\nif ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        //sendPush( msg )\n    }\n\n    if ( phone ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone, msg )\n    }\n}//END def sendMessage(msg)",
        "docstring": "Changes the mode at candle lighting and back after havdalah.  Uses the HebCal.com API to look for days that are shabbat or chag and pull real time candle lighting and havdalah times to change modes automatically"
    },
    {
        "code": "def installed() {\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef humidityHandler(evt) {\n\tlog.trace \"humidity: $evt.value\"\n    log.trace \"set high point: $humidityHigh\"\n    log.trace \"set low point: $humidityLow\"\n\n\tdef currentHumidity = Double.parseDouble(evt.value.replace(\"%\", \"\"))\n\tdef humidityHigh1 = humidityHigh \n    def humidityLow1 = humidityLow \n\tdef mySwitch = settings.switch1\n\n\tif (currentHumidity >= humidityHigh1) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting >= $humidityHigh1\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 \n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms1 = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) >= humidityHigh1 } > 1\n\n\t\tif (alreadySentSms1) {\n\t\t\tlog.debug \"Notification already sent within the last $deltaMinutes minutes\"\n\n\t\t} else {\n         \tif (state.lastStatus != \"off\") {\n                log.debug \"Humidity Rose Above $humidityHigh1:  sending SMS and deactivating $mySwitch\"\n                send(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}, turning off ${switch1.label}\")\n                switch1?.off()\n                state.lastStatus = \"off\"\n            }\n\t\t}\n\t}\n    else if (currentHumidity <= humidityLow1) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting <= $humidityLow1\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 \n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms2 = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) <= humidityLow1 } > 1\n\n\t\tif (alreadySentSms2) {\n\t\t\tlog.debug \"Notification already sent within the last $deltaMinutes minutes\"\n\n\t\t} else {\n        \tif (state.lastStatus != \"on\") {\n                log.debug \"Humidity Dropped Below $humidityLow1:  sending SMS and activating $mySwitch\"\n                send(\"${humiditySensor1.label} sensed low humidity level of ${evt.value}, turning on ${switch1.label}\")\n                switch1?.on()\n                state.lastStatus = \"on\"\n            }\n\t\t}\n\t}\n    else {\n    \t//log.debug \"Humidity remained in threshold:  sending SMS to $phone1 and activating $mySwitch\"\n\t\t//send(\"${humiditySensor1.label} sensed humidity level of ${evt.value} is within threshold, keeping on ${switch1.label}\")\n    \t//switch1?.on()\n    }\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n    }\n\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n\n    log.debug msg\n}",
        "docstring": "Turn on/off humidifier based on relative humidity from a sensor."
    },
    {
        "code": "def installed() {\n\tif (timeOne)\n\t{\n\t\tlog.debug \"scheduling 'Smart turn it on' to run at $timeOne\"\n\t\tschedule(timeOne, \"turnOn\")\n\t}\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tif (timeOne)\n\t{\n\t\tlog.debug \"scheduling 'Smart turn it on' to run at $timeOne\"\n\t\tschedule(timeOne, \"turnOn\")\n\t}\n}\n\ndef turnOn(){\nlog.debug \"Start\"\n\tdef dayCheck = dayOne.contains(new Date().format(\"EEE\"))\n    def dayTwo = new Date().format(\"EEE\");\n\tif(dayCheck){\n        def presenceTwo = presenceOne.latestValue(\"presence\").contains(\"present\")\n\t\tif (presenceTwo) {\n        \tswitchOne.on()\n\t\t\tdef delay = timeTwo * 60\n\t\t\trunIn(delay, \"turnOff\")\n\t\t}   \n    }\n}\n\n\n    \ndef turnOff() {\n\tswitchOne.off()\n}",
        "docstring": "Turns on selected device(s) at a set time on selected days of the week only if a selected person is present and turns off selected device(s) after a set time."
    },
    {
        "code": "def installed() {\n    subscribe(lock1, \"lock\", checkCode)\n}\n\ndef updated() {\n\tunsubscribe()\n    subscribe(lock1, \"lock\", checkCode)\n}\n\ndef checkCode(evt) {\n    log.debug \"$evt.value: $evt, $settings\"\n\n    if(evt.value == \"unlocked\" && evt.data) {\n    \tdef lockData = new JsonSlurper().parseText(evt.data)\n        \n        if(discoveryMode) {\n        \tsendPush \"Door unlocked with user code $lockData.usedCode\"\n        }\n        \n        if(lockData.usedCode == distressCode && discoveryMode == false) {\n        \tlog.info \"Distress Message Sent\"\n        \tsendSms(phone1, distressMsg)\n        }\n    }\n}",
        "docstring": "Sends a text to someone when a specific code is entered"
    },
    {
        "code": "def installed()\n{\n    initialize()\n}\n\ndef updated()\n{\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize()\n{\n    log.debug \"Settings: ${settings}\"\n    subscribe(lock1, \"lock\", doorHandler, [filterEvents: false])\n    subscribe(lock1, \"unlock\", doorHandler, [filterEvents: false])  \n    subscribe(contact1, \"contact.open\", doorHandler)\n\tsubscribe(contact1, \"contact.closed\", doorHandler)\n}\n\ndef lockDoor()\n{\n\tif (lock1.latestValue(\"lock\") == \"unlocked\")\n    \t{\n    \tlog.debug \"Locking $lock1...\"\n    \tlock1.lock()\n        log.debug (\"Sending Push Notification...\") \n    \tif (sendPushMessage != \"No\") sendPush(\"$lock1 locked after $contact1 was closed for $minutesLater minute(s)!\")\n    \tlog.debug(\"Sending text message...\")\n\t\tif ((sendText == \"Yes\") && (phoneNumber != \"0\")) sendSms(phoneNumber, \"$lock1 locked after $contact1 was closed for $minutesLater minute(s)!\")\n        }\n\telse if (lock1.latestValue(\"lock\") == \"locked\")\n    \t{\n        log.debug \"$lock1 was already locked...\"\n        }\n}\n\ndef unlockDoor()\n{\n\tif (lock1.latestValue(\"lock\") == \"locked\")\n    \t{\n    \tlog.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        log.debug (\"Sending Push Notification...\") \n    \tif (sendPushMessage != \"No\") sendPush(\"$lock1 unlocked after $contact1 was open for $secondsLater seconds(s)!\")\n    \tlog.debug(\"Sending text message...\")\n\t\tif ((sendText == \"Yes\") && (phoneNumber != \"0\")) sendSms(phoneNumber, \"$lock1 unlocked after $contact1 was open for $secondsLater seconds(s)!\")        \n        }\n\telse if (lock1.latestValue(\"lock\") == \"unlocked\")\n    \t{\n        log.debug \"$lock1 was already unlocked...\"\n        }\n}\n\ndef doorHandler(evt)\n{\n    if ((contact1.latestValue(\"contact\") == \"open\") && (evt.value == \"locked\"))\n    \t{\n        def delay = secondsLater\n        runIn (delay, unlockDoor)\n    \t}\n    else if ((contact1.latestValue(\"contact\") == \"open\") && (evt.value == \"unlocked\"))\n    \t{\n        unschedule (unlockDoor)\n\t\t}\n    else if ((contact1.latestValue(\"contact\") == \"closed\") && (evt.value == \"locked\"))\n    \t{\n        unschedule (lockDoor)\n    \t}   \n    else if ((contact1.latestValue(\"contact\") == \"closed\") && (evt.value == \"unlocked\"))\n    \t{\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        def delay = (minutesLater * 60)\n        runIn (delay, lockDoor)\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"open\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"closed\"))\n    \t{\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        def delay = (minutesLater * 60)\n        runIn (delay, lockDoor)\n    \t}\n\telse if ((lock1.latestValue(\"lock\") == \"locked\") && (evt.value == \"open\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"locked\") && (evt.value == \"closed\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else\n    \t{\n        log.debug \"Problem with $lock1, the lock might be jammed!\"\n        unschedule (lockDoor)\n        unschedule (unlockDoor)\n    \t}\n}",
        "docstring": "Automatically locks door X minutes after being closed and keeps door unlocked if door is open."
    },
    {
        "code": "def installed() {\n\tlog.debug \"<beacon-control> Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"<beacon-control> Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(beacons, \"presence\", beaconHandler)\n}\n\n// Event handlers\ndef beaconHandler(evt) {\n\tlog.debug \"<beacon-control> beaconHandler: $evt\"\n\n\tif (allOk) {\n\t\tdef data = new groovy.json.JsonSlurper().parseText(evt.data)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> data: $data - phones: \" + phones*.deviceNetworkId\n\n\t\tdef beaconName = getBeaconName(evt)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> beaconName: $beaconName\"\n\n\t\tdef phoneName = getPhoneName(data)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> phoneName: $phoneName\"\n\t\tif (phoneName != null) {\n            def action = data.presence == \"1\" ? \"arrived\" : \"left\"\n            def msg = \"$phoneName has $action ${action == 'arrived' ? 'at ' : ''}the $beaconName\"\n\n            if (action == \"arrived\") {\n                msg = arriveActions(msg)\n            }\n            else if (action == \"left\") {\n                msg = departActions(msg)\n            }\n            log.debug \"<beacon-control> msg: $msg\"\n\n            if (pushNotification || phone) {\n                def options = [\n                    method: (pushNotification && phone) ? \"both\" : (pushNotification ? \"push\" : \"sms\"),\n                    phone: phone\n                ]\n                sendNotification(msg, options)\n            }\n        }\n\t}\n}\n\n// Helpers\nprivate arriveActions(msg) {\n\tif (arrivalPhrase || arrivalOnSwitches || arrivalOffSwitches || arrivalLocks) msg += \", so\"\n\t\n\tif (arrivalPhrase) {\n\t\tlog.debug \"<beacon-control> executing: $arrivalPhrase\"\n\t\texecutePhrase(arrivalPhrase)\n\t\tmsg += \" ${prefix('executed')} $arrivalPhrase.\"\n\t}\n\tif (arrivalOnSwitches) {\n\t\tlog.debug \"<beacon-control> turning on: $arrivalOnSwitches\"\n\t\tarrivalOnSwitches.on()\n\t\tmsg += \" ${prefix('turned')} ${list(arrivalOnSwitches)} on.\"\n\t}\n\tif (arrivalOffSwitches) {\n\t\tlog.debug \"<beacon-control> turning off: $arrivalOffSwitches\"\n\t\tarrivalOffSwitches.off()\n\t\tmsg += \" ${prefix('turned')} ${list(arrivalOffSwitches)} off.\"\n\t}\n\tif (arrivalLocks) {\n\t\tlog.debug \"<beacon-control> unlocking: $arrivalLocks\"\n\t\tarrivalLocks.unlock()\n\t\tmsg += \" ${prefix('unlocked')} ${list(arrivalLocks)}.\"\n\t}\n\tmsg\n}\n\nprivate departActions(msg) {\n\tif (departPhrase || departOnSwitches || departOffSwitches || departLocks) msg += \", so\"\n\t\n\tif (departPhrase) {\n\t\tlog.debug \"<beacon-control> executing: $departPhrase\"\n\t\texecutePhrase(departPhrase)\n\t\tmsg += \" ${prefix('executed')} $departPhrase.\"\n\t}\n\tif (departOnSwitches) {\n\t\tlog.debug \"<beacon-control> turning on: $departOnSwitches\"\n\t\tdepartOnSwitches.on()\n\t\tmsg += \" ${prefix('turned')} ${list(departOnSwitches)} on.\"\n\t}\n\tif (departOffSwitches) {\n\t\tlog.debug \"<beacon-control> turning off: $departOffSwitches\"\n\t\tdepartOffSwitches.off()\n\t\tmsg += \" ${prefix('turned')} ${list(departOffSwitches)} off.\"\n\t}\n\tif (departLocks) {\n\t\tlog.debug \"<beacon-control> unlocking: $departLocks\"\n\t\tdepartLocks.lock()\n\t\tmsg += \" ${prefix('locked')} ${list(departLocks)}.\"\n\t}\n\tmsg\n}\n\nprivate prefix(word) {\n\tdef result\n\tdef index = settings.prefixIndex == null ? 0 : settings.prefixIndex + 1\n\tswitch (index) {\n\t\tcase 0:\n\t\t\tresult = \"I $word\"\n\t\t\tbreak\n\t\tcase 1:\n\t\t\tresult = \"I also $word\"\n\t\t\tbreak\n\t\tcase 2:\n\t\t\tresult = \"And I $word\"\n\t\t\tbreak\n\t\tdefault:\n\t\t\tresult = \"And $word\"\n\t\t\tbreak\n\t}\n\n\tsettings.prefixIndex = index\n\tlog.trace \"prefix($word'): $result\"\n\tresult\n}\n\nprivate listPhrases() {\n\tlocation.helloHome.getPhrases().label\n}\n\nprivate executePhrase(phraseName) {\n\tif (phraseName) {\n\t\tlocation.helloHome.execute(phraseName)\n\t\tlog.debug \"<beacon-control> executed phrase: $phraseName\"\n\t}\n}\n\nprivate getBeaconName(evt) {\n\tdef beaconName = beacons.find { b -> b.id == evt.deviceId }\n\treturn beaconName\n}\n\nprivate getPhoneName(data) {    \n\tdef phoneName = phones.find { phone ->\n\t\t// Work around DNI bug in data\n\t\tdef pParts = phone.deviceNetworkId.split('\\\\|')\n\t\tdef dParts = data.dni.split('\\\\|')\n        pParts[0] == dParts[0]\n\t}\n\treturn phoneName\n}\n\nprivate hideOptionsSection() {\n\t(starting || ending || days || modes) ? false : true\n}\n\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"<beacon-control> modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"<beacon-control> daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"<beacon-control> timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\") {\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel() {\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n\nprivate list(List names) {\n\tswitch (names.size()) {\n\t\tcase 0:\n\t\t\treturn null\n\t\tcase 1:\n\t\t\treturn names[0]\n\t\tcase 2:\n\t\t\treturn \"${names[0]} and ${names[1]}\"\n\t\tdefault:\n\t\t\treturn \"${names[0..-2].join(', ')}, and ${names[-1]}\"\n\t}\n}",
        "docstring": "Execute a Hello, Home phrase, turn on or off some lights, and/or lock or unlock your door when you enter or leave a monitored region"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef changedLocationMode(evt) {\n\tlog.debug \"changedLocationMode: $evt\"\n\tswitches?.off()\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt\"\n\tswitches?.off()\n}",
        "docstring": "Turn your lights off when the SmartApp is tapped or activated"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef changedLocationMode(evt) {\n\tlog.debug \"changedLocationMode: $evt\"\n\tswitches?.on()\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt\"\n\tswitches?.on()\n}",
        "docstring": "Turn your lights on when the SmartApp is tapped or activated."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n        // commented out log statement because presence sensor label could contain user's name\n\t//log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n        // commented out log statement because presence sensor label could contain user's name\n\t//log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tif (evt.value == \"not present\") {\n\t\tif (location.mode != newMode) {\n\t\t\tlog.debug \"checking if everyone is away\"\n\t\t\tif (everyoneIsAway()) {\n\t\t\t\tlog.debug \"starting sequence\"\n\t\t\t\trunIn(findFalseAlarmThreshold() * 60, \"takeAction\", [overwrite: false])\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"mode is the same, not evaluating\"\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"present; doing nothing\"\n\t}\n}\n\ndef takeAction()\n{\n\tif (everyoneIsAway()) {\n\t\tdef threshold = 1000 * 60 * findFalseAlarmThreshold() - 1000\n\t\tdef awayLongEnough = people.findAll { person ->\n\t\t\tdef presenceState = person.currentState(\"presence\")\n\t\t\tif (!presenceState) {\n\t\t\t\t// This device has yet to check in and has no presence state, treat it as not away long enough\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdef elapsed = now() - presenceState.rawDateCreated.time\n\t\t\telapsed >= threshold\n\t\t}\n\t\tlog.debug \"Found ${awayLongEnough.size()} out of ${people.size()} person(s) who were away long enough\"\n\t\tif (awayLongEnough.size() == people.size()) {\n\t\t\t// TODO -- uncomment when app label is available\n\t\t\tdef message = \"SmartThings changed your mode to '${newMode}' because everyone left home\"\n\t\t\tlog.info message\n\t\t\tsend(message)\n\t\t\tsetLocationMode(newMode)\n\t\t} else {\n\t\t\tlog.debug \"not everyone has been away long enough; doing nothing\"\n\t\t}\n\t} else {\n    \tlog.debug \"not everyone is away; doing nothing\"\n    }\n}\n\nprivate everyoneIsAway()\n{\n\tdef result = true\n\tfor (person in people) {\n\t\tif (person.currentPresence == \"present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"everyoneIsAway: $result\"\n\treturn result\n}\n\nprivate send(msg) {\n\tif (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse  {\n\t\tif (sendPushMessage != \"No\") {\n\t\t\tlog.debug(\"sending push message\")\n\t\t\tsendPush(msg)\n\t\t}\n\n\t\tif (phone) {\n\t\t\tlog.debug(\"sending text message\")\n\t\t\tsendSms(phone, msg)\n\t\t}\n\t}\n\tlog.debug msg\n}\n\nprivate findFalseAlarmThreshold() {\n\t(falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold : 10\n}",
        "docstring": "Monitors a set of SmartSense Presence tags or smartphones and triggers a mode change when everyone has left.  Used in conjunction with Big Turn Off or Make It So to turn off lights, appliances, adjust the thermostat, turn on security apps, and more."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\tlog.debug \"takeAction($actionType)\"\n\tdef options = [:]\n\tif (volume) {\n\t\tbose.setLevel(volume as Integer)\n\t\toptions.delay = 1000\n\t}\n\n\tswitch (actionType) {\n\t\tcase \"Turn On & Play\":\n\t\t\toptions ? bose.on(options) : bose.on()\n\t\t\tbreak\n\t\tcase \"Turn Off\":\n\t\t\toptions ? bose.off(options) : bose.off()\n\t\t\tbreak\n\t\tcase \"Toggle Play/Pause\":\n\t\t\tdef currentStatus = bose.currentValue(\"playpause\")\n\t\t\tif (currentStatus == \"play\") {\n\t\t\t\toptions ? bose.pause(options) : bose.pause()\n\t\t\t}\n\t\t\telse if (currentStatus == \"pause\") {\n\t\t\t\toptions ? bose.play(options) : bose.play()\n\t\t\t}\n\t\t\tbreak\n\t\tcase \"Skip to Next Track\":\n\t\t\toptions ? bose.nextTrack(options) : bose.nextTrack()\n\t\t\tbreak\n\t\tcase \"Skip to Beginning/Previous Track\":\n\t\t\toptions ? bose.previousTrack(options) : bose.previousTrack()\n\t\t\tbreak\n        case \"Play Preset 1\":\n\t\t\toptions ? bose.preset1(options) : bose.preset1()\n\t\t\tbreak\n        case \"Play Preset 2\":\n\t\t\toptions ? bose.preset2(options) : bose.preset2()\n\t\t\tbreak \n        case \"Play Preset 3\":\n\t\t\toptions ? bose.preset3(options) : bose.preset3()\n\t\t\tbreak\n        case \"Play Preset 4\":\n\t\t\toptions ? bose.preset4(options) : bose.preset4()\n\t\t\tbreak\n        case \"Play Preset 5\":\n\t\t\toptions ? bose.preset5(options) : bose.preset5()\n\t\t\tbreak\n        case \"Play Preset 6\":\n\t\t\toptions ? bose.preset6(options) : bose.preset6()\n\t\t\tbreak\n\t\tdefault:\n\t\t\tlog.error \"Action type '$actionType' not defined\"\n\t}\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Control your Bose\u00ae SoundTouch\u00ae when certain actions take place in your home."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tdef lightSensorState = luminance1.currentIlluminance\n\tlog.debug \"SENSOR = $lightSensorState\"\n\tif (lightSensorState != null && lightSensorState < 10) {\n\t\tlog.trace \"light.on() ... [luminance: ${lightSensorState}]\"\n\t\tswitch1.on()\n\t}\n}",
        "docstring": "Turn your lights on when a open/close sensor opens and the space is dark."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef motionActiveHandler(evt) {\n\tswitch1.on()\n}",
        "docstring": "Turn your lights on when motion is detected."
    },
    {
        "code": "def installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef configured() {\n\treturn buttonDevice || buttonConfigured(1) || buttonConfigured(2) || buttonConfigured(3) || buttonConfigured(4)\n}\n\ndef buttonConfigured(idx) {\n\treturn settings[\"lights_$idx_pushed\"] ||\n\t\tsettings[\"locks_$idx_pushed\"] ||\n\t\tsettings[\"sonos_$idx_pushed\"] ||\n\t\tsettings[\"mode_$idx_pushed\"] ||\n        settings[\"notifications_$idx_pushed\"] ||\n        settings[\"sirens_$idx_pushed\"] ||\n        settings[\"notifications_$idx_pushed\"]   ||\n        settings[\"phone_$idx_pushed\"]\n}\n\ndef buttonEvent(evt){\n\tif(allOk) {\n\t\tdef buttonNumber = evt.data // why doesn't jsonData work? always returning [:]\n\t\tdef value = evt.value\n\t\tlog.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\t\tlog.debug \"button: $buttonNumber, value: $value\"\n\n\t\tdef recentEvents = buttonDevice.eventsSince(new Date(now() - 3000)).findAll{it.value == evt.value && it.data == evt.data}\n\t\tlog.debug \"Found ${recentEvents.size()?:0} events in past 3 seconds\"\n\n\t\tif(recentEvents.size <= 1){\n\t\t\tswitch(buttonNumber) {\n\t\t\t\tcase ~/.*1.*/:\n\t\t\t\t\texecuteHandlers(1, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*2.*/:\n\t\t\t\t\texecuteHandlers(2, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*3.*/:\n\t\t\t\t\texecuteHandlers(3, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*4.*/:\n\t\t\t\t\texecuteHandlers(4, value)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Found recent button press events for $buttonNumber with value $value\"\n\t\t}\n\t}\n}\n\ndef executeHandlers(buttonNumber, value) {\n\tlog.debug \"executeHandlers: $buttonNumber - $value\"\n\n\tdef lights = find('lights', buttonNumber, value)\n\tif (lights != null) toggle(lights)\n\n\tdef locks = find('locks', buttonNumber, value)\n\tif (locks != null) toggle(locks)\n\n\tdef sonos = find('sonos', buttonNumber, value)\n\tif (sonos != null) toggle(sonos)\n\n\tdef mode = find('mode', buttonNumber, value)\n\tif (mode != null) changeMode(mode)\n\n\tdef phrase = find('phrase', buttonNumber, value)\n\tif (phrase != null) location.helloHome.execute(phrase)\n\n\tdef textMessage = findMsg('textMessage', buttonNumber)\n\n\tdef notifications = find('notifications', buttonNumber, value)\n\tif (notifications?.toBoolean()) sendPush(textMessage ?: \"Button $buttonNumber was pressed\" )\n\n\tdef phone = find('phone', buttonNumber, value)\n\tif (phone != null) sendSms(phone, textMessage ?:\"Button $buttonNumber was pressed\")\n\n    def sirens = find('sirens', buttonNumber, value)\n    if (sirens != null) toggle(sirens)\n}\n\ndef find(type, buttonNumber, value) {\n\tdef preferenceName = type + \"_\" + buttonNumber + \"_\" + value\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef findMsg(type, buttonNumber) {\n\tdef preferenceName = type + \"_\" + buttonNumber\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef toggle(devices) {\n\tlog.debug \"toggle: $devices = ${devices*.currentValue('switch')}\"\n\n\tif (devices*.currentValue('switch').contains('on')) {\n\t\tdevices.off()\n\t}\n\telse if (devices*.currentValue('switch').contains('off')) {\n\t\tdevices.on()\n\t}\n\telse if (devices*.currentValue('lock').contains('locked')) {\n\t\tdevices.unlock()\n\t}\n\telse if (devices*.currentValue('lock').contains('unlocked')) {\n\t\tdevices.lock()\n\t}\n\telse if (devices*.currentValue('alarm').contains('off')) {\n        devices.siren()\n    }\n\telse {\n\t\tdevices.on()\n\t}\n}\n\ndef changeMode(mode) {\n\tlog.debug \"changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes\"\n\n\tif (location.mode != mode && location.modes?.find { it.name == mode }) {\n\t\tsetLocationMode(mode)\n\t}\n}\n\n// execution filter methods\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location.timeZone).time\n\t\tdef stop = timeToday(ending, location.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate hideOptionsSection() {\n\t(starting || ending || days || modes) ? false : true\n}\n\nprivate timeIntervalLabel() {\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}",
        "docstring": "Control devices with buttons like the Aeon Labs Minimote"
    },
    {
        "code": "def installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n    /*\n\tdef tz = location.timeZone\n    \n    //if it's after the startTime but before the end time, turn it on\n    if(startTime && timeToday(startTime,tz).time > timeToday(now,tz).time){\n    \n      if(endTime && timeToday(endTime,tz).time < timeToday(now,tz).time){\n        switch1.on()\n      }\n      else{\n        switch1.off()\n      }\n    }\n    else if(endTime && timeToday(endtime,tz).time > timeToday(now,tz).time)\n    {\n      switch1.off()\n    }\n    */\n    \n    if(startTime)\n      runDaily(startTime, turnOnCamera)\n    if(endTime)\n      runDaily(endTime,turnOffCamera)\n}\n\ndef turnOnCamera()\n{\n  log.info \"turned on camera\"\n  switch1.on()\n}\n\ndef turnOffCamera()\n{\n  log.info \"turned off camera\"\n  switch1.off()\n}",
        "docstring": "Turn the power on and off at a specific time."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tlog.debug \"Current people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tlog.debug \"Current people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tif (evt.value == \"not present\") {\n\t\t\n        log.debug \"checking if everyone is away\"\n        if (everyoneIsAway()) {\n            log.debug \"starting on Sequence\"\n\n            runIn(60*2, \"turnOn\") //two minute delay after everyone has left\n        }\n\t}\n\telse {\n    \tif (!everyoneIsAway()) {\n          turnOff()\n        }\n\t}\n}\n\ndef turnOff()\n{\n    log.debug \"canceling On requests\"\n    unschedule(\"turnOn\")\n    \n    log.info \"turning off the camera\"\n    switches1.off()\n}\n\ndef turnOn()\n{\n\n\tlog.info \"turned on the camera\"\n    switches1.on()\n\n\tunschedule(\"turnOn\") // Temporary work-around to scheduling bug\n}\n\nprivate everyoneIsAway()\n{\n\tdef result = true\n\tfor (person in people) {\n\t\tif (person.currentPresence == \"present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"everyoneIsAway: $result\"\n\treturn result\n}",
        "docstring": "Turn cameras on when I'm away"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(driver, \"presence.present\", presence)\n}\n\ndef presence(evt) {\n\n\tif (evt.value == \"present\" && riderIsHome())\n\t{\n//        \tlog.debug \"Rider Is Home; Send A Text\"\n\t\tsendText()\n\t}\n\n}\n\ndef riderIsHome() {\n\n//\tlog.debug \"rider presence: ${rider.currentPresence}\"\n\n\tif (rider.currentPresence != \"present\")\n\t{\n\t\treturn false\n\t}\n\n\tdef riderState = rider.currentState(\"presence\")\n//\tlog.debug \"riderState: ${riderState}\"\n\tif (!riderState)\n\t{\n\t\treturn true\n\t}\n\n\tdef latestState = rider.latestState(\"presence\")\n\n\tdef now = new Date()\n\tdef minusFive = new Date(minutes: now.minutes - 5)\n\n\n\tif (minusFive > latestState.date)\n\t{\n\t\treturn true\n\t}\n\n\treturn false\n}\n\ndef sendText() {\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(message ?: \"Your ride is here!\", recipients)\n\t}\n\telse {\n\t\tsendSms(phoneNumber, message ?: \"Your ride is here!\")\n\t}\n}",
        "docstring": "Send notifications to your carpooling buddies when you arrive to pick them up. If the person you are picking up is home, and has been for 5 minutes or more, they will get a notification when you arrive."
    },
    {
        "code": "def installed() {\n \tsubscribe(sensor, \"water\", waterHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n \tsubscribe(sensor, \"water\", waterHandler)\n}\n\ndef waterHandler(evt) {\n\tlog.debug \"Sensor says ${evt.value}\"\n\tif (evt.value == \"wet\") {\n\t\tvalve.close()\n\t}\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}    \n}\n\nprivate sendMessage(evt) {\n\tdef msg = messageText ?: \"We closed the valve because moisture was detected\"\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (!phone || pushAndPhone != \"No\") {\n\t\tlog.debug \"sending push\"\n\t\tsendPush(msg)\n\t}\n\tif (phone) {\n\t\tlog.debug \"sending SMS\"\n\t\tsendSms(phone, msg)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}",
        "docstring": "Close a selected valve if moisture is detected, and get notified by SMS and push notification."
    },
    {
        "code": "def installed() {\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(motionSensors, \"motion.active\", motionActive)\n\tsubscribe(motionSensors, \"motion.inactive\", motionInactive)\n\tsubscribe(presenceSensors, \"presence.not present\", notPresent)\n}\n\ndef motionActive(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (anyHere()) {\n\t\toutletsOn()\n\t}\n}\n\ndef motionInactive(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (allQuiet()) {\n\t\toutletsOff()\n\t}\n}\n\ndef notPresent(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (!anyHere()) {\n\t\toutletsOff()\n\t}\n}\n\ndef allQuiet() {\n\tdef result = true\n\tfor (it in motionSensors) {\n\t\tif (it.currentMotion == \"active\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}\n\ndef anyHere() {\n\tdef result = true\n\tfor (it in presenceSensors) {\n\t\tif (it.currentPresence == \"not present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}\n\ndef outletsOn() {\n\toutlets.on()\n\tunschedule(\"scheduledTurnOff\")\n}\n\ndef outletsOff() {\n\tdef delay = minutes * 60\n\trunIn(delay, \"scheduledTurnOff\")\n}\n\ndef scheduledTurnOff() {\n\toutlets.off()\n\tunschedule(\"scheduledTurnOff\") // Temporary work-around to scheduling bug\n}",
        "docstring": "Turns on an outlet when the user is present and off after a period of time"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(motion1, \"motion.inactive\", motionInactiveHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.inactive\", motionInactiveHandler)\n}\n\ndef motionInactiveHandler(evt) {\n\tswitch1.off()\n}",
        "docstring": "Turn your lights off after a period of no motion being observed."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(master, \"switch\", switchHandler, [filterEvents: false])\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(master, \"switch\", switchHandler, [filterEvents: false])\n}\n\ndef switchHandler(evt) {\n\tlog.info evt.value\n\n\t// use Event rather than DeviceState because we may be changing DeviceState to only store changed values\n\tdef recentStates = master.eventsSince(new Date(now() - 4000), [all:true, max: 10]).findAll{it.name == \"switch\"}\n\tlog.debug \"${recentStates?.size()} STATES FOUND, LAST AT ${recentStates ? recentStates[0].dateCreated : ''}\"\n\n\tif (evt.physical) {\n\t\tif (evt.value == \"on\" && lastTwoStatesWere(\"on\", recentStates, evt)) {\n\t\t\tlog.debug \"detected two taps, turn on other light(s)\"\n\t\t\tonSwitches()*.on()\n\t\t} else if (evt.value == \"off\" && lastTwoStatesWere(\"off\", recentStates, evt)) {\n\t\t\tlog.debug \"detected two taps, turn off other light(s)\"\n\t\t\toffSwitches()*.off()\n\t\t}\n\t}\n\telse {\n\t\tlog.trace \"Skipping digital on/off event\"\n\t}\n}\n\nprivate onSwitches() {\n\t(switches + onSwitches).findAll{it}\n}\n\nprivate offSwitches() {\n\t(switches + offSwitches).findAll{it}\n}\n\nprivate lastTwoStatesWere(value, states, evt) {\n\tdef result = false\n\tif (states) {\n\n\t\tlog.trace \"unfiltered: [${states.collect{it.dateCreated + ':' + it.value}.join(', ')}]\"\n\t\tdef onOff = states.findAll { it.physical || !it.type }\n\t\tlog.trace \"filtered:   [${onOff.collect{it.dateCreated + ':' + it.value}.join(', ')}]\"\n\n\t\t// This test was needed before the change to use Event rather than DeviceState. It should never pass now.\n\t\tif (onOff[0].date.before(evt.date)) {\n\t\t\tlog.warn \"Last state does not reflect current event, evt.date: ${evt.dateCreated}, state.date: ${onOff[0].dateCreated}\"\n\t\t\tresult = evt.value == value && onOff[0].value == value\n\t\t}\n\t\telse {\n\t\t\tresult = onOff.size() > 1 && onOff[0].value == value && onOff[1].value == value\n\t\t}\n\t}\n\tresult\n}",
        "docstring": "Turn on or off any number of switches when an existing switch is tapped twice in a row."
    },
    {
        "code": "def installed() {\n\tsubscribe(sensor, \"water.dry\", waterHandler)\n\tsubscribe(sensor, \"water.wet\", waterHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(sensor, \"water.dry\", waterHandler)\n\tsubscribe(sensor, \"water.wet\", waterHandler)\n}\n\ndef waterHandler(evt) {\n\tlog.debug \"Sensor says ${evt.value}\"\n\tif (evt.value == \"wet\") {\n\t\tpump.on()\n\t} else if (evt.value == \"dry\") {\n\t\tpump.off()\n\t}\n}",
        "docstring": "Turns switch on and off based on moisture sensor input."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tif(noRecentContact() && noRecentMotion()) {\n\t\tdef person = person1 ?: \"your elder\"\n\t\tdef msg = \"Alert! There has been no activity at ${person}'s place ${timePhrase}\"\n\t\tlog.debug msg\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tif (phone1) {\n\t\t\t\tsendSms(phone1, msg)\n\t\t\t} else {\n\t\t\t\tsendPush(msg)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"There has been activity ${timePhrase}, not sending alert\"\n\t}\n}\n\nprivate noRecentMotion()\n{\n\tif(motion1) {\n\t\tdef motionEvents = motion1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} motion events\"\n\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"There have been recent 'active' events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent 'active' events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate noRecentContact()\n{\n\tif(contact1) {\n\t\tdef contactEvents = contact1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${contactEvents?.size() ?: 0} door events\"\n\t\tif (contactEvents.find { it.value == \"open\" }) {\n\t\t\tlog.debug \"There have been recent 'open' events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent 'open' events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Contact sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate getSinceTime() {\n\tif (time0) {\n\t\treturn timeToday(time0, location?.timeZone)\n\t}\n\telse {\n\t\treturn new Date(now() - 21600000)\n\t}\n}\n\nprivate getTimePhrase() {\n\tdef interval = now() - sinceTime.time\n\tif (interval < 3600000) {\n\t\treturn \"in the past ${Math.round(interval/60000)} minutes\"\n\t}\n\telse if (interval < 7200000) {\n\t\treturn \"in the past hour\"\n\t}\n\telse {\n\t\treturn \"in the past ${Math.round(interval/3600000)} hours\"\n\t}\n}",
        "docstring": "Stay connected to your loved ones. Get notified if they are not up and moving around by a specified time and/or if they have not opened a cabinet or door according to a set schedule."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.active = 0\n\tsubscribe(bedroomMotion, \"motion.active\", bedroomActive)\n    subscribe(bathroomMotion, \"motion.active\", bathroomActive)\n}\n\ndef bedroomActive(evt) {\n\tdef start = timeToday(startTime, location?.timeZone)\n    def stop = timeToday(stopTime, location?.timeZone)\n    def now = new Date()\n    log.debug \"bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now\"\n    if (state.status == \"waiting\") {\n    \tlog.debug \"motion detected in bedroom, disarming\"\n    \tunschedule(\"sendMessage\")\n        state.status = null\n    }\n    else {\n        if (start.before(now) && stop.after(now)) {\n            log.debug \"motion in bedroom, look for bathroom motion\"\n            state.status = \"pending\"\n        }\n        else {\n            log.debug \"Not in time window\"\n        }\n    }\n}\n\ndef bathroomActive(evt) {\n\tlog.debug \"bathroomActive, status: $state.status\"\n\tif (state.status == \"pending\") {\n    \tdef delay = threshold.toInteger() * 60\n    \tstate.status = \"waiting\"\n        log.debug \"runIn($delay)\"\n        runIn(delay, sendMessage)\n    }\n}\n\ndef sendMessage() {\n\tlog.debug \"sendMessage\"\n\tdef msg = warnMessage\n    log.info msg\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse {\n\t\tsendPush msg\n\t\tif (phone1) {\n\t\t\tsendSms phone1, msg\n\t\t}\n\t\tif (phone2) {\n\t\t\tsendSms phone2, msg\n\t\t}\n\t\tif (phone3) {\n\t\t\tsendSms phone3, msg\n\t\t}\n\t}\n    state.status = null\n}",
        "docstring": "Monitors motion sensors in bedroom and bathroom during the night and detects if occupant does not return from the bathroom after a specified period of time."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(meter, \"power\", meterHandler)\n}\n\ndef meterHandler(evt) {\n\n    def meterValue = evt.value as double\n\n    if (!atomicState.lastValue) {\n    \tatomicState.lastValue = meterValue\n    }\n\n    def lastValue = atomicState.lastValue as double\n    atomicState.lastValue = meterValue\n\n    def dUnit = evt.unit ?: \"Watts\"\n\n    def aboveThresholdValue = aboveThreshold as int\n    if (meterValue > aboveThresholdValue) {\n    \tif (lastValue < aboveThresholdValue) { // only send notifications when crossing the threshold\n\t\t    def msg = \"${meter} reported ${evt.value} ${dUnit} which is above your threshold of ${aboveThreshold}.\"\n    \t    sendMessage(msg)\n        } else {\n//        \tlog.debug \"not sending notification for ${evt.description} because the threshold (${aboveThreshold}) has already been crossed\"\n        }\n    }\n\n\n    def belowThresholdValue = belowThreshold as int\n    if (meterValue < belowThresholdValue) {\n    \tif (lastValue > belowThresholdValue) { // only send notifications when crossing the threshold\n\t\t    def msg = \"${meter} reported ${evt.value} ${dUnit} which is below your threshold of ${belowThreshold}.\"\n    \t    sendMessage(msg)\n        } else {\n//        \tlog.debug \"not sending notification for ${evt.description} because the threshold (${belowThreshold}) has already been crossed\"\n        }\n    }\n}\n\ndef sendMessage(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sms) {\n            sendSms(sms, msg)\n        }\n        if (pushNotification) {\n            sendPush(msg)\n        }\n    }\n}",
        "docstring": "Get notified if you're using too much energy"
    },
    {
        "code": "def updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(meter, \"power\", meterHandler)\n}\n\ndef meterHandler(evt) {\n    def meterValue = evt.value as double\n    def thresholdValue = threshold as int\n    if (meterValue > thresholdValue) {\n\t    log.debug \"${meter} reported energy consumption above ${threshold}. Turning of switches.\"\n    \tswitches.off()\n    }\n}",
        "docstring": "Turn things off if you're using too much energy"
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    // TODO: subscribe to attributes, devices, locations, etc.\n}",
        "docstring": "Every element demonstration app"
    },
    {
        "code": "def installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledFeeding\"\n\tfeeder?.feed()\n}",
        "docstring": "Setup a schedule for when your pet is fed. Purchase any SmartThings certified pet food feeder and install the Feed My Pet app, and set the time. You and your pet are ready to go. Your life just got smarter."
    },
    {
        "code": "def installed() {\n\tsubscribe(alarm, \"water.wet\", waterWetHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(alarm, \"water.wet\", waterWetHandler)\n}\n\ndef waterWetHandler(evt) {\n\tdef deltaSeconds = 60\n\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = alarm.eventsSince(timeAgo)\n\tlog.debug \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"wet\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t} else {\n\t\tdef msg = \"${alarm.displayName} is wet!\"\n\t\tlog.debug \"$alarm is wet, texting phone number\"\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tsendPush(msg)\n\t\t\tif (phone) {\n\t\t\t\tsendSms(phone, msg)\n\t\t\t}\n\t\t}\n\t}\n}",
        "docstring": "Get a push notification or text message when water is detected where it doesn't belong."
    },
    {
        "code": "def installed() {\n\t//log.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n\n\trunIn(300, \"doDeviceSync\" , [overwrite: false]) //setup ip:port syncing every 5 minutes\n\n\t//wait 5 seconds and get the deviceInfo\n\t//log.info \"calling 'getDeviceInfo()'\"\n\t//runIn(5, getDeviceInfo)\n}\n\n/////////////////////////////////////\ndef updated() {\n\t//log.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\n/////////////////////////////////////\ndef initialize() {\n\t// remove location subscription aftwards\n\tunsubscribe()\n\tstate.subscribe = false\n\n\tif (selectedFoscam)\n\t{\n\t\taddCameras()\n\t}\n}\n\ndef addCameras() {\n\tdef cameras = getCameras()\n\n\tselectedFoscam.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\n\t\tif(!d)\n\t\t{\n\t\t\tdef newFoscam = cameras.find { (it.value.ip + \":\" + it.value.port) == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Foscam\", dni, newFoscam?.value?.hub, [\"label\":newFoscam?.value?.name ?: \"Foscam Camera\", \"data\":[\"mac\": newFoscam?.value?.mac, \"ip\": newFoscam.value.ip, \"port\":newFoscam.value.port], \"preferences\":[\"username\":username, \"password\":password]])\n\n\t\t\tlog.debug \"created ${d.displayName} with id $dni\"\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug \"found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n}\n\ndef getDeviceInfo() {\n\tdef devices = getAllChildDevices()\n\tdevices.each { d ->\n\t\td.getDeviceInfo()\n\t}\n}\n\n/////////////////////////////////////\ndef locationHandler(evt) {\n\t/*\n\tFOSCAM EXAMPLE\n\t4D4F5F4901000000000000000000006200000000000000 (SOF) //46\n\t30303632364534443042344200 (mac) //26\n\t466F7363616D5F44617274684D61756C0000000000 (name) //42\n\t0A01652C (ip) //8\n\tFFFFFE00 (mask) //8\n\t00000000 (gateway ip) //8\n\t00000000 (dns) //8\n\t01005800 (reserve) //8\n\t01040108 (system software version) //8\n\t020B0106 (app software version) //8\n\t0058 (port) //4\n\t01 (dhcp enabled) //2\n\t*/\n\tdef description = evt.description\n\tdef hub = evt?.hubId\n\n\tlog.debug \"GOT LOCATION EVT: $description\"\n\n\tdef parsedEvent = stringToMap(description)\n\n\t//FOSCAM does a UDP response with camera operate protocol:\u201cMO_I\u201d i.e. \"4D4F5F49\"\n\tif (parsedEvent?.type == \"LAN_TYPE_UDPCLIENT\" && parsedEvent?.payload?.startsWith(\"4D4F5F49\"))\n\t{\n\t\tdef unpacked = [:]\n\t\tunpacked.mac = parsedEvent.mac.toString()\n\t\tunpacked.name = hexToString(parsedEvent.payload[72..113]).trim()\n\t\tunpacked.ip = parsedEvent.payload[114..121]\n\t\tunpacked.subnet = parsedEvent.payload[122..129]\n\t\tunpacked.gateway = parsedEvent.payload[130..137]\n\t\tunpacked.dns = parsedEvent.payload[138..145]\n\t\tunpacked.reserve = parsedEvent.payload[146..153]\n\t\tunpacked.sysVersion = parsedEvent.payload[154..161]\n\t\tunpacked.appVersion = parsedEvent.payload[162..169]\n\t\tunpacked.port = parsedEvent.payload[170..173]\n\t\tunpacked.dhcp = parsedEvent.payload[174..175]\n\t\tunpacked.hub = hub\n\n\t\tdef cameras = getCameras()\n\t\tif (!(cameras.\"${parsedEvent.mac.toString()}\"))\n\t\t{\n\t\t\tcameras << [(\"${parsedEvent.mac.toString()}\"):unpacked]\n\t\t}\n\t}\n}\n\n/////////////////////////////////////\nprivate Boolean canInstallLabs()\n{\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware)\n{\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions()\n{\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}\n\nprivate String hexToString(String txtInHex)\n{\n\tbyte [] txtInByte = new byte [txtInHex.length() / 2];\n\tint j = 0;\n\tfor (int i = 0; i < txtInHex.length(); i += 2)\n\t{\n\t\t\ttxtInByte[j++] = Byte.parseByte(txtInHex.substring(i, i + 2), 16);\n\t}\n\treturn new String(txtInByte);\n}",
        "docstring": "Connect and take pictures using your Foscam camera from inside the Smartthings app."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(multisensor, \"acceleration\", accelerationHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(multisensor, \"acceleration\", accelerationHandler)\n}\n\ndef accelerationHandler(evt) {\n\tdef latestThreeAxisState = multisensor.threeAxisState // e.g.: 0,0,-1000\n\tif (latestThreeAxisState) {\n\t\tdef isOpen = Math.abs(latestThreeAxisState.xyzValue.z) > 250 // TODO: Test that this value works in most cases...\n\t\tdef isNotScheduled = state.status != \"scheduled\"\n\n\t\tif (!isOpen) {\n\t\t\tclearSmsHistory()\n\t\t\tclearStatus()\n\t\t}\n\n\t\tif (isOpen && isNotScheduled) {\n\t\t\trunIn(maxOpenTime * 60, takeAction, [overwrite: false])\n\t\t\tstate.status = \"scheduled\"\n\t\t}\n\n\t}\n\telse {\n\t\tlog.warn \"COULD NOT FIND LATEST 3-AXIS STATE FOR: ${multisensor}\"\n\t}\n}\n\ndef takeAction(){\n\tif (state.status == \"scheduled\")\n\t{\n\t\tdef deltaMillis = 1000 * 60 * maxOpenTime\n\t\tdef timeAgo = new Date(now() - deltaMillis)\n\t\tdef openTooLong = multisensor.threeAxisState.dateCreated.toSystemDate() < timeAgo\n\n\t\tdef recentTexts = state.smsHistory.find { it.sentDate.toSystemDate() > timeAgo }\n\n\t\tif (!recentTexts) {\n\t\t\tsendTextMessage()\n\t\t}\n\t\trunIn(maxOpenTime * 60, takeAction, [overwrite: false])\n\t} else {\n\t\tlog.trace \"Status is no longer scheduled. Not sending text.\"\n\t}\n}\n\ndef sendTextMessage() {\n\tlog.debug \"$multisensor was open too long, texting phone\"\n\n\tupdateSmsHistory()\n\tdef openMinutes = maxOpenTime * (state.smsHistory?.size() ?: 1)\n\tdef msg = \"Your ${multisensor.label ?: multisensor.name} has been open for more than ${openMinutes} minutes!\"\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (phone) {\n            sendSms(phone, msg)\n        } else {\n            sendPush msg\n        }\n    }\n}\n\ndef updateSmsHistory() {\n\tif (!state.smsHistory) state.smsHistory = []\n\n\tif(state.smsHistory.size() > 9) {\n\t\tlog.debug \"SmsHistory is too big, reducing size\"\n\t\tstate.smsHistory = state.smsHistory[-9..-1]\n\t}\n\tstate.smsHistory << [sentDate: new Date().toSystemFormat()]\n}\n\ndef clearSmsHistory() {\n\tstate.smsHistory = null\n}\n\ndef clearStatus() {\n\tstate.status = null\n}",
        "docstring": "Monitor your garage door and get a text message if it is open too long"
    },
    {
        "code": "def installed() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribeToCommand(switch1, \"on\", onCommand)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(app, appTouchHandler)\n\tsubscribeToCommand(switch1, \"on\", onCommand)\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt.value, $evt\"\n\tswitch1?.on()\n}\n\ndef onCommand(evt) {\n\tlog.debug \"onCommand: $evt.value, $evt\"\n\tswitch1?.off(delay: 3000)\n}",
        "docstring": "Open your garage door when a switch is turned on."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installing 'Gentle Wake Up' with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updating 'Gentle Wake Up' with settings: ${settings}\"\n\tunschedule()\n\n\tdef controller = getController()\n\tif (controller) {\n\t\tcontroller.label = app.label\n\t}\n\n\tinitialize()\n}\n\nprivate initialize() {\n\tstop(\"settingsChange\")\n\n\tif (startTime) {\n\t\tlog.debug \"scheduling dimming routine to run at $startTime\"\n\t\tschedule(startTime, \"scheduledStart\")\n\t}\n\n\t// TODO: make this an option\n\tsubscribe(app, appHandler)\n\n\tsubscribe(location, locationHandler)\n\n\tif (manualOverride) {\n\t\tsubscribe(dimmers, \"switch.off\", stopDimmersHandler)\n\t}\n\n\tif (!getAllChildDevices()) {\n\t\t// create controller device and set name to the label used here\n\t\tdef dni = \"${new Date().getTime()}\"\n\t\tlog.debug \"app.label: ${app.label}\"\n\t\taddChildDevice(\"smartthings\", \"Gentle Wake Up Controller\", dni, null, [\"label\": app.label])\n\t\tstate.controllerDni = dni\n\t}\n}\n\ndef appHandler(evt) {\n\tlog.debug \"appHandler evt: ${evt.value}\"\n\tif (evt.value == \"touch\") {\n\t\tif (atomicState.running) {\n\t\t\tstop(\"appTouch\")\n\t\t} else {\n\t\t\tstart(\"appTouch\")\n\t\t}\n\t}\n}\n\ndef locationHandler(evt) {\n\tlog.debug \"locationHandler evt: ${evt.value}\"\n\n\tif (!modeStart) {\n\t\treturn\n\t}\n\n\tdef isSpecifiedMode = (evt.value == modeStart)\n\tdef modeStopIsTrue = (modeStop && modeStop != \"false\")\n\n\tif (isSpecifiedMode && canStartAutomatically()) {\n\t\tstart(\"modeChange\")\n\t} else if (!isSpecifiedMode && modeStopIsTrue) {\n\t\tstop(\"modeChange\")\n\t}\n\n}\n\ndef stopDimmersHandler(evt) {\n\tlog.trace \"stopDimmersHandler evt: ${evt.value}\"\n\tdef percentComplete = completionPercentage()\n\t// Often times, the first thing we do is turn lights on or off so make sure we don't stop as soon as we start\n\tif (percentComplete > 2 && percentComplete < 98) {\n\t\tif (manualOverride == \"cancel\") {\n\t\t\tlog.debug \"STOPPING in stopDimmersHandler\"\n\t\t\tstop(\"manualOverride\")\n\t\t} else if (manualOverride == \"jumpTo\") {\n\t\t\tdef end = dynamicEndLevel()\n\t\t\tlog.debug \"Jumping to 99% complete in stopDimmersHandler\"\n\t\t\tjumpTo(99)\n\t\t}\n\n\t} else {\n\t\tlog.debug \"not stopping in stopDimmersHandler\"\n\t}\n}\n\n// ========================================================\n// Scheduling\n// ========================================================\n\ndef scheduledStart() {\n\tif (canStartAutomatically()) {\n\t\tstart(\"schedule\")\n\t}\n}\n\npublic def start(source) {\n\tlog.trace \"START\"\n\n\tsendStartEvent(source)\n\n\tsetLevelsInState()\n\n\tatomicState.running = true\n\tatomicState.runCounter = 0\n\n\tatomicState.start = new Date().getTime()\n\n\tschedule(\"0 * * * * ?\", \"healthCheck\")\n\tincrement()\n}\n\npublic def stop(source) {\n\tlog.trace \"STOP\"\n\n\tsendStopEvent(source)\n\n\tatomicState.running = false\n\tatomicState.start = 0\n\tatomicState.runCounter = 0\n\n\tunschedule(\"healthCheck\")\n}\n\nprivate healthCheck() {\n\tlog.trace \"'Gentle Wake Up' healthCheck\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tincrement()\n}\n\n// ========================================================\n// Controller\n// ========================================================\n\ndef sendStartEvent(source) {\n\tlog.trace \"sendStartEvent(${source})\"\n\tdef eventData = [\n\t\t\tname: \"sessionStatus\",\n\t\t\tvalue: \"running\",\n\t\t\tdescriptionText: \"${app.label} has started dimming\",\n\t\t\tdisplayed: true,\n\t\t\tlinkText: app.label,\n\t\t\tisStateChange: true\n\t]\n\tif (source == \"modeChange\") {\n\t\teventData.descriptionText += \" because of a mode change\"\n\t} else if (source == \"schedule\") {\n\t\teventData.descriptionText += \" as scheduled\"\n\t} else if (source == \"appTouch\") {\n\t\teventData.descriptionText += \" because you pressed play on the app\"\n\t} else if (source == \"controller\") {\n\t\teventData.descriptionText += \" because you pressed play on the controller\"\n\t}\n\n\tsendControllerEvent(eventData)\n}\n\ndef sendStopEvent(source) {\n\tlog.trace \"sendStopEvent(${source})\"\n\tdef eventData = [\n\t\t\tname: \"sessionStatus\",\n\t\t\tvalue: \"stopped\",\n\t\t\tdescriptionText: \"${app.label} has stopped dimming\",\n\t\t\tdisplayed: true,\n\t\t\tlinkText: app.label,\n\t\t\tisStateChange: true\n\t]\n\tif (source == \"modeChange\") {\n\t\teventData.descriptionText += \" because of a mode change\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"schedule\") {\n\t\teventData.descriptionText = \"${app.label} has finished dimming\"\n\t} else if (source == \"appTouch\") {\n\t\teventData.descriptionText += \" because you pressed play on the app\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"controller\") {\n\t\teventData.descriptionText += \" because you pressed stop on the controller\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"settingsChange\") {\n\t\teventData.descriptionText += \" because the settings have changed\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"manualOverride\") {\n\t\teventData.descriptionText += \" because the dimmer was manually turned off\"\n\t\teventData.value += \"cancelled\"\n\t}\n\n\t// send 100% completion event\n\tsendTimeRemainingEvent(100)\n\n\t// send a non-displayed 0% completion to reset tiles\n\tsendTimeRemainingEvent(0, false)\n\n\t// send sessionStatus event last so the event feed is ordered properly\n\tsendControllerEvent(eventData)\n}\n\ndef sendTimeRemainingEvent(percentComplete, displayed = true) {\n\tlog.trace \"sendTimeRemainingEvent(${percentComplete})\"\n\n\tdef percentCompleteEventData = [\n\t\t\tname: \"percentComplete\",\n\t\t\tvalue: percentComplete as int,\n\t\t\tdisplayed: displayed,\n\t\t\tisStateChange: true\n\t]\n\tsendControllerEvent(percentCompleteEventData)\n\n\tdef duration = sanitizeInt(duration, 30)\n\tdef timeRemaining = duration - (duration * (percentComplete / 100))\n\tdef timeRemainingEventData = [\n\t\t\tname: \"timeRemaining\",\n\t\t\tvalue: displayableTime(timeRemaining),\n\t\t\tdisplayed: displayed,\n\t\t\tisStateChange: true\n\t]\n\tsendControllerEvent(timeRemainingEventData)\n}\n\ndef sendControllerEvent(eventData) {\n\tdef controller = getController()\n\tif (controller) {\n\t\tcontroller.controllerEvent(eventData)\n\t}\n}\n\ndef getController() {\n\tdef dni = state.controllerDni\n\tif (!dni) {\n\t\tlog.warn \"no controller dni\"\n\t\treturn null\n\t}\n\tdef controller = getChildDevice(dni)\n\tif (!controller) {\n\t\tlog.warn \"no controller\"\n\t\treturn null\n\t}\n\tlog.debug \"controller: ${controller}\"\n\treturn controller\n}\n\n// ========================================================\n// Setting levels\n// ========================================================\n\n\nprivate increment() {\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tif (atomicState.runCounter == null) {\n\t\tatomicState.runCounter = 1\n\t} else {\n\t\tatomicState.runCounter = atomicState.runCounter + 1\n\t}\n\tdef percentComplete = completionPercentage()\n\n\tif (percentComplete > 99) {\n\t\tpercentComplete = 99\n\t}\n\n\tif (atomicState.runCounter > 100) {\n\t\tlog.error \"Force stopping Gentle Wakeup due to too many increments\"\n\t\t// If increment has already been called 100 times, then stop regardless of state\n\t\tpercentComplete = 100\n\t} else {\n\t\tupdateDimmers(percentComplete)\n\t}\n\tif (percentComplete < 99) {\n\n\t\tdef runAgain = stepDuration()\n\t\tlog.debug \"Rescheduling to run again in ${runAgain} seconds\"\n\n\t\trunIn(runAgain, 'increment', [overwrite: true])\n\n\t} else {\n\n\t\tint completionDelay = completionDelaySeconds()\n\t\tif (completionDelay) {\n\t\t\tlog.debug \"Finished with steps. Scheduling completion for ${completionDelay} second(s) from now\"\n\t\t\trunIn(completionDelay, 'completion', [overwrite: true])\n\t\t\tunschedule(\"healthCheck\")\n\t\t\t// don't let the health check start incrementing again while we wait for the delayed execution of completion\n\t\t} else {\n\t\t\tlog.debug \"Finished with steps. Execution completion\"\n\t\t\tcompletion()\n\t\t}\n\n\t}\n}\n\n\ndef updateDimmers(percentComplete) {\n\tdimmers.each { dimmer ->\n\n\t\tdef nextLevel = dynamicLevel(dimmer, percentComplete)\n\n\t\tif (nextLevel == 0) {\n\n\t\t\tdimmer.off()\n\n\t\t} else {\n\n\t\t\tdef shouldChangeColors = (colorize && colorize != \"false\")\n\n\t\t\tif (shouldChangeColors && hasSetColorCommand(dimmer)) {\n\t\t\t\tdef hue = getHue(dimmer, nextLevel)\n\t\t\t\tlog.debug \"Setting ${deviceLabel(dimmer)} level to ${nextLevel} and hue to ${hue}\"\n\t\t\t\tdimmer.setColor([hue: hue, saturation: 100, level: nextLevel])\n\t\t\t} else if (hasSetLevelCommand(dimmer)) {\n\t\t\t\tlog.debug \"Setting ${deviceLabel(dimmer)} level to ${nextLevel}\"\n\t\t\t\tdimmer.setLevel(nextLevel)\n\t\t\t} else {\n\t\t\t\tlog.warn \"${deviceLabel(dimmer)} does not have setColor or setLevel commands.\"\n\t\t\t}\n\n\t\t}\n\t}\n\n\tsendTimeRemainingEvent(percentComplete)\n}\n\nint dynamicLevel(dimmer, percentComplete) {\n\tdef start = atomicState.startLevels[dimmer.id]\n\tdef end = dynamicEndLevel()\n\n\tif (!percentComplete) {\n\t\treturn start\n\t}\n\n\tdef totalDiff = end - start\n\tdef actualPercentage = percentComplete / 100\n\tdef percentOfTotalDiff = totalDiff * actualPercentage\n\n\t(start + percentOfTotalDiff) as int\n}\n\n// ========================================================\n// Completion\n// ========================================================\n\nprivate completion() {\n\tlog.trace \"Starting completion block\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tstop(\"schedule\")\n\n\thandleCompletionSwitches()\n\n\thandleCompletionMessaging()\n\n\thandleCompletionModesAndPhrases()\n}\n\nprivate handleCompletionSwitches() {\n\tcompletionSwitches.each { completionSwitch ->\n\n\t\tdef isDimmer = hasSetLevelCommand(completionSwitch)\n\n\t\tif (completionSwitchesLevel && isDimmer) {\n\t\t\tcompletionSwitch.setLevel(completionSwitchesLevel)\n\t\t} else {\n\t\t\tdef command = completionSwitchesState ?: \"on\"\n\t\t\tcompletionSwitch.\"${command}\"()\n\t\t}\n\t}\n}\n\nprivate handleCompletionMessaging() {\n\tif (completionMessage) {\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(completionMessage, recipients)\n\t\t} else {\n\t\t\tif (completionPhoneNumber) {\n\t\t\t\tsendSms(completionPhoneNumber, completionMessage)\n\t\t\t}\n\t\t\tif (completionPush) {\n\t\t\t\tsendPush(completionMessage)\n\t\t\t}\n\t\t}\n\t\tif (completionMusicPlayer) {\n\t\t\tspeak(completionMessage)\n\t\t}\n\t}\n}\n\nprivate handleCompletionModesAndPhrases() {\n\n\tif (completionMode) {\n\t\tsetLocationMode(completionMode)\n\t}\n\n\tif (completionPhrase) {\n\t\tlocation.helloHome.execute(completionPhrase)\n\t}\n\n}\n\ndef speak(message) {\n\tdef sound = textToSpeech(message)\n\tdef soundDuration = (sound.duration as Integer) + 2\n\tlog.debug \"Playing $sound.uri\"\n\tcompletionMusicPlayer.playTrack(sound.uri)\n\tlog.debug \"Scheduled resume in $soundDuration sec\"\n\trunIn(soundDuration, resumePlaying, [overwrite: true])\n}\n\ndef resumePlaying() {\n\tlog.trace \"resumePlaying()\"\n\tdef sonos = completionMusicPlayer\n\tif (sonos) {\n\t\tdef currentTrack = sonos.currentState(\"trackData\").jsonValue\n\t\tif (currentTrack.status == \"playing\") {\n\t\t\tsonos.playTrack(currentTrack)\n\t\t} else {\n\t\t\tsonos.setTrack(currentTrack)\n\t\t}\n\t}\n}\n\n// ========================================================\n// Helpers\n// ========================================================\n\ndef setLevelsInState() {\n\tdef startLevels = [:]\n\tdimmers.each { dimmer ->\n\t\tif (usesOldSettings()) {\n\t\t\tstartLevels[dimmer.id] = defaultStart()\n\t\t} else if (hasStartLevel()) {\n\t\t\tstartLevels[dimmer.id] = startLevel\n\t\t} else {\n\t\t\tdef dimmerIsOff = dimmer.currentValue(\"switch\") == \"off\"\n\t\t\tstartLevels[dimmer.id] = dimmerIsOff ? 0 : dimmer.currentValue(\"level\")\n\t\t}\n\t}\n\n\tatomicState.startLevels = startLevels\n}\n\ndef canStartAutomatically() {\n\n\tdef today = new Date().format(\"EEEE\")\n\tlog.debug \"today: ${today}, days: ${days}\"\n\n\tif (!days || days.contains(today)) {// if no days, assume every day\n\t\treturn true\n\t}\n\n\tlog.trace \"should not run\"\n\treturn false\n}\n\ndef completionPercentage() {\n\tlog.trace \"checkingTime\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tdef now = new Date().getTime()\n\tdef timeElapsed = now - atomicState.start\n\tdef totalRunTime = totalRunTimeMillis() ?: 1\n\tdef percentComplete = timeElapsed / totalRunTime * 100\n\tlog.debug \"percentComplete: ${percentComplete}\"\n\n\treturn percentComplete\n}\n\nint totalRunTimeMillis() {\n\tint minutes = sanitizeInt(duration, 30)\n\tconvertToMillis(minutes)\n}\n\nint convertToMillis(minutes) {\n\tdef seconds = minutes * 60\n\tdef millis = seconds * 1000\n\treturn millis\n}\n\ndef timeRemaining(percentComplete) {\n\tdef normalizedPercentComplete = percentComplete / 100\n\tdef duration = sanitizeInt(duration, 30)\n\tdef timeElapsed = duration * normalizedPercentComplete\n\tdef timeRemaining = duration - timeElapsed\n\treturn timeRemaining\n}\n\nint millisToEnd(percentComplete) {\n\tconvertToMillis(timeRemaining(percentComplete))\n}\n\nString displayableTime(timeRemaining) {\n\tdef timeString = \"${timeRemaining}\"\n\tdef parts = timeString.split(/\\./)\n\tif (!parts.size()) {\n\t\treturn \"0:00\"\n\t}\n\tdef minutes = parts[0]\n\tif (parts.size() == 1) {\n\t\treturn \"${minutes}:00\"\n\t}\n\tdef fraction = \"0.${parts[1]}\" as double\n\tdef seconds = \"${60 * fraction as int}\".padLeft(2, \"0\")\n\treturn \"${minutes}:${seconds}\"\n}\n\ndef jumpTo(percentComplete) {\n\tdef millisToEnd = millisToEnd(percentComplete)\n\tdef endTime = new Date().getTime() + millisToEnd\n\tdef duration = sanitizeInt(duration, 30)\n\tdef durationMillis = convertToMillis(duration)\n\tdef shiftedStart = endTime - durationMillis\n\tatomicState.start = shiftedStart\n\tupdateDimmers(percentComplete)\n\tsendTimeRemainingEvent(percentComplete)\n}\n\n\nint dynamicEndLevel() {\n\tif (usesOldSettings()) {\n\t\tif (direction && direction == \"Down\") {\n\t\t\treturn 0\n\t\t}\n\t\treturn 99\n\t}\n\treturn endLevel as int\n}\n\ndef getHue(dimmer, level) {\n\tdef start = atomicState.startLevels[dimmer.id] as int\n\tdef end = dynamicEndLevel()\n\tif (start > end) {\n\t\treturn getDownHue(level)\n\t} else {\n\t\treturn getUpHue(level)\n\t}\n}\n\ndef getUpHue(level) {\n\tgetBlueHue(level)\n}\n\ndef getDownHue(level) {\n\tgetRedHue(level)\n}\n\nprivate getBlueHue(level) {\n\tif (level < 5) return 72\n\tif (level < 10) return 71\n\tif (level < 15) return 70\n\tif (level < 20) return 69\n\tif (level < 25) return 68\n\tif (level < 30) return 67\n\tif (level < 35) return 66\n\tif (level < 40) return 65\n\tif (level < 45) return 64\n\tif (level < 50) return 63\n\tif (level < 55) return 62\n\tif (level < 60) return 61\n\tif (level < 65) return 60\n\tif (level < 70) return 59\n\tif (level < 75) return 58\n\tif (level < 80) return 57\n\tif (level < 85) return 56\n\tif (level < 90) return 55\n\tif (level < 95) return 54\n\tif (level >= 95) return 53\n}\n\nprivate getRedHue(level) {\n\tif (level < 6) return 1\n\tif (level < 12) return 2\n\tif (level < 18) return 3\n\tif (level < 24) return 4\n\tif (level < 30) return 5\n\tif (level < 36) return 6\n\tif (level < 42) return 7\n\tif (level < 48) return 8\n\tif (level < 54) return 9\n\tif (level < 60) return 10\n\tif (level < 66) return 11\n\tif (level < 72) return 12\n\tif (level < 78) return 13\n\tif (level < 84) return 14\n\tif (level < 90) return 15\n\tif (level < 96) return 16\n\tif (level >= 96) return 17\n}\n\nprivate dimmersContainUnsupportedDevices() {\n\tdef found = dimmers.find { hasSetLevelCommand(it) == false }\n\treturn found != null\n}\n\nprivate hasSetLevelCommand(device) {\n\treturn hasCommand(device, \"setLevel\")\n}\n\nprivate hasSetColorCommand(device) {\n\treturn hasCommand(device, \"setColor\")\n}\n\nprivate hasCommand(device, String command) {\n\treturn (device.supportedCommands.find { it.name == command } != null)\n}\n\nprivate dimmersWithSetColorCommand() {\n\tdef colorDimmers = []\n\tdimmers.each { dimmer ->\n\t\tif (hasSetColorCommand(dimmer)) {\n\t\t\tcolorDimmers << dimmer\n\t\t}\n\t}\n\treturn colorDimmers\n}\n\nprivate int sanitizeInt(i, int defaultValue = 0) {\n\ttry {\n\t\tif (!i) {\n\t\t\treturn defaultValue\n\t\t} else {\n\t\t\treturn i as int\n\t\t}\n\t}\n\tcatch (Exception e) {\n\t\tlog.debug e\n\t\treturn defaultValue\n\t}\n}\n\nprivate completionDelaySeconds() {\n\tint completionDelayMinutes = sanitizeInt(completionDelay)\n\tint completionDelaySeconds = (completionDelayMinutes * 60)\n\treturn completionDelaySeconds ?: 0\n}\n\nprivate stepDuration() {\n\tint minutes = sanitizeInt(duration, 30)\n\tint stepDuration = (minutes * 60) / 100\n\treturn stepDuration ?: 1\n}\n\nprivate debug(message) {\n\tlog.debug \"${message}\\nstate: ${state}\"\n}\n\npublic smartThingsDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" }\n\npublic humanReadableStartDate() {\n\tnew Date().parse(smartThingsDateFormat(), startTime).format(\"h:mm a\", timeZone(startTime))\n}\n\ndef fancyString(listOfStrings) {\n\n\tdef fancify = { list ->\n\t\treturn list.collect {\n\t\t\tdef label = it\n\t\t\tif (list.size() > 1 && it == list[-1]) {\n\t\t\t\tlabel = \"and ${label}\"\n\t\t\t}\n\t\t\tlabel\n\t\t}.join(\", \")\n\t}\n\n\treturn fancify(listOfStrings)\n}\n\ndef fancyDeviceString(devices = []) {\n\tfancyString(devices.collect { deviceLabel(it) })\n}\n\ndef deviceLabel(device) {\n\treturn device.label ?: device.name\n}\n\ndef schedulingHrefDescription() {\n\n\tdef descriptionParts = []\n\tif (days) {\n\t\tif (days == weekdays()) {\n\t\t\tdescriptionParts << \"On weekdays,\"\n\t\t} else if (days == weekends()) {\n\t\t\tdescriptionParts << \"On weekends,\"\n\t\t} else {\n\t\t\tdescriptionParts << \"On ${fancyString(days)},\"\n\t\t}\n\t}\n\n\tdescriptionParts << \"${fancyDeviceString(dimmers)} will start dimming\"\n\n\tif (startTime) {\n\t\tdescriptionParts << \"at ${humanReadableStartDate()}\"\n\t}\n\n\tif (modeStart) {\n\t\tif (startTime) {\n\t\t\tdescriptionParts << \"or\"\n\t\t}\n\t\tdescriptionParts << \"when ${location.name} enters '${modeStart}' mode\"\n\t}\n\n\tif (descriptionParts.size() <= 1) {\n\t\t// dimmers will be in the list no matter what. No rules are set if only dimmers are in the list\n\t\treturn null\n\t}\n\n\treturn descriptionParts.join(\" \")\n}\n\ndef completionHrefDescription() {\n\n\tdef descriptionParts = []\n\tdef example = \"Switch1 will be turned on. Switch2, Switch3, and Switch4 will be dimmed to 50%. The message '<message>' will be spoken, sent as a text, and sent as a push notification. The mode will be changed to '<mode>'. The phrase '<phrase>' will be executed\"\n\n\tif (completionSwitches) {\n\t\tdef switchesList = []\n\t\tdef dimmersList = []\n\n\n\t\tcompletionSwitches.each {\n\t\t\tdef isDimmer = completionSwitchesLevel ? hasSetLevelCommand(it) : false\n\n\t\t\tif (isDimmer) {\n\t\t\t\tdimmersList << deviceLabel(it)\n\t\t\t}\n\n\t\t\tif (!isDimmer) {\n\t\t\t\tswitchesList << deviceLabel(it)\n\t\t\t}\n\t\t}\n\n\n\t\tif (switchesList) {\n\t\t\tdescriptionParts << \"${fancyString(switchesList)} will be turned ${completionSwitchesState ?: 'on'}.\"\n\t\t}\n\n\t\tif (dimmersList) {\n\t\t\tdescriptionParts << \"${fancyString(dimmersList)} will be dimmed to ${completionSwitchesLevel}%.\"\n\t\t}\n\n\t}\n\n\tif (completionMessage && (completionPhoneNumber || completionPush || completionMusicPlayer)) {\n\t\tdef messageParts = []\n\n\t\tif (completionMusicPlayer) {\n\t\t\tmessageParts << \"spoken\"\n\t\t}\n\t\tif (completionPhoneNumber) {\n\t\t\tmessageParts << \"sent as a text\"\n\t\t}\n\t\tif (completionPush) {\n\t\t\tmessageParts << \"sent as a push notification\"\n\t\t}\n\n\t\tdescriptionParts << \"The message '${completionMessage}' will be ${fancyString(messageParts)}.\"\n\t}\n\n\tif (completionMode) {\n\t\tdescriptionParts << \"The mode will be changed to '${completionMode}'.\"\n\t}\n\n\tif (completionPhrase) {\n\t\tdescriptionParts << \"The phrase '${completionPhrase}' will be executed.\"\n\t}\n\n\treturn descriptionParts.join(\" \")\n}\n\ndef numbersPageHrefDescription() {\n\tdef title = \"All dimmers will dim for ${duration ?: '30'} minutes from ${startLevelLabel()} to ${endLevelLabel()}\"\n\tif (colorize) {\n\t\tdef colorDimmers = dimmersWithSetColorCommand()\n\t\tif (colorDimmers == dimmers) {\n\t\t\ttitle += \" and will gradually change color.\"\n\t\t} else {\n\t\t\ttitle += \".\\n${fancyDeviceString(colorDimmers)} will gradually change color.\"\n\t\t}\n\t}\n\treturn title\n}\n\ndef hueSatToHex(h, s) {\n\tdef convertedRGB = hslToRgb(h, s, 0.5)\n\treturn rgbToHex(convertedRGB)\n}\n\ndef hslToRgb(h, s, l) {\n\tdef r, g, b;\n\n\tif (s == 0) {\n\t\tr = g = b = l; // achromatic\n\t} else {\n\t\tdef hue2rgb = { p, q, t ->\n\t\t\tif (t < 0) t += 1;\n\t\t\tif (t > 1) t -= 1;\n\t\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\t\tif (t < 1 / 2) return q;\n\t\t\tif (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n\t\t\treturn p;\n\t\t}\n\n\t\tdef q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\tdef p = 2 * l - q;\n\n\t\tr = hue2rgb(p, q, h + 1 / 3);\n\t\tg = hue2rgb(p, q, h);\n\t\tb = hue2rgb(p, q, h - 1 / 3);\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n}\n\ndef rgbToHex(red, green, blue) {\n\tdef toHex = {\n\t\tint n = it as int;\n\t\tn = Math.max(0, Math.min(n, 255));\n\t\tdef hexOptions = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n\n\t\tdef firstDecimal = ((n - n % 16) / 16) as int\n\t\tdef secondDecimal = (n % 16) as int\n\n\t\treturn \"${hexOptions[firstDecimal]}${hexOptions[secondDecimal]}\"\n\t}\n\n\tdef rgbToHex = { r, g, b ->\n\t\treturn toHex(r) + toHex(g) + toHex(b)\n\t}\n\n\treturn rgbToHex(red, green, blue)\n}\n\ndef usesOldSettings() {\n\t!hasEndLevel()\n}\n\ndef hasStartLevel() {\n\treturn (startLevel != null && startLevel != \"\")\n}\n\ndef hasEndLevel() {\n\treturn (endLevel != null && endLevel != \"\")\n}",
        "docstring": "Dim your lights up slowly, allowing you to wake up more naturally."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Current mode = ${location.mode}\"\n\tcreateSubscriptions()\n}\n\ndef updated() {\n\tlog.debug \"Current mode = ${location.mode}\"\n\tunsubscribe()\n\tcreateSubscriptions()\n}\n\ndef createSubscriptions()\n{\n\tsubscribe(motionSensors, \"motion.active\", motionActiveHandler)\n\tsubscribe(motionSensors, \"motion.inactive\", motionInactiveHandler)\n\tsubscribe(switches, \"switch.off\", switchOffHandler)\n\tsubscribe(location, modeChangeHandler)\n\n\tif (state.modeStartTime == null) {\n\t\tstate.modeStartTime = 0\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tstate.modeStartTime = now()\n}\n\ndef switchOffHandler(evt) {\n\tif (correctMode() && correctTime()) {\n\t\tif (allQuiet() && switchesOk()) {\n\t\t\ttakeActions()\n\t\t}\n\t}\n}\n\ndef motionActiveHandler(evt)\n{\n\tlog.debug \"Motion active\"\n}\n\ndef motionInactiveHandler(evt)\n{\n\t// for backward compatibility\n\tif (state.modeStartTime == null) {\n\t\tsubscribe(location, modeChangeHandler)\n\t\tstate.modeStartTime = 0\n\t}\n\n\tif (correctMode() && correctTime()) {\n\t\trunIn(minutes * 60, scheduleCheck, [overwrite: false])\n\t}\n}\n\ndef scheduleCheck()\n{\n\tlog.debug \"scheduleCheck, currentMode = ${location.mode}, newMode = $newMode\"\n\t\n\tif (correctMode() && correctTime()) {\n\t\tif (allQuiet() && switchesOk()) {\n\t\t\ttakeActions()\n\t\t}\n\t}\n}\n\nprivate takeActions() {\n\tdef message = \"Goodnight! SmartThings changed the mode to '$newMode'\"\n\tsend(message)\n\tsetLocationMode(newMode)\n\tlog.debug message\n}\n\nprivate correctMode() {\n\tif (location.mode != newMode) {\n\t\ttrue\n\t} else {\n\t\tlog.debug \"Location is already in the desired mode:  doing nothing\"\n\t\tfalse\n\t}\n}\n\nprivate correctTime() {\n\tdef t0 = now()\n\tdef modeStartTime = new Date(state.modeStartTime)\n\tdef startTime = timeTodayAfter(modeStartTime, timeOfDay, location.timeZone)\n\tif (t0 >= startTime.time) {\n\t\ttrue\n\t} else {\n\t\tlog.debug \"The current time of day (${new Date(t0)}), is not in the correct time window ($startTime):  doing nothing\"\n\t\tfalse\n\t}\n}\n\nprivate switchesOk() {\n\tdef result = true\n\tfor (it in (switches ?: [])) {\n\t\tif (it.currentSwitch == \"on\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"Switches are all off: $result\"\n\tresult\n}\n\nprivate allQuiet() {\n\tdef threshold = 1000 * 60 * minutes - 1000\n\tdef states = motionSensors.collect { it.currentState(\"motion\") ?: [:] }.sort { a, b -> b.dateCreated <=> a.dateCreated }\n\tif (states) {\n\t\tif (states.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"Found active state\"\n\t\t\tfalse\n\t\t} else {\n\t\t\tdef sensor = states.first()\n\t\t    def elapsed = now() - sensor.rawDateCreated.time\n\t\t\tif (elapsed >= threshold) {\n\t\t\t\tlog.debug \"No active states, and enough time has passed\"\n\t\t\t\ttrue\n\t\t\t} else {\n\t\t\t\tlog.debug \"No active states, but not enough time has passed\"\n\t\t\t\tfalse\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"No states to check for activity\"\n\t\ttrue\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}",
        "docstring": "Changes mode when motion ceases after a specific time of night."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t// log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\t// log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tdef threshold = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? (falseAlarmThreshold * 60 * 1000) as Long : 10 * 60 * 1000L\n\n\tif (location.mode != newMode) {\n\n\t\tdef t0 = new Date(now() - threshold)\n\t\tif (evt.value == \"present\") {\n\n\t\t\tdef person = getPerson(evt)\n\t\t\tdef recentNotPresent = person.statesSince(\"presence\", t0).find{it.value == \"not present\"}\n\t\t\tif (recentNotPresent) {\n\t\t\t\tlog.debug \"skipping notification of arrival of Person because last departure was only ${now() - recentNotPresent.date.time} msec ago\"\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdef message = \"${person.displayName} arrived at home, changing mode to '${newMode}'\"\n\t\t\t\tsend(message)\n\t\t\t\tsetLocationMode(newMode)\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"mode is the same, not evaluating\"\n\t}\n}\n\nprivate getPerson(evt)\n{\n\tpeople.find{evt.deviceId == it.id}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone) {\n            log.debug(\"sending text message\")\n            sendSms(phone, msg)\n        }\n    }\n}",
        "docstring": "Monitors a set of presence detectors and triggers a mode change when someone arrives at home."
    },
    {
        "code": "def installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledCheck\"\n\n\tdef message = message1 ?: \"SmartThings - Habit Helper Reminder!\"\n\n    if (location.contactBookEnabled) {\n        log.debug \"Texting reminder to contacts:${recipients?.size()}\"\n        sendNotificationToContacts(message, recipients)\n    }\n    else {\n        log.debug \"Texting reminder\"\n        sendSms(phone1, message)\n    }\n}",
        "docstring": "Add something you want to be reminded about each day and get a text message to help you form positive habits."
    },
    {
        "code": "def installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledCheck\"\n\n\tdef midnight = (new Date()).clearTime()\n\tdef now = new Date()\n\tdef feederEvents = feeder1.eventsBetween(midnight, now)\n\tlog.trace \"Found ${feederEvents?.size() ?: 0} feeder events since $midnight\"\n\tdef feederOpened = feederEvents.count { it.value && it.value == \"open\" } > 0\n\n\tif (feederOpened) {\n\t\tlog.debug \"Feeder was opened since $midnight, no SMS required\"\n\t} else {\n        if (location.contactBookEnabled) {\n            log.debug \"Feeder was not opened since $midnight, texting contacts:${recipients?.size()}\"\n            sendNotificationToContacts(\"No one has fed the dog\", recipients)\n        }\n        else {\n            log.debug \"Feeder was not opened since $midnight, texting one phone number\"\n            sendSms(phone1, \"No one has fed the dog\")\n        }\n\t}\n}",
        "docstring": "Setup a schedule to be reminded to feed your pet. Purchase any SmartThings certified pet food feeder and install the Feed My Pet app, and set the time. You and your pet are ready to go. Your life just got smarter."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(hub, \"hubInfo\", registrationHandler, [filterEvents: false])\n}\n\ndef registrationHandler(evt) {\n\tdef hubInfo = evt.description.split(',').inject([:]) { map, token ->\n\t\ttoken.split(':').with { map[it[0].trim()] = it[1] }\n\t\tmap\n\t}\n\tstate.localip = hubInfo.localip\n\tstate.lastRegister = new Date()\n\tsendNotificationEvent(\"${hub.name} registered in prod with IP: ${hubInfo.localip}\")\n}",
        "docstring": "Listen for local IP changes when your hub registers."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt=null) {\n\tlog.trace \"Executing Mood Lighting\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\tlog.trace \"scheduledTimeHandler()\"\n\teventHandler()\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\n\tdef hueColor = 0\n\tdef saturation = 100\n\n\tswitch(color) {\n\t\tcase \"White\":\n\t\t\thueColor = 52\n\t\t\tsaturation = 19\n\t\t\tbreak;\n\t\tcase \"Daylight\":\n\t\t\thueColor = 53\n\t\t\tsaturation = 91\n\t\t\tbreak;\n\t\tcase \"Soft White\":\n\t\t\thueColor = 23\n\t\t\tsaturation = 56\n\t\t\tbreak;\n\t\tcase \"Warm White\":\n\t\t\thueColor = 20\n\t\t\tsaturation = 80 //83\n\t\t\tbreak;\n\t\tcase \"Blue\":\n\t\t\thueColor = 70\n\t\t\tbreak;\n\t\tcase \"Green\":\n\t\t\thueColor = 39\n\t\t\tbreak;\n\t\tcase \"Yellow\":\n\t\t\thueColor = 25\n\t\t\tbreak;\n\t\tcase \"Orange\":\n\t\t\thueColor = 10\n\t\t\tbreak;\n\t\tcase \"Purple\":\n\t\t\thueColor = 75\n\t\t\tbreak;\n\t\tcase \"Pink\":\n\t\t\thueColor = 83\n\t\t\tbreak;\n\t\tcase \"Red\":\n\t\t\thueColor = 100\n\t\t\tbreak;\n\t}\n\n\tstate.previous = [:]\n\n\thues.each {\n\t\tstate.previous[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\")\n\t\t]\n\t}\n\n\tlog.debug \"current values = $state.previous\"\n\n\tdef newValue = [hue: hueColor, saturation: saturation, level: lightLevel as Integer ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result - $lastTime\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Sets the colors and brightness level of your Philips Hue lights to match your mood."
    },
    {
        "code": "def installed() {\n\t//log.debug settings\n}\n\ndef updated() {\n\tdef currentDeviceIds = settings.collect { k, devices -> devices }.flatten().collect { it.id }.unique()\n\tdef subscriptionDevicesToRemove = app.subscriptions*.device.findAll { device ->\n\t\t!currentDeviceIds.contains(device.id)\n\t}\n\tsubscriptionDevicesToRemove.each { device ->\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\t//log.debug settings\n}\n\ndef list() {\n\t//log.debug \"[PROD] list, params: ${params}\"\n\tdef type = params.deviceType\n\tsettings[type]?.collect{deviceItem(it)} ?: []\n}\n\ndef listStates() {\n\tlog.debug \"[PROD] states, params: ${params}\"\n\tdef type = params.deviceType\n\tdef attributeName = attributeFor(type)\n\tsettings[type]?.collect{deviceState(it, it.currentState(attributeName))} ?: []\n}\n\ndef listSubscriptions() {\n\tstate\n}\n\ndef update() {\n\tdef type = params.deviceType\n\tdef data = request.JSON\n\tdef devices = settings[type]\n\tdef device = settings[type]?.find { it.id == params.id }\n\tdef command = data.command\n\n\t//log.debug \"[PROD] update, params: ${params}, request: ${data}, devices: ${devices*.id}\"\n\t\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t} \n\t\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"alarms\":\n\t\t\treturn \"Alarm\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n\ndef show() {\n\tdef type = params.deviceType\n\tdef devices = settings[type]\n\tdef device = devices.find { it.id == params.id }\n\n\t//log.debug \"[PROD] show, params: ${params}, devices: ${devices*.id}\"\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse {\n\t\tdef attributeName = attributeFor(type)\n\t\tdef s = device.currentState(attributeName)\n\t\tdeviceState(device, s)\n\t}\n}\n\ndef addSubscription() {\n\tlog.debug \"[PROD] addSubscription1\"\n\tdef type = params.deviceType\n\tdef data = request.JSON\n\tdef attribute = attributeFor(type)\n\tdef devices = settings[type]\n\tdef deviceId = data.deviceId\n\tdef callbackUrl = data.callbackUrl\n\tdef device = devices.find { it.id == deviceId }\n\n\t//log.debug \"[PROD] addSubscription, params: ${params}, request: ${data}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Adding switch subscription \" + callbackUrl\n\t\tstate[deviceId] = [callbackUrl: callbackUrl]\n\t\tsubscribe(device, attribute, deviceHandler)\n\t}\n\t//log.info state\n\n}\n\ndef removeSubscription() {\n\tdef type = params.deviceType\n\tdef devices = settings[type]\n\tdef deviceId = params.id\n\tdef device = devices.find { it.id == deviceId }\n\n\t//log.debug \"[PROD] removeSubscription, params: ${params}, request: ${data}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\t//log.info state\n}\n\ndef deviceHandler(evt) {\n\tdef deviceInfo = state[evt.deviceId]\n\tif (deviceInfo) {\n\t\ttry {\n\t\t\thttpPostJson(uri: deviceInfo.callbackUrl, path: '',  body: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]) {\n\t\t\t\tlog.debug \"[PROD IFTTT] Event data successfully posted\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.ResponseParseException e) {\n\t\t\tlog.error(\"Error parsing ifttt payload ${e}\")\n\t\t}\n\t} else {\n\t\tlog.debug \"[PROD] No subscribed device found\"\n\t}\n}\n\nprivate deviceItem(it) {\n\tit ? [id: it.id, label: it.displayName] : null\n}\n\nprivate deviceState(device, s) {\n\tdevice && s ? [id: device.id, label: device.displayName, name: s.name, value: s.value, unixTime: s.date.time] : null\n}\n\nprivate attributeFor(type) {\n\tswitch (type) {\n\t\tcase \"switches\":\n\t\t\tlog.debug \"[PROD] switch type\"\n\t\t\treturn \"switch\"\n\t\tcase \"locks\":\n\t\t\tlog.debug \"[PROD] lock type\"\n\t\t\treturn \"lock\"\n\t\tcase \"alarms\":\n\t\t\tlog.debug \"[PROD] alarm type\"\n\t\t\treturn \"alarm\"\n\t\tcase \"lightSensors\":\n\t\t\tlog.debug \"[PROD] illuminance type\"\n\t\t\treturn \"illuminance\"\n\t\tdefault:\n\t\t\tlog.debug \"[PROD] other sensor type\"\n\t\t\treturn type - \"Sensors\"\n\t}\n}",
        "docstring": "Put the internet to work for you."
    },
    {
        "code": "def installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\t// Don't send a continuous stream of text messages\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t} else {\n        if (location.contactBookEnabled) {\n            log.debug \"accelerationSensor has moved, texting contacts: ${recipients?.size()}\"\n            sendNotificationToContacts(\"${accelerationSensor.label ?: accelerationSensor.name} moved\", recipients)\n        }\n        else {\n            log.debug \"accelerationSensor has moved, sending text message\"\n            sendSms(phone1, \"${accelerationSensor.label ?: accelerationSensor.name} moved\")\n        }\n\t}\n}",
        "docstring": "Send a text when movement is detected"
    },
    {
        "code": "def installed() {\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(evt) {\n\tlog.trace \"temperature: $evt.value, $evt\"\n\n\tdef tooCold = temperature1\n\tdef mySwitch = settings.switch1\n\n\t// TODO: Replace event checks with internal state (the most reliable way to know if an SMS has been sent recently or not).\n\tif (evt.doubleValue <= tooCold) {\n\t\tlog.debug \"Checking how long the temperature sensor has been reporting <= $tooCold\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 // TODO: Ask for \"retry interval\" in prefs?\n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll { it.name == \"temperature\" }\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms = recentEvents.count { it.doubleValue <= tooCold } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaMinutes minutes\"\n\t\t\t// TODO: Send \"Temperature back to normal\" SMS, turn switch off\n\t\t} else {\n\t\t\tlog.debug \"Temperature dropped below $tooCold:  sending SMS and activating $mySwitch\"\n\t\t\tdef tempScale = location.temperatureScale ?: \"F\"\n\t\t\tsend(\"${temperatureSensor1.displayName} is too cold, reporting a temperature of ${evt.value}${evt.unit?:tempScale}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone1) {\n            log.debug(\"sending text message\")\n            sendSms(phone1, msg)\n        }\n    }\n\n    log.debug msg\n}",
        "docstring": "Monitor the temperature and when it drops below your setting get a text and/or turn on a heater or additional appliance."
    },
    {
        "code": "def installed() {\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(evt) {\n\tlog.trace \"temperature: $evt.value, $evt\"\n\n\tdef tooHot = temperature1\n\tdef mySwitch = settings.switch1\n\n\t// TODO: Replace event checks with internal state (the most reliable way to know if an SMS has been sent recently or not).\n\tif (evt.doubleValue >= tooHot) {\n\t\tlog.debug \"Checking how long the temperature sensor has been reporting <= $tooHot\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 // TODO: Ask for \"retry interval\" in prefs?\n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll { it.name == \"temperature\" }\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms = recentEvents.count { it.doubleValue >= tooHot } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaMinutes minutes\"\n\t\t\t// TODO: Send \"Temperature back to normal\" SMS, turn switch off\n\t\t} else {\n\t\t\tlog.debug \"Temperature rose above $tooHot:  sending SMS and activating $mySwitch\"\n\t\t\tdef tempScale = location.temperatureScale ?: \"F\"\n\t\t\tsend(\"${temperatureSensor1.displayName} is too hot, reporting a temperature of ${evt.value}${evt.unit?:tempScale}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone1) {\n            log.debug(\"sending text message\")\n            sendSms(phone1, msg)\n        }\n    }\n\n    log.debug msg\n}",
        "docstring": "Monitor the temperature and when it rises above your setting get a notification and/or turn on an A/C unit or fan."
    },
    {
        "code": "def installed()\n{\n\tlog.debug \"enter installed, state: $state\"\n\tsubscribeToEvents()\n}\n\ndef updated()\n{\n\tlog.debug \"enter updated, state: $state\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents()\n{\n\tsubscribe(location, changedLocationMode)\n\tif (sensor) {\n\t\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\t\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\t\tsubscribe(thermostat, \"thermostatMode\", temperatureHandler)\n\t}\n\tevaluate()\n}\n\ndef changedLocationMode(evt)\n{\n\tlog.debug \"changedLocationMode mode: $evt.value, heat: $heat, cool: $cool\"\n\tevaluate()\n}\n\ndef temperatureHandler(evt)\n{\n\tevaluate()\n}\n\nprivate evaluate()\n{\n\tif (sensor) {\n\t\tdef threshold = 1.0\n\t\tdef tm = thermostat.currentThermostatMode\n\t\tdef ct = thermostat.currentTemperature\n\t\tdef currentTemp = sensor.currentTemperature\n\t\tlog.trace(\"evaluate:, mode: $tm -- temp: $ct, heat: $thermostat.currentHeatingSetpoint, cool: $thermostat.currentCoolingSetpoint -- \"  +\n\t\t\t\"sensor: $currentTemp, heat: $heatingSetpoint, cool: $coolingSetpoint\")\n\t\tif (tm in [\"cool\",\"auto\"]) {\n\t\t\t// air conditioner\n\t\t\tif (currentTemp - coolingSetpoint >= threshold) {\n\t\t\t\tthermostat.setCoolingSetpoint(ct - 2)\n\t\t\t\tlog.debug \"thermostat.setCoolingSetpoint(${ct - 2}), ON\"\n\t\t\t}\n\t\t\telse if (coolingSetpoint - currentTemp >= threshold && ct - thermostat.currentCoolingSetpoint >= threshold) {\n\t\t\t\tthermostat.setCoolingSetpoint(ct + 2)\n\t\t\t\tlog.debug \"thermostat.setCoolingSetpoint(${ct + 2}), OFF\"\n\t\t\t}\n\t\t}\n\t\tif (tm in [\"heat\",\"emergency heat\",\"auto\"]) {\n\t\t\t// heater\n\t\t\tif (heatingSetpoint - currentTemp >= threshold) {\n\t\t\t\tthermostat.setHeatingSetpoint(ct + 2)\n\t\t\t\tlog.debug \"thermostat.setHeatingSetpoint(${ct + 2}), ON\"\n\t\t\t}\n\t\t\telse if (currentTemp - heatingSetpoint >= threshold && thermostat.currentHeatingSetpoint - ct >= threshold) {\n\t\t\t\tthermostat.setHeatingSetpoint(ct - 2)\n\t\t\t\tlog.debug \"thermostat.setHeatingSetpoint(${ct - 2}), OFF\"\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\t\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\t\tif (thermostat.hasCommand(\"poll\")) {\n\t\t\tthermostat.poll()\n\t\t}\n\t}\n}\n\n// for backward compatibility with existing subscriptions\ndef coolingSetpointHandler(evt) {\n\tlog.debug \"coolingSetpointHandler()\"\n}\ndef heatingSetpointHandler (evt) {\n\tlog.debug \"heatingSetpointHandler ()\"\n}",
        "docstring": "Works the same as Keep Me Cozy, but enables you to pick an alternative temperature sensor in a separate space from the thermostat. Focuses on making you comfortable where you are spending your time rather than where the thermostat is located."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(thermostat, \"heatingSetpoint\", heatingSetpointHandler)\n\tsubscribe(thermostat, \"coolingSetpoint\", coolingSetpointHandler)\n\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(thermostat, \"heatingSetpoint\", heatingSetpointHandler)\n\tsubscribe(thermostat, \"coolingSetpoint\", coolingSetpointHandler)\n\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef heatingSetpointHandler(evt)\n{\n\tlog.debug \"heatingSetpoint: $evt, $settings\"\n}\n\ndef coolingSetpointHandler(evt)\n{\n\tlog.debug \"coolingSetpoint: $evt, $settings\"\n}\n\ndef temperatureHandler(evt)\n{\n\tlog.debug \"currentTemperature: $evt, $settings\"\n}\n\ndef changedLocationMode(evt)\n{\n\tlog.debug \"changedLocationMode: $evt, $settings\"\n\n\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\tthermostat.poll()\n}\n\ndef appTouch(evt)\n{\n\tlog.debug \"appTouch: $evt, $settings\"\n\n\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\tthermostat.poll()\n}\n\n// catchall\ndef event(evt)\n{\n\tlog.debug \"value: $evt.value, event: $evt, settings: $settings, handlerName: ${evt.handlerName}\"\n}",
        "docstring": "Changes your thermostat settings automatically in response to a mode change.  Often used with Bon Voyage, Rise and Shine, and other Mode Magic SmartApps to automatically keep you comfortable while you're present and save you energy and money while you are away."
    },
    {
        "code": "def installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(sensor1, \"acceleration.active\", accelerationActiveHandler)\n\tsubscribe(sensor1, \"acceleration.inactive\", accelerationInactiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.trace \"vibration\"\n\tif (!state.isRunning) {\n\t\tlog.info \"Arming detector\"\n\t\tstate.isRunning = true\n\t\tstate.startedAt = now()\n\t}\n\tstate.stoppedAt = null\n}\n\ndef accelerationInactiveHandler(evt) {\n\tlog.trace \"no vibration, isRunning: $state.isRunning\"\n\tif (state.isRunning) {\n\t\tlog.debug \"startedAt: ${state.startedAt}, stoppedAt: ${state.stoppedAt}\"\n\t\tif (!state.stoppedAt) {\n\t\t\tstate.stoppedAt = now()\n            def delay = Math.floor(fillTime * 60).toInteger()\n\t\t\trunIn(delay, checkRunning, [overwrite: false])\n\t\t}\n\t}\n}\n\ndef checkRunning() {\n\tlog.trace \"checkRunning()\"\n\tif (state.isRunning) {\n\t\tdef fillTimeMsec = fillTime ? fillTime * 60000 : 300000\n\t\tdef sensorStates = sensor1.statesSince(\"acceleration\", new Date((now() - fillTimeMsec) as Long))\n\n\t\tif (!sensorStates.find{it.value == \"active\"}) {\n\n\t\t\tdef cycleTimeMsec = cycleTime ? cycleTime * 60000 : 600000\n\t\t\tdef duration = now() - state.startedAt\n\t\t\tif (duration - fillTimeMsec > cycleTimeMsec) {\n\t\t\t\tlog.debug \"Sending notification\"\n\n\t\t\t\tdef msg = \"${sensor1.displayName} is finished\"\n\t\t\t\tlog.info msg\n\n                if (location.contactBookEnabled) {\n                    sendNotificationToContacts(msg, recipients)\n                }\n                else {\n\n                    if (phone) {\n                        sendSms phone, msg\n                    } else {\n                        sendPush msg\n                    }\n\n                }\n\n\t\t\t\tif (switches) {\n\t\t\t\t\tif (lightMode?.equals(\"Turn On Lights\")) {\n\t\t\t\t\t\tswitches.on()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflashLights()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.debug \"Not sending notification because machine wasn't running long enough $duration versus $cycleTimeMsec msec\"\n\t\t\t}\n\t\t\tstate.isRunning = false\n\t\t\tlog.info \"Disarming detector\"\n\t\t} else {\n\t\t\tlog.debug \"skipping notification because vibration detected again\"\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"machine no longer running\"\n\t}\n}\n\nprivate flashLights() {\n\tdef doFlash = true\n\tdef onFor = onFor ?: 1000\n\tdef offFor = offFor ?: 1000\n\tdef numFlashes = numFlashes ?: 3\n\n\tlog.debug \"LAST ACTIVATED IS: ${state.lastActivated}\"\n\tif (state.lastActivated) {\n\t\tdef elapsed = now() - state.lastActivated\n\t\tdef sequenceTime = (numFlashes + 1) * (onFor + offFor)\n\t\tdoFlash = elapsed > sequenceTime\n\t\tlog.debug \"DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: ${state.lastActivated}\"\n\t}\n\n\tif (doFlash) {\n\t\tlog.debug \"FLASHING $numFlashes times\"\n\t\tstate.lastActivated = now()\n\t\tlog.debug \"LAST ACTIVATED SET TO: ${state.lastActivated}\"\n\t\tdef initialActionOn = switches.collect{it.currentSwitch != \"on\"}\n\t\tdef delay = 1L\n\t\tnumFlashes.times {\n\t\t\tlog.trace \"Switch on after  $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.on(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.off(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += onFor\n\t\t\tlog.trace \"Switch off after $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.off(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.on(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += offFor\n\t\t}\n\t}\n}",
        "docstring": "Sends a message and (optionally) turns on or blinks a light to indicate that laundry is done."
    },
    {
        "code": "def installed() {\n  log.trace \"installed()\"\n  subscribe()\n}\n\ndef updated() {\n  log.trace \"updated()\"\n  unsubscribe()\n  subscribe()\n}\n\ndef subscribe() {\n  subscribe(contact, \"contact.open\", doorOpen)\n  subscribe(contact, \"contact.closed\", doorClosed)\n}\n\ndef doorOpen(evt) {\n  log.trace \"doorOpen($evt.name: $evt.value)\"\n  def delay = (openThreshold != null && openThreshold != \"\") ? openThreshold * 60 : 600\n  runIn(delay, doorOpenTooLong, [overwrite: true])\n}\n\ndef doorClosed(evt) {\n  log.trace \"doorClosed($evt.name: $evt.value)\"\n  unschedule(doorOpenTooLong)\n}\n\ndef doorOpenTooLong() {\n  def contactState = contact.currentState(\"contact\")\n  def freq = (frequency != null && frequency != \"\") ? frequency * 60 : 600\n\n  if (contactState.value == \"open\") {\n    def elapsed = now() - contactState.rawDateCreated.time\n    def threshold = ((openThreshold != null && openThreshold != \"\") ? openThreshold * 60000 : 60000) - 1000\n    if (elapsed >= threshold) {\n      log.debug \"Contact has stayed open long enough since last check ($elapsed ms):  calling sendMessage()\"\n      sendMessage()\n      runIn(freq, doorOpenTooLong, [overwrite: false])\n    } else {\n      log.debug \"Contact has not stayed open long enough since last check ($elapsed ms):  doing nothing\"\n    }\n  } else {\n    log.warn \"doorOpenTooLong() called but contact is closed:  doing nothing\"\n  }\n}\n\nvoid sendMessage() {\n  def minutes = (openThreshold != null && openThreshold != \"\") ? openThreshold : 10\n  def msg = \"${contact.displayName} has been left open for ${minutes} minutes.\"\n  log.info msg\n  if (location.contactBookEnabled) {\n    sendNotificationToContacts(msg, recipients)\n  } else {\n    if (phone) {\n      sendSms phone, msg\n    } else {\n      sendPush msg\n    }\n  }\n}",
        "docstring": "Notifies you when you have left a door or window open longer that a specified amount of time."
    },
    {
        "code": "def installed() {\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"$evt.value\"\n\tif (evt.value == \"open\") {\n\t\tswitch1.on()\n\t} else if (evt.value == \"closed\") {\n\t\tswitch1.off()\n\t}\n}",
        "docstring": "Turn your lights on when a SmartSense Multi is opened and turn them off when it is closed."
    },
    {
        "code": "def installed() {\n\n\tif (!state?.circle)\n        state.circle = settings.circle\n\n\tlog.debug \"In installed() method.\"\n    // log.debug \"Members: ${state.members}\"\n    // log.debug \"Users: ${settings.users}\"\n    \n    settings.users.each {memberId->\n    \n    \t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \tdef member = state.members.find{it.id==memberId}\n        \n        // log.debug \"After Find Attempt.\"\n\n       \t// log.debug \"Member Id = ${member.id}, Name = ${member.firstName} ${member.lastName}, Email Address = ${member.loginEmail}\"\n        \n        // log.debug \"External Id=${app.id}:${member.id}\"\n       \n       \t// create the device\n        if (member) {\n        \n       \t\tdef childDevice = addChildDevice(\"smartthings\", \"Life360 User\", \"${app.id}.${member.id}\",null,[name:member.firstName, completedSetup: true])\n        \n        \t// save the memberId on the device itself so we can find easily later\n        \t// childDevice.setMemberId(member.id)\n        \n        \tif (childDevice)\n        \t{\n        \t\t// log.debug \"Child Device Successfully Created\"\n \t\t\t\tgenerateInitialEvent (member, childDevice)\n\t\t\t\n            \t// build the icon name form the L360 Avatar URL\n                // URL Format: https://www.life360.com/img/user_images/b4698717-1f2e-4b7a-b0d4-98ccfb4e9730/Maddie_Hagins_51d2eea2019c7.jpeg\n                // SmartThings Icon format is: L360.b4698717-1f2e-4b7a-b0d4-98ccfb4e9730.Maddie_Hagins_51d2eea2019c7\n                try {\n                \n                \t// build the icon name from the avatar URL\n                \tlog.debug \"Avatar URL = ${member.avatar}\"\n                \tdef urlPathElements = member.avatar.tokenize(\"/\")\n                    def fileElements = urlPathElements[5].tokenize(\".\")\n                    // def icon = \"st.Lighting.light1\"\n               \t\tdef icon=\"l360.${urlPathElements[4]}.${fileElements[0]}\"\n                    log.debug \"Icon = ${icon}\"\n\n            \t\t// set the icon on the device\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"present\",icon)\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"not present\",icon)\n\t\t\t\t\tchildDevice.save()\n                }\n                catch (e) { // do nothing\n                \tlog.debug \"Error = ${e}\"\n                } \n       \t\t}\n    \t}\n    }\n    \n    createCircleSubscription()\n    \n}\n\ndef createCircleSubscription() {\n\n    // delete any existing webhook subscriptions for this circle\n    //\n    // curl -X DELETE https://webhook.qa.life360.com/v3/circles/:circleId/webhook.json\n    \n    log.debug \"Remove any existing Life360 Webhooks for this Circle.\"\n    \n    def deleteUrl = \"https://api.life360.com/v3/circles/${state.circle}/webhook.json\"\n    \n    try { // ignore any errors - there many not be any existing webhooks\n    \n    \thttpDelete (uri: deleteUrl, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \t\tresult = response}\n\t\t}\n    \n    catch (e) {\n    \n    \tlog.debug (e)\n    }\n    \n    // subscribe to the life360 webhook to get push notifications on place events within this circle\n    \n    // POST /circles/:circle_id/places/webooks\n\t// Params: hook_url\n    \n    log.debug \"Create a new Life360 Webhooks for this Circle.\"\n    \n    createAccessToken() // create our own OAUTH access token to use in webhook url\n    \n    def hookUrl = \"${serverUrl}/api/smartapps/installations/${app.id}/placecallback?access_token=${state.accessToken}\".encodeAsURL()\n    \n    def url = \"https://api.life360.com/v3/circles/${state.circle}/webhook.json\"\n        \n    def postBody =  \"url=${hookUrl}\"\n\n    def result = null\n    \n    try {\n       \n \t    httpPost(uri: url, body: postBody, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \t    result = response}\n    \n    } catch (e) {\n        log.debug (e)\n    }\n    \n    // response from this call looks like this:\n    // {\"circleId\":\"41094b6a-32fc-4ef5-a9cd-913f82268836\",\"userId\":\"0d1db550-9163-471b-8829-80b375e0fa51\",\"clientId\":\"11\",\n    //    \"hookUrl\":\"https://testurl.com\"}\n    \n    log.debug \"Response = ${response}\"\n    \n    if (result.data?.hookUrl) {\n\t    log.debug \"Webhook creation successful. Response = ${result.data}\"\n    \n\t}\n}\n\n\ndef updated() {\n\n\tif (!state?.circle)\n        state.circle = settings.circle\n\n\tlog.debug \"In updated() method.\"\n    // log.debug \"Members: ${state.members}\"\n    // log.debug \"Users: ${settings.users}\"\n    \n    // loop through selected users and try to find child device for each\n    \n    settings.users.each {memberId->\n    \n    \tdef externalId = \"${app.id}.${memberId}\"\n\n\t\t// find the appropriate child device based on my app id and the device network id\n\n\t\tdef deviceWrapper = getChildDevice(\"${externalId}\")\n        \n        if (!deviceWrapper) { // device isn't there - so we need to create\n    \n    \t\t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \t\tdef member = state.members.find{it.id==memberId}\n        \n        \t// log.debug \"After Find Attempt.\"\n\n        \t// log.debug \"External Id=${app.id}:${member.id}\"\n       \n       \t\t// create the device\n       \t\tdef childDevice = addChildDevice(\"smartthings\", \"Life360 User\", \"${app.id}.${member.id}\",null,[name:member.firstName, completedSetup: true])\n            // childDevice.setMemberId(member.id)\n        \n        \tif (childDevice)\n        \t{\n        \t\t// log.debug \"Child Device Successfully Created\"\n \t\t\t\tgenerateInitialEvent (member, childDevice)\n                \n                // build the icon name form the L360 Avatar URL\n                // URL Format: https://www.life360.com/img/user_images/b4698717-1f2e-4b7a-b0d4-98ccfb4e9730/Maddie_Hagins_51d2eea2019c7.jpeg\n                // SmartThings Icon format is: L360.b4698717-1f2e-4b7a-b0d4-98ccfb4e9730.Maddie_Hagins_51d2eea2019c7\n                try {\n                \n                \t// build the icon name from the avatar URL\n                \tlog.debug \"Avatar URL = ${member.avatar}\"\n                \tdef urlPathElements = member.avatar.tokenize(\"/\")\n               \t\tdef icon=\"l360.${urlPathElements[4]}.${urlPathElements[5]}\"\n\n            \t\t// set the icon on the device\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"present\",icon)\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"not present\",icon)\n\t\t\t\t\tchildDevice.save()\n                }\n                catch (e) { // do nothing\n                \tlog.debug \"Error = ${e}\"\n                } \n       \t\t}\n            \n    \t}\n        else {\n        \n          \t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \t\tdef member = state.members.find{it.id==memberId}\n    \n        \tgenerateInitialEvent (member, deviceWrapper)\n            \n        }\n    }\n\n\t// Now remove any existing devices that represent users that are no longer selected\n    \n    def childDevices = getAllChildDevices()\n    \n    log.debug \"Child Devices = ${childDevices}\"\n    \n    childDevices.each {childDevice->\n    \n    \tlog.debug \"Child = ${childDevice}, DNI=${childDevice.deviceNetworkId}\"\n        \n        // def childMemberId = childDevice.getMemberId()\n        \n        def splitStrings = childDevice.deviceNetworkId.split(\"\\\\.\")\n        \n        log.debug \"Strings = ${splitStrings}\"\n        \n        def childMemberId = splitStrings[1]\n        \n        log.debug \"Child Member Id = ${childMemberId}\"\n        \n        log.debug \"Settings.users = ${settings.users}\"\n        \n        if (!settings.users.find{it==childMemberId}) {\n            deleteChildDevice(childDevice.deviceNetworkId)\n            def member = state.members.find {it.id==memberId}\n            if (member)\n            \tstate.members.remove(member)\n        }\n    \n    }\n}\n\ndef generateInitialEvent (member, childDevice) {\n\n    // lets figure out if the member is currently \"home\" (At the place)\n    \n    try { // we are going to just ignore any errors\n    \n    \tlog.info \"Life360 generateInitialEvent($member, $childDevice)\"\n        \n        def place = state.places.find{it.id==settings.place}\n        \n        if (place) {\n        \n        \tdef memberLatitude = new Float (member.location.latitude)\n            def memberLongitude = new Float (member.location.longitude)\n            def placeLatitude = new Float (place.latitude)\n            def placeLongitude = new Float (place.longitude)\n            def placeRadius = new Float (place.radius)\n        \n        \t// log.debug \"Member Location = ${memberLatitude}/${memberLongitude}\"\n            // log.debug \"Place Location = ${placeLatitude}/${placeLongitude}\"\n            // log.debug \"Place Radius = ${placeRadius}\"\n        \n        \tdef distanceAway = haversine(memberLatitude, memberLongitude, placeLatitude, placeLongitude)*1000 // in meters\n  \n        \t// log.debug \"Distance Away = ${distanceAway}\"\n  \n  \t\t\tboolean isPresent = (distanceAway <= placeRadius)\n\n\t\t\tlog.info \"Life360 generateInitialEvent, member: ($memberLatitude, $memberLongitude), place: ($placeLatitude, $placeLongitude), radius: $placeRadius, dist: $distanceAway, present: $isPresent\"\n                \n        \t// log.debug \"External Id=${app.id}:${member.id}\"\n        \n       \t\t// def childDevice2 = getChildDevice(\"${app.id}.${member.id}\")\n\t\t\n        \t// log.debug \"Child Device = ${childDevice2}\"\n        \n        \tchildDevice?.generatePresenceEvent(isPresent)\n        \n        \t// log.debug \"After generating presence event.\"\n            \n    \t}\n        \n\t}\n    catch (e) {\n    \t// eat it\n    }\n        \n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef haversine(lat1, lon1, lat2, lon2) {\n  def R = 6372.8\n  // In kilometers\n  def dLat = Math.toRadians(lat2 - lat1)\n  def dLon = Math.toRadians(lon2 - lon1)\n  lat1 = Math.toRadians(lat1)\n  lat2 = Math.toRadians(lat2)\n \n  def a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2)\n  def c = 2 * Math.asin(Math.sqrt(a))\n  def d = R * c\n  return(d)\n}\n\n\ndef placeEventHandler() {\n\n\tlog.info \"Life360 placeEventHandler: params=$params, settings.place=$settings.place\"\n\n\t// the POST to this end-point will look like:\n    // POST http://test.com/webhook?circleId=XXXX&placeId=XXXX&userId=XXXX&direction=arrive\n    \n    def circleId = params?.circleId\n    def placeId = params?.placeId\n    def userId = params?.userId\n    def direction = params?.direction\n    def timestamp = params?.timestamp\n    \n    if (placeId == settings.place) {\n\n\t\tdef presenceState = (direction==\"in\")\n    \n\t\tdef externalId = \"${app.id}.${userId}\"\n\n\t\t// find the appropriate child device based on my app id and the device network id\n\n\t\tdef deviceWrapper = getChildDevice(\"${externalId}\")\n\n\t\t// invoke the generatePresenceEvent method on the child device\n\n\t\tif (deviceWrapper) {\n\t\t\tdeviceWrapper.generatePresenceEvent(presenceState)\n    \t\tlog.debug \"Life360 event raised on child device: ${externalId}\"\n\t\t}\n   \t\telse {\n    \t\tlog.warn \"Life360 couldn't find child device associated with inbound Life360 event.\"\n    \t}\n    }\n\n}",
        "docstring": "Life360 Service Manager"
    },
    {
        "code": "def installed() {\n\tsubscribe(motion1, \"motion\", motionHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(motion1, \"motion\", motionHandler)\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"turning on lights\"\n\t\tswitches.on()\n\t} else if (evt.value == \"inactive\") {\n\t\trunIn(minutes1 * 60, scheduleCheck, [overwrite: false])\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check\"\n\tdef motionState = motion1.currentState(\"motion\")\n    if (motionState.value == \"inactive\") {\n        def elapsed = now() - motionState.rawDateCreated.time\n    \tdef threshold = 1000 * 60 * minutes1 - 1000\n    \tif (elapsed >= threshold) {\n            log.debug \"Motion has stayed inactive long enough since last check ($elapsed ms):  turning lights off\"\n            switches.off()\n    \t} else {\n        \tlog.debug \"Motion has not stayed inactive long enough since last check ($elapsed ms):  doing nothing\"\n        }\n    } else {\n    \tlog.debug \"Motion is active, do nothing and wait for inactive\"\n    }\n}",
        "docstring": "Turn your lights on when motion is detected and then off again once the motion stops for a set period of time."
    },
    {
        "code": "def installed() {\n\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler)\n}\n\n// New aeon implementation\ndef illuminanceHandler(evt) {\n\tdef lastStatus = state.lastStatus\n\tif (lastStatus != \"on\" && evt.integerValue < 30) {\n\t\tlights.on()\n\t\tstate.lastStatus = \"on\"\n\t}\n\telse if (lastStatus != \"off\" && evt.integerValue > 50) {\n\t\tlights.off()\n\t\tstate.lastStatus = \"off\"\n\t}\n}",
        "docstring": "Turn your lights on when it gets dark and off when it becomes light again."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contact1, \"contact.closed\", contactClosedHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.closed\", contactClosedHandler)\n}\n\ndef contactClosedHandler(evt) {\n\tswitch1.off()\n}",
        "docstring": "Turn your lights off when an open/close sensor closes."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(presence1, \"presence\", presence)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tif (evt.value == \"present\") {\n\t\tif (unlock == \"Yes\") {\n\t\t\tdef anyLocked = lock1.count{it.currentLock == \"unlocked\"} != lock1.size()\n\t\t\tif (anyLocked) {\n\t\t\t\tsendMessage(\"Doors unlocked at arrival of $evt.linkText\")\n\t\t\t}\n\t\t\tlock1.unlock()\n\t\t}\n\t}\n\telse {\n\t\tdef nobodyHome = presence1.find{it.currentPresence == \"present\"} == null\n\t\tif (nobodyHome) {\n\t\t\tdef anyUnlocked = lock1.count{it.currentLock == \"locked\"} != lock1.size()\n\t\t\tif (anyUnlocked) {\n\t\t\t\tsendMessage(\"Doors locked after everyone departed\")\n\t\t\t}\n\t\t\tlock1.lock()\n\t\t}\n\t}\n}\n\ndef sendMessage(msg) {\n\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (spam == \"Yes\") {\n            sendPush msg\n        }\n    }\n}",
        "docstring": "Locks a deadbolt or lever lock when a SmartSense Presence tag or smartphone leaves a location."
    },
    {
        "code": "def installed() {\n\tif (!state.accessToken) {\n\t\tlog.debug \"Harmony - About to create access token\"\n\t\tcreateAccessToken()\n\t} else {\n\t\tinitialize()\n\t}\n}\n\ndef updated() {\n\tif (!state.accessToken) {\n\t\tlog.debug \"Harmony - About to create access token\"\n\t\tcreateAccessToken()\n\t} else {\n\t\tinitialize()\n\t}\n}\n\ndef uninstalled() {\n\tif (state.HarmonyAccessToken) {\n\t\ttry {\n\t\t\tstate.HarmonyAccessToken = \"\"\n\t\t\tlog.debug \"Harmony - Success disconnecting Harmony from SmartThings\"\n\t\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tlog.error \"Harmony - Error disconnecting Harmony from SmartThings: ${e.statusCode}\"\n\t\t}\n\t}\n}\n\ndef initialize() {\n\tstate.aux = 0\n\tif (selectedhubs || selectedactivities) {\n\t\taddDevice()\n\t\trunEvery5Minutes(\"poll\")\n\t\tlog.trace getActivityList()\n\t}\n}\n\ndef getHarmonydevices() {\n\tstate.Harmonydevices ?: []\n}\n\nMap discoverDevices() {\n\tlog.trace \"Harmony - Discovering devices...\"\n\tdiscovery()\n\tif (getHarmonydevices() != []) {\n\t\tdef devices = state.Harmonydevices.hubs\n\t\tlog.trace devices.toString()\n\t\tdef activities = [:]\n\t\tdef hubs = [:]\n\t\tdevices.each {\n\t\t\tif (it.value.response){\n\t\t\t\tdef hubkey = it.key\n\t\t\t\tdef hubname = getHubName(it.key)\n\t\t\t\tdef hubvalue = \"${hubname}\"\n\t\t\t\thubs[\"harmony-${hubkey}\"] = hubvalue\n\t\t\t\tit.value.response.data?.activities?.each {\n\t\t\t\t\tdef value = \"${it.value.name}\"\n\t\t\t\t\tdef key = \"harmony-${hubkey}-${it.key}\"\n\t\t\t\t\tactivities[\"${key}\"] = value\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.trace \"Harmony - Device $it.key is no longer available\"\n\t\t\t}\n\t\t}\n\t\tstate.HarmonyHubs = hubs\n\t\tstate.HarmonyActivities = activities\n\t}\n}\n\n//CHILD DEVICE METHODS\ndef discovery() {\n\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\tdef url = \"https://home.myharmony.com/cloudapi/activity/all?${toQueryString(tokenParam)}\"\n\tdef params = [\n\t\turi: url,\n\t\tcontentType: 'application/json'\n\t]\n\tasynchttp_v1.get('discoveryResponse', params)\n\tlog.trace \"Harmony - Discovery Command Sent\"\n}\n\ndef discoveryResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Connection to the hub timed out. Please restart the hub and try again.\"\n\t\t\tstate.resethub = true\n\t\t}\n\t} else {\n\t\tif (response.status == 200) {\n\t\t\tlog.debug \"Harmony - valid Token\"\n\t\t\tstate.Harmonydevices = response.json\n\t\t\tstate.resethub = false\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Error, response status: $response.status\"\n\t\t}\n\t}\n}\n\ndef addDevice() {\n\tlog.trace \"Harmony - Adding Hubs\"\n\tselectedhubs.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newAction = state.HarmonyHubs.find { it.key == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Logitech Harmony Hub C2C\", dni, null, [label:\"${newAction.value}\"])\n\t\t\tlog.trace \"Harmony - Created ${d.displayName} with id $dni\"\n\t\t\tpoll()\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n\tlog.trace \"Harmony - Adding Activities\"\n\tselectedactivities.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newAction = state.HarmonyActivities.find { it.key == dni }\n\t\t\tif (newAction) {\n\t\t\t\td = addChildDevice(\"smartthings\", \"Harmony Activity\", dni, null, [label:\"${newAction.value} [Harmony Activity]\"])\n\t\t\t\tlog.trace \"Harmony - Created ${d.displayName} with id $dni\"\n\t\t\t\tpoll()\n\t\t\t}\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n}\n\ndef activity(dni,mode) {\n\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\tdef url\n\tif (dni == \"all\") {\n\t\turl = \"https://home.myharmony.com/cloudapi/activity/off?${toQueryString(tokenParam)}\"\n\t} else {\n\t\tdef aux = dni.split('-')\n\t\tdef hubId = aux[1]\n\t\tif (mode == \"hub\" || (aux.size() <= 2) || (aux[2] == \"off\")){\n\t\t\turl = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/off?${toQueryString(tokenParam)}\"\n\t\t} else {\n\t\t  def activityId = aux[2]\n\t\t\turl = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/${activityId}/${mode}?${toQueryString(tokenParam)}\"\n\t\t}\n\t}\n\tdef params = [\n\t\turi: url,\n\t\tcontentType: 'application/json'\n\t]\n\tasynchttp_v1.post('activityResponse', params)\n\tlog.trace \"Harmony - Command Sent\"\n}\n\ndef activityResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tif (response.status == 200) {\n\t\t\tlog.trace \"Harmony - Command sent succesfully\"\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Command failed. Error: $response.status\"\n\t\t}\n\t}\n}\n\ndef poll() {\n\t// GET THE LIST OF ACTIVITIES\n\tif (state.HarmonyAccessToken) {\n\t\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\t\tdef params = [\n\t\t\turi: \"https://home.myharmony.com/cloudapi/state?${toQueryString(tokenParam)}\",\n\t\t\theaders: [\"Accept\": \"application/json\"],\n\t\t\tcontentType: 'application/json'\n\t\t]\n\t\tasynchttp_v1.get('pollResponse', params)\n\t  } else {\n\t\tlog.warn \"Harmony - Access token has expired\"\n\t  }\n}\n\ndef pollResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tdef activities = getChildDevices()\n\t\t// Device-Watch relies on the Logitech Harmony Cloud to get the Device state.\n\t\tactivities.each { activity ->\n\t\t\tactivity.sendEvent(name: \"DeviceWatch-DeviceStatus\", value: \"offline\", displayed: false, isStateChange: true)\n\t\t}\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tdef ResponseValues\n\t\tdef currentActivities = []\n\t\ttry {\n\t\t\t// json response already parsed into JSONElement object\n\t\t\tResponseValues = response.json\n\t\t} catch (e) {\n\t\t\tlog.error \"Harmony - error parsing json from response: $e\"\n\t\t}\n\t\tif (ResponseValues) {\n\t\t\tlog.debug \"Harmony - response body: $response.data\"\n\t\t\tdef activities = getChildDevices()\n\t\t\tResponseValues.hubs.each {\n\t\t\t\t// Device-Watch relies on the Logitech Harmony Cloud to get the Device state.\n\t\t\t\tactivities.each { activity ->\n\t\t\t\t\tif (\"${activity.deviceNetworkId}\".contains(\"harmony-${it.key}\")) {\n\t\t\t\t\t\tactivity.sendEvent(name: \"DeviceWatch-DeviceStatus\", value: \"online\", displayed: false, isStateChange: true)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (it.value.message == \"OK\") {\n\t\t\t\t\tdef hub = getChildDevice(\"harmony-${it.key}\")\n\t\t\t\t\tif (hub) {\n\t\t\t\t\t\tif (it.value.response.data.currentAvActivity == \"-1\") {\n\t\t\t\t\t\t\thub.sendEvent(name: \"currentActivity\", value: \"--\", descriptionText: \"There isn't any activity running\", displayed: false)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdef currentActivity\n\t\t\t\t\t\t\tdef activityDTH = getChildDevice(\"harmony-${it.key}-${it.value.response.data.currentAvActivity}\")\n\t\t\t\t\t\t\tif (activityDTH)\n\t\t\t\t\t\t\t\tcurrentActivity = activityDTH.device.displayName\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrentActivity = getActivityName(it.value.response.data.currentAvActivity,it.key)\n\t\t\t\t\t\t\thub.sendEvent(name: \"currentActivity\", value: currentActivity, descriptionText: \"Current activity is ${currentActivity}\", displayed: false)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tit.value.response.data.currentActivities.each {currentActivity ->\n\t\t\t\t\t\t\tcurrentActivities.add(\"harmony-${it.key}-${currentActivity}\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t  \t} else {\n\t\t\t\t\tlog.trace \"Harmony - error response: $it.value.message\"\n\t\t\t  \t}\n\t\t\t}\n\t\t\tdef activitynotrunning = true\n\t\t\tlog.debug \"Harmony - Current Activities: $currentActivities\"\n\t\t\tactivities.each { activity ->\n\t\t\t\tif (currentActivities.contains(\"$activity.deviceNetworkId\")) {\n\t\t\t\t\tactivity.sendEvent(name: \"switch\", value: \"on\")\n\t\t\t\t} else {\n\t\t\t\t\tactivity.sendEvent(name: \"switch\", value: \"off\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Harmony - did not get json results from response body: $response.data\"\n\t\t}\n\t}\n}\n\ndef getActivityList() {\n\tif (state.HarmonyAccessToken) {\n\t\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/activity/all?${toQueryString(tokenParam)}\"\n\t\tdef params = [\n\t\t\turi: url,\n\t\t\tcontentType: 'application/json'\n\t\t]\n\t\tasynchttp_v1.get('getActivityListResponse', params)\n\t\tlog.trace \"Harmony - Activity List Request Sent\"\n\t}\n}\n\ndef getActivityListResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tlog.trace \"Harmony - Parsing Activity List Response\"\n\t\tresponse.json.hubs.each {\n\t\t\tdef hub = getChildDevice(\"harmony-${it.key}\")\n\t\t\tif (hub) {\n\t\t\t\tdef hubname = getHubName(\"${it.key}\")\n\t\t\t\tdef activities = []\n\t\t\t\tdef aux = it.value.response.data.activities.size()\n\t\t\t\tif (aux >= 1) {\n\t\t\t\t\tactivities = it.value.response.data.activities.collect {\n\t\t\t\t\t\t[id: it.key, name: it.value['name'], type: it.value['type']]\n\t\t\t\t\t}\n\t\t\t\t\tactivities += [id: \"off\", name: \"Activity OFF\", type: \"0\"]\n\t\t\t\t}\n\t\t\t\thub.sendEvent(name: \"activities\", value: new groovy.json.JsonBuilder(activities).toString(), descriptionText: \"Activities are ${activities.collect { it.name }?.join(', ')}\", displayed: false)\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef getActivityName(activity,hubId) {\n\t// GET ACTIVITY'S NAME\n\tdef actname = activity\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/all?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\tactname = response.data.data.activities[activity].name\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace e\n\t\t}\n\t}\n\treturn actname\n}\n\ndef getActivityId(activity,hubId) {\n\t// GET ACTIVITY'S NAME\n\tdef actid = activity\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/all?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\tresponse.data.data.activities.each {\n\t\t\t\t\tif (it.value.name == activity)\n\t\t\t\t\t\tactid = it.key\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace \"Harmony - getActivityId() response $e\"\n\t\t}\n\t}\n\treturn actid\n}\n\ndef getHubName(hubId) {\n\t// GET HUB'S NAME\n\tdef hubname = hubId\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/discover?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\thubname = response.data.data.name\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace \"Harmony - getHubName() response $e\"\n\t\t}\n\t}\n\treturn hubname\n}\n\ndef sendNotification(msg) {\n\tsendNotification(msg)\n}\n\ndef hookEventHandler() {\n\t// log.debug \"In hookEventHandler method.\"\n\tlog.debug \"Harmony - request = ${request}\"\n\n\tdef json = request.JSON\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\ndef listDevices() {\n\tlog.debug \"Harmony - getDevices(), params: ${params}\"\n\tallDevices.collect {\n\t\tdeviceItem(it)\n\t}\n}\n\ndef getDevice() {\n\tlog.debug \"Harmony - getDevice(), params: ${params}\"\n\tdef device = allDevices.find { it.id == params.id }\n\tif (!device) {\n\t\trender status: 404, data: '{\"msg\": \"Device not found\"}'\n\t} else {\n\t\tdeviceItem(device)\n\t}\n}\n\ndef updateDevice() {\n\tdef data = request.JSON\n\tdef command = data.command\n\tdef arguments = data.arguments\n\tlog.debug \"Harmony - updateDevice(), params: ${params}, request: ${data}\"\n\tif (!command) {\n\t\trender status: 400, data: '{\"msg\": \"command is required\"}'\n\t} else {\n\t\tdef device = allDevices.find { it.id == params.id }\n\tif (device) {\n\t\tif (validateCommand(device, command)) {\n\t\t\tif (arguments) {\n\t\t\t\tdevice.\"$command\"(*arguments)\n\t\t\t} else {\n\t\t\t\tdevice.\"$command\"()\n\t\t\t}\n\t\t\trender status: 204, data: \"{}\"\n\t\t} else {\n\t\t  render status: 403, data: '{\"msg\": \"Access denied. This command is not supported by current capability.\"}'\n\t\t}\n\t} else {\n\t  render status: 404, data: '{\"msg\": \"Device not found\"}'\n\t}\n  }\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(device)\n\tif (currentDeviceCapability != \"\" && capabilityCommands[currentDeviceCapability]) {\n\treturn (command in capabilityCommands[currentDeviceCapability] || (currentDeviceCapability == \"Switch\" && command == \"setLevel\" && device.hasCommand(\"setLevel\"))) ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(device) {\n\tdef capName = \"\"\n\tif (switches.find{it.id == device.id})\n\t\t\tcapName = \"Switch\"\n\t\telse if (alarms.find{it.id == device.id})\n\t\t\tcapName = \"Alarm\"\n\t\telse if (locks.find{it.id == device.id})\n\t\t\tcapName = \"Lock\"\n\tlog.trace \"Device: $device - Capability Name: $capName\"\n\t\treturn capName\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\ndef listSubscriptions() {\n\tlog.debug \"Harmony - listSubscriptions()\"\n\tapp.subscriptions?.findAll { it.device?.device && it.device.id }?.collect {\n\t\tdef deviceInfo = state[it.device.id]\n\t\tdef response = [\n\t\t\tid: it.id,\n\t\t\tdeviceId: it.device.id,\n\t\t\tattributeName: it.data,\n\t\t\thandler: it.handler\n\t\t]\n\t\tif (!state.harmonyHubs) {\n\t\t\tresponse.callbackUrl = deviceInfo?.callbackUrl\n\t\t}\n\t\tresponse\n\t} ?: []\n}\n\ndef addSubscription() {\n\tdef data = request.JSON\n\tdef attribute = data.attributeName\n\tdef callbackUrl = data.callbackUrl\n\n\tlog.debug \"Harmony - addSubscription, params: ${params}, request: ${data}\"\n\tif (!attribute) {\n\t\trender status: 400, data: '{\"msg\": \"attributeName is required\"}'\n\t} else {\n\t\tdef device = allDevices.find { it.id == data.deviceId }\n\t\tif (device) {\n\t\t\tif (!state.harmonyHubs) {\n\t\t\t\tlog.debug \"Harmony - Adding callbackUrl: $callbackUrl\"\n\t\t\t\tstate[device.id] = [callbackUrl: callbackUrl]\n\t\t\t}\n\t\t\tlog.debug \"Harmony - Adding subscription\"\n\t\t\tdef subscription = subscribe(device, attribute, deviceHandler)\n\t\t\tif (!subscription || !subscription.eventSubscription) {\n\t\t\t\tsubscription = app.subscriptions?.find { it.device?.device && it.device.id == data.deviceId && it.data == attribute && it.handler == 'deviceHandler' }\n\t\t\t}\n\n\t\t\tdef response = [\n\t\t\t\tid: subscription.id,\n\t\t\t\tdeviceId: subscription.device.id,\n\t\t\t\tattributeName: subscription.data,\n\t\t\t\thandler: subscription.handler\n\t\t\t]\n\t\t\tif (!state.harmonyHubs) {\n\t\t\t\tresponse.callbackUrl = callbackUrl\n\t\t\t}\n\t\t\tresponse\n\t\t} else {\n\t\t\trender status: 400, data: '{\"msg\": \"Device not found\"}'\n\t\t}\n\t}\n}\n\ndef removeSubscription() {\n\tdef subscription = app.subscriptions?.find { it.id == params.id }\n\tdef device = subscription?.device\n\n\tlog.debug \"removeSubscription, params: ${params}, subscription: ${subscription}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Harmony - Removing subscription for device: ${device.id}\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\trender status: 204, data: \"{}\"\n}\n\ndef listPhrases() {\n\tlocation.helloHome.getPhrases()?.collect {[\n\t\tid: it.id,\n\t\tlabel: it.label\n\t]}\n}\n\ndef executePhrase() {\n\tlog.debug \"executedPhrase, params: ${params}\"\n\tlocation.helloHome.execute(params.id)\n\trender status: 204, data: \"{}\"\n}\n\ndef deviceHandler(evt) {\n\tdef deviceInfo = state[evt.deviceId]\n\tif (state.harmonyHubs) {\n\t\tstate.harmonyHubs.each { harmonyHub ->\n\t  log.trace \"Harmony - Sending data to $harmonyHub.name\"\n\t\t\tsendToHarmony(evt, harmonyHub.callbackUrl)\n\t\t}\n\t} else if (deviceInfo) {\n\t\tif (deviceInfo.callbackUrl) {\n\t\t\tsendToHarmony(evt, deviceInfo.callbackUrl)\n\t\t} else {\n\t\t\tlog.warn \"Harmony - No callbackUrl set for device: ${evt.deviceId}\"\n\t\t}\n\t} else {\n\t\tlog.warn \"Harmony - No subscribed device found for device: ${evt.deviceId}\"\n\t}\n}\n\ndef sendToHarmony(evt, String callbackUrl) {\n  def callback = new URI(callbackUrl)\n  if (callback.port != -1) {\n  \tdef host = callback.port != -1 ? \"${callback.host}:${callback.port}\" : callback.host\n  \tdef path = callback.query ? \"${callback.path}?${callback.query}\".toString() : callback.path\n  \tsendHubCommand(new physicalgraph.device.HubAction(\n  \t\tmethod: \"POST\",\n  \t\tpath: path,\n  \t\theaders: [\n  \t\t\t\"Host\": host,\n  \t\t\t\"Content-Type\": \"application/json\"\n  \t\t],\n  \t\tbody: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]\n  \t))\n  } else {\n\tdef params = [\n\t  uri: callbackUrl,\n\t  body: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]\n\t]\n\ttry {\n\t\tlog.debug \"Harmony - Sending data to Harmony Cloud: $params\"\n\t\thttpPostJson(params) { resp ->\n\t\t\tlog.debug \"Harmony - Cloud Response: ${resp.status}\"\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"Harmony - Cloud Something went wrong: $e\"\n\t}\n  }\n}\n\ndef listHubs() {\n\tlocation.hubs?.findAll { it.type.toString() == \"PHYSICAL\" }?.collect { hubItem(it) }\n}\n\ndef getHub() {\n\tdef hub = location.hubs?.findAll { it.type.toString() == \"PHYSICAL\" }?.find { it.id == params.id }\n\tif (!hub) {\n\t\trender status: 404, data: '{\"msg\": \"Hub not found\"}'\n\t} else {\n\t\thubItem(hub)\n\t}\n}\n\ndef activityCallback() {\n\tdef data = request.JSON\n\tdef device = getChildDevice(params.dni)\n\tif (device) {\n\t\tif (data.errorCode == \"200\") {\n\t\t\tdevice.setCurrentActivity(data.currentActivityId)\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Activity callback error: ${data}\"\n\t\t}\n\t} else {\n\t\tlog.warn \"Harmony - Activity callback sent to non-existant dni: ${params.dni}\"\n\t}\n\trender status: 200, data: '{\"msg\": \"Successfully received callbackUrl\"}'\n}\n\ndef getHarmony() {\n\tstate.harmonyHubs ?: []\n}\n\ndef harmony() {\n\tdef data = request.JSON\n\tif (data.mac && data.callbackUrl && data.name) {\n\t\tif (!state.harmonyHubs) { state.harmonyHubs = [] }\n\t\tdef harmonyHub = state.harmonyHubs.find { it.mac == data.mac }\n\t\tif (harmonyHub) {\n\t\t\tharmonyHub.mac = data.mac\n\t\t\tharmonyHub.callbackUrl = data.callbackUrl\n\t\t\tharmonyHub.name = data.name\n\t\t} else {\n\t\t\tstate.harmonyHubs << [mac: data.mac, callbackUrl: data.callbackUrl, name: data.name]\n\t\t}\n\t\trender status: 200, data: '{\"msg\": \"Successfully received Harmony data\"}'\n\t} else {\n\t\tif (!data.mac) {\n\t\t\trender status: 400, data: '{\"msg\": \"mac is required\"}'\n\t\t} else if (!data.callbackUrl) {\n\t\t\trender status: 400, data: '{\"msg\": \"callbackUrl is required\"}'\n\t\t} else if (!data.name) {\n\t\t\trender status: 400, data: '{\"msg\": \"name is required\"}'\n\t\t}\n\t}\n}\n\ndef deleteHarmony() {\n\tlog.debug \"Harmony - Trying to delete Harmony hub with mac: ${params.mac}\"\n\tdef harmonyHub = state.harmonyHubs?.find { it.mac == params.mac }\n\tif (harmonyHub) {\n\t\tlog.debug \"Harmony - Deleting Harmony hub with mac: ${params.mac}\"\n\t\tstate.harmonyHubs.remove(harmonyHub)\n\t} else {\n\t\tlog.debug \"Harmony - Couldn't find Harmony hub with mac: ${params.mac}\"\n\t}\n\trender status: 204, data: \"{}\"\n}\n\ndef getAllDevices() {\n\t([] + switches + motionSensors + contactSensors + thermostats + presenceSensors + temperatureSensors + accelerationSensors + waterSensors + lightSensors + humiditySensors + alarms + locks)?.findAll()?.unique { it.id }\n}\n\ndef deviceItem(device) {\n\t[\n\t\tid: device.id,\n\t\tlabel: device.displayName,\n\t\tcurrentStates: device.currentStates,\n\t\tcapabilities: device.capabilities?.collect {[\n\t\t\tname: it.name\n\t\t]},\n\t\tattributes: device.supportedAttributes?.collect {[\n\t\t\tname: it.name,\n\t\t\tdataType: it.dataType,\n\t\t\tvalues: it.values\n\t\t]},\n\t\tcommands: device.supportedCommands?.collect {[\n\t\t\tname: it.name,\n\t\t\targuments: it.arguments\n\t\t]},\n\t\ttype: [\n\t\t\tname: device.typeName,\n\t\t\tauthor: device.typeAuthor\n\t\t]\n\t]\n}\n\ndef hubItem(hub) {\n\t[\n\t\tid: hub.id,\n\t\tname: hub.name,\n\t\tip: hub.localIP,\n\t\tport: hub.localSrvPortTCP\n\t]\n}",
        "docstring": "Allows you to integrate your Logitech Harmony account with SmartThings."
    },
    {
        "code": "def installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\t// Don't send a continuous stream of notifications\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentNotifications = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentNotifications) {\n\t\tlog.debug \"Notifications already sent within the last $deltaSeconds seconds (phone1: $phone1, pushNotification: $pushNotification)\"\n\t}\n\telse {\n        if (location.contactBookEnabled) {\n            log.debug \"$accelerationSensor has moved, notifying ${recipients?.size()}\"\n            sendNotificationToContacts(\"Mail has arrived!\", recipients)\n        }\n        else {\n        if (phone1 != null && phone1 != \"\") {\n            log.debug \"$accelerationSensor has moved, texting $phone1\"\n            sendSms(phone1, \"Mail has arrived!\")\n        }\n        if (pushNotification) {\n            log.debug \"$accelerationSensor has moved, sending push\"\n            sendPush(\"Mail has arrived!\")\n        }\n    }\n\t}\n}",
        "docstring": "Send a text when mail arrives in your mailbox using a SmartSense Multi on your mailbox door. Note: battery life may be impacted in cold climates."
    },
    {
        "code": "def installed() {\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n\tsaveState()\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n\tsaveState()\n}\n\ndef appTouch(evt)\n{\n\trestoreState(currentMode)\n}\n\ndef changedLocationMode(evt)\n{\n\trestoreState(evt.value)\n}\n\nprivate restoreState(mode)\n{\n\tlog.info \"restoring state for mode '$mode'\"\n\tdef map = state[mode] ?: [:]\n\tswitches?.each {\n\t\tdef value = map[it.id]\n\t\tif (value?.switch == \"on\") {\n\t\t\tdef level = value.level\n\t\t\tif (level) {\n\t\t\t\tlog.debug \"setting $it.label level to $level\"\n\t\t\t\tit.setLevel(level)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.debug \"turning $it.label on\"\n\t\t\t\tit.on()\n\t\t\t}\n\t\t}\n\t\telse if (value?.switch == \"off\") {\n\t\t\tlog.debug \"turning $it.label off\"\n\t\t\tit.off()\n\t\t}\n\t}\n\n\tthermostats?.each {\n\t\tdef value = map[it.id]\n\t\tif (value?.coolingSetpoint) {\n\t\t\tlog.debug \"coolingSetpoint = $value.coolingSetpoint\"\n\t\t\tit.setCoolingSetpoint(value.coolingSetpoint)\n\t\t}\n\t\tif (value?.heatingSetpoint) {\n\t\t\tlog.debug \"heatingSetpoint = $value.heatingSetpoint\"\n\t\t\tit.setHeatingSetpoint(value.heatingSetpoint)\n\t\t}\n\t}\n\n\tlocks?.each {\n\t\tdef value = map[it.id]\n\t\tif (value) {\n\t\t\tif (value?.locked) {\n\t\t\t\tit.lock()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit.unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nprivate saveState()\n{\n\tdef mode = currentMode\n\tdef map = state[mode] ?: [:]\n\n\tswitches?.each {\n\t\tmap[it.id] = [switch: it.currentSwitch, level: it.currentLevel]\n\t}\n\n\tthermostats?.each {\n\t\tmap[it.id] = [coolingSetpoint: it.currentCoolingSetpoint, heatingSetpoint: it.currentHeatingSetpoint]\n\t}\n\n\tlocks?.each {\n\t\tmap[it.id] = [locked: it.currentLock == \"locked\"]\n\t}\n\n\tstate[mode] = map\n\tlog.debug \"saved state for mode ${mode}: ${state[mode]}\"\n\tlog.debug \"state: $state\"\n}\n\nprivate getCurrentMode()\n{\n\tlocation.mode ?: \"_none_\"\n}",
        "docstring": "Saves the states of a specified set switches and thermostat setpoints and restores them at each mode change. To use 1) Set the mode, 2) Change switches and setpoint to where you want them for that mode, and 3) Install or update the app. Changing to that mode or touching the app will set the devices to the saved state."
    },
    {
        "code": "def installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tdef window = timeWindowMsec\n\t[time1, time2, time3, time4].eachWithIndex {time, index ->\n\t\tif (time != null) {\n\t\t\tdef endTime = new Date(timeToday(time, location?.timeZone).time + window)\n\t\t\tlog.debug \"Scheduling check at $endTime\"\n\t\t\t//runDaily(endTime, \"scheduleCheck${index}\")\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tschedule(endTime, scheduleCheck0)\n\t\t\t\t\tbreak\n\t\t\t\tcase 1:\n\t\t\t\t\tschedule(endTime, scheduleCheck1)\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\tschedule(endTime, scheduleCheck2)\n\t\t\t\t\tbreak\n\t\t\t\tcase 3:\n\t\t\t\t\tschedule(endTime, scheduleCheck3)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef scheduleCheck0() { scheduleCheck() }\ndef scheduleCheck1() { scheduleCheck() }\ndef scheduleCheck2() { scheduleCheck() }\ndef scheduleCheck3() { scheduleCheck() }\n\ndef scheduleCheck()\n{\n\tlog.debug \"scheduleCheck\"\n\tdef t0 = new Date(now() - (2 * timeWindowMsec))\n\tdef t1 = new Date()\n\tdef cabinetOpened = cabinet1.eventsBetween(t0, t1).find{it.name == \"contact\" && it.value == \"open\"}\n\tlog.trace \"Looking for events between $t0 and $t1: $cabinetOpened\"\n\n\tif (cabinetOpened) {\n\t\tlog.trace \"Medicine cabinet was opened since $midnight, no notification required\"\n\t} else {\n\t\tlog.trace \"Medicine cabinet was not opened since $midnight, sending notification\"\n\t\tsendMessage()\n\t}\n}\n\nprivate sendMessage() {\n\tdef msg = \"Please remember to take your medicine\"\n\tlog.info msg\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (phone1) {\n            sendSms(phone1, msg)\n        }\n        if (sendPush == \"Yes\") {\n            sendPush(msg)\n        }\n    }\n}\n\ndef getTimeWindowMsec() {\n\t(timeWindow ?: 15) * 60000 as Long\n}",
        "docstring": "Set up a reminder so that if you forget to take your medicine (determined by whether a cabinet or drawer has been opened) by specified time you get a notification or text message."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tstate.colorIndex = -1    \n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe controller, \"button\", buttonHandler\n}\n\ndef buttonHandler(evt) {\n\tswitch(evt.jsonData?.buttonNumber) {\n    \tcase 2:\n        \tif (evt.value == \"held\") {\n            \tbulbs.setLevel(100)\n            }\n            else {\n            \tlevelUp()\n            }\n        \tbreak\n        \n        case 3:\n        \tif (evt.value == \"held\") {\n                def color = [name:\"Soft White\", hue: 23, saturation: 56]\n                bulbs.setColor(hue: color.hue, saturation: color.saturation)            \t\n            }\n            else {\n            \tchangeColor()\n            }\n        \tbreak\n        \n        case 4:\n        \tif (evt.value == \"held\") {\n            \tbulbs.setLevel(10)\n            }\n            else {\n            \tlevelDown()\n            }\n        \tbreak\n        \n        default:\n        \ttoggleState()\n        \tbreak\n    }\n}\n\nprivate toggleState() {\n\tif (currentSwitchState == \"on\") {\n    \tlog.debug \"off\"\n    \tbulbs.off()\n    }\n    else {\n    \tlog.debug \"on\"\n    \tbulbs.on()\n    }\n}\n\nprivate levelUp() {\n\tdef level = Math.min(currentSwitchLevel + 10, 100)\n    log.debug \"level = $level\"\n    bulbs.setLevel(level)\n}\n\nprivate levelDown() {\n\tdef level = Math.max(currentSwitchLevel - 10, 10)\n\tlog.debug \"level = $level\"\n    bulbs.setLevel(level)\n}\n\nprivate changeColor() {\n\n\tfinal colors = [\n        [name:\"Soft White\", hue: 23, saturation: 56],\n        [name:\"Daylight\", hue: 53, saturation: 91],\n        [name:\"White\", hue: 52, saturation: 19],\n        [name:\"Warm White\", hue: 20, saturation: 80],\n        [name:\"Blue\", hue: 70, saturation: 100],\n        [name:\"Green\", hue: 39, saturation: 100],\n        [name:\"Yellow\", hue: 25, saturation: 100],\n        [name:\"Orange\", hue: 10, saturation: 100],\n        [name:\"Purple\", hue: 75, saturation: 100],\n        [name:\"Pink\", hue: 83, saturation: 100],\n        [name:\"Red\", hue: 100, saturation: 100]\n\t]\n    \n    final maxIndex = colors.size() - 1\n    \n    if (state.colorIndex < maxIndex) {\n    \tstate.colorIndex = state.colorIndex + 1\n    }\n    else {\n    \tstate.colorIndex = 0\n    }\n    \n    def color = colors[state.colorIndex]\n    bulbs.setColor(hue: color.hue, saturation: color.saturation)\n}\n\nprivate getCurrentSwitchState() {\n\tdef on = 0\n    def off = 0\n    bulbs.each {\n    \tif (it.currentValue(\"switch\") == \"on\") {\n        \ton++\n        }\n        else {\n        \toff++\n        }\n    }\n    on > off ? \"on\" : \"off\"\n}\n\nprivate getCurrentSwitchLevel() {\n\tdef level = 0\n    bulbs.each {\n    \tlevel = Math.max(it.currentValue(\"level\")?.toInteger() ?: 0, level)\n    }\n    level.toInteger()\n}",
        "docstring": "Control one or more Hue bulbs using an Aeon MiniMote."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe cube, \"threeAxis\", positionHandler\n}\n\n\n/******************\n * Event handlers *\n ******************/\ndef positionHandler(evt) {\n\n\tdef sceneId = getOrientation(evt.xyzValue)\n\tlog.trace \"orientation: $sceneId\"\n\n\tif (sceneId != state.lastActiveSceneId) {\n\t\trestoreStates(sceneId)\n\t}\n\telse {\n\t\tlog.trace \"No status change\"\n\t}\n\tstate.lastActiveSceneId = sceneId\n}\n\n\n/******************\n * Helper methods *\n ******************/\nprivate Boolean sceneIsDefined(sceneId) {\n\tdef tgt = \"onoff_${sceneId}\".toString()\n\tsettings.find{it.key.startsWith(tgt)} != null\n}\n\nprivate updateSetting(name, value) {\n\tapp.updateSetting(name, value)\n\tsettings[name] = value\n}\n\nprivate closestLevel(level) {\n\tlevel ? \"${Math.round(level/5) * 5}%\" : \"0%\"\n}\n\nprivate saveStates(params) {\n\tlog.trace \"saveStates($params)\"\n\tdef sceneId = params.sceneId as Integer\n\tgetDeviceCapabilities()\n\n\tlights.each {light ->\n\t\tdef type = state.lightCapabilities[light.id]\n\n\t\tupdateSetting(\"onoff_${sceneId}_${light.id}\", light.currentValue(\"switch\") == \"on\")\n\n\t\tif (type == \"level\") {\n\t\t\tupdateSetting(\"level_${sceneId}_${light.id}\", closestLevel(light.currentValue('level')))\n\t\t}\n\t\telse if (type == \"color\") {\n\t\t\tupdateSetting(\"level_${sceneId}_${light.id}\", closestLevel(light.currentValue('level')))\n\t\t\tupdateSetting(\"color_${sceneId}_${light.id}\", \"${light.currentValue(\"hue\")}/${light.currentValue(\"saturation\")}\")\n\t\t}\n\t}\n}\n\n\nprivate restoreStates(sceneId) {\n\tlog.trace \"restoreStates($sceneId)\"\n\tgetDeviceCapabilities()\n\n\tlights.each {light ->\n\t\tdef type = state.lightCapabilities[light.id]\n\n\t\tdef isOn = settings.\"onoff_${sceneId}_${light.id}\" == \"true\" ? true : false\n\t\tlog.debug \"${light.displayName} is '$isOn'\"\n\t\tif (isOn) {\n\t\t\tlight.on()\n\t\t}\n\t\telse {\n\t\t\tlight.off()\n\t\t}\n\n\t\tif (type != \"switch\") {\n\t\t\tdef level = switchLevel(sceneId, light)\n\n\t\t\tif (type == \"level\") {\n\t\t\t\tlog.debug \"${light.displayName} level is '$level'\"\n\t\t\t\tif (level != null) {\n\t\t\t\t\tlight.setLevel(level)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == \"color\") {\n\t\t\t\tdef segs = settings.\"color_${sceneId}_${light.id}\"?.split(\"/\")\n\t\t\t\tif (segs?.size() == 2) {\n\t\t\t\t\tdef hue = segs[0].toInteger()\n\t\t\t\t\tdef saturation = segs[1].toInteger()\n\t\t\t\t\tlog.debug \"${light.displayName} color is level: $level, hue: $hue, sat: $saturation\"\n\t\t\t\t\tif (level != null) {\n\t\t\t\t\t\tlight.setColor(level: level, hue: hue, saturation: saturation)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlight.setColor(hue: hue, saturation: saturation)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"${light.displayName} level is '$level'\"\n\t\t\t\t\tif (level != null) {\n\t\t\t\t\t\tlight.setLevel(level)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.error \"Unknown type '$type'\"\n\t\t\t}\n\t\t}\n\n\n\t}\n}\n\nprivate switchLevel(sceneId, light) {\n\tdef percent = settings.\"level_${sceneId}_${light.id}\"\n\tif (percent) {\n\t\tpercent[0..-2].toInteger()\n\t}\n\telse {\n\t\tnull\n\t}\n}\n\nprivate getDeviceCapabilities() {\n\tdef caps = [:]\n\tlights.each {\n\t\tif (it.hasCapability(\"Color Control\")) {\n\t\t\tcaps[it.id] = \"color\"\n\t\t}\n\t\telse if (it.hasCapability(\"Switch Level\")) {\n\t\t\tcaps[it.id] = \"level\"\n\t\t}\n\t\telse {\n\t\t\tcaps[it.id] = \"switch\"\n\t\t}\n\t}\n\tstate.lightCapabilities = caps\n}\n\nprivate getLevels() {\n\tdef levels = []\n\tfor (int i = 0; i <= 100; i += 5) {\n\t\tlevels << \"$i%\"\n\t}\n\tlevels\n}\n\nprivate getOrientation(xyz=null) {\n\tfinal threshold = 250\n\n\tdef value = xyz ?: cube.currentValue(\"threeAxis\")\n\n\tdef x = Math.abs(value.x) > threshold ? (value.x > 0 ? 1 : -1) : 0\n\tdef y = Math.abs(value.y) > threshold ? (value.y > 0 ? 1 : -1) : 0\n\tdef z = Math.abs(value.z) > threshold ? (value.z > 0 ? 1 : -1) : 0\n\n\tdef orientation = 0\n\tif (z > 0) {\n\t\tif (x == 0 && y == 0) {\n\t\t\torientation = 1\n\t\t}\n\t}\n\telse if (z < 0) {\n\t\tif (x == 0 && y == 0) {\n\t\t\torientation = 2\n\t\t}\n\t}\n\telse {\n\t\tif (x > 0) {\n\t\t\tif (y == 0) {\n\t\t\t\torientation = 3\n\t\t\t}\n\t\t}\n\t\telse if (x < 0) {\n\t\t\tif (y == 0) {\n\t\t\t\torientation = 4\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (y > 0) {\n\t\t\t\torientation = 5\n\t\t\t}\n\t\t\telse if (y < 0) {\n\t\t\t\torientation = 6\n\t\t\t}\n\t\t}\n\t}\n\n\torientation\n}\n\nprivate sceneName(num) {\n\tfinal names = [\"UNDEFINED\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\"]\n\tsettings.\"sceneName${num}\" ?: \"Scene ${names[num]}\"\n}",
        "docstring": "Set your lighting by rotating a cube containing a SmartSense Multi"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe tag, \"nfcTouch\", touchHandler\n    subscribe app, touchHandler\n}\n\nprivate currentStatus(devices, master, attribute) {\n\tlog.trace \"currentStatus($devices, $master, $attribute)\"\n\tdef result = null\n\tif (master) {\n    \tresult = devices.find{it.id == master}?.currentValue(attribute)\n    }\n    else {\n    \tdef map = [:]\n        devices.each {\n        \tdef value = it.currentValue(attribute)\n            map[value] = (map[value] ?: 0) + 1\n            log.trace \"$it.displayName: $value\"\n        }\n        log.trace map\n        result = map.collect{it}.sort{it.value}[-1].key\n    }\n    log.debug \"$attribute = $result\"\n    result\n}\n\ndef touchHandler(evt) {\n\tlog.trace \"touchHandler($evt.descriptionText)\"\n    if (switch1) {\n    \tdef status = currentStatus(switch1, masterSwitch, \"switch\")\n        switch1.each {\n            if (status == \"on\") {\n                it.off()\n            }\n            else {\n                it.on()\n            }\n        }\n    }\n    \n    if (lock) {\n    \tdef status = currentStatus(lock, masterLock, \"lock\")\n        lock.each {\n            if (status == \"locked\") {\n                lock.unlock()\n            }\n            else {\n                lock.lock()\n            }\n        }\n    }\n    \n    if (garageDoor) {\n        def status = currentStatus(garageDoor, masterDoor, \"status\")\n    \tgarageDoor.each {\n        \tif (status == \"open\") {\n            \tit.close()\n            }\n            else {\n            \tit.open()\n            }\n        }\n    }\n}",
        "docstring": "Allows toggling of a switch, lock, or garage door based on an NFC Tag touch event"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$contact1 was opened, sending push message to user\"\n\tsendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n}",
        "docstring": "Get a push message sent to your phone when an open/close sensor is opened."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(button, \"button.pushed\", eventHandler) //tw\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tlog.debug \"Notify got evt ${evt}\"\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}\n}\n\nprivate sendMessage(evt) {\n\tString msg = messageText\n\tMap options = [:]\n\n\tif (!messageText) {\n\t\tmsg = defaultText(evt)\n\t\toptions = [translatable: true, triggerEvent: evt]\n\t}\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients, options)\n\t} else {\n\t\tif (phone) {\n\t\t\toptions.phone = phone\n\t\t\tif (pushAndPhone != 'No') {\n\t\t\t\tlog.debug 'Sending push and SMS'\n\t\t\t\toptions.method = 'both'\n\t\t\t} else {\n\t\t\t\tlog.debug 'Sending SMS'\n\t\t\t\toptions.method = 'phone'\n\t\t\t}\n\t\t} else if (pushAndPhone != 'No') {\n\t\t\tlog.debug 'Sending push'\n\t\t\toptions.method = 'push'\n\t\t} else {\n\t\t\tlog.debug 'Sending nothing'\n\t\t\toptions.method = 'none'\n\t\t}\n\t\tsendNotification(msg, options)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}\n\nprivate defaultText(evt) {\n\tif (evt.name == 'presence') {\n\t\tif (evt.value == 'present') {\n\t\t\tif (includeArticle) {\n\t\t\t\t'{{ triggerEvent.linkText }} has arrived at the {{ location.name }}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t'{{ triggerEvent.linkText }} has arrived at {{ location.name }}'\n\t\t\t}\n\t\t} else {\n\t\t\tif (includeArticle) {\n\t\t\t\t'{{ triggerEvent.linkText }} has left the {{ location.name }}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t'{{ triggerEvent.linkText }} has left {{ location.name }}'\n\t\t\t}\n\t\t}\n\t} else {\n\t\t'{{ triggerEvent.descriptionText }}'\n\t}\n}\n\nprivate getIncludeArticle() {\n\tdef name = location.name.toLowerCase()\n\tdef segs = name.split(\" \")\n\t!([\"work\",\"home\"].contains(name) || (segs.size() > 1 && ([\"the\",\"my\",\"a\",\"an\"].contains(segs[0]) || segs[0].endsWith(\"'s\"))))\n}",
        "docstring": "Receive notifications when anything happens in your home."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n\telse {\n\t\ttakeAction(evt)\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n\n\tdef hueColor = 0\n\tif(color == \"Blue\")\n\t\thueColor = 70//60\n\telse if(color == \"Green\")\n\t\thueColor = 39//30\n\telse if(color == \"Yellow\")\n\t\thueColor = 25//16\n\telse if(color == \"Orange\")\n\t\thueColor = 10\n\telse if(color == \"Purple\")\n\t\thueColor = 75\n\telse if(color == \"Pink\")\n\t\thueColor = 83\n\n\n\tstate.previous = [:]\n\n\thues.each {\n\t\tstate.previous[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\"),\n\t\t\t\"color\": it.currentValue(\"color\")\t\t\t\n\t\t]\n\t}\n\n\tlog.debug \"current values = $state.previous\"\n\n\tdef newValue = [hue: hueColor, saturation: 100, level: (lightLevel as Integer) ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n\tsetTimer()\n}\n\ndef setTimer()\n{\n\tif(!duration) //default to 10 seconds\n\t{\n\t\tlog.debug \"pause 10\"\n\t\tpause(10 * 1000)\n\t\tlog.debug \"reset hue\"\n\t\tresetHue()\n\t}\n\telse if(duration < 10)\n\t{\n\t\tlog.debug \"pause $duration\"\n\t\tpause(duration * 1000)\n\t\tlog.debug \"resetHue\"\n\t\tresetHue()\n\t}\n\telse\n\t{\n\t\tlog.debug \"runIn $duration, resetHue\"\n\t\trunIn(duration,\"resetHue\", [overwrite: false])\n\t}\n}\n\n\ndef resetHue()\n{\n\thues.each {\n\t\tit.setColor(state.previous[it.id])        \n\t}\n}",
        "docstring": "Changes the color and brightness of Philips Hue bulbs when any of a variety of SmartThings is activated.  Supports motion, contact, acceleration, moisture and presence sensors as well as switches."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(startTime, \"startTimerCallback\")\n\tschedule(stopTime, \"stopTimerCallback\")\n\n}\n\ndef updated(settings) {\n\tunschedule()\n\tschedule(startTime, \"startTimerCallback\")\n\tschedule(stopTime, \"stopTimerCallback\")\n}\n\ndef startTimerCallback() {\n\tlog.debug \"Turning on switches\"\n\tswitches.on()\n\n}\n\ndef stopTimerCallback() {\n\tlog.debug \"Turning off switches\"\n\tswitches.off()\n}",
        "docstring": "Turn on one or more switches at a specified time and turn them off at a later time."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(contact, \"contact.open\", sendMessage)\n\tsubscribe(acceleration, \"acceleration.active\", sendMessage)\n\tsubscribe(motion, \"motion.active\", sendMessage)\n\tsubscribe(mySwitch, \"switch.on\", sendMessage)\n\tsubscribe(arrivalPresence, \"presence.present\", sendMessage)\n\tsubscribe(departurePresence, \"presence.not present\", sendMessage)\n}\n\ndef sendMessage(evt) {\n\tlog.debug \"$evt.name: $evt.value, $messageText\"\n\n    camera.take()\n\t(1..((burstCount ?: 5) - 1)).each {\n\t\tcamera.take(delay: (500 * it))\n\t}\n\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(messageText, recipients)\n    }\n    else {\n        sendPush(messageText)\n        if (phone) {\n            sendSms(phone, messageText)\n        }\n    }\n}",
        "docstring": "Take a burst of photos and send a push notification when..."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(theSwitch, \"switch.on\", switchOnHandler, [filterEvents: false])\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe(theSwitch, \"switch.on\", switchOnHandler, [filterEvents: false])\n}\n\ndef switchOnHandler(evt) {\n\tlog.debug \"Switch ${theSwitch} turned: ${evt.value}\"\n\tdef delay = minutesLater * 60\n\tlog.debug \"Turning off in ${minutesLater} minutes (${delay}seconds)\"\n\trunIn(delay, turnOffSwitch)\n}\n\ndef turnOffSwitch() {\n\ttheSwitch.off()\n}",
        "docstring": "Save energy or restrict total time an appliance (like a curling iron or TV) can be in use.  When a switch turns on, automatically turn it back off after a set number of minutes you specify."
    },
    {
        "code": "def installed() {\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt) {\n\tif (evt.value == \"present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has arrived at the ${location}\"\n    \tsendPush(\"${presence.label ?: presence.name} has arrived at the ${location}\")\n\t} else if (evt.value == \"not present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has left the ${location}\"\n    \tsendPush(\"${presence.label ?: presence.name} has left the ${location}\")\n\t}\n}",
        "docstring": "Get a push notification when a SmartSense Presence tag or smartphone arrives at or departs from a location."
    },
    {
        "code": "def installed() {\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt) {\n\tif (evt.value == \"present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has arrived at the ${location}\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"${presence.label ?: presence.name} has arrived at the ${location}\", recipients)\n        }\n        else {\n            sendSms(phone1, \"${presence.label ?: presence.name} has arrived at the ${location}\")\n        }\n\t} else if (evt.value == \"not present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has left the ${location}\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"${presence.label ?: presence.name} has left the ${location}\", recipients)\n        }\n        else {\n            sendSms(phone1, \"${presence.label ?: presence.name} has left the ${location}\")\n        }\n\t}\n}",
        "docstring": "Send me a text message when my presence status changes."
    },
    {
        "code": "def installed() {\n\tlog.trace \"installed()\"\n\tsubscribe()\n}\n\ndef updated() {\n\tlog.trace \"updated()\"\n\tunsubscribe()\n\tsubscribe()\n}\n\ndef subscribe() {\n\t// log.debug \"present: ${cars.collect{it.displayName + ': ' + it.currentPresence}}\"\n\tsubscribe(doorSensor, \"contact\", garageDoorContact)\n\n\tsubscribe(cars, \"presence\", carPresence)\n\tsubscribe(carDoorSensors, \"acceleration\", accelerationActive)\n\n\tif (interiorDoorSensor) {\n\t\tsubscribe(interiorDoorSensor, \"contact.closed\", interiorDoorClosed)\n\t}\n}\n\ndef doorOpenCheck()\n{\n\tfinal thresholdMinutes = openThreshold\n\tif (thresholdMinutes) {\n\t\tdef currentState = doorSensor.contactState\n\t\tlog.debug \"doorOpenCheck\"\n\t\tif (currentState?.value == \"open\") {\n\t\t\tlog.debug \"open for ${now() - currentState.date.time}, openDoorNotificationSent: ${state.openDoorNotificationSent}\"\n\t\t\tif (!state.openDoorNotificationSent && now() - currentState.date.time > thresholdMinutes * 60 *1000) {\n\t\t\t\tdef msg = \"${doorSwitch.displayName} has been open for ${thresholdMinutes} minutes\"\n\t\t\t\tlog.info msg\n\n                if (location.contactBookEnabled) {\n                    sendNotificationToContacts(msg, recipients)\n                }\n                else {\n                    sendPush msg\n                    if (phone) {\n                        sendSms phone, msg\n                    }\n                }\n\t\t\t\tstate.openDoorNotificationSent = true\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate.openDoorNotificationSent = false\n\t\t}\n\t}\n}\n\ndef carPresence(evt)\n{\n\tlog.info \"$evt.name: $evt.value\"\n\t// time in which there must be no \"not present\" events in order to open the door\n\tfinal openDoorAwayInterval = falseAlarmThreshold ? falseAlarmThreshold * 60 : 600\n\n\tif (evt.value == \"present\") {\n\t\t// A car comes home\n\n\t\tdef car = getCar(evt)\n\t\tdef t0 = new Date(now() - (openDoorAwayInterval * 1000))\n\t\tdef states = car.statesSince(\"presence\", t0)\n\t\tdef recentNotPresentState = states.find{it.value == \"not present\"}\n\n\t\tif (recentNotPresentState) {\n\t\t\tlog.debug \"Not opening ${doorSwitch.displayName} since car was not present at ${recentNotPresentState.date}, less than ${openDoorAwayInterval} sec ago\"\n\t\t}\n\t\telse {\n\t\t\tif (doorSensor.currentContact == \"closed\") {\n\t\t\t\topenDoor()\n                sendPush \"Opening garage door due to arrival of ${car.displayName}\"\n                state.appOpenedDoor = now()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.debug \"door already open\"\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// A car departs\n\t\tif (doorSensor.currentContact == \"open\") {\n\t\t\tcloseDoor()\n\t\t\tlog.debug \"Closing ${doorSwitch.displayName} after departure\"\n            sendPush(\"Closing ${doorSwitch.displayName} after departure\")\n\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not closing ${doorSwitch.displayName} because its already closed\"\n\t\t}\n\t}\n}\n\ndef garageDoorContact(evt)\n{\n\tlog.info \"garageDoorContact, $evt.name: $evt.value\"\n\tif (evt.value == \"open\") {\n\t\tschedule(\"0 * * * * ?\", \"doorOpenCheck\")\n\t}\n\telse {\n\t\tunschedule(\"doorOpenCheck\")\n\t}\n}\n\n\ndef interiorDoorClosed(evt)\n{\n\tlog.info \"interiorContact, $evt.name: $evt.value\"\n\n\t// time during which closing the interior door will shut the garage door, if the app opened it\n\tfinal threshold = 15 * 60 * 1000\n\tif (state.appOpenedDoor && now() - state.appOpenedDoor < threshold) {\n\t\tstate.appOpenedDoor = 0\n\t\tcloseDoor()\n\t}\n\telse {\n\t\tlog.debug \"app didn't open door\"\n\t}\n}\n\ndef accelerationActive(evt)\n{\n\tlog.info \"$evt.name: $evt.value\"\n\n\tif (doorSensor.currentContact == \"closed\") {\n\t\tlog.debug \"opening door when car door opened\"\n\t\topenDoor()\n\t}\n}\n\nprivate openDoor()\n{\n\tif (doorSensor.currentContact == \"closed\") {\n\t\tlog.debug \"opening door\"\n\t\tdoorSwitch.push()\n\t}\n}\n\nprivate closeDoor()\n{\n\tif (doorSensor.currentContact == \"open\") {\n\t\tlog.debug \"closing door\"\n\t\tdoorSwitch.push()\n\t}\n}\n\nprivate getCar(evt)\n{\n\tcars.find{it.id == evt.deviceId}\n}",
        "docstring": "Monitors arrival and departure of car(s) and 1) opens door when car arrives, 2) closes door after car has departed (for N minutes), 3) opens door when car door motion is detected, 4) closes door when door was opened due to arrival and interior door is closed."
    },
    {
        "code": "def installed() {\n\tlog.debug \"installed, current mode = ${location.mode}, state.actionTakenOn = ${state.actionTakenOn}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"updated, current mode = ${location.mode}, state.actionTakenOn = ${state.actionTakenOn}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.trace \"timeOfDay: $timeOfDay, endTime: $endTime\"\n\tsubscribe(motionSensors, \"motion.active\", motionActiveHandler)\n\tsubscribe(location, modeChangeHandler)\n\tif (state.modeStartTime == null) {\n\t\tstate.modeStartTime = 0\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tstate.modeStartTime = now()\n}\n\ndef motionActiveHandler(evt)\n{\n\t// for backward compatibility\n\tif (state.modeStartTime == null) {\n\t\tsubscribe(location, modeChangeHandler)\n\t\tstate.modeStartTime = 0\n\t}\n\n\tdef t0 = now()\n\tdef modeStartTime = new Date(state.modeStartTime)\n\tdef timeZone = location.timeZone ?: timeZone(timeOfDay)\n\tdef startTime = timeTodayAfter(modeStartTime, timeOfDay, timeZone)\n\tdef endTime = timeTodayAfter(startTime, endTime ?: \"16:00\", timeZone)\n\tlog.debug \"startTime: $startTime, endTime: $endTime, t0: ${new Date(t0)}, modeStartTime: ${modeStartTime},  actionTakenOn: $state.actionTakenOn, currentMode: $location.mode, newMode: $newMode \"\n\n\tif (t0 >= startTime.time && t0 <= endTime.time && location.mode != newMode) {\n\t\tdef message = \"Good morning! SmartThings changed the mode to '$newMode'\"\n\t\tsend(message)\n\t\tsetLocationMode(newMode)\n\t\tlog.debug message\n\n\t\tdef dateString = new Date().format(\"yyyy-MM-dd\")\n\t\tlog.debug \"last turned on switches on ${state.actionTakenOn}, today is ${dateString}\"\n\t\tif (state.actionTakenOn != dateString) {\n\t\t\tlog.debug \"turning on switches\"\n\t\t\tstate.actionTakenOn = dateString\n\t\t\tswitches?.on()\n\t\t}\n\n\t}\n\telse {\n\t\tlog.debug \"not in time window, or mode is already set, currentMode = ${location.mode}, newMode = $newMode\"\n\t}\n}\n\nprivate send(msg) {\n\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}",
        "docstring": "Changes mode when someone wakes up after a set time in the morning."
    },
    {
        "code": "def installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tschedule(time, changeMode)\n}\n\ndef changeMode() {\n\tlog.debug \"changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes\"\n\tif (location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t\tsend \"${label} has changed the mode to '${newMode}'\"\n\t\t}\n\t\telse {\n\t\t\tsend \"${label} tried to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage == \"Yes\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}\n\nprivate getLabel() {\n\tapp.label ?: \"SmartThings\"\n}",
        "docstring": "Changes mode at a specific time of day."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tsendHttp()\n}\n\ndef sendHttp() {\ndef ip = \"${settings.server}:${settings.port}\"\ndef deviceNetworkId = \"1234\"\nsendHubCommand(new physicalgraph.device.HubAction(\"\"\"GET /?${settings.HAMBcommand} HTTP/1.1\\r\\nHOST: $ip\\r\\n\\r\\n\"\"\", physicalgraph.device.Protocol.LAN, \"${deviceNetworkId}\"))\n}",
        "docstring": "Sends a command to your HAM Bridge server when SmartThings are activated."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    scheduleJob()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unschedule()\n    scheduleJob()\n}\n\ndef scheduleJob() {\n    def sec = Math.round(Math.floor(Math.random() * 60))\n    def min = Math.round(Math.floor(Math.random() * 60))\n    def cron = \"$sec $min * * * ?\"\n    schedule(cron, \"checkForSevereWeather\")\n}\n\ndef checkForSevereWeather() {\n    def alerts\n    if(locationIsDefined()) {\n        if(!(zipcodeIsValid())) {\n            log.warn \"Severe Weather Alert: Invalid zipcode entered, defaulting to location's zipcode\"\n        }\n        def zipToLocation = getTwcLocation(\"$zipCode\").location\n        alerts = getTwcAlerts(\"${zipToLocation.latitude},${zipToLocation.longitude}\")\n    } else {\n        log.warn \"Severe Weather Alert: Location is not defined\"\n    }\n\n    if (alerts) {\n        alerts.each {alert ->\n            def msg = alert.headlineText\n            if (alert.effectiveTimeLocal && !msg.contains(\" from \")) {\n                msg += \" from ${parseAlertTime(alert.effectiveTimeLocal).format(\"E hh:mm a\", TimeZone.getTimeZone(alert.effectiveTimeLocalTimeZone))}\"\n            }\n            if (alert.expireTimeLocal && !msg.contains(\" until \")) {\n                msg += \" until ${parseAlertTime(alert.expireTimeLocal).format(\"E hh:mm a\", TimeZone.getTimeZone(alert.expireTimeLocalTimeZone))}\"\n            }\n            send(msg)\n        }\n    } else {\n        log.info \"No current alerts\"\n    }\n}\n\ndef descriptionFilter(String description) {\n    def filterList = [\"special\", \"statement\", \"test\"]\n    def passesFilter = true\n    filterList.each() { word ->\n        if(description.toLowerCase().contains(word)) { passesFilter = false }\n    }\n    passesFilter\n}\n\ndef locationIsDefined() {\n    zipcodeIsValid() || location.zipCode || ( location.latitude && location.longitude )\n}\n\ndef zipcodeIsValid() {\n    zipCode && zipCode.isNumber() && zipCode.size() == 5\n}\n\nprivate send(message) {\n    sendPush message\n    if (settings.phone1) {\n        sendSms phone1, message\n    }\n    if (settings.phone2) {\n        sendSms phone2, message\n    }\n    if (settings.phone3) {\n        sendSms phone3, message\n    }\n}",
        "docstring": "Get a push notification when severe weather is in your area."
    },
    {
        "code": "def installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef configured() {\n\treturn buttonDevice || buttonConfigured(1)\n}\n\ndef buttonConfigured(idx) {\n\treturn settings[\"lights_$idx_pushed\"] ||\n\t\tsettings[\"locks_$idx_pushed\"] ||\n\t\tsettings[\"sonos_$idx_pushed\"] ||\n\t\tsettings[\"mode_$idx_pushed\"]\n}\n\ndef buttonEvent(evt){\n\tdef buttonNumber = evt.data // why doesn't jsonData work? always returning [:]\n\tdef value = evt.value\n\tlog.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\tlog.debug \"button: $buttonNumber, value: $value\"\n\n\tdef recentEvents = buttonDevice.eventsSince(new Date(now() - 3000)).findAll{it.value == evt.value}\n\tlog.debug \"Found ${recentEvents.size()?:0} events in past 3 seconds\"\n\n\texecuteHandlers(1, value)\n}\n\ndef executeHandlers(buttonNumber, value) {\n\tlog.debug \"executeHandlers: $buttonNumber - $value\"\n\n\tdef lights = find('lights', buttonNumber, value)\n\tif (lights != null) toggle(lights)\n\n\tdef locks = find('locks', buttonNumber, value)\n\tif (locks != null) toggle(locks)\n\n\tdef sonos = find('sonos', buttonNumber, value)\n\tif (sonos != null) toggle(sonos)\n\n\tdef mode = find('mode', buttonNumber, value)\n\tif (mode != null) changeMode(mode)\n\n\tdef phrase = find('phrase', buttonNumber, value)\n\tif (phrase != null) location.helloHome.execute(phrase)\n}\n\ndef find(type, buttonNumber, value) {\n\tdef preferenceName = type + \"_\" + buttonNumber + \"_\" + value\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef toggle(devices) {\n\tlog.debug \"toggle: $devices = ${devices*.currentValue('switch')}\"\n\n\tif (devices*.currentValue('switch').contains('on')) {\n\t\tdevices.off()\n\t}\n\telse if (devices*.currentValue('switch').contains('off')) {\n\t\tdevices.on()\n\t}\n\telse if (devices*.currentValue('lock').contains('locked')) {\n\t\tdevices.unlock()\n\t}\n\telse if (devices*.currentValue('lock').contains('unlocked')) {\n\t\tdevices.lock()\n\t}\n\telse {\n\t\tdevices.on()\n\t}\n}\n\ndef changeMode(mode) {\n\tlog.debug \"changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes\"\n\n\tif (location.mode != mode && location.modes?.find { it.name == mode }) {\n\t\tsetLocationMode(mode)\n\t}\n}",
        "docstring": "Use your Aeon Panic Button to setup events when the button is used"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n    \n    log.debug \"Subscribing to sleeping events.\"\n    \n   \tsubscribe (jawbone, \"sleeping\", jawboneHandler)\n    \n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n    \n    log.debug \"Subscribing to sleeping events.\"\n        \n   \tsubscribe (jawbone, \"sleeping\", jawboneHandler)\n    \n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef jawboneHandler(evt) {\n\tlog.debug \"In Jawbone Event Handler, Event Name = ${evt.name}, Value = ${evt.value}\"\n\tif (evt.value == \"sleeping\" && sleepPhrase) {\n    \tlog.debug \"Sleeping\"\n        sendNotificationEvent(\"Sleepy Time performing \\\"${sleepPhrase}\\\" for you as requested.\")\n    \tlocation.helloHome.execute(settings.sleepPhrase)\n    }\n    else if (evt.value == \"not sleeping\" && wakePhrase) {\n    \tlog.debug \"Awake\"\n        sendNotificationEvent(\"Sleepy Time performing \\\"${wakePhrase}\\\" for you as requested.\")\n\t\tlocation.helloHome.execute(settings.wakePhrase)\n    }\n        \n}",
        "docstring": "Use Jawbone sleep mode events to automatically execute Hello, Home phrases. Automatially put the house to bed or wake it up in the morning by pushing the button on your UP."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tif(noRecentContact() && noRecentMotion()) {\n\t\tdef person = person1 ?: \"your elder\"\n\t\tdef msg = \"Alert! There has been no activity at ${person}\u2018s place ${timePhrase}\"\n\t\tlog.debug msg\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tif (phone1) {\n\t\t\t\tsendSms(phone1, msg)\n\t\t\t} else {\n\t\t\t\tsendPush(msg)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"There has been activity ${timePhrase}, not sending alert\"\n\t}\n}\n\nprivate noRecentMotion()\n{\n\tif(motion1) {\n\t\tdef motionEvents = motion1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} motion events\"\n\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"There have been recent \u2018active\u2019 events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent \u2018active\u2019 events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate noRecentContact()\n{\n\tif(contact1) {\n\t\tdef contactEvents = contact1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${contactEvents?.size() ?: 0} door events\"\n\t\tif (contactEvents.find { it.value == \"open\" }) {\n\t\t\tlog.debug \"There have been recent \u2018open\u2019 events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent \u2018open\u2019 events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Contact sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate getSinceTime() {\n\tif (time0) {\n\t\treturn timeToday(time0, location?.timeZone)\n\t}\n\telse {\n\t\treturn new Date(now() - 21600000)\n\t}\n}\n\nprivate getTimePhrase() {\n\tdef interval = now() - sinceTime.time\n\tif (interval < 3600000) {\n\t\treturn \"in the past ${Math.round(interval/60000)} minutes\"\n\t}\n\telse if (interval < 7200000) {\n\t\treturn \"in the past hour\"\n\t}\n\telse {\n\t\treturn \"in the past ${Math.round(interval/3600000)} hours\"\n\t}\n}",
        "docstring": "Stay connected to your loved ones. Get notified if they are not up and moving around by a specified time and/or if they have not opened a cabinet or door according to a set schedule."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.active = 0\n\tsubscribe(bedroomMotion, \"motion.active\", bedroomActive)\n\tsubscribe(bathroomMotion, \"motion.active\", bathroomActive)\n}\n\ndef bedroomActive(evt) {\n\tdef start = timeToday(startTime, location?.timeZone)\n\tdef stop = timeToday(stopTime, location?.timeZone)\n\tdef now = new Date()\n\tlog.debug \"bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now\"\n\tif (state.status == \"waiting\") {\n\t\tlog.debug \"motion detected in bedroom, disarming\"\n\t\tunschedule(\"sendMessage\")\n\t\tstate.status = null\n\t}\n\telse {\n\t\tif (start.before(now) && stop.after(now)) {\n\t\t\tlog.debug \"motion in bedroom, look for bathroom motion\"\n\t\t\tstate.status = \"pending\"\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not in time window\"\n\t\t}\n\t}\n}\n\ndef bathroomActive(evt) {\n\tlog.debug \"bathroomActive, status: $state.status\"\n\tif (state.status == \"pending\") {\n\t\tdef delay = threshold.toInteger() * 60\n\t\tstate.status = \"waiting\"\n\t\tlog.debug \"runIn($delay)\"\n\t\trunIn(delay, sendMessage)\n\t}\n}\n\ndef sendMessage() {\n\tlog.debug \"sendMessage\"\n\tdef msg = warnMessage\n\tlog.info msg\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse {\n\t\tsendPush msg\n\t\tif (phone1) {\n\t\t\tsendSms phone1, msg\n\t\t}\n\t\tif (phone2) {\n\t\t\tsendSms phone2, msg\n\t\t}\n\t\tif (phone3) {\n\t\t\tsendSms phone3, msg\n\t\t}\n\t}\n\tstate.status = null\n}",
        "docstring": "Monitors motion sensors in bedroom and bathroom during the night and detects if occupant does not return from the bathroom after a specified period of time."
    },
    {
        "code": "def installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(motionSensor, \"motion\", motionHandler)\n\tif (lightSensor) {\n\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t}\n\telse {\n\t\tsubscribe(location, \"position\", locationPositionChange)\n\t\tsubscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n\t\tsubscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\tastroCheck()\n\t}\n}\n\ndef locationPositionChange(evt) {\n\tlog.trace \"locationChange()\"\n\tastroCheck()\n}\n\ndef sunriseSunsetTimeHandler(evt) {\n\tstate.lastSunriseSunsetEvent = now()\n\tlog.debug \"SmartNightlight.sunriseSunsetTimeHandler($app.id)\"\n\tastroCheck()\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"active\") {\n\t\tif (enabled()) {\n\t\t\tlog.debug \"turning on lights due to motion\"\n\t\t\tlights.on()\n\t\t\tstate.lastStatus = \"on\"\n\t\t}\n\t\tstate.motionStopTime = null\n\t}\n\telse {\n\t\tstate.motionStopTime = now()\n\t\tif(delayMinutes) {\n\t\t\trunIn(delayMinutes*60, turnOffMotionAfterDelay, [overwrite: true])\n\t\t} else {\n\t\t\tturnOffMotionAfterDelay()\n\t\t}\n\t}\n}\n\ndef illuminanceHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value, lastStatus: $state.lastStatus, motionStopTime: $state.motionStopTime\"\n\tdef lastStatus = state.lastStatus\n\tif (lastStatus != \"off\" && evt.integerValue > 50) {\n\t\tlights.off()\n\t\tstate.lastStatus = \"off\"\n\t}\n\telse if (state.motionStopTime) {\n\t\tif (lastStatus != \"off\") {\n\t\t\tdef elapsed = now() - state.motionStopTime\n\t\t\tif (elapsed >= ((delayMinutes ?: 0) * 60000L) - 2000) {\n\t\t\t\tlights.off()\n\t\t\t\tstate.lastStatus = \"off\"\n\t\t\t}\n\t\t}\n\t}\n\telse if (lastStatus != \"on\" && evt.integerValue < 30){\n\t\tlights.on()\n\t\tstate.lastStatus = \"on\"\n\t}\n}\n\ndef turnOffMotionAfterDelay() {\n\tlog.trace \"In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus\"\n\tif (state.motionStopTime && state.lastStatus != \"off\") {\n\t\tdef elapsed = now() - state.motionStopTime\n        log.trace \"elapsed = $elapsed\"\n\t\tif (elapsed >= ((delayMinutes ?: 0) * 60000L) - 2000) {\n        \tlog.debug \"Turning off lights\"\n\t\t\tlights.off()\n\t\t\tstate.lastStatus = \"off\"\n\t\t}\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"In scheduleCheck - skipping\"\n\t//turnOffMotionAfterDelay()\n}\n\ndef astroCheck() {\n\tdef s = getSunriseAndSunset(zipCode: zipCode, sunriseOffset: sunriseOffset, sunsetOffset: sunsetOffset)\n\tstate.riseTime = s.sunrise.time\n\tstate.setTime = s.sunset.time\n\tlog.debug \"rise: ${new Date(state.riseTime)}($state.riseTime), set: ${new Date(state.setTime)}($state.setTime)\"\n}\n\nprivate enabled() {\n\tdef result\n\tif (lightSensor) {\n\t\tresult = lightSensor.currentIlluminance?.toInteger() < 30\n\t}\n\telse {\n\t\tdef t = now()\n\t\tresult = t < state.riseTime || t > state.setTime\n\t}\n\tresult\n}\n\nprivate getSunriseOffset() {\n\tsunriseOffsetValue ? (sunriseOffsetDir == \"Before\" ? \"-$sunriseOffsetValue\" : sunriseOffsetValue) : null\n}\n\nprivate getSunsetOffset() {\n\tsunsetOffsetValue ? (sunsetOffsetDir == \"Before\" ? \"-$sunsetOffsetValue\" : sunsetOffsetValue) : null\n}",
        "docstring": "Turns on lights when it's dark and motion is detected. Turns lights off when it becomes light or some time after motion ceases."
    },
    {
        "code": "def installed() {\n\tlog.debug \"INSTALLED\"\n\tsubscribeToEvents()\n\tstate.alarmActive = null\n}\n\ndef updated() {\n\tlog.debug \"UPDATED\"\n\tunsubscribe()\n\tsubscribeToEvents()\n\tunschedule()\n\tstate.alarmActive = null\n\tstate.residentsAreUp = null\n\tstate.lastIntruderMotion = null\n\talarms?.off()\n}\n\nprivate subscribeToEvents()\n{\n\tsubscribe intrusionMotions, \"motion\", intruderMotion\n\t// subscribe residentMotions, \"motion\", residentMotion\n\tsubscribe intrusionContacts, \"contact\", contact\n\tsubscribe alarms, \"alarm\", alarm\n\tsubscribe(app, appTouch)\n}\n\nprivate residentsHaveBeenQuiet()\n{\n\tdef threshold = ((residentsQuietThreshold != null && residentsQuietThreshold != \"\") ? residentsQuietThreshold : 3) * 60 * 1000\n\tdef result = true\n\tdef t0 = new Date(now() - threshold)\n\tfor (sensor in residentMotions) {\n\t\tdef recentStates = sensor.statesSince(\"motion\", t0)\n\t\tif (recentStates.find{it.value == \"active\"}) {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"residentsHaveBeenQuiet: $result\"\n\tresult\n}\n\nprivate intruderMotionInactive()\n{\n\tdef result = true\n\tfor (sensor in intrusionMotions) {\n\t\tif (sensor.currentMotion == \"active\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tresult\n}\n\nprivate isResidentMotionSensor(evt)\n{\n\tresidentMotions?.find{it.id == evt.deviceId} != null\n}\n\ndef appTouch(evt)\n{\n\talarms?.off()\n\tstate.alarmActive = false\n}\n\n// Here to handle old subscriptions\ndef motion(evt)\n{\n\tif (isResidentMotionSensor(evt)) {\n\t\tlog.debug \"resident motion, $evt.name: $evt.value\"\n\t\tresidentMotion(evt)\n\t}\n\telse {\n\t\tlog.debug \"intruder motion, $evt.name: $evt.value\"\n\t\tintruderMotion(evt)\n\t}\n}\n\ndef intruderMotion(evt)\n{\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"motion by potential intruder, residentsAreUp: $state.residentsAreUp\"\n\t\tif (!state.residentsAreUp) {\n\t\t\tlog.trace \"checking if residents have been quiet\"\n\t\t\tif (residentsHaveBeenQuiet()) {\n\t\t\t\tlog.trace \"calling startAlarmSequence\"\n\t\t\t\tstartAlarmSequence()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.trace \"calling disarmIntrusionDetection\"\n\t\t\t\tdisarmIntrusionDetection()\n\t\t\t}\n\t\t}\n\t}\n\tstate.lastIntruderMotion = now()\n}\n\ndef residentMotion(evt)\n{\n\t// Don't think we need this any more\n\t//if (evt.value == \"inactive\") {\n\t//\tif (state.residentsAreUp) {\n\t//    \tstartReArmSequence()\n\t//    }\n\t//}\n  unsubscribe(residentMotions)\n}\n\ndef contact(evt)\n{\n\tif (evt.value == \"open\") {\n\t\t// TODO - check for residents being up?\n\t\tif (!state.residentsAreUp) {\n\t\t\tif (residentsHaveBeenQuiet()) {\n\t\t\t\tstartAlarmSequence()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisarmIntrusionDetection()\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef alarm(evt)\n{\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"off\") {\n\t\talarms?.off()\n\t\tstate.alarmActive = false\n\t}\n}\n\nprivate disarmIntrusionDetection()\n{\n\tlog.debug \"residents are up, disarming intrusion detection\"\n\tstate.residentsAreUp = true\n\tscheduleReArmCheck()\n}\n\nprivate scheduleReArmCheck()\n{\n\tdef cron = \"0 * * * * ?\"\n\tschedule(cron, \"checkForReArm\")\n\tlog.debug \"Starting re-arm check, cron: $cron\"\n}\n\ndef checkForReArm()\n{\n\tdef threshold = ((residentsQuietThreshold != null && residentsQuietThreshold != \"\") ? residentsQuietThreshold : 3) * 60 * 1000\n\tlog.debug \"checkForReArm: threshold is $threshold\"\n\t// check last intruder motion\n\tdef lastIntruderMotion = state.lastIntruderMotion\n\tlog.debug \"checkForReArm: lastIntruderMotion=$lastIntruderMotion\"\n\tif (lastIntruderMotion != null)\n\t{\n\t\tlog.debug \"checkForReArm, time since last intruder motion: ${now() - lastIntruderMotion}\"\n\t\tif (now() - lastIntruderMotion > threshold) {\n\t\t\tlog.debug \"re-arming intrusion detection\"\n\t\t\tstate.residentsAreUp = false\n\t\t\tunschedule()\n\t\t}\n\t}\n\telse {\n\t\tlog.warn \"checkForReArm: lastIntruderMotion was null, unable to check for re-arming intrusion detection\"\n\t}\n}\n\nprivate startAlarmSequence()\n{\n\tif (state.alarmActive) {\n\t\tlog.debug \"alarm already active\"\n\t}\n\telse {\n\t\tstate.alarmActive = true\n\t\tlog.debug \"starting alarm sequence\"\n\n\t\tsendPush(\"Potential intruder detected!\")\n\n\t\tif (newMode) {\n\t\t\tsetLocationMode(newMode)\n\t\t}\n\n\t\tif (silentAlarm()) {\n\t\t\tlog.debug \"Silent alarm only\"\n\t\t\talarms?.strobe()\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(textMessage ?: \"Potential intruder detected\", recipients)\n            }\n            else {\n                if (phone) {\n                    sendSms(phone, textMessage ?: \"Potential intruder detected\")\n                }\n            }\n\t\t}\n\t\telse {\n\t\t\tdef delayTime = seconds\n\t\t\tif (delayTime) {\n\t\t\t\talarms?.strobe()\n\t\t\t\trunIn(delayTime, \"soundSiren\")\n\t\t\t\tlog.debug \"Sounding siren in $delayTime seconds\"\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsoundSiren()\n\t\t\t}\n\t\t}\n\n\t\tif (lights) {\n\t\t\tflashLights(Math.min((seconds/2) as Integer, 10))\n\t\t}\n\t}\n}\n\ndef soundSiren()\n{\n\tif (state.alarmActive) {\n\t\tlog.debug \"Sounding siren\"\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(textMessage ?: \"Potential intruder detected\", recipients)\n        }\n        else {\n            if (phone) {\n                sendSms(phone, textMessage ?: \"Potential intruder detected\")\n            }\n        }\n\t\talarms?.both()\n\t\tif (lights) {\n\t\t\tlog.debug \"continue flashing lights\"\n\t\t\tcontinueFlashing()\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"alarm activation aborted\"\n\t}\n\tunschedule(\"soundSiren\") // Temporary work-around to scheduling bug\n}\n\ndef continueFlashing()\n{\n\tunschedule()\n\tif (state.alarmActive) {\n\t\tflashLights(10)\n\t\tschedule(util.cronExpression(now() + 10000), \"continueFlashing\")\n\t}\n}\n\nprivate flashLights(numFlashes) {\n\tdef onFor = 1000\n\tdef offFor = 1000\n\n\tlog.debug \"FLASHING $numFlashes times\"\n\tdef delay = 1L\n\tnumFlashes.times {\n\t\tlog.trace \"Switch on after  $delay msec\"\n\t\tlights?.on(delay: delay)\n\t\tdelay += onFor\n\t\tlog.trace \"Switch off after $delay msec\"\n\t\tlights?.off(delay: delay)\n\t\tdelay += offFor\n\t}\n}\n\nprivate silentAlarm()\n{\n\tsilent?.toLowerCase() in [\"yes\",\"true\",\"y\"]\n}",
        "docstring": "Alerts you when there are intruders but not when you just got up for a glass of water in the middle of the night"
    },
    {
        "code": "def updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n    scheduledEvent()\n}\n\ndef scheduledEvent() {\n\tlog.info \"SmartWeather Station Controller / scheduledEvent terminated due to deprecation\" // device handles this itself now -- Bob\n/*\n\tlog.trace \"scheduledEvent()\"\n\n\tdef delayTimeSecs = 60 * 60 // reschedule every 60 minutes\n\tdef runAgainWindowMS = 58 * 60 * 1000 // can run at most every 58 minutes\n\tdef timeSinceLastRunMS = state.lastRunTime ? now() - state.lastRunTime : null //how long since it last ran?\n\n\tif(!timeSinceLastRunMS || timeSinceLastRunMS > runAgainWindowMS){\n\t\trunIn(delayTimeSecs, scheduledEvent, [overwrite: false])\n\t\tstate.lastRunTime = now()\n\t\tweatherDevices.refresh()\n\t} else {\n\t\tlog.trace \"Trying to run smartweather-station-controller too soon. Has only been ${timeSinceLastRunMS} ms but needs to be at least ${runAgainWindowMS} ms\"\n\t}\n    */\n}",
        "docstring": "Updates SmartWeather Station Tile devices every hour."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsaveSelectedSongs()\n\n\tsubscribe(location, modeChangeHandler)\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler($evt.name: $evt.value)\"\n\tif (allOk) {\n\t\tif (frequency) {\n\t\t\tdef lastTime = state[frequencyKey(evt)]\n\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n}\n\nprivate takeAction(evt) {\n\n\tdef name = \"mode_$evt.value\".toString()\n\tdef selectedSong = state.selectedSongs.\"$name\"\n\n\tif (selectedSong == \"PAUSE\") {\n\t\tsonos.stop()\n\t}\n\telse {\n\t\tlog.info \"Playing '$selectedSong\"\n\n\t\tif (volume != null) {\n\t\t\tsonos.stop()\n\t\t\tpause(500)\n\t\t\tsonos.setLevel(volume)\n\t\t\tpause(500)\n\t\t}\n\n\t\tsonos.playTrack(selectedSong)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Plays a different selected song or station for each mode."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef buttonEvent(evt){\n\tdef buttonNumber = evt.data\n\tdef value = evt.value\n    log.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\tlog.debug \"button: $buttonNumber, value: $value\"\n    \n    def recentEvents = buttonDevice.eventsSince(new Date(now() - 2000)).findAll{it.value == evt.value && it.data == evt.data}\n    log.debug \"Found ${recentEvents.size()?:0} events in past 2 seconds\"\n    \n    if(recentEvents.size <= 1){\n        handleButton(extractButtonNumber(buttonNumber), value)\n    } else {\n    \tlog.debug \"Found recent button press events for $buttonNumber with value $value\"\n    }\n}\n\ndef extractButtonNumber(data) {\n\tdef buttonNumber\n    //TODO must be a better way to do this. Data is like {buttonNumber:1}\n    switch(data) {\n        case ~/.*1.*/:\n            buttonNumber = 1\n            break\n        case ~/.*2.*/:\n            buttonNumber = 2\n            break\n        case ~/.*3.*/:\n            buttonNumber = 3\n            break\n        case ~/.*4.*/:\n            buttonNumber = 4\n            break\n    }\n    return buttonNumber\n}\n\ndef handleButton(buttonNumber, value) {\n\tswitch([number: buttonNumber, value: value]) {\n        case{it.number == 1 && it.value == 'pushed'}:\n            log.debug \"Button 1 pushed - Play/Pause\"\n            togglePlayPause()\n            break\n        case{it.number == 2 && it.value == 'pushed'}:\n            log.debug \"Button 2 pushed - Volume Up\"\n            adjustVolume(true, false)\n            break\n        case{it.number == 3 && it.value == 'pushed'}:\n            log.debug \"Button 3 pushed - Next Track\"\n            sonos.nextTrack()\n            break\n        case{it.number == 4 && it.value == 'pushed'}:\n            log.debug \"Button 4 pushed - Volume Down\"\n\t\t\tadjustVolume(false, false)\n            break\n        case{it.number == 2 && it.value == 'held'}:\n            log.debug \"Button 2 held - Volume Up 2x\"\n            adjustVolume(true, true)\n            break\n        case{it.number == 3 && it.value == 'held'}:\n\t        log.debug \"Button 3 held - Previous Track\"\n            sonos.previousTrack()\n        \tbreak  \n        case{it.number == 4 && it.value == 'held'}:\n            log.debug \"Button 4 held - Volume Down 2x\"\n            adjustVolume(false, true)\n            break\n        default:\n            log.debug \"Unhandled command: $buttonNumber $value\"\n           \n    }\n}\n\ndef togglePlayPause() {\n\tdef currentStatus = sonos.currentValue(\"status\")\n    if (currentStatus == \"playing\") {\n        options ? sonos.pause(options) : sonos.pause()\n    }\n    else {\n        options ? sonos.play(options) : sonos.play()\n    }\n}\n\ndef adjustVolume(boolean up, boolean doubleAmount) {\n\tdef changeAmount = (volumeOffset ?: 5) * (doubleAmount ? 2 : 1)\n    def currentVolume = sonos.currentValue(\"level\")\n    \n    if(up) {\n    \tsonos.setLevel(currentVolume + changeAmount)\n    } else {\n\t    sonos.setLevel(currentVolume - changeAmount)\n    }\n}",
        "docstring": "Control your Sonos system with an Aeon Minimote"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\tlog.debug \"takeAction($actionType)\"\n\tdef options = [:]\n\tif (volume) {\n\t\tsonos.setLevel(volume as Integer)\n\t\toptions.delay = 1000\n\t}\n\n\tswitch (actionType) {\n\t\tcase \"Play\":\n\t\t\toptions ? sonos.on(options) : sonos.on()\n\t\t\tbreak\n\t\tcase \"Stop Playing\":\n\t\t\toptions ? sonos.off(options) : sonos.off()\n\t\t\tbreak\n\t\tcase \"Toggle Play/Pause\":\n\t\t\tdef currentStatus = sonos.currentValue(\"status\")\n\t\t\tif (currentStatus == \"playing\") {\n\t\t\t\toptions ? sonos.pause(options) : sonos.pause()\n\t\t\t}\n\t\t\telse {\n\t\t\t\toptions ? sonos.play(options) : sonos.play()\n\t\t\t}\n\t\t\tbreak\n\t\tcase \"Skip to Next Track\":\n\t\t\toptions ? sonos.nextTrack(options) : sonos.nextTrack()\n\t\t\tbreak\n\t\tcase \"Play Previous Track\":\n\t\t\toptions ? sonos.previousTrack(options) : sonos.previousTrack()\n\t\t\tbreak\n\t\tdefault:\n\t\t\tlog.error \"Action type '$actionType' not defined\"\n\t}\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Play or pause your Speaker when certain actions take place in your home."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsaveSelectedSong()\n\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tif (frequency) {\n\t\t\tdef lastTime = state[frequencyKey(evt)]\n\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tlog.info \"Playing '$state.selectedSong\"\n\n\tif (volume != null) {\n\t\tsonos.stop()\n\t\tpause(500)\n\t\tsonos.setLevel(volume)\n\t\tpause(500)\n\t}\n\n\tsonos.playTrack(state.selectedSong)\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Plays a selected song or station."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n\n\tif (song) {\n\t\tsaveSelectedSong()\n\t}\n\n\tloadText()\n}\n\ndef eventHandler(evt) {\n\tlog.trace \"eventHandler($evt?.name: $evt?.value)\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tlog.trace \"takeAction()\"\n\n\tif (song) {\n\t\tsonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)\n\t}\n\telse if (resumePlaying){\n\t\tsonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)\n\t}\n\telse {\n\t\tsonos.playTrackAndRestore(state.sound.uri, state.sound.duration, volume)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getTimeLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize\n\nprivate loadText() {\n\tswitch ( actionType) {\n\t\tcase \"Bell 1\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell1.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Bell 2\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell2.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Dogs Barking\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/dogs.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Fire Alarm\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/alarm.mp3\", duration: \"17\"]\n\t\t\tbreak;\n\t\tcase \"The mail has arrived\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/the+mail+has+arrived.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"A door opened\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/a+door+opened.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"There is motion\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/there+is+motion.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Smartthings detected a flood\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+a+flood.mp3\", duration: \"2\"]\n\t\t\tbreak;\n\t\tcase \"Smartthings detected smoke\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+smoke.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Someone is arriving\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/someone+is+arriving.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Piano\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/piano2.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Lightsaber\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/lightsaber.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Custom Message\":\n\t\t\tif (message) {\n\t\t\t\tstate.sound = textToSpeech(message instanceof List ? message[0] : message) // not sure why this is (sometimes) needed)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate.sound = textToSpeech(\"You selected the custom message option but did not enter a message in the $app.label Smart App\")\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell1.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t}\n}",
        "docstring": "Play a sound or custom message through your Speaker when the mode changes or other events occur."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location,modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n\n\tif (song) {\n\t\tsaveSelectedSong()\n\t}\n}\n\ndef eventHandler(evt) {\n\tlog.trace \"eventHandler($evt?.name: $evt?.value)\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tloadText()\n\n\tif (song) {\n\t\tsonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)\n\t}\n\telse if (resumePlaying){\n\t\tsonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)\n\t}\n\telse if (volume) {\n\t\tsonos.playTrackAtVolume(state.sound.uri, volume)\n\t}\n\telse {\n\t\tsonos.playTrack(state.sound.uri)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n}\n\nprivate songOptions() {\n\n\t// Make sure current selection is in the set\n\n\tdef options = new LinkedHashSet()\n\tif (state.selectedSong?.station) {\n\t\toptions << state.selectedSong.station\n\t}\n\telse if (state.selectedSong?.description) {\n\t\t// TODO - Remove eventually? 'description' for backward compatibility\n\t\toptions << state.selectedSong.description\n\t}\n\n\t// Query for recent tracks\n\tdef states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n\tdef dataMaps = states.collect{it.jsonValue}\n\toptions.addAll(dataMaps.collect{it.station})\n\n\tlog.trace \"${options.size()} songs in list\"\n\toptions.take(20) as List\n}\n\nprivate saveSelectedSong() {\n\ttry {\n\t\tdef thisSong = song\n\t\tlog.info \"Looking for $thisSong\"\n\t\tdef songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n\t\tlog.info \"Searching ${songs.size()} records\"\n\n\t\tdef data = songs.find {s -> s.station == thisSong}\n\t\tlog.info \"Found ${data?.station}\"\n\t\tif (data) {\n\t\t\tstate.selectedSong = data\n\t\t\tlog.debug \"Selected song = $state.selectedSong\"\n\t\t}\n\t\telse if (song == state.selectedSong?.station) {\n\t\t\tlog.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n\t\t}\n\t\telse {\n\t\t\tlog.warn \"Selected song '$song' not found\"\n\t\t}\n\t}\n\tcatch (Throwable t) {\n\t\tlog.error t\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getTimeLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize\n\nprivate loadText() {\n\tif (location.timeZone || zipCode) {\n\t\tdef weather = getWeatherFeature(\"forecast\", zipCode)\n\t\tdef current = getWeatherFeature(\"conditions\", zipCode)\n\t\tdef isMetric = location.temperatureScale == \"C\"\n\t\tdef delim = \"\"\n\t\tdef sb = new StringBuilder()\n\t\tlist(forecastOptions).sort().each {opt ->\n\t\t\tif (opt == \"0\") {\n\t\t\t\tif (isMetric) {\n                \tsb << \"The current temperature is ${Math.round(current.current_observation.temp_c)} degrees.\"\n                }\n                else {\n                \tsb << \"The current temperature is ${Math.round(current.current_observation.temp_f)} degrees.\"\n                }\n\t\t\t\tdelim = \" \"\n\t\t\t}\n\t\t\telse if (opt == \"1\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Today's forecast is \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[0].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[0].fcttext\n                }\n\t\t\t}\n\t\t\telse if (opt == \"2\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Tonight will be \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[1].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[1].fcttext\n                }\n\t\t\t}\n\t\t\telse if (opt == \"3\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Tomorrow will be \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[2].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[2].fcttext\n                }\n\t\t\t}\n\t\t}\n\n\t\tdef msg = sb.toString()\n        msg = msg.replaceAll(/([0-9]+)C/,'$1 degrees') // TODO - remove after next release\n\t\tlog.debug \"msg = ${msg}\"\n\t\tstate.sound = textToSpeech(msg, true)\n\t}\n\telse {\n\t\tstate.sound = textToSpeech(\"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.\")\n\t}\n}\n\nprivate list(String s) {\n\t[s]\n}\nprivate list(l) {\n\tl\n}",
        "docstring": "Play a weather report through your Speaker when the mode changes or other events occur"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\n\tlog.trace \"Entering initialize()\"\n    \n\tstate.lastSteps = 0\n    state.steps = jawbone.currentValue(\"steps\").toInteger()\n    state.goal = jawbone.currentValue(\"goal\").toInteger()\n    \n\tsubscribe (jawbone,\"goal\",goalHandler)\n    subscribe (jawbone,\"steps\",stepHandler)\n    \n    if (song) {\n\t\tsaveSelectedSong()\n\t}\n    \n\tlog.trace \"Exiting initialize()\"    \n}\n\ndef goalHandler(evt) {\n\n\tlog.trace \"Entering goalHandler()\"\n\n\tdef goal = evt.value.toInteger()\n    \n    state.goal = goal\n    \n    log.trace \"Exiting goalHandler()\"\n}\n\ndef stepHandler(evt) {\n\n\tlog.trace \"Entering stepHandler()\"\n    \n    log.debug \"Event Value ${evt.value}\"\n    log.debug \"state.steps = ${state.steps}\"\n    log.debug \"state.goal = ${state.goal}\"\n\n\tdef steps = evt.value.toInteger()\n    \n    state.lastSteps = state.steps\n    state.steps = steps\n    \n    def stepGoal\n    if (settings.thresholdType == \"Goal\")\n    \tstepGoal = state.goal\n    else\n    \tstepGoal = settings.threshold\n    \n    if ((state.lastSteps < stepGoal) && (state.steps >= stepGoal)) { // only trigger when crossing through the goal threshold\n    \n    // goal achieved for the day! Yay! Lets tell someone!\n    \n    \tif (settings.notificationType != \"None\") { // Push or SMS Notification requested\n\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(stepMessage, recipients)\n            }\n            else {\n\n                def options = [\n                    method: settings.notificationType.toLowerCase(),\n                    phone: settings.phone\n                ]\n\n                sendNotification(stepMessage, options)\n            }\n        }\n        \n        if (settings.sonos) { // play a song on the Sonos as requested\n        \n        \t// runIn(1, sonosNotification, [overwrite: false])\n            sonosNotification()\n            \n        }  \n        \n        if (settings.hues) { // change the color of hue bulbs ras equested\n        \n        \t// runIn(1, hueNotification, [overwrite: false])\n            hueNotification()\n        \n        }        \n        \n        if (settings.lights) { // flash the lights as requested\n        \n\t\t\t// runIn(1, lightsNotification, [overwrite: false])\n        \tlightsNotification()\n        \n        }\n    \n    }\n    \n\tlog.trace \"Exiting stepHandler()\"    \n\n}\n\n\ndef lightsNotification() {\n\n\t// save the current state of the lights \n    \n    log.trace \"Save current state of lights\"\n    \n\tstate.previousLights = [:]\n\n\tlights.each {\n\t\tstate.previousLights[it.id] = it.currentValue(\"switch\")\n\t}\n    \n    // Flash the light on and off 5 times for now - this could be configurable \n            \n    log.trace \"Now flash the lights\"\n    \n    for (i in 1..flashCount) {\n           \n    \tlights.on()\n        pause(500)\n        lights.off()\n               \n    }\n    \n    // restore the original state\n    \n    log.trace \"Now restore the original state of lights\"    \n    \n \tlights.each {\n\t\tit.\"${state.previousLights[it.id]}\"()\n\t}   \n\n\n}\n\ndef hueNotification() {\n\n\tlog.trace \"Entering hueNotification()\"\n\n\tdef hueColor = 0\n\tif(color == \"Blue\")\n\t\thueColor = 70//60\n\telse if(color == \"Green\")\n\t\thueColor = 39//30\n\telse if(color == \"Yellow\")\n\t\thueColor = 25//16\n\telse if(color == \"Orange\")\n\t\thueColor = 10\n\telse if(color == \"Purple\")\n\t\thueColor = 75\n\telse if(color == \"Pink\")\n\t\thueColor = 83\n\n\n\tstate.previousHue = [:]\n\n\thues.each {\n\t\tstate.previousHue[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\")\n\t\t]\n\t}\n\n\tlog.debug \"current values = ${state.previousHue}\"\n\n\tdef newValue = [hue: hueColor, saturation: 100, level: (lightLevel as Integer) ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n\tsetTimer()\n    \n\tlog.trace \"Exiting hueNotification()\"\n    \n}\n\ndef setTimer()\n{\n\tlog.debug \"runIn ${duration}, resetHue\"\n\trunIn(duration, resetHue, [overwrite: false])\n}\n\n\ndef resetHue()\n{\n    log.trace \"Entering resetHue()\"\n\tsettings.hues.each {\n\t\tit.setColor(state.previousHue[it.id])\n\t}\n    log.trace \"Exiting resetHue()\"    \n}\n\ndef sonosNotification() {\n\n\tlog.trace \"sonosNotification()\"\n    \n    if (settings.song) {\n    \n   \t\tif (settings.resumePlaying) {\n     \t\tif (settings.volume)\n\t\t\t\tsonos.playTrackAndResume(state.selectedSong, settings.songDuration, settings.volume)\n            else\n            \tsonos.playTrackAndResume(state.selectedSong, settings.songDuration)\n        } else {\n        \tif (settings.volume)\n \t\t\t\tsonos.playTrackAtVolume(state.selectedSong, settings.volume)\n            else\n                sonos.playTrack(state.selectedSong)\n        }\n        \n\t\tsonos.on() // make sure it is playing\n        \n\t}\n\n\tlog.trace \"Exiting sonosNotification()\"\n}",
        "docstring": "Use a step tracker device to track daily step goals and trigger various device actions when your goals are met!"
    },
    {
        "code": "def installed() {\n    initialize()\n}\n\ndef updated() {\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize() {\n    subscribe(location, \"position\", locationPositionChange)\n    subscribe(location, \"sunriseTime\", sunriseTimeHandler)\n    subscribe(location, \"sunsetTime\", sunsetTimeHandler)\n\n    //Run today too\n    scheduleWithOffset(location.currentValue(\"sunsetTime\"), sunsetOffsetValue, sunsetOffsetDir, \"sunsetHandler\")\n    scheduleWithOffset(location.currentValue(\"sunriseTime\"), sunriseOffsetValue, sunriseOffsetDir, \"sunriseHandler\")\n}\n\ndef locationPositionChange(evt) {\n    log.trace \"locationChange()\"\n    updated()\n}\n\ndef sunsetTimeHandler(evt) {\n    log.trace \"sunsetTimeHandler()\"\n    scheduleWithOffset(evt.value, sunsetOffsetValue, sunsetOffsetDir, \"sunsetHandler\")\n}\n\ndef sunriseTimeHandler(evt) {\n    log.trace \"sunriseTimeHandler()\"\n    scheduleWithOffset(evt.value, sunriseOffsetValue, sunriseOffsetDir, \"sunriseHandler\")\n}\n\ndef scheduleWithOffset(nextSunriseSunsetTime, offset, offsetDir, handlerName) {\n    def nextSunriseSunsetTimeDate = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", nextSunriseSunsetTime)\n    def offsetTime = new Date(nextSunriseSunsetTimeDate.time + getOffset(offset, offsetDir))\n\n    log.debug \"scheduling Sunrise/Sunset for $offsetTime\"\n    runOnce(offsetTime, handlerName, [overwrite: false])\n}\n\ndef sunriseHandler() {\n    log.info \"Executing sunrise handler\"\n    if (sunriseOn) {\n        sunriseOn.on()\n    }\n    if (sunriseOff) {\n        sunriseOff.off()\n    }\n    changeMode(sunriseMode)\n}\n\ndef sunsetHandler() {\n    log.info \"Executing sunset handler\"\n    if (sunsetOn) {\n        sunsetOn.on()\n    }\n    if (sunsetOff) {\n        sunsetOff.off()\n    }\n    changeMode(sunsetMode)\n}\n\ndef changeMode(newMode) {\n    if (newMode && location.mode != newMode) {\n        if (location.modes?.find{it.name == newMode}) {\n            setLocationMode(newMode)\n            send \"${label} has changed the mode to '${newMode}'\"\n        }\n        else {\n            send \"${label} tried to change to undefined mode '${newMode}'\"\n        }\n    }\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n    log.debug msg\n}\n\nprivate getLabel() {\n    app.label ?: \"SmartThings\"\n}\n\nprivate getOffset(String offsetValue, String offsetDir) {\n    def timeOffsetMillis = calculateTimeOffsetMillis(offsetValue)\n    if (offsetDir == \"Before\") {\n        return -timeOffsetMillis\n    }\n    return timeOffsetMillis\n}\n\nprivate calculateTimeOffsetMillis(String offset) {\n    def result = 0\n    if (!offset) {\n        return result\n    }\n\n    def before = offset.startsWith('-')\n    if (before || offset.startsWith('+')) {\n        offset = offset[1..-1]\n    }\n\n    if (offset.isNumber()) {\n        result = Math.round((offset as Double) * 60000L)\n    } else if (offset.contains(\":\")) {\n        def segs = offset.split(\":\")\n        result = (segs[0].toLong() * 3600000L) + (segs[1].toLong() * 60000L)\n    }\n\n    if (before) {\n        result = -result\n    }\n\n    result\n}",
        "docstring": "Changes mode and controls lights based on local sunrise and sunset times."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef uninstalled() {\n\tremoveChildDevices(getChildDevices())\n}\n\ndef initialize() {\n\n\tif (selectCars) {\n\t\taddDevice()\n\t}\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !selectedCars }\n\tlog.info delete\n    //removeChildDevices(delete)\n}\n\n//CHILD DEVICE METHODS\ndef addDevice() {\n    def devices = getcarList()\n    log.trace \"Adding childs $devices - $selectedCars\"\n\tselectedCars.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newCar = devices.find { (it.dni) == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Tesla\", dni, null, [name:\"Tesla\", label:\"Tesla\"])\n\t\t\tlog.trace \"created ${d.name} with id $dni\"\n\t\t} else {\n\t\t\tlog.trace \"found ${d.name} with id $key already exists\"\n\t\t}\n\t}\n}\n\nprivate removeChildDevices(delete)\n{\n\tlog.debug \"deleting ${delete.size()} Teslas\"\n\tdelete.each {\n\t\tstate.suppressDelete[it.deviceNetworkId] = true\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t\tstate.suppressDelete.remove(it.deviceNetworkId)\n\t}\n}\n\ndef getcarList() {\n\tdef devices = []\n\n\tdef carListParams = [\n\t\turi: \"https://portal.vn.teslamotors.com/\",\n        path: \"/vehicles\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n    \n\thttpGet(carListParams) { resp ->\n\t\tlog.debug \"Getting car list\"\n\t\tif(resp.status == 200) {\n            def vehicleId = resp.data.id.value[0].toString()\n            def vehicleVIN = resp.data.vin[0]\n            def dni = vehicleVIN + \":\" + vehicleId\n \t\t\tdef name = \"Tesla [${vehicleId}]\"\n            // CHECK HERE IF MOBILE IS ENABLE\n            // path: \"/vehicles/${vehicleId}/mobile_enabled\",\n            // if (enable)\n            devices += [\"name\" : \"${name}\", \"dni\" : \"${dni}\"]\n            // else return [errorMessage:\"Mobile communication isn't enable on all of your vehicles.\"]\n\t\t} else if(resp.status == 302) {\n        \t// Token expired or incorrect\n\t\t\tsingleUrl = resp.headers.Location.value\n\t\t} else {\n\t\t\t// ERROR\n\t\t\tlog.error \"car list: unknown response\"\n\t\t}        \n\t}\n    return devices\n}\n\nMap carsDiscovered() {\n\tdef devices =  getcarList()\n    log.trace \"Map $devices\"    \n\tdef map = [:]\n\tif (devices instanceof java.util.Map) {\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.dni\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t} else { //backwards compatable\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.dni\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t}\n\tmap\n}\n\ndef removeChildFromSettings(child) {\n\tdef device = child.device\n\tdef dni = device.deviceNetworkId\n\tlog.debug \"removing child device $device with dni ${dni}\"\n\tif(!state?.suppressDelete?.get(dni))\n\t{\n\t\tdef newSettings = settings.cars?.findAll { it != dni } ?: []\n\t\tapp.updateSetting(\"cars\", newSettings)\n\t}\n}\n\nprivate forceLogin() {\n\tupdateCookie(null)\n\tlogin()\n}\n\n\nprivate login() {\n\tif(getCookieValueIsValid()) {\n\t\treturn [success:true]\n\t}\n\treturn doLogin()\n}\n\nprivate doLogin() {\n\tdef loginParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n        path: \"/login\",\n\t\tcontentType: \"application/x-www-form-urlencoded\",\n\t\tbody: \"user_session%5Bemail%5D=${username}&user_session%5Bpassword%5D=${password}\"\n\t]\n\n\tdef result = [success:false]\n\t\n    try {\n    \thttpPost(loginParams) { resp ->\n            if (resp.status == 302) {\n                log.debug \"login 302 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n                def cookie = resp?.headers?.'Set-Cookie'?.split(\";\")?.getAt(0)\n                if (cookie) {\n                    log.debug \"login setting cookie to $cookie\"\n                    updateCookie(cookie)                \n                    result.success = true\n                } else {\n                    // ERROR: any more information we can give?\n                    result.reason = \"Bad login\"\n                }\n            } else {\n                // ERROR: any more information we can give?\n                result.reason = \"Bad login\"\n            }\n    \t}        \n\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tresult.reason = \"Bad login\"\n\t}\n\treturn result\n}\n\nprivate command(String dni, String command, String value = '') {\n\tdef id = getVehicleId(dni)\n    def commandPath\n\tswitch (command) {\n\t\tcase \"flash\":\n    \t\tcommandPath = \"/vehicles/${id}/command/flash_lights\"\n            break;\n\t\tcase \"honk\":\n    \t\tcommandPath = \"/vehicles/${id}/command/honk_horn\"  \n            break;\n\t\tcase \"doorlock\":\n    \t\tcommandPath = \"/vehicles/${id}/command/door_lock\"  \n            break;            \n\t\tcase \"doorunlock\":\n    \t\tcommandPath = \"/vehicles/${id}/command/door_unlock\"  \n            break;  \n\t\tcase \"climaon\":\n    \t\tcommandPath = \"/vehicles/${id}/command/auto_conditioning_start\"  \n            break;            \n\t\tcase \"climaoff\":\n    \t\tcommandPath = \"/vehicles/${id}/command/auto_conditioning_stop\"  \n            break;             \n\t\tcase \"roof\":\n    \t\tcommandPath = \"/vehicles/${id}/command/sun_roof_control?state=${value}\" \n            break;    \n\t\tcase \"temp\":\n    \t\tcommandPath = \"/vehicles/${id}/command/set_temps?driver_temp=${value}&passenger_temp=${value}\"\n            break;              \n\t\tdefault:\n\t\t\tbreak; \n    }   \n    \n\tdef commandParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: commandPath,\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef loginRequired = false\n\n\thttpGet(commandParams) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            sendNotification(data.toString())\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\tif(loginRequired) { throw new Exception(\"Login Required\") }\n}\n\nprivate honk(String dni) {\n\tdef id = getVehicleId(dni)\n\tdef honkParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/honk_horn\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef loginRequired = false\n\n\thttpGet(honkParams) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired) {\n\t\tthrow new Exception(\"Login Required\")\n\t}\n}\n\nprivate poll(String dni) {\n\tdef id = getVehicleId(dni)\n\tdef pollParams1 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/climate_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef childDevice = getChildDevice(dni)\n    \n\tdef loginRequired = false\n\n\thttpGet(pollParams1) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            childDevice?.sendEvent(name: 'temperature', value: cToF(data.inside_temp).toString())\n            if (data.is_auto_conditioning_on)            \n            \tchildDevice?.sendEvent(name: 'clima', value: 'on')\n            else\n                childDevice?.sendEvent(name: 'clima', value: 'off')\n            childDevice?.sendEvent(name: 'thermostatSetpoint', value: cToF(data.driver_temp_setting).toString())            \n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tdef pollParams2 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/vehicle_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\thttpGet(pollParams2) { resp ->\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            if (data.sun_roof_percent_open == 0)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'close')\n\t\t\telse if (data.sun_roof_percent_open > 0 && data.sun_roof_percent_open < 70)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'vent')\n\t\t\telse if (data.sun_roof_percent_open >= 70 && data.sun_roof_percent_open <= 80)                \n            \tchildDevice?.sendEvent(name: 'roof', value: 'comfort')\n            else if (data.sun_roof_percent_open > 80 && data.sun_roof_percent_open <= 100)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'open')           \n            if (data.locked)            \n            \tchildDevice?.sendEvent(name: 'door', value: 'lock')\n            else\n                childDevice?.sendEvent(name: 'door', value: 'unlock')\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tdef pollParams3 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/charge_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\thttpGet(pollParams3) { resp ->\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            childDevice?.sendEvent(name: 'connected', value: data.charging_state.toString())\n            childDevice?.sendEvent(name: 'miles', value: data.battery_range.toString())\n            childDevice?.sendEvent(name: 'battery', value: data.battery_level.toString())\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired) {\n\t\tthrow new Exception(\"Login Required\")\n\t}\n}\n\nprivate getVehicleId(String dni) {\n    return dni.split(\":\").last()\n}\n\nprivate Boolean getCookieValueIsValid()\n{\n\t// TODO: make a call with the cookie to verify that it works\n\treturn getCookieValue()\n}\n\nprivate updateCookie(String cookie) {\n\tstate.cookie = cookie\n}\n\nprivate getCookieValue() {\n\tstate.cookie\n}\n\ndef cToF(temp) {\n    return temp * 1.8 + 32\n}\n\nprivate validUserAgent() {\n\t\"curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8x zlib/1.2.5\"\n}",
        "docstring": "Integrate your Tesla car with SmartThings."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n  log.debug \"$contact1 was opened, sending text\"\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(\"Your ${contact1.label ?: contact1.name} was opened\", recipients)\n    }\n    else {\n        sendSms(phone1, \"Your ${contact1.label ?: contact1.name} was opened\")\n    }\n}",
        "docstring": "Get a text message sent to your phone when an open/close sensor is opened."
    },
    {
        "code": "def installed() {\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef motionActiveHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\tif (presence1.latestValue(\"presence\") == \"not present\") {\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaSeconds = 10\n\t\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\t\tdef recentEvents = motion1.eventsSince(timeAgo)\n\t\tlog.debug \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\t\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t\t} else {\n            if (location.contactBookEnabled) {\n                log.debug \"$motion1 has moved while you were out, sending notifications to: ${recipients?.size()}\"\n                sendNotificationToContacts(\"${motion1.label} ${motion1.name} moved while you were out\", recipients)\n            }\n            else {\n                log.debug \"$motion1 has moved while you were out, sending text\"\n                sendSms(phone1, \"${motion1.label} ${motion1.name} moved while you were out\")\n            }\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion detected, but presence sensor indicates you are present\"\n\t}\n}",
        "docstring": "Send a text message when there is motion while you are away."
    },
    {
        "code": "def installed()\n{   \n\tsubscribe(master, \"switch.on\", onHandler)\n\tsubscribe(master, \"switch.off\", offHandler)\n\tsubscribe(master, \"level\", dimHandler)   \n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(master, \"switch.on\", onHandler)\n\tsubscribe(master, \"switch.off\", offHandler)\n\tsubscribe(master, \"level\", dimHandler)   \n}\n\ndef logHandler(evt) {\n\tlog.debug evt.value\n}\n\ndef onHandler(evt) {\n\tlog.debug evt.value\n\tlog.debug onSwitches()\n\tonSwitches()?.on()\n}\n\ndef offHandler(evt) {\n\tlog.debug evt.value\n\tlog.debug offSwitches()\n\toffSwitches()?.off()\n}\n\ndef dimHandler(evt) {\n\tlog.debug \"Dim level: $evt.value\"\n\tdimSwitches?.setLevel(evt.value)\n}\n\nprivate onSwitches() {\n\tif(switches && onSwitches) { switches + onSwitches }\n\telse if(switches) { switches }\n\telse { onSwitches }\n}\n\nprivate offSwitches() {\n\tif(switches && offSwitches) { switches + offSwitches }\n\telse if(switches) { switches }\n\telse { offSwitches }\n}",
        "docstring": "Turns on, off and dim a collection of lights based on the state of a specific switch."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tsubscribe()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe()\n}\n\ndef subscribe() {\n\tif (contact) {\n\t\tsubscribe(contact, \"contact.open\", contactOpenHandler)\n\t}\n\tif (acceleration) {\n\t\tsubscribe(acceleration, \"acceleration.active\", accelerationActiveHandler)\n\t}\n\tif (motion) {\n\t\tsubscribe(motion, \"motion.active\", motionActiveHandler)\n\t}\n\tif (mySwitch) {\n\t\tsubscribe(mySwitch, \"switch.on\", switchOnHandler)\n\t}\n\tif (myPresence) {\n\t\tsubscribe(myPresence, \"presence\", presenceHandler)\n\t}\n}\n\ndef motionActiveHandler(evt) {\n\tlog.debug \"motion $evt.value\"\n\tflashLights()\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"contact $evt.value\"\n\tflashLights()\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.debug \"acceleration $evt.value\"\n\tflashLights()\n}\n\ndef switchOnHandler(evt) {\n\tlog.debug \"switch $evt.value\"\n\tflashLights()\n}\n\ndef presenceHandler(evt) {\n\tlog.debug \"presence $evt.value\"\n\tif (evt.value == \"present\") {\n\t\tflashLights()\n\t} else if (evt.value == \"not present\") {\n\t\tflashLights()\n\t}\n}\n\nprivate flashLights() {\n\tdef doFlash = true\n\tdef onFor = onFor ?: 1000\n\tdef offFor = offFor ?: 1000\n\tdef numFlashes = numFlashes ?: 3\n\n\tlog.debug \"LAST ACTIVATED IS: ${state.lastActivated}\"\n\tif (state.lastActivated) {\n\t\tdef elapsed = now() - state.lastActivated\n\t\tdef sequenceTime = (numFlashes + 1) * (onFor + offFor)\n\t\tdoFlash = elapsed > sequenceTime\n\t\tlog.debug \"DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: ${state.lastActivated}\"\n\t}\n\n\tif (doFlash) {\n\t\tlog.debug \"FLASHING $numFlashes times\"\n\t\tstate.lastActivated = now()\n\t\tlog.debug \"LAST ACTIVATED SET TO: ${state.lastActivated}\"\n\t\tdef initialActionOn = switches.collect{it.currentSwitch != \"on\"}\n\t\tdef delay = 0L\n\t\tnumFlashes.times {\n\t\t\tlog.trace \"Switch on after  $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.on(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.off(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += onFor\n\t\t\tlog.trace \"Switch off after $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.off(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.on(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += offFor\n\t\t}\n\t}\n}",
        "docstring": "Flashes a set of lights in response to motion, an open/close event, or a switch."
    },
    {
        "code": "def installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\t// Don't send a continuous stream of text messages\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent to phone within the last $deltaSeconds seconds\"\n\t} else {\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"Gun case has moved!\", recipients)\n        }\n        else {\n            log.debug \"$accelerationSensor has moved, texting phone\"\n            sendSms(phone1, \"Gun case has moved!\")\n        }\n\t}\n}",
        "docstring": "Send a text when your gun case moves"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(smokeDevices, \"smoke.detected\", eventHandler)\n\tsubscribe(smokeDevices, \"smoke.tested\", eventHandler)\n\tsubscribe(smokeDevices, \"carbonMonoxide.detected\", eventHandler)\n \tsubscribe(carbonMonoxideDevices, \"carbonMonoxide.detected\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tlog.debug \"Notify got evt ${evt}\"\n\t// Turn off thermostat\n\tthermostatDevices*.setThermostatMode(\"off\")\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}\n}\n\nprivate sendMessage(evt) {\n\tString msg = messageText\n\tMap options = [:]\n\n\tif (!messageText) {\n\t\tmsg = '{{ triggerEvent.descriptionText }}'\n\t\toptions = [translatable: true, triggerEvent: evt]\n\t}\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients, options)\n\t} else {\n\t\tif (phone) {\n\t\t\toptions.phone = phone\n\t\t\tif (pushAndPhone != 'No') {\n\t\t\t\tlog.debug 'Sending push and SMS'\n\t\t\t\toptions.method = 'both'\n\t\t\t} else {\n\t\t\t\tlog.debug 'Sending SMS'\n\t\t\t\toptions.method = 'phone'\n\t\t\t}\n\t\t} else if (pushAndPhone != 'No') {\n\t\t\tlog.debug 'Sending push'\n\t\t\toptions.method = 'push'\n\t\t} else {\n\t\t\tlog.debug 'Sending nothing'\n\t\t\toptions.method = 'none'\n\t\t}\n\t\tsendNotification(msg, options)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}",
        "docstring": "Receive notifications when anything happens in your home."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef uninstalled() {\n    getChildDevices().each {\n        deleteChildDevice(it.deviceNetworkId)\n    }\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initializeDevices()\n}\n\ndef initializeDevices() {\n    settings.each { key, value ->\n        log.debug \"$key : $value\"\n        def existingDevice = getChildDevices().find { it.name == key }\n        log.debug \"$existingDevice\"\n        if (existingDevice && !value) {\n            deleteChildDevice(existingDevice.deviceNetworkId)\n        } else if (!existingDevice && value) {\n            String dni = UUID.randomUUID()\n            log.debug \"$dni\"\n            addChildDevice(app.namespace, key, dni, null, [\n                label: labelMap()[key] ?: key,\n                completedSetup: true\n            ])\n        }\n    }\n}\n\n// Map the name of the Device to a proper Label\ndef labelMap() {\n    [\n        genericDeviceTile: \"Tile Multiattribute Generic\",\n        lightingDeviceTile: \"Tile Multiattribute Lighting\",\n        thermostatDeviceTile: \"Tile Multiattribute Thermostat\",\n        mediaPlayerDeviceTile: \"Tile Multiattribute Media Player\",\n        videoPlayerDeviceTile: \"Tile Multiattribute Video Player\",\n        standardDeviceTile: \"Tile Device Standard\",\n        valueDeviceTile: \"Tile Device Value\",\n        presenceDeviceTile: \"Tile Device Presence\",\n        carouselDeviceTile: \"Tile Device Carousel\",\n        sliderDeviceTile: \"Tile Device Slider\",\n        colorWheelDeviceTile: \"Tile Device Color Wheel\"\n    ]\n}",
        "docstring": "A controller SmartApp to install virtual devices into your location in order to simulate various native Device Tiles."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated(settings) {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tswitch1.on()\n\tdef fiveMinuteDelay = 60 * 5\n\trunIn(fiveMinuteDelay, turnOffSwitch)\n}\n\ndef turnOffSwitch() {\n\tswitch1.off()\n}",
        "docstring": "When a SmartSense Multi is opened, a switch will be turned on, and then turned off after 5 minutes."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt)\n{\n\tlog.debug \"presenceHandler $evt.name: $evt.value\"\n\tdef current = presence1.currentValue(\"presence\")\n\tlog.debug current\n\tdef presenceValue = presence1.find{it.currentPresence == \"present\"}\n\tlog.debug presenceValue\n\tif(presenceValue){\n\t\tswitch1.on()\n\t\tlog.debug \"Someone's home!\"\n\t}\n\telse{\n\t\tswitch1.off()\n\t\tlog.debug \"Everyone's away.\"\n\t}\n}",
        "docstring": "Turn something on when you arrive and back off when you leave."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"$evt.value: $evt, $settings\"\n\tlog.trace \"Turning on switches: $switches\"\n\tswitches.on()\n}",
        "docstring": "Turn something on when an open/close sensor opens."
    },
    {
        "code": "def installed()\n{\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt)\n{\n\tdef now = new Date()\n\tdef sunTime = getSunriseAndSunset();\n    \n\tlog.debug \"nowTime: $now\"\n\tlog.debug \"riseTime: $sunTime.sunrise\"\n\tlog.debug \"setTime: $sunTime.sunset\"\n\tlog.debug \"presenceHandler $evt.name: $evt.value\"\n    \n\tdef current = presence1.currentValue(\"presence\")\n\tlog.debug current\n\tdef presenceValue = presence1.find{it.currentPresence == \"present\"}\n\tlog.debug presenceValue\n\tif(presenceValue && (now > sunTime.sunset)) {\n\t\tswitch1.on()\n\t\tlog.debug \"Welcome home at night!\"\n\t}\n    else if(presenceValue && (now < sunTime.sunset)) {\n    \tlog.debug \"Welcome home at daytime!\"\n    }\n\telse {\n\t\tswitch1.off()\n\t\tlog.debug \"Everyone's away.\"\n\t}\n}",
        "docstring": "Turn something on only if you arrive after sunset and back off anytime you leave."
    },
    {
        "code": "def installed() {\n//\tsubscribe(motions, \"motion.active\", motionOpenHandler)\n\n//\tsubscribe(contactSensors, \"contact.open\", contactOpenHandler)\n//\tlog.trace \"contactSensors Installed\"\n\n}\n\ndef updated() {\n\n//\tunsubscribe()\n//    subscribe(motions, \"motion.active\", motionOpenHandler)\n//\tsubscribe(contactSensors, \"contact.open\", contactOpenHandler)\n\n//log.trace \"contactSensors Updated\"\n\n}\n\ndef listAll() {\n\tlistSwitches() + listMotions() + listLocks() + listContactSensors() + listPresenceSensors() + listPhrasesWithType()\n}\n\ndef listContactSensors() {\n\tcontactSensors.collect { device(it, \"contactSensor\") }\n}\n\n\nvoid updateContactSensors() {\n\tupdateAll(contactSensors)\n}\n\ndef showContactSensor() {\n\tshow(contactSensors, \"contact\")\n}\n\nvoid updateContactSensor() {\n\tupdate(contactSensors)\n}\n\ndef addContactSubscription() {\n\tlog.debug \"addContactSensorSubscription,  params: ${params}\"\n\taddSubscription(contactSensors, \"contact\")\n}\n\ndef removeContactSensorSubscription() {\n\tremoveSubscription(contactSensors)\n}\n\n\ndef listPresenceSensors() {\n\tpresenceSensors.collect { device(it, \"presenceSensor\") }\n}\n\n\nvoid updatePresenceSensors() {\n\tupdateAll(presenceSensors)\n}\n\ndef showPresenceSensor() {\n\tshow(presenceSensors, \"presence\")\n}\n\nvoid updatePresenceSensor() {\n\tupdate(presenceSensors)\n}\n\ndef addPresenceSubscription() {\n\tlog.debug \"addPresenceSensorSubscription,  params: ${params}\"\n\taddSubscription(presenceSensors, \"presence\")\n}\n\ndef removePresenceSensorSubscription() {\n\tremoveSubscription(presenceSensors)\n}\n\n\ndef listSwitches() {\n\tswitches.collect { device(it, \"switch\") }\n}\n\nvoid updateSwitches() {\n\tupdateAll(switches)\n}\n\ndef showSwitch() {\n\tshow(switches, \"switch\")\n}\n\nvoid updateSwitch() {\n\tupdate(switches)\n}\n\ndef addSwitchSubscription() {\n\tlog.debug \"addSwitchSubscription,  params: ${params}\"\n\taddSubscription(switches, \"switch\")\n}\n\ndef removeSwitchSubscription() {\n\tremoveSubscription(switches)\n}\n\ndef listMotions() {\n\tmotions.collect { device(it, \"motionSensor\") }\n}\n\nvoid updateMotions() {\n\tupdateAll(motions)\n}\n\ndef showMotion() {\n\tshow(motions, \"motion\")\n}\n\nvoid updateMotion() {\n\tupdate(motions)\n}\n\ndef addMotionSubscription() {\n\n\taddSubscription(motions, \"motion\")\n}\n\ndef removeMotionSubscription() {\n\tremoveSubscription(motions)\n}\n\ndef listLocks() {\n\tlocks.collect { device(it, \"lock\") }\n}\n\nvoid updateLocks() {\n\tupdateAll(locks)\n}\n\ndef showLock() {\n\tshow(locks, \"lock\")\n}\n\nvoid updateLock() {\n\tupdate(locks)\n}\n\ndef addLockSubscription() {\n\taddSubscription(locks, \"lock\")\n}\n\ndef removeLockSubscription() {\n\tremoveSubscription(locks)\n}\n\n/*\ndef motionOpenHandler(evt) {\n//log.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$motions was active, sending push message to user\"\n\t//sendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n\n\n\thttpPostJson(uri: \"http://automatesolutions.ca/test.php\", path: '', body: [evt: [value: \"motionSensor Active\"]]) {\n\tlog.debug \"Event data successfully posted\"\n    }\n\n}\ndef contactOpenHandler(evt) {\n\t//log.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$contactSensors was opened, sending push message to user\"\n\t//sendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n\n\n\thttpPostJson(uri: \"http://automatesolutions.ca/test.php\", path: '', body: [evt: [value: \"ContactSensor Opened\"]]) {\n\tlog.debug \"Event data successfully posted\"\n    }\n\n\n}\n*/\n\n\ndef deviceHandler(evt) {\n\tlog.debug \"~~~~~TEST~~~~~~\"\n\tdef deviceInfo = state[evt.deviceId]\n\tif (deviceInfo)\n\t{\n\t\thttpPostJson(uri: deviceInfo.callbackUrl, path: '', body: [evt: [value: evt.value]]) {\n\t\t\tlog.debug \"Event data successfully posted\"\n\t\t}\n\t}\n\telse\n\t{\n\t\tlog.debug \"No subscribed device found\"\n\t}\n}\n\ndef currentState() {\n\tstate\n}\n\ndef showStates() {\n\tdef device = (switches + motions + locks).find { it.id == params.id }\n\tif (!device)\n\t{\n\t\thttpError(404, \"Switch not found\")\n\t}\n\telse\n\t{\n\t\tdevice.events(params)\n\t}\n}\n\ndef listPhrasesWithType() {\n\tlocation.helloHome.getPhrases().collect {\n\t\t[\n\t\t\t\"id\"   : it.id,\n\t\t\t\"label\": it.label,\n\t\t\t\"type\" : \"phrase\"\n\t\t]\n\t}\n}\n\ndef listPhrases() {\n\tlocation.helloHome.getPhrases().label\n}\n\ndef executePhrase() {\n\tdef phraseName = params.phraseName\n\tif (phraseName)\n\t{\n\t\tlocation.helloHome.execute(phraseName)\n\t\tlog.debug \"executed phrase: $phraseName\"\n\t}\n\telse\n\t{\n\t\thttpError(404, \"Phrase not found\")\n\t}\n}\n\nprivate void updateAll(devices) {\n\tdef type = params.param1\n\tdef command = request.JSON?.command\n\tif (!devices) {\n\t\thttpError(404, \"Devices not found\")\n\t}\n\tif (command){\n\t\tdevices.each { device ->\n\t\t\texecuteCommand(device, type, command)\n\t\t}\n\t}\n}\n\nprivate void update(devices) {\n\tlog.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n\tdef type = params.param1\n\tdef command = request.JSON?.command\n\tdef device = devices?.find { it.id == params.id }\n\n\tif (!device) {\n\t\t\thttpError(404, \"Device not found\")\n\t}\n\n\tif (command) {\n\t\texecuteCommand(device, type, command)\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n/**\n * Validates and executes the command\n * on the device or devices\n */\ndef executeCommand(device, type, command) {\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\t\n}\n\nprivate show(devices, type) {\n\tdef device = devices.find { it.id == params.id }\n\tif (!device)\n\t{\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse\n\t{\n\t\tdef attributeName = type\n\n\t\tdef s = device.currentState(attributeName)\n\t\t[id: device.id, label: device.displayName, value: s?.value, unitTime: s?.date?.time, type: type]\n\t}\n}\n\nprivate addSubscription(devices, attribute) {\n\t//def deviceId = request.JSON?.deviceId\n\t//def callbackUrl = request.JSON?.callbackUrl\n\n\tlog.debug \"addSubscription,  params: ${params}\"\n\n\tdef deviceId = params.deviceId\n\tdef callbackUrl = params.callbackUrl\n\n\tdef myDevice = devices.find { it.id == deviceId }\n\tif (myDevice)\n\t{\n\t\tlog.debug \"Adding switch subscription\" + callbackUrl\n\t\tstate[deviceId] = [callbackUrl: callbackUrl]\n\t\tlog.debug \"Added state: $state\"\n\t\tdef subscription = subscribe(myDevice, attribute, deviceHandler)\n\t\tif (subscription && subscription.eventSubscription) {\n\t\t\tlog.debug \"Subscription is newly created\"\n\t\t} else {\n\t\t\tlog.debug \"Subscription already exists, returning existing subscription\"\n\t\t\tsubscription = app.subscriptions?.find { it.deviceId == deviceId && it.data == attribute && it.handler == 'deviceHandler' }\n\t\t}\n\t\t[\n\t\t\tid: subscription.id,\n\t\t\tdeviceId: subscription.deviceId,\n\t\t\tdata: subscription.data,\n\t\t\thandler: subscription.handler,\n\t\t\tcallbackUrl: callbackUrl\n\t\t]\n\t}\n}\n\nprivate removeSubscription(devices) {\n\tdef deviceId = params.id\n\tdef device = devices.find { it.id == deviceId }\n\tif (device)\n\t{\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n}\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.displayName, type: type] : null\n}",
        "docstring": "Add your Ubi device to your SmartThings Account"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(contacts, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contacts, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"$evt.value: $evt, $settings\"\n\tlog.trace \"The Undead are coming! Turning on the lights: $switches\"\n\tswitches.on()\n}",
        "docstring": "Undead Early Warning"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(presence1, \"presence.present\", presence)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence.present\", presence)\n}\n\ndef presence(evt)\n{\n\tdef anyLocked = lock1.count{it.currentLock == \"unlocked\"} != lock1.size()\n\tif (anyLocked) {\n\t\tsendPush \"Unlocked door due to arrival of $evt.displayName\"\n\t\tlock1.unlock()\n\t}\n}",
        "docstring": "Unlocks the door when you arrive at your location."
    },
    {
        "code": "def installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    state.nextDni = 1\n}\n\ndef uninstalled() {\n    getAllChildDevices().each {\n        deleteChildDevice(it.deviceNetworkId, true)\n    }\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    initialize()\n}\n\ndef initialize() {\n    def latestDni = state.nextDni\n    if (virtualDeviceType) {\n        def d = addChildDevice(\"smartthings\", virtualDeviceType, \"virtual-$latestDni\", theHub?.id, [completedSetup: true, label: deviceName])\n        latestDni++\n        state.nextDni = latestDni\n    } else {\n        log.error \"Failed creating Virtual Device because the device type was missing\"\n    }\n}",
        "docstring": "Creates virtual devices"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tif (motion) {\n\t\tsubscribe(motion, \"motion\", motionHandler)\n\t}\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tif (motion) {\n\t\tsubscribe(motion, \"motion\", motionHandler)\n\t}\n}\n\ndef temperatureHandler(evt)\n{\n\tdef isActive = hasBeenRecentMotion()\n\tif (isActive || emergencySetpoint) {\n\t\tevaluate(evt.doubleValue, isActive ? setpoint : emergencySetpoint)\n\t}\n\telse {\n\t\toutlets.off()\n\t}\n}\n\ndef motionHandler(evt)\n{\n\tif (evt.value == \"active\") {\n\t\tdef lastTemp = sensor.currentTemperature\n\t\tif (lastTemp != null) {\n\t\t\tevaluate(lastTemp, setpoint)\n\t\t}\n\t} else if (evt.value == \"inactive\") {\n\t\tdef isActive = hasBeenRecentMotion()\n\t\tlog.debug \"INACTIVE($isActive)\"\n\t\tif (isActive || emergencySetpoint) {\n\t\t\tdef lastTemp = sensor.currentTemperature\n\t\t\tif (lastTemp != null) {\n\t\t\t\tevaluate(lastTemp, isActive ? setpoint : emergencySetpoint)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toutlets.off()\n\t\t}\n\t}\n}\n\nprivate evaluate(currentTemp, desiredTemp)\n{\n\tlog.debug \"EVALUATE($currentTemp, $desiredTemp)\"\n\tdef threshold = 1.0\n\tif (mode == \"cool\") {\n\t\t// air conditioner\n\t\tif (currentTemp - desiredTemp >= threshold) {\n\t\t\toutlets.on()\n\t\t}\n\t\telse if (desiredTemp - currentTemp >= threshold) {\n\t\t\toutlets.off()\n\t\t}\n\t}\n\telse {\n\t\t// heater\n\t\tif (desiredTemp - currentTemp >= threshold) {\n\t\t\toutlets.on()\n\t\t}\n\t\telse if (currentTemp - desiredTemp >= threshold) {\n\t\t\toutlets.off()\n\t\t}\n\t}\n}\n\nprivate hasBeenRecentMotion()\n{\n\tdef isActive = false\n\tif (motion && minutes) {\n\t\tdef deltaMinutes = minutes as Long\n\t\tif (deltaMinutes) {\n\t\t\tdef motionEvents = motion.eventsSince(new Date(now() - (60000 * deltaMinutes)))\n\t\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\t\tisActive = true\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tisActive = true\n\t}\n\tisActive\n}",
        "docstring": "Control a space heater or window air conditioner in conjunction with any temperature sensor, like a SmartSense Multi."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tgetDataFromWattvision()\n\tscheduleDataCollection()\n}\n\ndef getDataFromWattvision() {\n\n\tlog.trace \"Getting data from Wattvision\"\n\n\tdef children = getChildDevices()\n\tif (!children) {\n\t\tlog.warn \"No children. Not collecting data from Wattviwion\"\n\t\t// currently only support one child\n\t\treturn\n\t}\n\n\tdef endDate = new Date()\n\tdef startDate\n\n\tif (!state.lastUpdated) {\n//\t\tlog.debug \"no state.lastUpdated\"\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t} else {\n//\t\tlog.debug \"parsing state.lastUpdated\"\n\t\tstartDate = new Date().parse(smartThingsDateFormat(), state.lastUpdated)\n\t}\n\n\tstate.lastUpdated = endDate.format(smartThingsDateFormat())\n\n\tchildren.each { child ->\n\t\tgetDataForChild(child, startDate, endDate)\n\t}\n\n}\n\ndef getDataForChild(child, startDate, endDate) {\n\tif (!child) {\n\t\treturn\n\t}\n\n\tdef wattvisionURL = wattvisionURL(child.deviceNetworkId, startDate, endDate)\n\tif (wattvisionURL) {\n\t\ttry {\n\t\t\thttpGet(uri: wattvisionURL) { response ->\n\t\t\t\tdef json = new org.json.JSONObject(response.data.toString())\n\t\t\t\tchild.addWattvisionData(json)\n\t\t\t\treturn \"success\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.HttpResponseException httpE) {\n\t\t\tlog.error \"Wattvision getDataForChild HttpResponseException: ${httpE} -> ${httpE.response.data}\"\n\t\t\t//log.debug \"wattvisionURL = ${wattvisionURL}\"\n\t\t\treturn \"fail\"\n\t\t} catch (e) {\n\t\t\tlog.error \"Wattvision getDataForChild General Exception: ${e}\"\n\t\t\t//log.debug \"wattvisionURL = ${wattvisionURL}\"\n\t\t\treturn \"fail\"\n\t\t}\n\t}\n}\n\ndef wattvisionURL(senorId, startDate, endDate) {\n\n\tlog.trace \"getting wattvisionURL\"\n\n\tdef wattvisionApiAccess = state.wattvisionApiAccess\n\tif (!wattvisionApiAccess.id || !wattvisionApiAccess.key) {\n\t\treturn null\n\t}\n\n\tif (!endDate) {\n\t\tendDate = new Date()\n\t}\n\tif (!startDate) {\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t}\n\n\tdef diff = endDate.getTime() - startDate.getTime()\n\tif (diff > 10800000) { // 3 hours in milliseconds\n\t\t// Wattvision only allows pulling 3 hours of data at a time\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t} else if (diff < 10000) { // 10 seconds in milliseconds\n\t\t// Wattvision throws errors when the difference between start_time and end_time is 5 seconds or less\n\t\t// So we are going to make sure that we have a few more seconds of breathing room\n\t\tuse (groovy.time.TimeCategory) {\n\t\t\tstartDate = endDate - 10.seconds\n\t\t}\n\t}\n\n\tdef params = [\n\t\t\"sensor_id\" : senorId,\n\t\t\"api_id\"    : wattvisionApiAccess.id,\n\t\t\"api_key\"   : wattvisionApiAccess.key,\n\t\t\"type\"      : wattvisionDataType ?: \"rate\",\n\t\t\"start_time\": startDate.format(wattvisionDateFormat()),\n\t\t\"end_time\"  : endDate.format(wattvisionDateFormat())\n\t]\n\n\tdef parameterString = params.collect { key, value -> \"${key.encodeAsURL()}=${value.encodeAsURL()}\" }.join(\"&\")\n\tdef accessURL = wattvisionApiAccess.url ?: \"https://www.wattvision.com/api/v0.2/elec\"\n\tdef url = \"${accessURL}?${parameterString}\"\n\n//\tlog.debug \"wattvisionURL: ${url}\"\n\treturn url\n}\n\ndef getData() {\n\tstate.lastUpdated = new Date().format(smartThingsDateFormat())\n}\n\npublic smartThingsDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" }\n\npublic wattvisionDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss\" }\n\ndef childMarshaller(child) {\n\treturn [\n\t\tname     : child.name,\n\t\tlabel    : child.label,\n\t\tsensor_id: child.deviceNetworkId,\n\t\tlocation : child.location.name\n\t]\n}\n\n// ========================================================\n// ENDPOINTS\n// ========================================================\n\ndef listDevices() {\n\tgetChildDevices().collect { childMarshaller(it) }\n}\n\ndef getDevice() {\n\n\tlog.trace \"Getting device\"\n\n\tdef child = getChildDevice(params.sensorId)\n\n\tif (!child) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\treturn childMarshaller(child)\n}\n\ndef updateDevice() {\n\n\tlog.trace \"Updating Device with data from Wattvision\"\n\n\tdef body = request.JSON\n\n\tdef child = getChildDevice(params.sensorId)\n\n\tif (!child) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\tchild.addWattvisionData(body)\n\n\trender([status: 204, data: \" \"])\n}\n\ndef createDevice() {\n\n\tlog.trace \"Creating Wattvision device\"\n\n\tif (getChildDevice(params.sensorId)) {\n\t\thttpError(403, \"Device already exists\")\n\t}\n\n\tdef child = addChildDevice(\"smartthings\", \"Wattvision\", params.sensorId, null, [name: \"Wattvision\", label: request.JSON.label])\n\n\tchild.setGraphUrl(getGraphUrl(params.sensorId));\n\n\tgetDataForChild(child, null, null)\n\n\treturn childMarshaller(child)\n}\n\ndef deleteDevice() {\n\n\tlog.trace \"Deleting Wattvision device\"\n\n\tdeleteChildDevice(params.sensorId)\n\trender([status: 204, data: \" \"])\n}\n\ndef setApiAccess() {\n\n\tlog.trace \"Granting access to Wattvision API\"\n\n\tdef body = request.JSON\n\n\tstate.wattvisionApiAccess = [\n\t\turl: body.url,\n\t\tid : body.id,\n\t\tkey: body.key\n\t]\n\n\tscheduleDataCollection()\n\n\trender([status: 204, data: \" \"])\n}\n\ndef scheduleDataCollection() {\n\tschedule(\"* /1 * * * ?\", \"getDataFromWattvision\") // every 1 minute\n}\n\ndef revokeApiAccess() {\n\n\tlog.trace \"Revoking access to Wattvision API\"\n\n\tstate.wattvisionApiAccess = [:]\n\trender([status: 204, data: \" \"])\n}\n\npublic getGraphUrl(sensorId) {\n\n\tlog.trace \"Collecting URL for Wattvision graph\"\n\n\tdef apiId = state.wattvisionApiAccess.id\n\tdef apiKey = state.wattvisionApiAccess.key\n\n\t// TODO: allow the changing of type?\n\t\"http://www.wattvision.com/partners/smartthings/charts?s=${sensorId}&api_id=${apiId}&api_key=${apiKey}&type=w\"\n}\n\n// ========================================================\n// SmartThings initiated setup\n// ========================================================\n\n/* Debug info for Steve / Andrew\n\nthis page: /partners/smartthings/whatswv\n\t- linked from within smartthings, will tell you how to get a wattvision sensor, etc.\n\t- pass the debug flag (?debug=1) to show this text.\n\nlogin page: /partners/smartthings/login?callback_url=CALLBACKURL\n\t- open this page, which will require login.\n\t- once login is complete, we call you back at callback_url with:\n\t\t<callback_url>?id=<wattvision_api_id>&key=<wattvision_api_key>\n\t\t\tquestion: will you know which user this is on your end?\n\nsensor json: /partners/smartthings/sensor_list?api_id=...&api_key=...\n\t- returns a list of sensors and their associated house names, as a json object\n\t- example return value with one sensor id 2, associated with house 'Test's House'\n\t\t- content type is application/json\n\t\t- {\"2\": \"Test's House\"}\n\n*/\n\ndef loginCallback() {\n\tlog.trace \"loginCallback\"\n\n\tstate.wattvisionApiAccess = [\n\t\tid : params.id,\n\t\tkey: params.key\n\t]\n\n\tgetSensorJSON(params.id, params.key)\n\n\tconnectionSuccessful(\"Wattvision\", \"https://s3.amazonaws.com/smartapp-icons/Partner/wattvision@2x.png\")\n}\n\nprivate getSensorJSON(id, key) {\n\tlog.trace \"getSensorJSON\"\n\n\tdef sensorUrl = \"${wattvisionBaseURL()}/partners/smartthings/sensor_list?api_id=${id}&api_key=${key}\"\n\n    httpGet(uri: sensorUrl) { response ->\n\n\t\tdef sensors = [:]\n\n        response.data.each { sensorId, sensorName ->\n        \tsensors[sensorId] = sensorName\n\t\t\tcreateChild(sensorId, sensorName)\n        }\n        \n        state.sensors = sensors\n\n\t\treturn \"success\"\n\t}\n    \n}\n\ndef createChild(sensorId, sensorName) {\n\tlog.trace \"creating Wattvision Child\"\n\n\tdef child = getChildDevice(sensorId)\n\n\tif (child) {\n\t\tlog.warn \"Device already exists\"\n\t} else {\n\t\tchild = addChildDevice(\"smartthings\", \"Wattvision\", sensorId, null, [name: \"Wattvision\", label: sensorName])\n\t}\n\n\tchild.setGraphUrl(getGraphUrl(sensorId));\n\n\tgetDataForChild(child, null, null)\n\n\tscheduleDataCollection()\n\n\treturn childMarshaller(child)\n}\n\n// ========================================================\n// URL HELPERS\n// ========================================================\n\nprivate loginURL() { \"${wattvisionBaseURL()}${loginPath()}\" }\n\nprivate wattvisionBaseURL() { \"https://www.wattvision.com\" }\n\nprivate loginPath() { \"/partners/smartthings/login?callback_url=${loginCallbackURL().encodeAsURL()}\" }\n\nprivate loginCallbackURL() {\n\tif (!atomicState.accessToken) { createAccessToken() }\n\tbuildActionUrl(loginCallbackPath())\n}\nprivate loginCallbackPath() { \"login/callback\" }\n\n// ========================================================\n// Access Token\n// ========================================================\n\nprivate getMyAccessToken() { return atomicState.accessToken ?: createAccessToken() }\n\n// ========================================================\n// CONNECTED HTML\n// ========================================================\n\ndef connectionSuccessful(deviceName, iconSrc) {\n\tdef html = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=640\">\n<title>Withings Connection</title>\n<style type=\"text/css\">\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t.container {\n\t\twidth: 560px;\n\t\tpadding: 40px;\n\t\t/*background: #eee;*/\n\t\ttext-align: center;\n\t}\n\timg {\n\t\tvertical-align: middle;\n\t}\n\timg:nth-child(2) {\n\t\tmargin: 0 30px;\n\t}\n\tp {\n\t\tfont-size: 2.2em;\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\ttext-align: center;\n\t\tcolor: #666666;\n\t\tpadding: 0 40px;\n\t\tmargin-bottom: 0;\n\t}\n/*\n\tp:last-child {\n\t\tmargin-top: 0px;\n\t}\n*/\n\tspan {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t}\n</style>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<img src=\"${iconSrc}\" alt=\"${deviceName} icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t<p>Your ${deviceName} is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t</div>\n</body>\n</html>\n\"\"\"\n\n\trender contentType: 'text/html', data: html\n}",
        "docstring": "Monitor your whole-house energy use by connecting to your Wattvision account"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed: $settings\"\n\tschedule(time, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated: $settings\"\n\tunschedule()\n\tschedule(time, \"scheduleCheck\")\n}\n\ndef scheduleCheck() {\n\tdef response = getWeatherFeature(\"forecast\", zipcode)\n\tif (isStormy(response)) {\n\t\tdef open = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\t\tif (open) {\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(\"A storm is a coming and the following things are open: ${open.join(', ')}\", recipients)\n            }\n            else {\n                sendSms(phone, \"A storm is a coming and the following things are open: ${open.join(', ')}\")\n            }\n\t\t}\n\t}\n}\n\nprivate isStormy(json) {\n\tdef STORMY = ['rain', 'snow', 'showers', 'sprinkles', 'precipitation']\n\n\tdef forecast = json?.forecast?.txt_forecast?.forecastday?.first()\n\tif (forecast) {\n\t\tdef text = forecast?.fcttext?.toLowerCase()\n\t\tif (text) {\n\t\t\tdef result = false\n\t\t\tfor (int i = 0; i < STORMY.size() && !result; i++) {\n\t\t\t\tresult = text.contains(STORMY[i])\n\t\t\t}\n\t\t\treturn result\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\tlog.warn \"Did not get a forecast: $json\"\n\t\treturn false\n\t}\n}",
        "docstring": "Is your shed closed? Are your windows shut? Is the grill covered? Are your dogs indoors? Will the lawn and plants need to be watered tomorrow?"
    },
    {
        "code": "def installOptions = false\n\tdef description = \"Required (tap to set)\"\n\tdef authState\n\n\tif (oauth_token()) {\n\t\t// TODO: Check if it's valid\n\t\tif (true) {\n\t\t\tdescription = \"Saved (tap to change)\"\n\t\t\tinstallOptions = true\n\t\t\tauthState = \"complete\"\n\t\t} else {\n\t\t\t// Worth differentiating here? (no longer valid vs. non-existent state.externalAuthToken?)\n\t\t\tdescription = \"Required (tap to set)\"\n\t\t}\n\t}\n\n\n\tdynamicPage(name: \"authPage\", install: installOptions, uninstall: true) {\n\t\tsection {\n\n\t\t\tif (installOptions) {\n\t\t\t\tinput(name: \"withingsLabel\", type: \"text\", title: \"Add a name\", description: null, required: true)\n\t\t\t}\n\n\t\t\thref url: shortUrl(\"authenticate\"), style: \"embedded\", required: false, title: \"Authenticate with Withings\", description: description, state: authState\n\t\t}\n\t}\n}\n\n// ========================================================\n// MAPPINGS\n// ========================================================\n\nmappings {\n\tpath(\"/authenticate\") {\n\t\taction:\n\t\t[\n\t\t\tGET: \"authenticate\"\n\t\t]\n\t}\n\tpath(\"/x\") {\n\t\taction:\n\t\t[\n\t\t\tGET: \"exchangeTokenFromWithings\"\n\t\t]\n\t}\n\tpath(\"/n\") {\n\t\taction:\n\t\t[POST: \"notificationReceived\"]\n\t}\n\n\tpath(\"/test/:action\") {\n\t\taction:\n\t\t[GET: \"test\"]\n\t}\n}\n\ndef test() {\n\t\"${params.action}\"()\n}\n\ndef authenticate() {\n\t// do not hit userAuthorizationUrl when the page is executed. It will replace oauth_tokens\n\t// instead, redirect through here so we know for sure that the user wants to authenticate\n\t// plus, the short-lived tokens that are used during authentication are only valid for 2 minutes\n\t// so make sure we give the user as much of that 2 minutes as possible to enter their credentials and deal with network latency\n\tlog.trace \"starting Withings authentication flow\"\n\tredirect location: userAuthorizationUrl()\n}\n\ndef exchangeTokenFromWithings() {\n\t// Withings hits us here during the oAuth flow\n//\tlog.trace \"exchangeTokenFromWithings ${params}\"\n\tatomicState.userid = params.userid // TODO: restructure this for multi-user access\n\texchangeToken()\n}\n\ndef notificationReceived() {\n//\tlog.trace \"notificationReceived params: ${params}\"\n\n\tdef notificationParams = [\n\t\tstartdate: params.startdate,\n\t\tuserid   : params.userid,\n\t\tenddate  : params.enddate,\n\t]\n\n\tdef measures = wGetMeasures(notificationParams)\n\tsendMeasureEvents(measures)\n\treturn [status: 0]\n}\n\n// ========================================================\n// HANDLERS\n// ========================================================\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n//\twRevokeAllNotifications()\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tif (!getChild()) { createChild() }\n\tapp.updateLabel(withingsLabel)\n\twCreateNotification()\n\tbackfillMeasures()\n}\n\n// ========================================================\n// CHILD DEVICE\n// ========================================================\n\nprivate getChild() {\n\tdef children = childDevices\n\tchildren.size() ? children.first() : null\n}\n\nprivate void createChild() {\n\tdef child = addChildDevice(\"smartthings\", \"Withings User\", userid(), null, [name: app.label, label: withingsLabel])\n\tatomicState.child = [dni: child.deviceNetworkId]\n}\n\n// ========================================================\n// URL HELPERS\n// ========================================================\n\ndef stBaseUrl() {\n\tif (!atomicState.serverUrl) {\n\t\tstToken()\n\t\tatomicState.serverUrl = buildActionUrl(\"\").split(/api\\//).first()\n\t}\n\treturn atomicState.serverUrl\n}\n\ndef stToken() {\n\tatomicState.accessToken ?: createAccessToken()\n}\n\ndef shortUrl(path = \"\", urlParams = [:]) {\n\tattachParams(\"${stBaseUrl()}api/t/${stToken()}/s/${app.id}/${path}\", urlParams)\n}\n\ndef noTokenUrl(path = \"\", urlParams = [:]) {\n\tattachParams(\"${stBaseUrl()}api/smartapps/installations/${app.id}/${path}\", urlParams)\n}\n\ndef attachParams(url, urlParams = [:]) {\n\t[url, toQueryString(urlParams)].findAll().join(\"?\")\n}\n\nString toQueryString(Map m = [:]) {\n//\tlog.trace \"toQueryString. URLEncoder will be used on ${m}\"\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\n// ========================================================\n// WITHINGS MEASURES\n// ========================================================\n\ndef unixTime(date = new Date()) {\n\tdef unixTime = date.time / 1000 as int\n//\tlog.debug \"converting ${date.time} to ${unixTime}\"\n\tunixTime\n}\n\ndef backfillMeasures() {\n//\tlog.trace \"backfillMeasures\"\n\tdef measureParams = [startdate: unixTime(new Date() - 10)]\n\tdef measures = wGetMeasures(measureParams)\n\tsendMeasureEvents(measures)\n}\n\n// this is body measures. // TODO: get activity and others too\ndef wGetMeasures(measureParams = [:]) {\n\tdef baseUrl = \"https://wbsapi.withings.net/measure\"\n\tdef urlParams = [\n\t\taction     : \"getmeas\",\n\t\tuserid     : userid(),\n\t\tstartdate  : unixTime(new Date() - 5),\n\t\tenddate    : unixTime(),\n\t\toauth_token: oauth_token()\n\t] + measureParams\n\tdef measureData = fetchDataFromWithings(baseUrl, urlParams)\n//\tlog.debug \"measureData: ${measureData}\"\n\tmeasureData.body.measuregrps.collect { parseMeasureGroup(it) }.flatten()\n}\n/*\n[\n\tbody:[\n\t\tmeasuregrps:[\n\t\t\t[\n\t\t\t\tcategory:1, // 1 for real measurements, 2 for user objectives.\n\t\t\t\tgrpid:310040317,\n\t\t\t\tmeasures:[\n\t\t\t\t\t[\n\t\t\t\t\t\tunit:0, \t// Power of ten the \"value\" parameter should be multiplied to to get the real value. Eg : value = 20 and unit=-1 means the value really is 2.0\n\t\t\t\t\t\tvalue:60, // Value for the measure in S.I units (kilogram, meters, etc.). Value should be multiplied by 10 to the power of \"unit\" (see below) to get the real value.\n\t\t\t\t\t\ttype:11   // 1 : Weight (kg), 4 : Height (meter), 5 : Fat Free Mass (kg), 6 : Fat Ratio (%), 8 : Fat Mass Weight (kg), 9 : Diastolic Blood Pressure (mmHg), 10 : Systolic Blood Pressure (mmHg), 11 : Heart Pulse (bpm), 54 : SP02(%)\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tunit:-3,\n\t\t\t\t\t\tvalue:-1000,\n\t\t\t\t\t\ttype:18\n\t\t\t\t\t]\n\t\t\t\t],\n\t\t\t\tdate:1422750210,\n\t\t\t\tattrib:2\n\t\t\t]\n\t\t],\n\t\tupdatetime:1422750227\n\t],\n\tstatus:0\n]\n*/\n\ndef sendMeasureEvents(measures) {\n//\tlog.debug \"measures: ${measures}\"\n\tmeasures.each {\n\t\tif (it.name && it.value) {\n\t\t\tsendEvent(userid(), it)\n\t\t}\n\t}\n}\n\ndef parseMeasureGroup(measureGroup) {\n\tlong time = measureGroup.date // must be long. INT_MAX is too small\n\ttime *= 1000\n\tmeasureGroup.measures.collect { parseMeasure(it) + [date: new Date(time)] }\n}\n\ndef parseMeasure(measure) {\n//\tlog.debug \"parseMeasure($measure)\"\n\t[\n\t\tname : measureAttribute(measure),\n\t\tvalue: measureValue(measure)\n\t]\n}\n\ndef measureValue(measure) {\n\tdef value = measure.value * 10.power(measure.unit)\n\tif (measure.type == 1) { // Weight (kg)\n\t\tvalue *= 2.20462262 // kg to lbs\n\t}\n\tvalue\n}\n\nString measureAttribute(measure) {\n\tdef attribute = \"\"\n\tswitch (measure.type) {\n\t\tcase 1: attribute = \"weight\"; break;\n\t\tcase 4: attribute = \"height\"; break;\n\t\tcase 5: attribute = \"leanMass\"; break;\n\t\tcase 6: attribute = \"fatRatio\"; break;\n\t\tcase 8: attribute = \"fatMass\"; break;\n\t\tcase 9: attribute = \"diastolicPressure\"; break;\n\t\tcase 10: attribute = \"systolicPressure\"; break;\n\t\tcase 11: attribute = \"heartPulse\"; break;\n\t\tcase 54: attribute = \"SP02\"; break;\n\t}\n\treturn attribute\n}\n\nString measureDescription(measure) {\n\tdef description = \"\"\n\tswitch (measure.type) {\n\t\tcase 1: description = \"Weight (kg)\"; break;\n\t\tcase 4: description = \"Height (meter)\"; break;\n\t\tcase 5: description = \"Fat Free Mass (kg)\"; break;\n\t\tcase 6: description = \"Fat Ratio (%)\"; break;\n\t\tcase 8: description = \"Fat Mass Weight (kg)\"; break;\n\t\tcase 9: description = \"Diastolic Blood Pressure (mmHg)\"; break;\n\t\tcase 10: description = \"Systolic Blood Pressure (mmHg)\"; break;\n\t\tcase 11: description = \"Heart Pulse (bpm)\"; break;\n\t\tcase 54: description = \"SP02(%)\"; break;\n\t}\n\treturn description\n}\n\n// ========================================================\n// WITHINGS NOTIFICATIONS\n// ========================================================\n\ndef wNotificationBaseUrl() { \"https://wbsapi.withings.net/notify\" }\n\ndef wNotificationCallbackUrl() { shortUrl(\"n\") }\n\ndef wGetNotification() {\n\tdef userId = userid()\n\tdef url = wNotificationBaseUrl()\n\tdef params = [\n\t\taction: \"subscribe\"\n\t]\n\n}\n\n// TODO: keep track of notification expiration\ndef wCreateNotification() {\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"subscribe\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token(),\n\t\tcomment    : \"hmm\" // TODO: figure out what to do here. spaces seem to break the request\n\t]\n\n\tfetchDataFromWithings(baseUrl, urlParams)\n}\n\ndef wRevokeAllNotifications() {\n\tdef notifications = wListNotifications()\n\tnotifications.each {\n\t\twRevokeNotification([callbackurl: it.callbackurl]) // use the callbackurl Withings has on file\n\t}\n}\n\ndef wRevokeNotification(notificationParams = [:]) {\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"revoke\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token()\n\t] + notificationParams\n\n\tfetchDataFromWithings(baseUrl, urlParams)\n}\n\ndef wListNotifications() {\n\n\t/*\n\t{\n\t\tbody: {\n\t\t\tprofiles: [\n\t\t\t\t{\n\t\t\t\t\tappli: 1,\n\t\t\t\t\texpires: 2147483647,\n\t\t\t\t\tcallbackurl: \"https://graph.api.smartthings.com/api/t/72ab3e57-5839-4cca-9562-dcc818f83bc9/s/537757a0-c4c8-40ea-8cea-aa283915bbd9/n\",\n\t\t\t\t\tcomment: \"hmm\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\tstatus: 0\n\t}*/\n\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"list\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token()\n\t]\n\n\tdef notificationData = fetchDataFromWithings(baseUrl, urlParams)\n\tnotificationData.body.profiles\n}\n\ndef defaultOauthParams() {\n\tdefaultParameterKeys().inject([:]) { keyMap, currentKey ->\n\t\tkeyMap[currentKey] = \"${currentKey}\"()\n\t\tkeyMap\n\t}\n}\n\n// ========================================================\n// WITHINGS DATA FETCHING\n// ========================================================\n\ndef fetchDataFromWithings(baseUrl, urlParams) {\n\n//\tlog.debug \"fetchDataFromWithings(${baseUrl}, ${urlParams})\"\n\n\tdef defaultParams = defaultOauthParams()\n\tdef paramStrings = buildOauthParams(urlParams + defaultParams)\n//\tlog.debug \"paramStrings: $paramStrings\"\n\tdef url = buildOauthUrl(baseUrl, paramStrings, oauth_token_secret())\n\tdef json\n//\tlog.debug \"about to make request to ${url}\"\n\thttpGet(uri: url, headers: [\"Content-Type\": \"application/json\"]) { response ->\n\t\tjson = new groovy.json.JsonSlurper().parse(response.data)\n\t}\n\treturn json\n}\n\n// ========================================================\n// WITHINGS OAUTH LOGGING\n// ========================================================\n\ndef wLogEnabled() { false } // For troubleshooting Oauth flow\n\nvoid wLog(message = \"\") {\n\tif (!wLogEnabled()) { return }\n\tdef wLogMessage = atomicState.wLogMessage\n\tif (wLogMessage.length()) {\n\t\twLogMessage += \"\\n|\"\n\t}\n\twLogMessage += message\n\tatomicState.wLogMessage = wLogMessage\n}\n\nvoid wLogNew(seedMessage = \"\") {\n\tif (!wLogEnabled()) { return }\n\tdef olMessage = atomicState.wLogMessage\n\tif (oldMessage) {\n\t\tlog.debug \"purging old wLogMessage: ${olMessage}\"\n\t}\n\tatomicState.wLogMessage = seedMessage\n}\n\nString wLogMessage() {\n\tif (!wLogEnabled()) { return }\n\tdef wLogMessage = atomicState.wLogMessage\n\tatomicState.wLogMessage = \"\"\n\twLogMessage\n}\n\n// ========================================================\n// WITHINGS OAUTH DESCRIPTION\n// >>>>>>\tThe user opens the authPage for this SmartApp\n// STEP 1 get a token to be used in the url the user taps\n// STEP 2 generate the url to be tapped by the user\n// >>>>>>\tThe user taps the url and logs in to Withings\n// STEP 3 generate a token to be used for accessing user data\n// STEP 4 access user data\n// ========================================================\n\n// ========================================================\n// WITHINGS OAUTH STEP 1: get an oAuth \"request token\"\n// ========================================================\n\ndef requestTokenUrl() {\n\twLogNew \"WITHINGS OAUTH STEP 1: get an oAuth 'request token'\"\n\n\tdef keys = defaultParameterKeys() + \"oauth_callback\"\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/request_token\", paramStrings, \"\")\n}\n\n// ========================================================\n// WITHINGS OAUTH STEP 2: End-user authorization\n// ========================================================\n\ndef userAuthorizationUrl() {\n\n\t// get url from Step 1\n\tdef tokenUrl = requestTokenUrl()\n\n\t// collect token from Withings\n\tcollectTokenFromWithings(tokenUrl)\n\n\twLogNew \"WITHINGS OAUTH STEP 2: End-user authorization\"\n\n\tdef keys = defaultParameterKeys() + \"oauth_token\"\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/authorize\", paramStrings, oauth_token_secret())\n}\n\n// ========================================================\n// WITHINGS OAUTH STEP 3: Generating access token\n// ========================================================\n\ndef exchangeTokenUrl() {\n\twLogNew \"WITHINGS OAUTH STEP 3: Generating access token\"\n\n\tdef keys = defaultParameterKeys() + [\"oauth_token\", \"userid\"]\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/access_token\", paramStrings, oauth_token_secret())\n}\n\ndef exchangeToken() {\n\n\tdef tokenUrl = exchangeTokenUrl()\n//\tlog.debug \"about to hit ${tokenUrl}\"\n\n\ttry {\n\t\t// replace old token with a long-lived token\n\t\tdef token = collectTokenFromWithings(tokenUrl)\n//\t\tlog.debug \"collected token from Withings: ${token}\"\n\t\trenderAction(\"authorized\", \"Withings Connection\")\n\t}\n\tcatch (Exception e) {\n\t\tlog.error e\n\t\trenderAction(\"notAuthorized\", \"Withings Connection Failed\")\n\t}\n}\n\n// ========================================================\n// OAUTH 1.0\n// ========================================================\n\ndef defaultParameterKeys() {\n\t[\n\t\t\"oauth_consumer_key\",\n\t\t\"oauth_nonce\",\n\t\t\"oauth_signature_method\",\n\t\t\"oauth_timestamp\",\n\t\t\"oauth_version\"\n\t]\n}\n\ndef oauth_consumer_key() { consumerKey }\n\ndef oauth_nonce() { nonce() }\n\ndef nonce() { UUID.randomUUID().toString().replaceAll(\"-\", \"\") }\n\ndef oauth_signature_method() { \"HMAC-SHA1\" }\n\ndef oauth_timestamp() { (int) (new Date().time / 1000) }\n\ndef oauth_version() { 1.0 }\n\ndef oauth_callback() { shortUrl(\"x\") }\n\ndef oauth_token() { atomicState.wToken?.oauth_token }\n\ndef oauth_token_secret() { atomicState.wToken?.oauth_token_secret }\n\ndef userid() { atomicState.userid }\n\nString hmac(String oAuthSignatureBaseString, String oAuthSecret) throws java.security.SignatureException {\n\tif (!oAuthSecret.contains(\"&\")) { log.warn \"Withings requires \\\"&\\\" to be included no matter what\" }\n\t// get an hmac_sha1 key from the raw key bytes\n\tdef signingKey = new javax.crypto.spec.SecretKeySpec(oAuthSecret.getBytes(), \"HmacSHA1\")\n\t// get an hmac_sha1 Mac instance and initialize with the signing key\n\tdef mac = javax.crypto.Mac.getInstance(\"HmacSHA1\")\n\tmac.init(signingKey)\n\t// compute the hmac on input data bytes\n\tbyte[] rawHmac = mac.doFinal(oAuthSignatureBaseString.getBytes())\n\treturn org.apache.commons.codec.binary.Base64.encodeBase64String(rawHmac)\n}\n\nMap parseResponseString(String responseString) {\n//\tlog.debug \"parseResponseString: ${responseString}\"\n\tresponseString.split(\"&\").inject([:]) { c, it ->\n\t\tdef parts = it.split('=')\n\t\tdef k = parts[0]\n\t\tdef v = parts[1]\n\t\tc[k] = v\n\t\treturn c\n\t}\n}\n\nString applyParams(endpoint, oauthParams) { endpoint + \"?\" + oauthParams.sort().join(\"&\") }\n\nString buildSignature(endpoint, oAuthParams, oAuthSecret) {\n\tdef oAuthSignatureBaseParts = [\"GET\", endpoint, oAuthParams.join(\"&\")]\n\tdef oAuthSignatureBaseString = oAuthSignatureBaseParts.collect { URLEncoder.encode(it) }.join(\"&\")\n\twLog \"    ==> oAuth signature base string : \\n${oAuthSignatureBaseString}\"\n\twLog \"    .. applying hmac-sha1 to base string, with secret : ${oAuthSecret} (notice the \\\"&\\\")\"\n\twLog \"    .. base64 encode then url-encode the hmac-sha1 hash\"\n\tString hmacResult = hmac(oAuthSignatureBaseString, oAuthSecret)\n\tdef signature = URLEncoder.encode(hmacResult)\n\twLog \"    ==> oauth_signature = ${signature}\"\n\treturn signature\n}\n\nList buildOauthParams(List parameterKeys) {\n\twLog \"    .. adding oAuth parameters : \"\n\tdef oauthParams = []\n\tparameterKeys.each { key ->\n\t\tdef value = \"${key}\"()\n\t\twLog \"        ${key} = ${value}\"\n\t\toauthParams << \"${key}=${URLEncoder.encode(value.toString())}\"\n\t}\n\n\twLog \"    .. sorting all request parameters alphabetically \"\n\toauthParams.sort()\n}\n\nList buildOauthParams(Map parameters) {\n\twLog \"    .. adding oAuth parameters : \"\n\tdef oauthParams = []\n\tparameters.each { k, v ->\n\t\twLog \"        ${k} = ${v}\"\n\t\toauthParams << \"${k}=${URLEncoder.encode(v.toString())}\"\n\t}\n\n\twLog \"    .. sorting all request parameters alphabetically \"\n\toauthParams.sort()\n}\n\nString buildOauthUrl(String endpoint, List parameterStrings, String oAuthTokenSecret) {\n\twLog \"Api endpoint : ${endpoint}\"\n\n\twLog \"Signing request :\"\n\tdef oAuthSecret = \"${consumerSecret}&${oAuthTokenSecret}\"\n\tdef signature = buildSignature(endpoint, parameterStrings, oAuthSecret)\n\n\tparameterStrings << \"oauth_signature=${signature}\"\n\n\tdef finalUrl = applyParams(endpoint, parameterStrings)\n\twLog \"Result: ${finalUrl}\"\n\tif (wLogEnabled()) {\n\t\tlog.debug wLogMessage()\n\t}\n\treturn finalUrl\n}\n\ndef collectTokenFromWithings(tokenUrl) {\n\t// get token from Withings using the url generated in Step 1\n\tdef tokenString\n\thttpGet(uri: tokenUrl) { resp -> // oauth_token=<token_key>&oauth_token_secret=<token_secret>\n\t\ttokenString = resp.data.toString()\n//\t\tlog.debug \"collectTokenFromWithings: ${tokenString}\"\n\t}\n\tdef token = parseResponseString(tokenString)\n\tatomicState.wToken = token\n\treturn token\n}\n\n// ========================================================\n// APP SETTINGS\n// ========================================================\n\ndef getConsumerKey() { appSettings.consumerKey }\n\ndef getConsumerSecret() { appSettings.consumerSecret }\n\n// figure out how to put this in settings\ndef getUserId() { atomicState.wToken?.userid }\n\n// ========================================================\n// HTML rendering\n// ========================================================\n\ndef renderAction(action, title = \"\") {\n\tlog.debug \"renderAction: $action\"\n\trenderHTML(title) {\n\t\thead { \"${action}HtmlHead\"() }\n\t\tbody { \"${action}HtmlBody\"() }\n\t}\n}\n\ndef authorizedHtmlHead() {\n\tlog.trace \"authorizedHtmlHead\"\n\t\"\"\"\n\t\t<style type=\"text/css\">\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t.container {\n\t\t\t\t/*width: 560px;\n\t\t\t\tpadding: 40px;*/\n\t\t\t\t/*background: #eee;*/\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\timg {\n\t\t\t\tvertical-align: middle;\n\t\t\t\t\t\t\tmax-width:20%;\n\t\t\t}\n\t\t\timg:nth-child(2) {\n\t\t\t\tmargin: 0 30px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\t/*font-size: 1.2em;*/\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\ttext-align: center;\n\t\t\t\tcolor: #666666;\n\t\t\t\tpadding: 0 10px;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\t\t/*\n\t\t\tp:last-child {\n\t\t\t\tmargin-top: 0px;\n\t\t\t}\n\t\t*/\n\t\t\tspan {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t}\n\t\t</style>\n\t\t\"\"\"\n}\n\ndef authorizedHtmlBody() {\n\t\"\"\"\n\t\t<div class=\"container\">\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/withings@2x.png\" alt=\"withings icon\" />\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t\t<p>Your Withings scale is now connected to SmartThings!</p>\n\t\t\t<p>Click 'Done' to finish setup.</p>\n\t\t</div>\n\t\t\"\"\"\n}\n\ndef notAuthorizedHtmlHead() {\n\tlog.trace \"notAuthorizedHtmlHead\"\n\tauthorizedHtmlHead()\n}\n\ndef notAuthorizedHtmlBody() {\n\t\"\"\"\n\t\t<div class=\"container\">\n\t\t\t<p>There was an error connecting to SmartThings!</p>\n\t\t\t<p>Click 'Done' to try again.</p>\n\t\t</div>\n\t\t\"\"\"\n}",
        "docstring": "Connect With Withings"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef poll() {\n\tif(shouldPoll())\n\t{\n\t\treturn getMeasurement()\n\t}\n\n\treturn null\n}\n\ndef shouldPoll() {\n\tdef lastPollString = state.lastPollMillisString\n\tdef lastPoll = lastPollString?.isNumber() ? lastPollString.toLong() : 0\n\tdef ONE_HOUR = 60 * 60 * 1000\n\n\tdef time = new Date().time\n\n\tif(time > (lastPoll + ONE_HOUR))\n\t{\n\t\tlog.debug \"Executing poll b/c (now > last + 1hr): ${time} > ${lastPoll + ONE_HOUR} (last: ${lastPollString})\"\n\t\tstate.lastPollMillisString = time\n\n\t\treturn true\n\t}\n\n\tlog.debug \"skipping poll b/c !(now > last + 1hr): ${time} > ${lastPoll + ONE_HOUR} (last: ${lastPollString})\"\n\treturn false\n}\n\ndef refresh() {\n\tlog.debug \"Executing 'refresh'\"\n\treturn getMeasurement()\n}\n\ndef getChildNamespace() { \"smartthings\" }\ndef getScaleChildName() { \"Wireless Scale\" }\ndef getBodyAnalyzerChildName() { \"Smart Body Analyzer\" }\n\ndef getServerUrl() { appSettings.serverUrl }\ndef getSmartThingsConsumerKey() { appSettings.clientId }\ndef getSmartThingsConsumerSecret() { appSettings.clientSecret }",
        "docstring": "Connect your Withings scale to SmartThings."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef uninstalled() {\n\tremoveChildDevices(getChildDevices())\n}\n\ndef initialize() {\n\n\tif(!state.suppressDelete)\n\t{\n\t\tstate.suppressDelete = [:]\n\t}\n\n\tlog.debug \"settings: $settings\"\n\n\tdef devices = cameras.collect { dni ->\n\n\t\tdef name = state.cameraNames[dni] ?: \"Yoics Device\"\n\n\t\tdef d = getChildDevice(dni)\n\n\t\tif(!d)\n\t\t{\n\t\t\td = addChildDevice(\"smartthings\", \"Yoics Camera\", dni, null, [name:\"YoicsCamera\", label:name])\n\n\t\t\t/* WE'LL GET PROXY ON TAKE REQUEST\n\t\t\tdef setupProxyResult = setupProxy(dni)\n\t\t\tif(setupProxyResult.success)\n\t\t\t{\n\t\t\t\tlog.debug \"Setting up the proxy worked...taking image capture now?\"\n\n\t\t\t}\n\t\t\t*/\n\n\t\t\t//Let's not take photos on add\n\t\t\t//d.take()\n\n\t\t\tlog.debug \"created ${d.displayName} with id $dni\"\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug \"found ${d.displayName} with id $dni already exists\"\n\t\t}\n\n\t\treturn d\n\t}\n\n\tlog.debug \"created ${devices.size()} dropcams\"\n\n\t/* //Original Code seems to delete the dropcam that is being added */\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !cameras?.contains(it.deviceNetworkId) }\n\tremoveChildDevices(delete)\n}\n\nprivate removeChildDevices(delete)\n{\n\tlog.debug \"deleting ${delete.size()} dropcams\"\n\tdelete.each {\n\t\tstate.suppressDelete[it.deviceNetworkId] = true\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t\tstate.suppressDelete.remove(it.deviceNetworkId)\n\t}\n}\nprivate List getDeviceList()\n{\n\n\t//https://apilb.yoics.net/web/api/getdevices.ashx?token=&filter=all&whose=me&state=%20all&type=xml\n\n\tdef deviceListParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/getdevices.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), filter: \"all\", whose: \"me\", state: \"all\", type:\"json\" ]\n\t]\n\n\tlog.debug \"cam list via: $deviceListParams\"\n\n\tdef multipleHtml\n\tdef singleUrl\n\tdef something\n\tdef more\n\n\tdef devices = []\n\n\thttpGet(deviceListParams) { resp ->\n\n\t\tlog.debug \"getting device list...\"\n\n\t\tsomething = resp.status\n\t\tmore = \"headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\n\t\tif(resp.status == 200)\n\t\t{\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\t//log.debug \"get devices list response: ${jsonString}\"\n\t\t\t//log.debug \"get device list response: ${body}\"\n\n\t\t\tbody.NewDataSet.Table.each { d ->\n\t\t\t\t//log.debug \"Addding ${d.devicealias} with address: ${d.deviceaddress}\"\n\t\t\t\tdevices << [title: d.devicealias, uuid: d.deviceaddress]\t//uuid should be another name\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR\n\t\t\tlog.error \"camera list: unknown response\"\n\t\t}\n\n\t}\n\n\t log.debug \"list: after getting cameras: \" + [devices:devices, url:singleUrl, html:multipleHtml?.size(), something:something, more:more]\n\n\t// ERROR?\n\treturn devices\n}\n\ndef removeChildFromSettings(child)\n{\n\tdef device = child.device\n\n\tdef dni = device.deviceNetworkId\n\tlog.debug \"removing child device $device with dni ${dni}\"\n\n\tif(!state?.suppressDelete?.get(dni))\n\t{\n\t\tdef newSettings = settings.cameras?.findAll { it != dni } ?: []\n\t\tapp.updateSetting(\"cameras\", newSettings)\n\t}\n}\n\nprivate forceLogin() {\n\tupdateAuthHash(null)\n\tlogin()\n}\n\n\nprivate login() {\n\n\tif(getAuthHashValueIsValid())\n\t{\n\t\treturn [success:true]\n\t}\n\treturn doLogin()\n}\n\n/*private setupProxy(dni) {\n\t//https://apilb.yoics.net/web/api/connect.ashx?token=&deviceaddress=00:00:48:02:2A:A2:08:0E&type=xml\n\n\tdef address = dni?.split(/\\./)?.last()\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/connect.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), deviceaddress:address, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tdef proxy = body?.NewDataSet?.Table[0]?.proxy\n\t\t\tdef requested = body?.NewDataSet?.Table[0]?.requested\n\t\t\tdef expirationsec = body?.NewDataSet?.Table[0]?.expirationsec\n\t\t\tdef url = body?.NewDataSet?.Table[0]?.url\n\n\t\t\tdef proxyMap = [proxy:proxy, requested: requested, expirationsec:expirationsec, url: url]\n\n\t\t\tif (proxy) {\n\t\t\t\t//log.debug \"setting ${dni} proxy to ${proxyMap}\"\n\t\t\t\t//updateDeviceProxy(address, proxyMap)\n\t\t\t\tresult.success = true\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}*/\n\n\n\nprivate doLogin(user = \"\", pwd = \"\") { //change this name\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/login.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [key: \"SmartThingsApplication\", usr: username, pwd: password, apilevel: 12, type:\"json\" ]\n\t]\n\n\tif (user) {\n\t\tloginParams.query = [key: \"SmartThingsApplication\", usr: user, pwd: pwd, apilevel: 12, type:\"json\" ]\n\t}\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tlog.debug \"login response: ${jsonString}\"\n\t\t\tlog.debug \"login response: ${body}\"\n\n\t\t\tdef authhash = body?.NewDataSet?.Table[0]?.authhash //.token\n\n\t\t\t//this may return as well??\n\t\t\tdef token = body?.NewDataSet?.Table[0]?.token ?: null\n\n\t\t\tif (authhash) {\n\t\t\t\tlog.debug \"login setting authhash to ${authhash}\"\n\t\t\t\tupdateAuthHash(authhash)\n\t\t\t\tif (token) {\n\t\t\t\t\tlog.debug \"login setting login token to ${token}\"\n\t\t\t\t\tupdateLoginToken(token)\n\t\t\t\t\tresult.success = true\n\t\t\t\t} else {\n\t\t\t\t\tresult.success = doLoginToken()\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}\n\nprivate doLoginToken() {\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/login.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [key: \"SmartThingsApplication\", usr: getUserName(), auth: getAuthHashValue(), apilevel: 12, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200)\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tdef token = body?.NewDataSet?.Table[0]?.token\n\n\t\t\tif (token) {\n\t\t\t\tlog.debug \"login setting login to $token\"\n\t\t\t\tupdateLoginToken(token)\n\t\t\t\tresult.success = true\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}\n\ndef takePicture(String dni, Integer imgWidth=null)\n{\n\n\t//turn on any of the selected lights that are off\n\tdef offLights = switches.findAll{(it.currentValue(\"switch\") == \"off\")}\n\tlog.debug offLights\n\toffLights.collect{it.on()}\n\n\tlog.debug \"parent.takePicture(${dni}, ${imgWidth})\"\n\n\tdef uuid = dni?.split(/\\./)?.last()\n\n\tlog.debug \"taking picture for $uuid (${dni})\"\n\n\tdef imageBytes\n\tdef loginRequired = false\n\n\ttry\n\t{\n\t\timageBytes = doTakePicture(uuid, imgWidth)\n\t}\n\tcatch(Exception e)\n\t{\n\t\tlog.error \"Exception $e trying to take a picture, attempting to login again\"\n\t\tloginRequired = true\n\t}\n\n\tif(loginRequired)\n\t{\n\t\tdef loginResult = doLoginToken()\n\t\tif(loginResult.success)\n\t\t{\n\t\t\t// try once more\n\t\t\timageBytes = doTakePicture(uuid, imgWidth)\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error \"tried to login to dropcam after failing to take a picture and failed\"\n\t\t}\n\t}\n\n\t//turn previously off lights to their original state\n\toffLights.collect{it.off()}\n\treturn imageBytes\n}\n\nprivate doTakePicture(String uuid, Integer imgWidth)\n{\n\timgWidth = imgWidth ?: 1280\n\tdef loginRequired = false\n\n\tdef proxyParams = getDeviceProxy(uuid)\n\tif(!proxyParams.success)\n\t{\n\t\tthrow new Exception(\"Login Required\")\n\t}\n\n\tdef takeParams = [\n\t\turi: \"${proxyParams.uri}\",\n\t\tpath: \"${proxyParams.path}\",\n\t\theaders: ['User-Agent': validUserAgent()]\n\t]\n\n\tdef imageBytes\n\n\thttpGet(takeParams) { resp ->\n\n\t\tif(resp.status == 403)\n\t\t{\n\t\t\tloginRequired = true\n\t\t}\n\t\telse if (resp.status == 200 && resp.headers.'Content-Type'.contains(\"image/jpeg\"))\n\t\t{\n\t\t\timageBytes = resp.data\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error \"unknown takePicture() response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired)\n\t{\n\t\tthrow new Exception(\"Login Required\")\n\t}\n\n\treturn imageBytes\n}\n\n/////////////////////////\nprivate Boolean getLoginTokenValueIsValid()\n{\n\treturn getLoginTokenValue()\n}\n\nprivate updateLoginToken(String token) {\n\tstate.loginToken = token\n}\n\nprivate getLoginTokenValue() {\n\tstate.loginToken\n}\n\nprivate Boolean getAuthHashValueIsValid()\n{\n\treturn getAuthHashValue()\n}\n\nprivate updateAuthHash(String hash) {\n\tstate.authHash = hash\n}\n\nprivate getAuthHashValue() {\n\tstate.authHash\n}\n\nprivate updateUserName(String username) {\n\tstate.username = username\n}\n\nprivate getUserName() {\n\tstate.username\n}\n\n/*private getDeviceProxy(dni){\n\t//check if it exists or is not longer valid and create a new proxy here\n\tlog.debug \"returning proxy ${state.proxy[dni].proxy}\"\n\tdef proxy = [uri:state.proxy[dni].proxy, path:state.proxy[dni].url]\n\tlog.debug \"returning proxy ${proxy}\"\n\tproxy\n}*/\n\nprivate updateDeviceProxy(dni, map){\n\tif (!state.proxy) { state.proxy = [:] }\n\tstate.proxy[dni] = map\n}\n\nprivate getDeviceProxy(dni) {\n\tdef address = dni?.split(/\\./)?.last()\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/connect.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), deviceaddress:address, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tif (body?.NewDataSet?.Table[0]?.error)\n\t\t\t{\n\t\t\t\tlog.error \"Attempt to get Yoics Proxy failed\"\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = body?.NewDataSet?.Table[0]?.message\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.uri = body?.NewDataSet?.Table[0]?.proxy\n\t\t\t\tresult.path = body?.NewDataSet?.Table[0]?.url\n\t\t\t\tresult.requested = body?.NewDataSet?.Table[0]?.requested\n\t\t\t\tresult.expirationsec = body?.NewDataSet?.Table[0]?.expirationsec\n\t\t\t\tresult.success = true\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n\n}\n\nprivate validUserAgent() {\n\t\"curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8x zlib/1.2.5\"\n}\n\ndef foauth() {\n\tdef html = \"\"\"<html>\n<head>\n\t<title>$inputQuery results</title>\n\t<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<link rel=\"shortcut icon\" href=\"/static/sT2cZkBCCKJduBLfQ6NfUjZg1AiMhFK9ESNxUjjlvsk.ico\" type=\"image/x-icon\">\n\t<link rel=\"apple-touch-icon\" href=\"/static/7UIUNICQhrzmPRYK3T7j5BhAsvUIbKE8OARNI702Dw9.png\">\n\t<link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/static/HkpqhLsUc5flOzvxrpaoyybhcCP1iRd0ogxhWFJ9vKo.png\">\n\n\t<script src=\"/static/1vXORVkZK58St3QjdbzerXZDi9MfZQ8Q3wCyumiNiep.js\" type=\"text/javascript\" ></script>\n\t<link href=\"/static/ZLo6WmGLBQwvykZ4sFgJS1W8IKyGj3TKdKZXyHcBB9l.css\" type=\"text/css\" rel=\"stylesheet\" media=\"screen, projection\" />\n\t<link rel=\"stylesheet\" href=\"/static/sd6ug4HGJyhdTwTONDZK6Yw8VsYbyDa4qUPgLokOkTn.css\" type=\"text/css\">\n\n</head>\n<body>\n\n\t<h1>\n\t\tYoics Login\n\t</h1>\n\n<form name=\"login\" action=\"${buildUrl(\"\", \"authorize\")}\" method=\"post\">\nUser:\n<br>\n<input type=\"text\" name=\"user\" style=\"height: 50px;\">\n<br>\n<br>\nPassword:\n<br>\n<input type=\"password\" name=\"password\" style=\"height: 50px;\">\n\n<input type=\"submit\" value=\"Submit\">\n</form>\n\n\n</body>\n</html>\"\"\"\n\n\trender status: 200, contentType: 'text/html', data: html\n}\n\ndef authorize() {\n\n\tdef loginResult = doLogin(params.user, params.password)\n\n\tdef result\n\tif (loginResult.success) {\n    \tresult = \"Successful\"\n\n        //save username\n\t\tupdateUserName(params.user)\n    } else {\n    \tresult = \"Failed\"\n    }\n\n\tdef html = \"\"\"<html>\n<head>\n\t<title>$inputQuery results</title>\n\t<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<link rel=\"shortcut icon\" href=\"/static/sT2cZkBCCKJduBLfQ6NfUjZg1AiMhFK9ESNxUjjlvsk.ico\" type=\"image/x-icon\">\n<link rel=\"apple-touch-icon\" href=\"/static/7UIUNICQhrzmPRYK3T7j5BhAsvUIbKE8OARNI702Dw9.png\">\n<link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/static/HkpqhLsUc5flOzvxrpaoyybhcCP1iRd0ogxhWFJ9vKo.png\">\n\n\n\n<script src=\"/static/1vXORVkZK58St3QjdbzerXZDi9MfZQ8Q3wCyumiNiep.js\" type=\"text/javascript\" ></script>\n<link href=\"/static/ZLo6WmGLBQwvykZ4sFgJS1W8IKyGj3TKdKZXyHcBB9l.css\" type=\"text/css\" rel=\"stylesheet\" media=\"screen, projection\" />\n<link rel=\"stylesheet\" href=\"/static/sd6ug4HGJyhdTwTONDZK6Yw8VsYbyDa4qUPgLokOkTn.css\" type=\"text/css\">\n<script>\nfunction buildCmd(){\n\n}\n</script>\n</head>\n<body>\n\n\t<h1>\n\t\tYoics Login ${result}!\n\t</h1>\n\n</body>\n</html>\"\"\"\n\n\trender status: 200, contentType: 'text/html', data: html\n}",
        "docstring": "Connect and Control your Yoics Enabled Devices"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n    def startHour = startHour1\n    def stopHour = stopHour1\n    def startTime = minutes\n    if (minutes == \"1\") {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tstartTime = \"0 0,30 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tstartTime = \"0 0,20,40 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tstartTime = \"0 0,15,30,45 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tstartTime = \"0 0,12,24,36,48 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tstartTime = \"0 0,10,20,30,40,50 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tstartTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tstartTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tstartTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t}\n\tlog.debug \"${startTime}\"   \n    /*\n    def stopTime = \"0 $minutes $stopHour * * ?\"   */\n\tschedule(startTime, openValve)\n/*\tschedule(\"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\", openValve) */\n/*\tschedule(stopTime, closeValve)  */\n   \tsubscribe(valves1, \"switch.on\", valveOnHandler, [filterEvents: false])\n\n}\n\ndef updated(settings) {\n\tunschedule()\n\tunsubscribe()\n\tlog.debug \"Installed with settings: ${settings}\"\n    def startHour = startHour1\n    def stopHour = stopHour1\n    def startTime = minutes\n    if (minutes == \"1\") {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tstartTime = \"0 0,30 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tstartTime = \"0 0,20,40 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tstartTime = \"0 0,15,30,45 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tstartTime = \"0 0,12,24,36,48 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tstartTime = \"0 0,10,20,30,40,50 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tstartTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tstartTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tstartTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t}\n\tlog.debug \"${startTime}\"   \n    /*\n    def stopTime = \"0 $minutes $stopHour * * ?\"   */\n\tschedule(startTime, openValve)\n/*\tschedule(stopTime, closeValve)  */\n   \tsubscribe(valves1, \"switch.on\", valveOnHandler, [filterEvents: false])\n/*\tschedule(\"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\", openValve)  */\n\n}\n\ndef openValve() {\n\tlog.debug \"Turning on Sprinklers ${valves1}\"\n\tvalves1.on()\n\n}\n\ndef closeValve() {\n\tlog.debug \"Turning off Sprinklers ${valves1}\"\n\tvalves1.off()\n}\n\ndef valveOnHandler(evt) {\n\tlog.debug \"Valve ${valves1} turned: ${evt.value}\"\n\tdef delay = duration\n\tlog.debug \"Turning off in ${duration/60} minutes (${delay}seconds)\"\n\trunIn(delay, closeValve)\n}\n\ndef setStartTime() {\n    if (minutes == \"1\") {\n\t\tdef startTime = \"0 0 $startHour * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tdef startTime = \"0 0,30 $startHour * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tdef startTime = \"0 0,20,40 $startHour * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tdef startTime = \"0 0,15,30,45 $startHour * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tdef startTime = \"0 0,12,24,36,48 $startHour * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tdef startTime = \"0 0,10,20,30,40,50 $startHour * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tdef startTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tdef startTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tdef startTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?\"\n\t} else {\n\t\tdef startTime = \"0 0 $startHour * * ?\"\n\t}\n}",
        "docstring": "Control Sprayers for a period of time a number of times per hour"
    },
    {
        "code": "def installed() {\n    LOG(\"installed()\")\n\n    initialize()\n    state.installed = true\n}\n\ndef updated() {\n    LOG(\"updated()\")\n\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\nprivate def setupInit() {\n    LOG(\"setupInit()\")\n\n    if (state.installed == null) {\n        state.installed = false\n        state.armed = false\n        state.zones = []\n        state.alarms = []\n        state.history = []\n    } else {\n        def version = state.version as String\n        if (version == null || version.startsWith('1')) {\n            return false\n        }\n    }\n\n    state.version = getVersion()\n    return true\n}\n\nprivate def initialize() {\n    log.debug \"Smart Alarm. Version ${getVersion()}. ${textCopyright()}\"\n    LOG(\"settings: ${settings}\")\n\n    clearAlarm()\n    state.delay = settings.delay?.toInteger() ?: 30\n    state.offSwitches = []\n    state.history = []\n\n    if (settings.awayModes?.contains(location.mode)) {\n        state.armed = true\n        state.stay = false\n    } else if (settings.stayModes?.contains(location.mode)) {\n        state.armed = true\n        state.stay = true\n    } else {\n        state.armed = false\n        state.stay = false\n    }\n\n    initZones()\n    initButtons()\n    initRestApi()\n    subscribe(location, onLocation)\n\n    STATE()\n}\n\nprivate def clearAlarm() {\n    LOG(\"clearAlarm()\")\n\n    state.alarms = []\n    settings.alarms*.off()\n\n    // Turn off only those switches that we've turned on\n    def switchesOff = state.offSwitches\n    if (switchesOff) {\n        LOG(\"switchesOff: ${switchesOff}\")\n        settings.switches.each() {\n            if (switchesOff.contains(it.id)) {\n                it.off()\n            }\n        }\n        state.offSwitches = []\n    }\n}\n\nprivate def initZones() {\n    LOG(\"initZones()\")\n\n    state.zones = []\n\n    state.zones << [\n        deviceId:   null,\n        sensorType: \"panic\",\n        zoneType:   \"alert\",\n        delay:      false\n    ]\n\n    if (settings.z_contact) {\n        settings.z_contact.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"contact\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"exterior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_contact, \"contact.open\", onContact)\n    }\n\n    if (settings.z_motion) {\n        settings.z_motion.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"motion\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"interior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_motion, \"motion.active\", onMotion)\n    }\n\n    if (settings.z_movement) {\n        settings.z_movement.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"acceleration\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"interior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_movement, \"acceleration.active\", onMovement)\n    }\n\n    if (settings.z_smoke) {\n        settings.z_smoke.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"smoke\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"alert\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_smoke, \"smoke.detected\", onSmoke)\n        subscribe(settings.z_smoke, \"smoke.tested\", onSmoke)\n        subscribe(settings.z_smoke, \"carbonMonoxide.detected\", onSmoke)\n        subscribe(settings.z_smoke, \"carbonMonoxide.tested\", onSmoke)\n    }\n\n    if (settings.z_water) {\n        settings.z_water.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"water\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"alert\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_water, \"water.wet\", onWater)\n    }\n\n    state.zones.each() {\n        def zoneType = it.zoneType\n\n        if (zoneType == \"alert\") {\n            it.armed = true\n        } else if (zoneType == \"exterior\") {\n            it.armed = state.armed\n        } else if (zoneType == \"interior\") {\n            it.armed = state.armed && !state.stay\n        } else {\n            it.armed = false\n        }\n    }\n}\n\nprivate def initButtons() {\n    LOG(\"initButtons()\")\n\n    state.buttonActions = []\n    if (settings.remotes) {\n        if (settings.buttonArmAway) {\n            def button = settings.buttonArmAway.toInteger()\n            def event = settings.holdArmAway ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"armAway\"]\n        }\n\n        if (settings.buttonArmStay) {\n            def button = settings.buttonArmStay.toInteger()\n            def event = settings.holdArmStay ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"armStay\"]\n        }\n\n        if (settings.buttonDisarm) {\n            def button = settings.buttonDisarm.toInteger()\n            def event = settings.holdDisarm ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"disarm\"]\n        }\n\n        if (settings.buttonPanic) {\n            def button = settings.buttonPanic.toInteger()\n            def event = settings.holdPanic ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"panic\"]\n        }\n\n        if (state.buttonActions) {\n            subscribe(settings.remotes, \"button\", onButtonEvent)\n        }\n    }\n}\n\nprivate def initRestApi() {\n    if (settings.restApiEnabled) {\n        if (!state.accessToken) {\n            def token = createAccessToken()\n            LOG(\"Created new access token: ${token})\")\n        }\n        state.url = \"https://graph.api.smartthings.com/api/smartapps/installations/${app.id}/\"\n        log.debug \"REST API enabled\"\n    } else {\n        state.url = \"\"\n        log.debug \"REST API disabled\"\n    }\n}\n\nprivate def isRestApiEnabled() {\n    return settings.restApiEnabled && state.accessToken\n}\n\ndef onContact(evt)  { onZoneEvent(evt, \"contact\") }\ndef onMotion(evt)   { onZoneEvent(evt, \"motion\") }\ndef onMovement(evt) { onZoneEvent(evt, \"acceleration\") }\ndef onSmoke(evt)    { onZoneEvent(evt, \"smoke\") }\ndef onWater(evt)    { onZoneEvent(evt, \"water\") }\n\nprivate def onZoneEvent(evt, sensorType) {\n    LOG(\"onZoneEvent(${evt.displayName}, ${sensorType})\")\n\n    def zone = getZoneForDevice(evt.deviceId, sensorType)\n    if (!zone) {\n        log.warn \"Cannot find zone for device ${evt.deviceId}\"\n        return\n    }\n\n    if (zone.armed) {\n        state.alarms << evt.displayName\n        if (zone.zoneType == \"alert\" || !zone.delay || (state.stay && settings.stayDelayOff)) {\n            activateAlarm()\n        } else {\n            myRunIn(state.delay, activateAlarm)\n        }\n    }\n}\n\ndef onLocation(evt) {\n    LOG(\"onLocation(${evt.value})\")\n\n    String mode = evt.value\n    if (settings.awayModes?.contains(mode)) {\n        armAway()\n    } else if (settings.stayModes?.contains(mode)) {\n        armStay()\n    } else if (settings.disarmModes?.contains(mode)) {\n        disarm()\n    }\n}\n\ndef onButtonEvent(evt) {\n    LOG(\"onButtonEvent(${evt.displayName})\")\n\n    if (!state.buttonActions || !evt.data) {\n        return\n    }\n\n    def slurper = new JsonSlurper()\n    def data = slurper.parseText(evt.data)\n    def button = data.buttonNumber?.toInteger()\n    if (button) {\n        LOG(\"Button '${button}' was ${evt.value}.\")\n        def item = state.buttonActions.find {\n            it.button == button && it.event == evt.value\n        }\n\n        if (item) {\n            LOG(\"Executing '${item.action}' button action\")\n            \"${item.action}\"()\n        }\n    }\n}\n\ndef armAway() {\n    LOG(\"armAway()\")\n\n    if (!atomicState.armed || atomicState.stay) {\n        armPanel(false)\n    }\n}\n\ndef armStay() {\n    LOG(\"armStay()\")\n\n    if (!atomicState.armed || !atomicState.stay) {\n        armPanel(true)\n    }\n}\n\ndef disarm() {\n    LOG(\"disarm()\")\n\n    if (atomicState.armed) {\n        state.armed = false\n        state.zones.each() {\n            if (it.zoneType != \"alert\") {\n                it.armed = false\n            }\n        }\n\n        reset()\n    }\n}\n\ndef panic() {\n    LOG(\"panic()\")\n\n    state.alarms << \"Panic\"\n    activateAlarm()\n}\n\ndef reset() {\n    LOG(\"reset()\")\n\n    unschedule()\n    clearAlarm()\n\n    // Send notification\n    def msg = \"${location.name} is \"\n    if (state.armed) {\n        msg += \"ARMED \"\n        msg += state.stay ? \"STAY\" : \"AWAY\"\n    } else {\n        msg += \"DISARMED.\"\n    }\n\n    notify(msg)\n    notifyVoice()\n}\n\ndef exitDelayExpired() {\n    LOG(\"exitDelayExpired()\")\n\n    def armed = atomicState.armed\n    def stay = atomicState.stay\n    if (!armed) {\n        log.warn \"exitDelayExpired: unexpected state!\"\n        STATE()\n        return\n    }\n\n    state.zones.each() {\n        def zoneType = it.zoneType\n        if (zoneType == \"exterior\" || (zoneType == \"interior\" && !stay)) {\n            it.armed = true\n        }\n    }\n\n    def msg = \"${location.name}: all \"\n    if (stay) {\n        msg += \"exterior \"\n    }\n    msg += \"zones are armed.\"\n\n    notify(msg)\n}\n\nprivate def armPanel(stay) {\n    LOG(\"armPanel(${stay})\")\n\n    unschedule()\n    clearAlarm()\n\n    state.armed = true\n    state.stay = stay\n\n    def armDelay = false\n    state.zones.each() {\n        def zoneType = it.zoneType\n        if (zoneType == \"exterior\") {\n            if (it.delay) {\n                it.armed = false\n                armDelay = true\n            } else {\n                it.armed = true\n            }\n        } else if (zoneType == \"interior\") {\n            if (stay) {\n                it.armed = false\n            } else if (it.delay) {\n                it.armed = false\n                armDelay = true\n            } else {\n                it.armed = true\n            }\n        }\n    }\n\n    def delay = armDelay && !(stay && settings.stayDelayOff) ? atomicState.delay : 0\n    if (delay) {\n        myRunIn(delay, exitDelayExpired)\n    }\n\n    def mode = stay ? \"STAY\" : \"AWAY\"\n    def msg = \"${location.name} \"\n    if (delay) {\n        msg += \"will arm ${mode} in ${state.delay} seconds.\"\n    } else {\n        msg += \"is ARMED ${mode}.\"\n    }\n\n    notify(msg)\n    notifyVoice()\n}\n\n// .../armaway REST API endpoint\ndef apiArmAway() {\n    LOG(\"apiArmAway()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && settings.armWithPin && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    armAway()\n    return apiStatus()\n}\n\n// .../armstay REST API endpoint\ndef apiArmStay() {\n    LOG(\"apiArmStay()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && settings.armWithPin && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    armStay()\n    return apiStatus()\n}\n\n// .../disarm REST API endpoint\ndef apiDisarm() {\n    LOG(\"apiDisarm()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    disarm()\n    return apiStatus()\n}\n\n// .../panic REST API endpoint\ndef apiPanic() {\n    LOG(\"apiPanic()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    panic()\n    return apiStatus()\n}\n\n// .../status REST API endpoint\ndef apiStatus() {\n    LOG(\"apiStatus()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    def status = [\n        status: state.armed ? (state.stay ? \"armed stay\" : \"armed away\") : \"disarmed\",\n        alarms: state.alarms\n    ]\n\n    return status\n}\n\ndef activateAlarm() {\n    LOG(\"activateAlarm()\")\n\n    if (state.alarms.size() == 0) {\n        log.warn \"activateAlarm: false alarm\"\n        return\n    }\n\n    switch (settings.sirenMode) {\n    case \"Siren\":\n        settings.alarms*.siren()\n        break\n\n    case \"Strobe\":\n        settings.alarms*.strobe()\n        break\n\n    case \"Both\":\n        settings.alarms*.both()\n        break\n    }\n\n    // Only turn on those switches that are currently off\n    def switchesOn = settings.switches?.findAll { it?.currentSwitch == \"off\" }\n    LOG(\"switchesOn: ${switchesOn}\")\n    if (switchesOn) {\n        switchesOn*.on()\n        state.offSwitches = switchesOn.collect { it.id }\n    }\n\n    settings.cameras*.take()\n\n    if (settings.helloHomeAction) {\n        log.debug \"Executing HelloHome action '${settings.helloHomeAction}'\"\n        location.helloHome.execute(settings.helloHomeAction)\n    }\n\n    def msg = \"Alarm at ${location.name}!\"\n    state.alarms.each() {\n        msg += \"\\n${it}\"\n    }\n\n    notify(msg)\n    notifyVoice()\n\n    myRunIn(180, reset)\n}\n\nprivate def notify(msg) {\n    LOG(\"notify(${msg})\")\n\n    log.debug msg\n\n    if (state.alarms.size()) {\n        // Alarm notification\n        if (settings.pushMessage) {\n            mySendPush(msg)\n        } else {\n            sendNotificationEvent(msg)\n        }\n\n        if (settings.smsAlarmPhone1 && settings.phone1) {\n            sendSms(phone1, msg)\n        }\n\n        if (settings.smsAlarmPhone2 && settings.phone2) {\n            sendSms(phone2, msg)\n        }\n\n        if (settings.smsAlarmPhone3 && settings.phone3) {\n            sendSms(phone3, msg)\n        }\n\n        if (settings.smsAlarmPhone4 && settings.phone4) {\n            sendSms(phone4, msg)\n        }\n\n        if (settings.pushbulletAlarm && settings.pushbullet) {\n            settings.pushbullet*.push(location.name, msg)\n        }\n    } else {\n        // Status change notification\n        if (settings.pushStatusMessage) {\n            mySendPush(msg)\n        } else {\n            sendNotificationEvent(msg)\n        }\n\n        if (settings.smsStatusPhone1 && settings.phone1) {\n            sendSms(phone1, msg)\n        }\n\n        if (settings.smsStatusPhone2 && settings.phone2) {\n            sendSms(phone2, msg)\n        }\n\n        if (settings.smsStatusPhone3 && settings.phone3) {\n            sendSms(phone3, msg)\n        }\n\n        if (settings.smsStatusPhone4 && settings.phone4) {\n            sendSms(phone4, msg)\n        }\n\n        if (settings.pushbulletStatus && settings.pushbullet) {\n            settings.pushbullet*.push(location.name, msg)\n        }\n    }\n}\n\nprivate def notifyVoice() {\n    LOG(\"notifyVoice()\")\n\n    if (!settings.audioPlayer) {\n        return\n    }\n\n    def phrase = null\n    if (state.alarms.size()) {\n        // Alarm notification\n        if (settings.speechOnAlarm) {\n            phrase = settings.speechText ?: getStatusPhrase()\n        }\n    } else {\n        // Status change notification\n        if (settings.speechOnStatus) {\n            if (state.armed) {\n                if (state.stay) {\n                    phrase = settings.speechTextArmedStay ?: getStatusPhrase()\n                } else {\n                    phrase = settings.speechTextArmedAway ?: getStatusPhrase()\n                }\n            } else {\n                phrase = settings.speechTextDisarmed ?: getStatusPhrase()\n            }\n        }\n    }\n\n    if (phrase) {\n        settings.audioPlayer*.playText(phrase)\n    }\n}\n\nprivate def history(String event, String description = \"\") {\n    LOG(\"history(${event}, ${description})\")\n\n    def history = atomicState.history\n    history << [time: now(), event: event, description: description]\n    if (history.size() > 10) {\n        history = history.sort{it.time}\n        history = history[1..-1]\n    }\n\n    LOG(\"history: ${history}\")\n    state.history = history\n}\n\nprivate def getStatusPhrase() {\n    LOG(\"getStatusPhrase()\")\n\n    def phrase = \"\"\n    if (state.alarms.size()) {\n        phrase = \"Alarm at ${location.name}!\"\n        state.alarms.each() {\n            phrase += \" ${it}.\"\n        }\n    } else {\n        phrase = \"${location.name} security is \"\n        if (state.armed) {\n            def mode = state.stay ? \"stay\" : \"away\"\n            phrase += \"armed in ${mode} mode.\"\n        } else {\n            phrase += \"disarmed.\"\n        }\n    }\n\n    return phrase\n}\n\nprivate def getHelloHomeActions() {\n    def actions = location.helloHome?.getPhrases().collect() { it.label }\n    return actions.sort()\n}\n\nprivate def getAlarmStatus() {\n    def alarmStatus\n\n    if (atomicState.armed) {\n        alarmStatus = \"ARMED \"\n        alarmStatus += atomicState.stay ? \"STAY\" : \"AWAY\"\n    } else {\n        alarmStatus = \"DISARMED\"\n    }\n\n    return alarmStatus\n}\n\nprivate def getZoneStatus(device, sensorType) {\n\n    def zone = getZoneForDevice(device.id, sensorType)\n    if (!zone) {\n        return null\n    }\n\n    def str = \"${device.displayName}: ${zone.zoneType}, \"\n    str += zone.armed ? \"armed, \" : \"disarmed, \"\n    str += device.currentValue(sensorType)\n\n    return str\n}\n\nprivate def getZoneForDevice(id, sensorType) {\n    return state.zones.find() { it.deviceId == id && it.sensorType == sensorType }\n}\n\nprivate def isZoneReady(device, sensorType) {\n    def ready\n\n    switch (sensorType) {\n    case \"contact\":\n        ready = \"closed\".equals(device.currentValue(\"contact\"))\n        break\n\n    case \"motion\":\n        ready = \"inactive\".equals(device.currentValue(\"motion\"))\n        break\n\n    case \"acceleration\":\n        ready = \"inactive\".equals(device.currentValue(\"acceleration\"))\n        break\n\n    case \"smoke\":\n        ready = \"clear\".equals(device.currentValue(\"smoke\"))\n        break\n\n    case \"water\":\n        ready = \"dry\".equals(device.currentValue(\"water\"))\n        break\n\n    default:\n        ready = false\n    }\n\n    return ready\n}\n\nprivate def getDeviceById(id, sensorType) {\n    switch (sensorType) {\n    case \"contact\":\n        return settings.z_contact?.find() { it.id == id }\n\n    case \"motion\":\n        return settings.z_motion?.find() { it.id == id }\n\n    case \"acceleration\":\n        return settings.z_movement?.find() { it.id == id }\n\n    case \"smoke\":\n        return settings.z_smoke?.find() { it.id == id }\n\n    case \"water\":\n        return settings.z_water?.find() { it.id == id }\n    }\n\n    return null\n}\n\nprivate def getNumZones() {\n    def numZones = 0\n\n    numZones += settings.z_contact?.size() ?: 0\n    numZones += settings.z_motion?.size() ?: 0\n    numZones += settings.z_movement?.size() ?: 0\n    numZones += settings.z_smoke?.size() ?: 0\n    numZones += settings.z_water?.size() ?: 0\n\n    return numZones\n}\n\nprivate def myRunIn(delay_s, func) {\n    if (delay_s > 0) {\n        def date = new Date(now() + (delay_s * 1000))\n        runOnce(date, func)\n        LOG(\"scheduled '${func}' to run at ${date}\")\n    }\n}\n\nprivate def mySendPush(msg) {\n    // sendPush can throw an exception\n    try {\n        sendPush(msg)\n    } catch (e) {\n        log.error e\n    }\n}\n\nprivate def getVersion() {\n    return \"2.4.3\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright \u00a9 2014 Statusbits.com\"\n}\n\nprivate def textLicense() {\n    def text =\n        \"This program is free software: you can redistribute it and/or \" +\n        \"modify it under the terms of the GNU General Public License as \" +\n        \"published by the Free Software Foundation, either version 3 of \" +\n        \"the License, or (at your option) any later version.\\n\\n\" +\n        \"This program is distributed in the hope that it will be useful, \" +\n        \"but WITHOUT ANY WARRANTY; without even the implied warranty of \" +\n        \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU \" +\n        \"General Public License for more details.\\n\\n\" +\n        \"You should have received a copy of the GNU General Public License \" +\n        \"along with this program. If not, see <http://www.gnu.org/licenses/>.\"\n}\n\nprivate def LOG(message) {\n    //log.trace message\n}\n\nprivate def STATE() {\n    //log.trace \"state: ${state}\"\n}",
        "docstring": "Tap for more information"
    },
    {
        "code": "def installed()\n{\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tlog.debug \"enter installed, state: $state\"\n}\n\ndef updated()\n{\n\tlog.debug \"enter updated, state: $state\"\n\tunsubscribe()\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(event)\n{\n\tlog.debug \"temperature received from remote device: ${event?.value}\"\n\tif (event?.value) {\n\t\tthermostats?.setOutdoorTemperature(event.value)\n\t}\n}",
        "docstring": "Retrieves the temperature from a sensor and sends it to a specific Stelpro thermostat."
    },
    {
        "code": "def installed() {\n      initialize()\n    \n    }\n    \n    def updated() {\n      unsubscribe()\n      initialize()\n    }\n    \n    def initialize() {\n    \tsubscribe(people, \"presence\", presence)\n        runIn(60, checkSun)\n    \tsubscribe(location, \"sunrise\", setSunrise)\n    \tsubscribe(location, \"sunset\", setSunset)\n    }\n    \n    //check current sun state when installed.\n    def checkSun() {\n      def zip     = settings.zip as String\n      def sunInfo = getSunriseAndSunset(zipCode: zip)\n     def current = now()\n    \n    if (sunInfo.sunrise.time < current && sunInfo.sunset.time > current) {\n        state.sunMode = \"sunrise\"\n       setSunrise()\n      }\n      \n    else {\n       state.sunMode = \"sunset\"\n        setSunset()\n      }\n    }\n    \n    //change to sunrise mode on sunrise event\n    def setSunrise(evt) {\n      state.sunMode = \"sunrise\";\n      changeSunMode(newMode);\n    }\n    \n    //change to sunset mode on sunset event\n    def setSunset(evt) {\n      state.sunMode = \"sunset\";\n      changeSunMode(newMode)\n    }\n    \n    //change mode on sun event\n    def changeSunMode(newMode) {\n      if(allOk) {\n    \n      if(everyoneIsAway() && (state.sunMode == \"sunrise\")) {\n        log.debug(\"Home is Empty  Setting New Away Mode\")\n        def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n        runIn(delay, \"setAway\")\n      }\n    \n      if(everyoneIsAway() && (state.sunMode == \"sunset\")) {\n        log.debug(\"Home is Empty  Setting New Away Mode\")\n        def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n        runIn(delay, \"setAway\")\n      }\n      \n      else {\n      log.debug(\"Home is Occupied Setting New Home Mode\")\n      setHome()\n    \n    \n      }\n    }\n    }\n    \n    //presence change run logic based on presence state of home\n    def presence(evt) {\n      if(allOk) {\n      if(evt.value == \"not present\") {\n        log.debug(\"Checking if everyone is away\")\n    \n        if(everyoneIsAway()) {\n          log.debug(\"Nobody is home, running away sequence\")\n          def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n          runIn(delay, \"setAway\")\n        }\n      }\n    \n    else {\n    \tdef lastTime = state[evt.deviceId]\n        if (lastTime == null || now() - lastTime >= 1 * 60000) {\n      \t\tlog.debug(\"Someone is home, running home sequence\")\n      \t\tsetHome()\n        }    \n    \tstate[evt.deviceId] = now()\n    \n      }\n    }\n    }\n    \n    //if empty set home to one of the away modes\n    def setAway() {\n      if(everyoneIsAway()) {\n        if(state.sunMode == \"sunset\") {\n          def message = \"Performing \\\"${awayNight}\\\" for you as requested.\"\n          log.debug(message)\n          sendAway(message)\n          location.helloHome.execute(settings.awayNight)\n        }\n        \n        else if(state.sunMode == \"sunrise\") {\n          def message = \"Performing \\\"${awayDay}\\\" for you as requested.\"\n          log.debug(message)\n          sendAway(message)\n          location.helloHome.execute(settings.awayDay)\n          }\n        else {\n          log.debug(\"Mode is the same, not evaluating\")\n        }\n      }\n    \n      else {\n        log.debug(\"Somebody returned home before we set to '${newAwayMode}'\")\n      }\n    }\n    \n    //set home mode when house is occupied\n    def setHome() {\n    sendOutOfDateNotification()\n    log.debug(\"Setting Home Mode!!\")\n    if(anyoneIsHome()) {\n          if(state.sunMode == \"sunset\"){\n          if (location.mode != \"${homeModeNight}\"){\n          def message = \"Performing \\\"${homeNight}\\\" for you as requested.\"\n            log.debug(message)\n            sendHome(message)\n            location.helloHome.execute(settings.homeNight)\n            }\n           }\n           \n          if(state.sunMode == \"sunrise\"){\n          if (location.mode != \"${homeModeDay}\"){\n          def message = \"Performing \\\"${homeDay}\\\" for you as requested.\"\n            log.debug(message)\n            sendHome(message)\n            location.helloHome.execute(settings.homeDay)\n                }\n          }      \n        }\n        \n    }\n    \n    private everyoneIsAway() {\n      def result = true\n    \n      if(people.findAll { it?.currentPresence == \"present\" }) {\n        result = false\n      }\n    \n      log.debug(\"everyoneIsAway: ${result}\")\n    \n      return result\n    }\n    \n    private anyoneIsHome() {\n      def result = false\n    \n      if(people.findAll { it?.currentPresence == \"present\" }) {\n        result = true\n      }\n    \n      log.debug(\"anyoneIsHome: ${result}\")\n    \n      return result\n    }\n    \n    def sendAway(msg) {\n      if(sendPushMessage != \"No\") {\n        log.debug(\"Sending push message\")\n        sendPush(msg)\n      }\n    \n      log.debug(msg)\n    }\n    \n    def sendHome(msg) {\n      if(sendPushMessageHome != \"No\") {\n        log.debug(\"Sending push message\")\n        sendPush(msg)\n      }\n    \n      log.debug(msg)\n    }\n    \n    private getAllOk() {\n    \tmodeOk && daysOk && timeOk\n    }\n    \n    private getModeOk() {\n    \tdef result = !modes || modes.contains(location.mode)\n    \tlog.trace \"modeOk = $result\"\n    \tresult\n    }\n    \n    private getDaysOk() {\n    \tdef result = true\n    \tif (days) {\n    \t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n    \t\tif (location.timeZone) {\n    \t\t\tdf.setTimeZone(location.timeZone)\n    \t\t}\n    \t\telse {\n    \t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n    \t\t}\n    \t\tdef day = df.format(new Date())\n    \t\tresult = days.contains(day)\n    \t}\n    \tlog.trace \"daysOk = $result\"\n    \tresult\n    }\n    \n    private getTimeOk() {\n    \tdef result = true\n    \tif (starting && ending) {\n    \t\tdef currTime = now()\n    \t\tdef start = timeToday(starting, location?.timeZone).time\n    \t\tdef stop = timeToday(ending, location?.timeZone).time\n    \t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n    \t}\n    \tlog.trace \"timeOk = $result\"\n    \tresult\n    }\n    \n    private hhmm(time, fmt = \"h:mm a\")\n    {\n    \tdef t = timeToday(time, location.timeZone)\n    \tdef f = new java.text.SimpleDateFormat(fmt)\n    \tf.setTimeZone(location.timeZone ?: timeZone(time))\n    \tf.format(t)\n    }\n    \n    private getTimeIntervalLabel()\n    {\n    \t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n    }\n    \n    private hideOptionsSection() {\n    \t(starting || ending || days || modes) ? false : true\n    }\n    \n    def sendOutOfDateNotification(){\n    \tif(!state.lastTime){\n    \t\tstate.lastTime = (new Date() + 31).getTime()\n            sendNotification(\"Your version of Hello, Home Phrase Director is currently out of date. Please look for the new version of Hello, Home Phrase Director now called 'Routine Director' in the marketplace.\")\n        }\n        else if (((new Date()).getTime()) >= state.lastTime){\n        \tsendNotification(\"Your version of Hello, Home Phrase Director is currently out of date. Please look for the new version of Hello, Home Phrase Director now called 'Routine Director' in the marketplace.\")\n        \tstate.lastTime = (new Date() + 31).getTime()\n        }\n    }",
        "docstring": "Monitor a set of presence sensors and activate Hello, Home phrases based on whether your home is empty or occupied.  Each presence status change will check against the current 'sun state' to run phrases based on occupancy and whether the sun is up or down."
    },
    {
        "code": "def installed() {\n    initialize()\n}\n\ndef updated() {\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n\nmidNightReset()\n\nif(A_motion) {\n\tsubscribe(settings.A_motion, \"motion\", onEventA)\n}\n\nif(A_acceleration) {\n\tsubscribe(settings.A_acceleration, \"acceleration\", onEventA)\n}\n\nif(A_contact) {\n\tsubscribe(settings.A_contact, \"contact\", onEventA)\n}\n\nif(A_lock) {\n\tsubscribe(settings.A_lock, \"lock\", onEventA)\n}\n\nif(A_switchDisable) {\n\tsubscribe(A_switches, \"switch.off\", onPressA)\n    subscribe(A_dimmers, \"switch.off\", onPressA)\n}\n\nif(A_mode) {\n    subscribe(location, onEventA)\n}\n\nif(B_motion) {\n\tsubscribe(settings.B_motion, \"motion\", onEventB)\n}\n\nif(B_acceleration) {\n\tsubscribe(settings.B_acceleration, \"acceleration\", onEventB)\n}\n\nif(B_contact) {\n\tsubscribe(settings.B_contact, \"contact\", onEventB)\n}\n\nif(B_lock) {\n\tsubscribe(settings.B_lock, \"lock\", onEventB)\n}\n\nif(B_switchDisable) {\n\tsubscribe(B_switches, \"switch.off\", onPressB)\n    subscribe(B_dimmers, \"switch.off\", onPressB)\n}\n\nif(B_mode) {\n    subscribe(location, onEventB)\n}\n\nif(C_motion) {\n\tsubscribe(settings.C_motion, \"motion\", onEventC)\n}\n\nif(C_acceleration) {\n\tsubscribe(settings.C_acceleration, \"acceleration\", onEventC)\n}\n\nif(C_contact) {\n\tsubscribe(settings.C_contact, \"contact\", onEventC)\n}\n\nif(C_lock) {\n\tsubscribe(settings.C_lock, \"lock\", onEventC)\n}\n\nif(C_switchDisable) {\n\tsubscribe(C_switches, \"switch.off\", onPressC)\n    subscribe(C_dimmers, \"switch.off\", onPressC)\n}\n\nif(C_mode) {\n    subscribe(location, onEventC)\n}\n\nif(D_motion) {\n\tsubscribe(settings.D_motion, \"motion\", onEventD)\n}\n\nif(D_acceleration) {\n\tsubscribe(settings.D_acceleration, \"acceleration\", onEventD)\n}\n\nif(D_contact) {\n\tsubscribe(settings.D_contact, \"contact\", onEventD)\n}\n\nif(D_lock) {\n\tsubscribe(settings.D_lock, \"lock\", onEventD)\n}\n\nif(D_switchDisable) {\n\tsubscribe(D_switches, \"switch.off\", onPressD)\n    subscribe(D_dimmers, \"switch.off\", onPressD)\n}\n\nif(D_mode) {\n    subscribe(location, onEventD)\n}\n\n}\n\ndef onEventA(evt) {\n\nif ((!A_triggerOnce || (A_triggerOnce && !state.A_triggered)) && (!A_switchDisable || (A_switchDisable && !state.A_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!A_mode || A_mode.contains(location.mode)) && getTimeOk (A_timeStart, A_timeEnd) && getDayOk(A_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!A_luxSensors) || (A_luxSensors.latestValue(\"illuminance\") <= A_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef A_levelOn = A_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(A_motion, A_contact, A_lock, A_acceleration)) {\n        \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameA}'\")\n            settings.A_dimmers?.setLevel(A_levelOn)\n            settings.A_switches?.on()\n            if (A_triggerOnce){\n            \tstate.A_triggered = true\n                if (!A_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.A_timerStart){\n            \tunschedule(delayTurnOffA)\n            \tstate.A_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n\t\t\n    \tif (settings.A_turnOff) {\n\t\t\trunIn(A_turnOff * 60, \"delayTurnOffA\")\n        \tstate.A_timerStart = true\n        }\n        else {\n        \tsettings.A_switches?.off()\n\t\t\tsettings.A_dimmers?.setLevel(0)\n        \tif (state.A_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffA(){\n\tsettings.A_switches?.off()\n\tsettings.A_dimmers?.setLevel(0)\n\tstate.A_timerStart = false\n\tif (state.A_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressA(evt) {\nif ((!A_mode || A_mode.contains(location.mode)) && getTimeOk (A_timeStart, A_timeEnd) && getDayOk(A_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!A_luxSensors) || (A_luxSensors.latestValue(\"illuminance\") <= A_turnOnLux)){ \nif ((!A_triggerOnce || (A_triggerOnce && !state.A_triggered)) && (!A_switchDisable || (A_switchDisable && !state.A_triggered))) {    \n    if (evt.physical){\n    \tstate.A_triggered = true\n        unschedule(delayTurnOffA)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameA}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventB(evt) {\n\nif ((!B_triggerOnce || (B_triggerOnce && !state.B_triggered)) && (!B_switchDisable || (B_switchDisable && !state.B_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!B_mode ||B_mode.contains(location.mode)) && getTimeOk (B_timeStart, B_timeEnd) && getDayOk(B_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!B_luxSensors) || (B_luxSensors.latestValue(\"illuminance\") <= B_turnOnLux)) { //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef B_levelOn = B_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(B_motion, B_contact, B_lock, B_acceleration)) {\n\t\t\n        \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameB}'\")\n\t\t\tsettings.B_dimmers?.setLevel(B_levelOn)\n            settings.B_switches?.on()\n            if (B_triggerOnce){\n            \tstate.B_triggered = true\n                if (!B_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.B_timerStart) {\n            \tunschedule(delayTurnOffB)\n            \tstate.B_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.B_turnOff) {\n\t\t\trunIn(B_turnOff * 60, \"delayTurnOffB\")\n        \tstate.B_timerStart = true\n        }\n        \n        else {\n        \tsettings.B_switches?.off()\n\t\t\tsettings.B_dimmers?.setLevel(0)\n            if (state.B_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n\t\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffB(){\n\tsettings.B_switches?.off()\n\tsettings.B_dimmers?.setLevel(0)\n\tstate.B_timerStart = false\n    if (state.B_triggered) {\n    \trunOnce (getMidnight(), midNightReset) \n\t}\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressB(evt) {\nif ((!B_mode ||B_mode.contains(location.mode)) && getTimeOk (B_timeStart, B_timeEnd) && getDayOk(B_day)) {  //checks to make sure we are not opperating outside of set restrictions.\nif ((!B_luxSensors) || (B_luxSensors.latestValue(\"illuminance\") <= B_turnOnLux)) {\nif ((!B_triggerOnce || (B_triggerOnce && !state.B_triggered)) && (!B_switchDisable || (B_switchDisable && !state.B_triggered))) {\n\tif (evt.physical){\n    \tstate.B_triggered = true\n        unschedule(delayTurnOffB)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameB}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventC(evt) {\n\nif ((!C_triggerOnce || (C_triggerOnce && !state.C_triggered)) && (!C_switchDisable || (C_switchDisable && !state.C_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!C_mode || C_mode.contains(location.mode)) && getTimeOk (C_timeStart, C_timeEnd) && getDayOk(C_day) && !state.C_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!C_luxSensors) || (C_luxSensors.latestValue(\"illuminance\") <= C_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef C_levelOn = settings.C_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(C_motion, C_contact, C_lock, C_acceleration)) {\n           \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameC}'\")\n            settings.C_dimmers?.setLevel(C_levelOn)\n            settings.C_switches?.on()\n            if (C_triggerOnce){\n            \tstate.C_triggered = true\n                if (!C_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.C_timerStart){\n            \tunschedule(delayTurnOffC)\n            \tstate.C_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.C_turnOff) {\n\t\trunIn(C_turnOff * 60, \"delayTurnOffC\")\n        state.C_timerStart = true\n        }\n        else {\n        settings.C_switches?.off()\n\t\tsettings.C_dimmers?.setLevel(0)\n        \tif (state.C_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n\t\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffC(){\n\tsettings.C_switches?.off()\n\tsettings.C_dimmers?.setLevel(0)\n\tstate.C_timerStart = false\n\tif (state.C_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressC(evt) {\nif ((!C_mode || C_mode.contains(location.mode)) && getTimeOk (C_timeStart, C_timeEnd) && getDayOk(C_day) && !state.C_triggered){\nif ((!C_luxSensors) || (C_luxSensors.latestValue(\"illuminance\") <= C_turnOnLux)){\nif ((!C_triggerOnce || (C_triggerOnce && !state.C_triggered)) && (!C_switchDisable || (C_switchDisable && !state.C_triggered))) {\n\tif (evt.physical){\n    \tstate.C_triggered = true\n        unschedule(delayTurnOffC)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameC}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventD(evt) {\n\nif ((!D_triggerOnce || (D_triggerOnce && !state.D_triggered)) && (!D_switchDisable || (D_switchDisable && !state.D_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!D_mode || D_mode.contains(location.mode)) && getTimeOk (D_timeStart, D_timeEnd) && getDayOk(D_day) && !state.D_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!D_luxSensors) || (D_luxSensors.latestValue(\"illuminance\") <= D_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef D_levelOn = D_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(D_motion, D_contact, D_lock, D_acceleration)) {\n           \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameD}'\")\n            settings.D_dimmers?.setLevel(D_levelOn)\n            settings.D_switches?.on()\n            if (D_triggerOnce){\n            \tstate.D_triggered = true\n                if (!D_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.D_timerStart){\n            \tunschedule(delayTurnOffD)\n            \tstate.D_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.D_turnOff) {\n\t\trunIn(D_turnOff * 60, \"delayTurnOffD\")\n        state.D_timerStart = true\n        }\n        else {\n        settings.D_switches?.off()\n\t\tsettings.D_dimmers?.setLevel(0)\n        \tif (state.D_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffD(){\n\tsettings.D_switches?.off()\n\tsettings.D_dimmers?.setLevel(0)\n\tstate.D_timerStart = false\n\tif (state.D_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressD(evt) {\nif ((!D_mode || D_mode.contains(location.mode)) && getTimeOk (D_timeStart, D_timeEnd) && getDayOk(D_day) && !state.D_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!D_luxSensors) || (D_luxSensors.latestValue(\"illuminance\") <= D_turnOnLux)){\nif ((!D_triggerOnce || (D_triggerOnce && !state.D_triggered)) && (!D_switchDisable || (D_switchDisable && !state.D_triggered))) {  \n\tif (evt.physical){\n    \tstate.D_triggered = true\n        unschedule(delayTurnOffD)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameD}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\n//Common Methods\n\n//resets once a day trigger at midnight so trigger can be ran again the next day.\ndef midNightReset() {\n\tstate.A_triggered = false\n    state.B_triggered = false\n    state.C_triggered = false\n    state.D_triggered = false\n}\n\nprivate def helpText() {\n\tdef text =\n\t\t\"Select motion sensors, acceleration sensors, contact sensors or locks to control a set of lights. \" +\n        \"Each scenario can control dimmers and switches but can also be \" +\n        \"restricted to modes or between certain times and turned off after \" +\n        \"motion stops, doors close or lock. Scenarios can also be limited to  \" +\n        \"running once or to stop running if the physical switches are turned off.\"\n\ttext\n}\n\n//should scenario be marked complete or not\ndef greyOut(scenario){\n\tdef result = \"\"\n    if (scenario) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n//should i mark the time restriction green or grey\ndef greyedOutTime(start, end){\n\tdef result = \"\"\n    if (start || end) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n\ndef getTitle(scenario) {\n\tdef title = \"Empty\"\n\tif (scenario) {\n\t\ttitle = scenario\n    }\n\ttitle\n}\n\n//recursively applies label to each scenario depending on if the scenario has deatils inside it or not\ndef getDesc(scenario) {\n\tdef desc = \"Tap to create a scenario\"\n\tif (scenario) {\n\t\tdesc = \"Tap to edit scenario\"\n    }\n\tdesc\t\n}\n\n\ndef getMidnight() {\n\tdef midnightToday = timeToday(\"2000-01-01T23:59:59.999-0000\", location.timeZone)\n\tmidnightToday\n}\n\n//used to recursively check device states when methods are triggered \nprivate getInputOk(motion, contact, lock, acceleration) {\n\ndef motionDetected = false\ndef accelerationDetected = false\ndef contactDetected = false\ndef unlockDetected = false\ndef result = false\n\nif (motion) {\n\tif (motion.latestValue(\"motion\").contains(\"active\")) {\n\t\tmotionDetected = true\n\t}\n}\n\nif (acceleration) {\n\tif (acceleration.latestValue(\"acceleration\").contains(\"active\")) {\n\t\taccelerationDetected = true\n\t}\n}\n\nif (contact) {\n\tif (contact.latestValue(\"contact\").contains(\"open\")) {\n\t\tcontactDetected = true\n\t}\n}\n\nif (lock) {\n\tif (lock.latestValue(\"lock\").contains(\"unlocked\")) {\n\t\tunlockDetected = true\n\t}\n}\n\nresult = motionDetected || contactDetected || unlockDetected || accelerationDetected\nresult\n\n}\n\nprivate getTimeOk(starting, ending) {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n    \n    else if (starting){\n    \tresult = currTime >= start\n    }\n    else if (ending){\n    \tresult = currTime <= stop\n    }\n    \n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\ndef getTimeLabel(start, end){\n\tdef timeLabel = \"Tap to set\"\n\t\n    if(start && end){\n    \ttimeLabel = \"Between\" + \" \" + hhmm(start) + \" \"  + \"and\" + \" \" +  hhmm(end)\n    }\n    else if (start) {\n\t\ttimeLabel = \"Start at\" + \" \" + hhmm(start)\n    }\n    else if(end){\n    timeLabel = \"End at\" + hhmm(end)\n    }\n\ttimeLabel\t\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getDayOk(dayList) {\n\tdef result = true\n    if (dayList) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = dayList.contains(day)\n\t}\n    result\n}\n\n\npage(name: \"timeIntervalInputA\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"A_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"A_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }  \npage(name: \"timeIntervalInputB\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"B_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"B_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }  \npage(name: \"timeIntervalInputC\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"C_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"C_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }         \npage(name: \"timeIntervalInputD\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"D_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"D_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }",
        "docstring": "Control up to 4 sets (scenarios) of lights based on motion, door contacts and illuminance levels."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    subscribe(people, \"presence\", presence)\n    checkSun()\n    subscribe(location, \"sunrise\", setSunrise)\n    subscribe(location, \"sunset\", setSunset)\n    state.homestate = null\n}\n\n//check current sun state when installed.\ndef checkSun() {\n    def zip = settings.zip as String\n    def sunInfo = getSunriseAndSunset(zipCode: zip)\n    def current = now()\n\n    if (sunInfo.sunrise.time < current && sunInfo.sunset.time > current) {\n        state.sunMode = \"sunrise\"\n        runIn(60,\"setSunrise\")\n    }\n    else {\n        state.sunMode = \"sunset\"\n        runIn(60,\"setSunset\")\n    }\n}\n\n//change to sunrise mode on sunrise event\ndef setSunrise(evt) {\n    state.sunMode = \"sunrise\";\n    changeSunMode(newMode);\n    log.debug \"Current sun mode is ${state.sunMode}\"\n}\n\n//change to sunset mode on sunset event\ndef setSunset(evt) {\n    state.sunMode = \"sunset\";\n    changeSunMode(newMode)\n    log.debug \"Current sun mode is ${state.sunMode}\"\n}\n\n//change mode on sun event\ndef changeSunMode(newMode) {\n    if (allOk) {\n\n        if (everyoneIsAway()) /*&& (state.sunMode == \"sunrise\")*/ {\n            log.debug(\"Home is Empty  Setting New Away Mode\")\n            def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n            setAway()\n        }\n/*\n        else if (everyoneIsAway() && (state.sunMode == \"sunset\")) {\n            log.debug(\"Home is Empty  Setting New Away Mode\")\n            def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n            setAway()\n        }*/\n        else if (anyoneIsHome()) {\n            log.debug(\"Home is Occupied Setting New Home Mode\")\n            setHome()\n\n\n        }\n    }\n}\n\n//presence change run logic based on presence state of home\ndef presence(evt) {\n    if (allOk) {\n        if (evt.value == \"not present\") {\n            log.debug(\"Checking if everyone is away\")\n\n            if (everyoneIsAway()) {\n                log.debug(\"Nobody is home, running away sequence\")\n                def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n                runIn(delay, \"setAway\")\n            }\n        }\n        else {\n            def lastTime = state[evt.deviceId]\n            if (lastTime == null || now() - lastTime >= 1 * 60000) {\n                log.debug(\"Someone is home, running home sequence\")\n                setHome()\n            }\n            state[evt.deviceId] = now()\n\n        }\n    }\n}\n\n//if empty set home to one of the away modes\ndef setAway() {\n    if (everyoneIsAway()) {\n        if (state.sunMode == \"sunset\") {\n            def message = \"Performing \\\"${awayNight}\\\" for you as requested.\"\n            log.debug(message)\n            sendAway(message)\n            location.helloHome.execute(settings.awayNight)\n            state.homestate = \"away\"\n\n        }\n        else if (state.sunMode == \"sunrise\") {\n            def message = \"Performing \\\"${awayDay}\\\" for you as requested.\"\n            log.debug(message)\n            sendAway(message)\n            location.helloHome.execute(settings.awayDay)\n            state.homestate = \"away\"\n        }\n        else {\n            log.debug(\"Mode is the same, not evaluating\")\n        }\n    }\n}\n\n//set home mode when house is occupied\ndef setHome() {\n    log.debug(\"Setting Home Mode!!\")\n    if (anyoneIsHome()) {\n        if (state.sunMode == \"sunset\") {\n            if (state.homestate != \"homeNight\") {\n                def message = \"Performing \\\"${homeNight}\\\" for you as requested.\"\n                log.debug(message)\n                sendHome(message)\n                location.helloHome.execute(settings.homeNight)\n                state.homestate = \"homeNight\"\n            }\n        }\n\n        if (state.sunMode == \"sunrise\") {\n            if (state.homestate != \"homeDay\") {\n                def message = \"Performing \\\"${homeDay}\\\" for you as requested.\"\n                log.debug(message)\n                sendHome(message)\n                location.helloHome.execute(settings.homeDay)\n                state.homestate = \"homeDay\"\n            }\n        }\n    }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\ndef sendAway(msg) {\n    if (sendPushMessage) {\n    \tif (recipients) {\n        \tsendNotificationToContacts(msg, recipients)\n        }\n        else {\n        \tsendPush(msg)\n        \tif(phone){\n            \t\tsendSms(phone, msg)\n        \t}\n        }\n    }\n\n    log.debug(msg)\n}\n\ndef sendHome(msg) {\n    if (sendPushMessageHome) {\n    \tif (recipients) {\n        \tsendNotificationToContacts(msg, recipients)\n        }\n        else {\n        \tsendPush(msg)\n                if(phone){\n            \t\tsendSms(phone, msg)\n        \t}\n        }\n    }\n\n    log.debug(msg)\n}\n\nprivate getAllOk() {\n    modeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n    def result = !modes || modes.contains(location.mode)\n    log.trace \"modeOk = $result\"\n    result\n}\n\nprivate getDaysOk() {\n    def result = true\n    if (days) {\n        def df = new java.text.SimpleDateFormat(\"EEEE\")\n        if (location.timeZone) {\n            df.setTimeZone(location.timeZone)\n        }\n        else {\n            df.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n        }\n        def day = df.format(new Date())\n        result = days.contains(day)\n    }\n    log.trace \"daysOk = $result\"\n    result\n}\n\nprivate getTimeOk() {\n    def result = true\n    if (starting && ending) {\n        def currTime = now()\n        def start = timeToday(starting, location?.timeZone).time\n        def stop = timeToday(ending, location?.timeZone).time\n        result = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n    }\n    log.trace \"timeOk = $result\"\n    result\n}\n\nprivate hhmm(time, fmt = \"h:mm a\") {\n    def t = timeToday(time, location.timeZone)\n    def f = new java.text.SimpleDateFormat(fmt)\n    f.setTimeZone(location.timeZone?:timeZone(time))\n    f.format(t)\n}\n\nprivate getTimeIntervalLabel() {\n    (starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\"): \"\"\n}\n\nprivate hideOptionsSection() {\n    (starting || ending || days || modes) ? false: true\n}",
        "docstring": "Monitor a set of presence sensors and activate routines based on whether your home is empty or occupied.  Each presence status change will check against the current 'sun state' to run routines based on occupancy and whether the sun is up or down."
    },
    {
        "code": "def installed(){\n\tinit()\n}\n\ndef updated(){\n\tunsubscribe()\n\tinit()\n}\n\ndef init(){\n\tstate.lastStatus = null\n\tsubscribe(app, appTouch)\n    runIn(60, \"temperatureHandler\")\n    subscribe(sensor, \"temperature\", temperatureHandler)\n    if(modes1){\n    \tsubscribe(location, modeBoostChange)\n    }\n\tif(doors){\n\t\tsubscribe(doors, \"contact.open\", temperatureHandler)\n        subscribe(doors, \"contact.closed\", doorCheck)\n\t}\n}\n\ndef temperatureHandler(evt) {\n\tif(modeOk && daysOk && timeOk) {\n\t\tif(setLow > setHigh){\n\t\t\tdef temp = setLow\n\t\t\tsetLow = setHigh\n\t\t\tsetHigh = temp\n\t\t}\n\t\tif (doorsOk) {\n\t\t\tdef currentTemp = sensor.latestValue(\"temperature\")\n\t\t\tif (currentTemp < setLow) {\n            \tif (state.lastStatus == \"two\" || state.lastStatus == \"three\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${cold}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${cold} because temperature is below ${setLow}\"\n\t\t\t\t\tthermostat?.\"${cold}\"()\n                    sendMessage(msg)\n                    }\n\t\t\t\tstate.lastStatus = \"one\"\n\t\t\t}\n\t\t\tif (currentTemp > setHigh) {\n            \tif (state.lastStatus == \"one\" || state.lastStatus == \"three\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${hot}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${hot} because temperature is above ${setHigh}\"\n\t\t\t\t\tthermostat?.\"${hot}\"()\n\t\t\t\t\tsendMessage(msg)\n\t\t\t\t}\n\t\t\t\tstate.lastStatus = \"two\"\n\t\t\t}\n\t\t\tif (currentTemp > setLow && currentTemp < setHigh) {\n            \tif (state.lastStatus == \"two\" || state.lastStatus == \"one\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${neutral}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${neutral} because temperature is neutral\"\n\t\t\t\t\tthermostat?.\"${neutral}\"()\n\t\t\t\t\tsendMessage(msg)\n\t\t\t\t}\n\t\t\t\tstate.lastStatus = \"three\"\n\t\t\t}\n\t\t}\n        else{\n\t\t\tdef delay = (turnOffDelay != null && turnOffDelay != \"\") ? turnOffDelay * 60 : 60\n\t\t\tlog.debug(\"Detected open doors.  Checking door states again\")\n\t\t\trunIn(delay, \"doorCheck\")\n\t\t}\n\t}\n}\n\ndef appTouch(evt) {\nif(thermostat1){\n\tstate.lastStatus = \"disabled\"\n\tdef currentCoolSetpoint = thermostat1.latestValue(\"coolingSetpoint\") as String\n    def currentHeatSetpoint = thermostat1.latestValue(\"heatingSetpoint\") as String\n    def currentMode = thermostat1.latestValue(\"thermostatMode\") as String\n\tdef mode = turnOnTherm\n    state.currentCoolSetpoint1 = currentCoolSetpoint\n    state.currentHeatSetpoint1 = currentHeatSetpoint\n    state.currentMode1 = currentMode\n\n    \tthermostat1.\"${mode}\"()\n    \tthermostat1.setCoolingSetpoint(coolingTemp)\n    \tthermostat1.setHeatingSetpoint(heatingTemp)\n\n    thermoShutOffTrigger()\n    //log.debug(\"current coolingsetpoint is ${state.currentCoolSetpoint1}\")\n    //log.debug(\"current heatingsetpoint is ${state.currentHeatSetpoint1}\")\n    //log.debug(\"current mode is ${state.currentMode1}\")\n}\n}\n\ndef modeBoostChange(evt) {\n\tif(thermostat1 && modes1.contains(location.mode)){\n\t\tstate.lastStatus = \"disabled\"\n\t\tdef currentCoolSetpoint = thermostat1.latestValue(\"coolingSetpoint\") as String\n    \tdef currentHeatSetpoint = thermostat1.latestValue(\"heatingSetpoint\") as String\n    \tdef currentMode = thermostat1.latestValue(\"thermostatMode\") as String\n\t\tdef mode = turnOnTherm\n    \tstate.currentCoolSetpoint1 = currentCoolSetpoint\n    \tstate.currentHeatSetpoint1 = currentHeatSetpoint\n    \tstate.currentMode1 = currentMode\n\n    \t\tthermostat1.\"${mode}\"()\n    \t\tthermostat1.setCoolingSetpoint(coolingTemp)\n    \t\tthermostat1.setHeatingSetpoint(heatingTemp)\n\n    \tlog.debug(\"current coolingsetpoint is ${state.currentCoolSetpoint1}\")\n    \tlog.debug(\"current heatingsetpoint is ${state.currentHeatSetpoint1}\")\n    \tlog.debug(\"current mode is ${state.currentMode1}\")\n\t}\n\telse{\n\t\tthermoShutOff()\n    }\n}\n\ndef thermoShutOffTrigger() {\n    //log.info(\"Starting timer to turn off thermostat\")\n    def delay = (turnOffDelay2 != null && turnOffDelay2 != \"\") ? turnOffDelay2 * 60 : 60\n    state.turnOffTime = now()\n\tlog.debug (\"Turn off delay is ${delay}\")\n    runIn(delay, \"thermoShutOff\")\n  }\n\ndef thermoShutOff(){\n\tif(state.lastStatus == \"disabled\"){\n\t\tdef coolSetpoint = state.currentCoolSetpoint1\n    \tdef heatSetpoint = state.currentHeatSetpoint1\n\t\tdef mode = state.currentMode1\n    \tdef coolSetpoint1 = coolSetpoint.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n    \tdef heatSetpoint1 = heatSetpoint.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n    \tdef mode1 = mode.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n\n\t\tstate.lastStatus = null\n\t\t//log.info(\"Returning thermostat back to normal\")\n\t\tthermostat1.setCoolingSetpoint(\"${coolSetpoint1}\")\n    \tthermostat1.setHeatingSetpoint(\"${heatSetpoint1}\")\n    \tthermostat1.\"${mode1}\"()\n    \ttemperatureHandler()\n    }\n}\n\ndef doorCheck(evt){\n\tif (!doorsOk){\n\t\tlog.debug(\"doors still open turning off ${thermostat}\")\n\t\tdef msg = \"I changed your thermostat mode to off because some doors are open\"\n\n        if (state.lastStatus != \"off\"){\n        \tthermostat?.off()\n\t\t\tsendMessage(msg)\n\t\t}\n\t\tstate.lastStatus = \"off\"\n\t}\n\n\telse{\n    \tif (state.lastStatus == \"off\"){\n\t\t\tstate.lastStatus = null\n        }\n        temperatureHandler()\n\t}\n}\n\nprivate sendMessage(msg){\n\tif (sendPushMessage == \"Yes\") {\n\t\tsendPush(msg)\n\t}\n\tif (phoneNumber != null) {\n\t\tsendSms(phoneNumber, msg)\n\t}\n}\n\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk && doorsOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDoorsOk() {\n\tdef result = !doors || !doors.latestValue(\"contact\").contains(\"open\")\n\tlog.trace \"doorsOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\n    else if (starting){\n    \tresult = currTime >= start\n    }\n    else if (ending){\n    \tresult = currTime <= stop\n    }\n\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\ndef getTimeLabel(starting, ending){\n\n\tdef timeLabel = \"Tap to set\"\n\n    if(starting && ending){\n    \ttimeLabel = \"Between\" + \" \" + hhmm(starting) + \" \"  + \"and\" + \" \" +  hhmm(ending)\n    }\n    else if (starting) {\n\t\ttimeLabel = \"Start at\" + \" \" + hhmm(starting)\n    }\n    else if(ending){\n    timeLabel = \"End at\" + hhmm(ending)\n    }\n\ttimeLabel\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\ndef greyedOut(){\n\tdef result = \"\"\n    if (sensor) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTherm(){\n\tdef result = \"\"\n    if (thermostat) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTherm1(){\n\tdef result = \"\"\n    if (thermostat1) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutSettings(){\n\tdef result = \"\"\n    if (starting || ending || days || modes || sendPushMessage) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTime(starting, ending){\n\tdef result = \"\"\n    if (starting || ending) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\ndef timeIntervalInput() {\n    dynamicPage(name: \"timeIntervalInput\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n        section(\"\") {\n\t\t\tinput \"starting\", \"time\", title: \"Starting\", multiple: false, required: ending != null, submitOnChange: true\n\t\t\tinput \"ending\", \"time\", title: \"Ending\", multiple: false, required: starting != null, submitOnChange: true\n\t\t}\n    }\n}",
        "docstring": "Changes mode of your thermostat based on the temperature range of a specified temperature sensor and shuts off the thermostat if any windows/doors are open."
    },
    {
        "code": "def installed() {\ninitialize()\n}\n\ndef updated() {\n  unsubscribe();\n  unschedule();\n  initialize()\n}\n\ndef initialize(){\n\n\tif (newMode != null) {\n\t\tsubscribe(location, modeChangeHandler)\n    }\n    if (starting != null) {\n    \tschedule(starting, modeChangeHandler)\n    }\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef modeChangeHandler(evt) {\n\t\tdef delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 2 * 60  \n    \trunIn(delay, scheduleCheck)\n}\n\n\n//Main logic to pick a random set of lights from the large set of lights to turn on and then turn the rest off\ndef scheduleCheck(evt) {\n    if(allOk){\n        log.debug(\"Running\")\n        // turn off all the switches\n        switches.off()\n        \n        // grab a random switch\n        def random = new Random()\n        def inactive_switches = switches\n        for (int i = 0 ; i < number_of_active_lights ; i++) {\n            // if there are no inactive switches to turn on then let's break\n            if (inactive_switches.size() == 0){\n                break\n            }\n            \n            // grab a random switch and turn it on\n            def random_int = random.nextInt(inactive_switches.size())\n            inactive_switches[random_int].on()\n            \n            // then remove that switch from the pool off switches that can be turned on\n            inactive_switches.remove(random_int)\n        }\n        \n        // re-run again when the frequency demands it\n        schedule(\"0 0/${frequency_minutes} * 1/1 * ? *\", scheduleCheck)\n    }\n    //Check to see if mode is ok but not time/day.  If mode is still ok, check again after frequency period.\n    else if (modeOk) {\n        log.debug(\"mode OK.  Running again\")\n        switches.off()\n    }\n    //if none is ok turn off frequency check and turn off lights.\n    else {\n    \tif(people){\n        \t//don't turn off lights if anyone is home\n        \tif(someoneIsHome){\n        \t    log.debug(\"Stopping Check for Light\")\n        \t    unschedule()\n        \t}\n        \telse{\n        \t    log.debug(\"Stopping Check for Light and turning off all lights\")\n        \t    switches.off()\n        \t    unschedule()\n        \t}\n    \t}\n        else if (!modeOk) {\n        \tunschedule()\n        }\n    }\n}      \n\n\n//below is used to check restrictions\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk && homeIsEmpty\n}\n\n\nprivate getModeOk() {\n\tdef result = !newMode || newMode.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getHomeIsEmpty() {\n  def result = true\n\n  if(people?.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"homeIsEmpty: ${result}\")\n\n  return result\n}\n\nprivate getSomeoneIsHome() {\n  def result = false\n\n  if(people?.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tdef start = timeWindowStart()\n\tdef stop = timeWindowStop()\n\tif (start && stop && location.timeZone) {\n\t\tresult = timeOfDayIsBetween(start, stop, new Date(), location.timeZone)\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate timeWindowStart() {\n\tdef result = null\n\tif (startTimeType == \"sunrise\") {\n\t\tresult = location.currentState(\"sunriseTime\")?.dateValue\n\t\tif (result && startTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(startTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (startTimeType == \"sunset\") {\n\t\tresult = location.currentState(\"sunsetTime\")?.dateValue\n\t\tif (result && startTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(startTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (starting && location.timeZone) {\n\t\tresult = timeToday(starting, location.timeZone)\n\t}\n\tlog.trace \"timeWindowStart = ${result}\"\n\tresult\n}\n\nprivate timeWindowStop() {\n\tdef result = null\n\tif (endTimeType == \"sunrise\") {\n\t\tresult = location.currentState(\"sunriseTime\")?.dateValue\n\t\tif (result && endTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(endTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (endTimeType == \"sunset\") {\n\t\tresult = location.currentState(\"sunsetTime\")?.dateValue\n\t\tif (result && endTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(endTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (ending && location.timeZone) {\n\t\tresult = timeToday(ending, location.timeZone)\n\t}\n\tlog.trace \"timeWindowStop = ${result}\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel() {\n\tdef start = \"\"\n\tswitch (startTimeType) {\n\t\tcase \"time\":\n\t\t\tif (ending) {\n            \tstart += hhmm(starting)\n            }\n\t\t\tbreak\n\t\tcase \"sunrise\":\n\t\tcase \"sunset\":\n        \tstart += startTimeType[0].toUpperCase() + startTimeType[1..-1]\n\t\t\tif (startTimeOffset) {\n\t\t\t\tstart += startTimeOffset > 0 ? \"+${startTimeOffset} min\" : \"${startTimeOffset} min\"\n\t\t\t}\n\t\t\tbreak\n\t}\n\n    def finish = \"\"\n\tswitch (endTimeType) {\n\t\tcase \"time\":\n\t\t\tif (ending) {\n            \tfinish += hhmm(ending)\n            }\n\t\t\tbreak\n\t\tcase \"sunrise\":\n\t\tcase \"sunset\":\n        \tfinish += endTimeType[0].toUpperCase() + endTimeType[1..-1]\n\t\t\tif (endTimeOffset) {\n\t\t\t\tfinish += endTimeOffset > 0 ? \"+${endTimeOffset} min\" : \"${endTimeOffset} min\"\n\t\t\t}\n\t\t\tbreak\n\t}\n\tstart && finish ? \"${start} to ${finish}\" : \"\"\n}\n\n//sets complete/not complete for the setup section on the main dynamic page\ndef greyedOut(){\n\tdef result = \"\"\n    if (switches) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n//sets complete/not complete for the settings section on the main dynamic page\ndef greyedOutSettings(){\n\tdef result = \"\"\n    if (people || days || falseAlarmThreshold ) {\n    \tresult = \"complete\"\t\n    }\n    result\n}",
        "docstring": "Randomly turn on/off lights to simulate the appearance of a occupied home while you are away."
    },
    {
        "code": "def installed() {\n  schedule(time, \"setTimeCallback\")\n\n}\n\ndef updated(settings) {\n  unschedule()\n  schedule(time, \"setTimeCallback\")\n}\n\ndef setTimeCallback() {\n  if (contact) {\n    doorOpenCheck()\n  } else {\n    lockMessage()\n    lock.lock()\n  }\n}\ndef doorOpenCheck() {\n  def currentState = contact.contactState\n  if (currentState?.value == \"open\") {\n    def msg = \"${contact.displayName} is open.  Scheduled lock failed.\"\n    log.debug msg\n    if (sendPushMessage) {\n      sendPush msg\n    }\n    if (phone) {\n      sendSms phone, msg\n    }\n  } else {\n    lockMessage()\n    lock.lock()\n  }\n}\n\ndef lockMessage() {\n  def msg = \"Locking ${lock.displayName} due to scheduled lock.\"\n  log.debug msg\n  if (sendPushMessage) {\n    sendPush msg\n  }\n  if (phone) {\n    sendSms phone, msg\n  }\n}",
        "docstring": "Make sure a door is locked at a specific time.  Option to add door contact sensor to only lock if closed."
    },
    {
        "code": "def installed() {}\n\ndef updated() {}\n\ndef listSwitches() {\n\tswitches.collect { device(it,\"switch\") }\n}\nvoid updateSwitches() {\n\tupdateAll(switches)\n}\ndef showSwitch() {\n\tshow(switches, \"switch\")\n}\nvoid updateSwitch() {\n\tupdate(switches)\n}\n\ndef listLocks() {\n\tlocks.collect { device(it, \"lock\") }\n}\nvoid updateLocks() {\n\tupdateAll(locks)\n}\ndef showLock() {\n\tshow(locks, \"lock\")\n}\nvoid updateLock() {\n\tupdate(locks)\n}\n\nprivate void updateAll(devices) {\n\tdef command = request.JSON?.command\n\tdef type = params.param1\n\tif (!devices) {\n\t\thttpError(404, \"Devices not found\")\n\t}\n\t\n\tif (command){\n\t\tdevices.each { device ->\n\t\t\texecuteCommand(device, type, command)\n\t\t}\n\t}\n}\n\nprivate void update(devices) {\n\tlog.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n\tdef command = request.JSON?.command\n\tdef type = params.param1\n\tdef device = devices?.find { it.id == params.id }\n\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\tif (command) {\n\t\texecuteCommand(device, type, command)\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n/**\n * Validates and executes the command\n * on the device or devices\n */\ndef executeCommand(device, type, command) {\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\t\n}\n\nprivate show(devices, name) {\n\tdef device = devices.find { it.id == params.id }\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse {\n\t\tdef s = device.currentState(name)\n\t\t[id: device.id, label: device.displayName, name: device.displayName, state: s]\n\t}\n}\n\nprivate device(it, name) {\n\tif (it) {\n\t\tdef s = it.currentState(name)\n\t\t[id: it.id, label: it.displayName, name: it.displayName, state: s]\n    }\n}",
        "docstring": "This SmartApp allows you to interact with the things in your physical graph through Alfred."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(location, modeChangeHandler)\n}\n\ndef modeChangeHandler(evt) {\n\tdef newMode = evt.value\n\tlog.debug \"evt: ${newMode}\"\n\tif (modes && modes.contains(newMode))\n\t{\n\t\tdef message = customMessage ?: \"SmartThings mode has changed to: \\\"${newMode}\\\"\"\n\t\tchatMessageToMC(message)\n\t}\n}\n\ndef chatMessageToMC(message) {\n\n\tdef parent = app.getParent()\n\n\tdef url = \"${parent.getServerURL()}/chat?message=${message.encodeAsURL()}\"\n\n\tif (username)\n\t{\n\t\turl += \"&username=${username.encodeAsURL()}\"\n\t}\n\tlog.debug \"POST to ${url}\"\n\n\thttpPost(url, \"foo=bar\") { response ->\n\t\tcontent = response.data\n\t\tlog.debug \"response: ${content}\"\n\t}\n\n}",
        "docstring": "Send chat messages into Minecraft via the SmartBlock mod"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\n\tif (blockUpdatesSwitch)\n\t{\n\t\tsubscribe(linkedSmartBlock, \"level\", updateSwitchLevel)\n\t\tsubscribe(linkedSmartBlock, \"switch\", updateSwitchState)\n\t}\n\n\tif (switchUpdatesBlock)\n\t{\n\t\tsubscribe(linkedSwitch, \"level\", updateBlockLevel)\n\t\tsubscribe(linkedSwitch, \"switch\", updateBlockState)\n\t}\n\n}\n\ndef updateSwitchLevel(evt) {\n\tint level = evt.value as int\n\tlog.debug \"matching level: ${level}\"\n\tlinkedSwitch.setLevel(level)\n}\n\ndef updateBlockLevel(evt) {\n\tint level = evt.value as int\n\tlog.debug \"matching level: ${level}\"\n\tlinkedSmartBlock.setLevel(level)\n}\n\ndef updateSwitchState(evt) {\n\tlog.debug \"setting linkedSwitch to ${evt.value}\"\n\tlinkedSwitch.\"${evt.value}\"()\n}\n\ndef updateBlockState(evt) {\n\tlog.debug \"setting linkedSmartBlock to ${evt.value}\"\n\tlinkedSmartBlock.\"${evt.value}\"()\n}\n\ndef getBlockId() {\n\treturn linkedSmartBlock.id\n}\n\ndef getLinkerDescription() {\n\n\tdef left = linkedSmartBlock ? \"${linkedSmartBlock.label ?: linkedSmartBlock.name}\" : \"\"\n\tdef right = linkedSwitch ? \"${linkedSwitch.label ?: linkedSwitch.name}\" : \"\"\n\n\tlog.debug \"left: ${left}, right: ${right}\"\n\n\tdef leftLink = switchUpdatesBlock ? \"<\" : \"\"\n\tdef rightLink = blockUpdatesSwitch ? \">\" : \"\"\n\n\tlog.debug \"leftLink: ${leftLink}, rightLink: ${rightLink}\"\n\n\tlog.debug \"switchUpdatesBlock: ${switchUpdatesBlock}\"\n\tlog.debug \"blockUpdatesSwitch: ${blockUpdatesSwitch}\"\n\n\tif (leftLink == \"\" && rightLink == \"\")\n\t{\n\t\treturn null\n\t}\n\n\t\"${left} ${leftLink}--${rightLink} ${right}\"\n}",
        "docstring": "A SmartApp that links SmartBlocks to switches"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// update all children with serverIp.\n\tif (serverIp) {\n\t\tgetChildDevices().each { block ->\n\t\t\tblock.setServerIp(serverIp)\n\t\t}\n\t}\n\n}\n\npublic getServerURL() {\n\treturn \"http://${serverIp}:3333\"\n}",
        "docstring": "A SmartApp for managing SmartBlocks"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.debug \"initializing\"\n\tsubscribe(smartBlock, \"redstoneSignalStrength\", redstoneSignalStrengthHandler)\n\tsubscribe(smartBlock, \"smartBlockNeighborChanged\", smartBlockNeighborChangedHandler, [filterEvents: false])\n\tsubscribe(smartBlock, \"smartBlockNeighborChanged\", smartBlockNeighborChangedHandler, [filterEvents: false])\n\tsubscribe(smartBlock, \"blockDestroyed.true\", smartBlockDestroyedHandler, [filterEvents: false])\n}\n\n/*\n* EVENT HANDLERS\n*/\n\ndef smartBlockDestroyedHandler(evt) {\n\tlog.debug \"smartBlockDestroyedHandler evt.value: ${evt.value}\"\n\n\tdef pageName = \"destroyedPage\"\n\tdef message = message(pageName)\n\tnotifyUser(pageName, message)\n}\n\ndef smartBlockNeighborChangedHandler(evt) {\n\tlog.debug \"smartBlockNeighborChangedHandler evt.value: ${evt.value}\"\n\tlog.debug \"neighborBlockParsed: ${neighborBlockParsed}\"\n\n\tif (neighborBlockParsed?.contains(evt.value)) {\n\t\tnotifyUserOfNeighborChange(evt.value)\n\t}\n}\n\ndef redstoneSignalStrengthHandler(evt) {\n\tlog.debug \"redstoneSignalStrengthHandler: ${evt.value}\"\n\n\tint newValue = evt.value as int\n\tint lastValue = smartBlock.latestState(\"redstoneSignalStrength\").value as int\n\n\tif (redstoneGreaterThan) {\n\t\tint gt = redstoneGreaterThan as int\n//\t\tlog.debug \"$newValue > $gt\"\n\t\tif (newValue > gt) {\n\t\t\tlog.debug \"greater than ${gt}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n\tif (redstoneLessThan) {\n\t\tint lt = redstoneLessThan as int\n//\t\tlog.debug \"$newValue < $lt\"\n\t\tif (newValue < lt) {\n\t\t\tlog.debug \"less than ${lt}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n\tif (redstoneEqualTo) {\n\t\tint et = redstoneEqualTo as int\n//\t\tlog.debug \"$newValue == $et\"\n\t\tif (newValue == et) {\n\t\t\tlog.debug \"equal to ${et}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n}\n\n/*\n* NOTIFICATIONS\n*/\n\ndef notifyUserOfRedstoneChange(value) {\n\tdef msg = message(\"redstonePage\")\n\tlog.debug \"message: ${msg}\"\n\tdef notificationMessage = msg ?: \"${smartBlock} redstone signal is ${value}\"\n\tnotifyUser(notificationMessage)\n}\n\ndef notifyUserOfNeighborChange(value) {\n\tdef msg = message(\"neighborPage\")\n\tlog.debug \"message: ${msg}\"\n\tdef notificationMessage = msg ?: \"${smartBlock} was updated by ${value}\"\n\tnotifyUser(notificationMessage)\n}\n\ndef notifyUser(pageName, messageToSend) {\n\tlog.debug \"notifyUser pageName: ${pageName}\"\n\n\tdef closestPlayerMessage = message(\"${pageName}ClosestPlayer\")\n\tlog.debug \"closestPlayerMessage = ${closestPlayerMessage}\"\n\tdef latestClosePlayer = getLatestClosePlayer()\n\tlog.debug \"latestClosePlayer = ${latestClosePlayer}\"\n\tif (closestPlayerMessage && latestClosePlayer != \"unknown\") {\n\t\tlog.debug \"chatting closestPlayer\"\n\t\tchatMessageToMC(closestPlayerMessage, latestClosePlayer)\n\t}\n\n\n\tdef wantsHH = app.\"${pageName}WantsHH\"\n\tlog.debug \"wantsHH = ${wantsHH}\"\n\tif (wantsHH) {\n\n\t\tlog.debug \"sending HH\"\n\t\tsendNotificationEvent(messageToSend)\n\n\t} else {\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(messageToSend, recipients)\n        }\n        else {\n\n            def wantsPush = app.\"${pageName}WantsPush\"\n            log.debug \"wantsPush = ${wantsPush}\"\n            if (wantsPush && wantsPush != \"false\") {\n                log.debug \"sending push\"\n                sendPush(messageToSend)\n            }\n\n            def wantsSms = app.\"${pageName}WantsSms\"\n            log.debug \"wantsSms = ${wantsSms}\"\n            if (wantsSms) {\n                log.debug \"sending sms to: ${wantsSms}\"\n                sendSms(wantsSms, messageToSend)\n            }\n        }\n\t}\n\n\tdef username = app.\"${pageName}ChatUsername\"\n\tdef allUsers = app.\"${pageName}ChatAllUsers\"\n\n\tlog.debug \"username = ${username}\"\n\tlog.debug \"allUsers = ${allUsers}\"\n\n\tif (username && username != \"\") {\n\t\tlog.debug \"chatting username: ${username}\"\n\t\tchatMessageToMC(messageToSend, username)\n\t} else if (allUsers) {\n\t\tlog.debug \"chatting all users\"\n\t\tchatMessageToMC(messageToSend, null)\n\t}\n\n}\n\ndef chatMessageToMC(message, username) {\n\tlog.debug \"chatMessageToMC\"\n\n\tdef url = \"${app.getParent().getServerURL()}/chat?message=${message.encodeAsURL()}\"\n\tif (username) {\n\t\turl = \"${url}&username=${username.encodeAsURL()}\"\n\t}\n\n\tlog.debug \"POST to ${url}\"\n\n\thttpPost(url, \"foo=bar\") {}\n}\n\ndef messageDescriptionPartsForPage(pageName) {\n\tdef size = messageBuilderOptions().size() * 2\n\t(0..size).collect { app.\"${pageName}MessagePart${it}\" }\n}\n\ndef messagePartsSet(pageName) { // are any set?\n\tmessageDescriptionPartsForPage(pageName).collect { !it }.unique().contains(false)\n}\n\ndef defaultMessageDescription(pageName) {\n\tdef description = \"\"\n\n\tif (pageName == \"destroyedPage\" || pageName == \"redstonePage\" || pageName == \"neighborBlockPage\") {\n\t\tdef second = messageBuilderOptions()[messagePartDefaultValue(pageName, 1)]\n\t\tif (second) description = \"\\${${second}}\"\n\n\t\tdef third = messagePartDefaultValue(pageName, 2)\n\t\tif (third) description = \"${description} ${third}\"\n\n\t\tdef fourth = messageBuilderOptions()[messagePartDefaultValue(pageName, 3)]\n\t\tif (fourth) description = \"${description} \\${${fourth}}\"\n\t}\n\n\treturn description\n}\n\ndef messageDescriptionForPage(pageName) {\n\n\tdef parts = messageDescriptionPartsForPage(pageName)\n\tdef messageParts = []\n\tparts.eachWithIndex { part, idx ->\n\t\tif (part != null && part != \"null\") {\n\t\t\tif (idx % 2) {\n\t\t\t\tmessageParts << \"\\${${messageBuilderOptions()[part]}}\"\n\t\t\t} else {\n\t\t\t\tmessageParts << part\n\t\t\t}\n\t\t}\n\t}\n\n\tif (messageParts) {\n\t\treturn messageParts.join(\" \").trim()\n\t} else {\n\t\treturn defaultMessageDescription()\n\t}\n}\n\ndef messagePartDefaultValue(pageName, part) {\n\tif (pageName == \"destroyedPage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"was destroyed by\"\n\t\tif (part == 3) return \"closestPlayer\"\n\t}\n\n\tif (pageName == \"neighborBlockPage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"has a redstone signal of\"\n\t\tif (part == 3) return \"redstoneSignalStrength\"\n\t}\n\n\tif (pageName == \"redstonePage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"was updated by\"\n\t\tif (part == 3) return \"closestPlayer\"\n\t}\n\n\treturn null\n}\n\ndef message(pageName) {\n\tlog.debug \"building message\"\n\tdef messageParts = []\n\n\tmessageDescriptionPartsForPage(pageName).eachWithIndex { part, idx ->\n\t\tif (idx % 2) {\n//\t\t\tdef option = messageBuilderOptions()[part]\n\t\t\tdef optionPart = getMessagePartFromOption(part)\n\t\t\tif (optionPart) messageParts << optionPart\n\t\t} else {\n\t\t\tif (part) messageParts << part\n\t\t}\n\t}\n\n\tdef message = messageParts.join(\" \").trim()\n\tlog.debug \"message: ${message}\"\n\treturn message\n}\n\ndef messageBuilderOptions() {\n\treturn [\n\t\t\"name\": \"SmartBlock name\",\n\t\t\"neighborBlockName\": \"Neighbor block name\",\n\t\t\"blockDestroyed\": \"Destroyed State ('destroyed' / 'OK')\",\n\t\t\"redstoneSignalStrength\": \"Redstone signal strength\",\n\t\t\"worldSeed\": \"World seed\",\n\t\t\"dimensionName\": \"Dimension name (World, Nether, End)\",\n\t\t\"coordinates\": \"Block coordinates\",\n\t\t\"closestPlayer\": \"Username of Closest player (within the past minute)\",\n\t\t\"placedBy\": \"Username of who placed the block\"\n\t]\n}\n\ndef getMessagePartFromOption(optionKey) {\n\tlog.debug \"optionKey: ${optionKey}\"\n\tif (optionKey == \"name\") return smartBlock.label ?: smartBlock.name\n\tif (optionKey == \"closestPlayer\") return getLatestClosePlayer()\n\tif (optionKey == \"blockDestroyed\") return smartBlock.latestValue(\"blockDestroyed\") ? \"OK\" : \"destroyed\"\n\treturn smartBlock.latestValue(optionKey)\n}\n\ndef getLatestClosePlayer() {\n\tdef now = new Date()\n\tdef minusOne = new Date(minutes: now.minutes - 1)\n\tdef latestStates = smartBlock.statesSince(\"closestPlayer\", minusOne)\n\tif (latestStates.size) {\n\t\treturn latestStates[0].value\n\t}\n\treturn \"unknown\"\n}\n\n/*\n* BLOCKS\n*/\n\ndef settingsAsIds() {\n\tlog.debug \"settingsAsIds\"\n\tlog.debug \"neighborBlockParsed: $neighborBlockParsed\"\n\n\tdef subscribedIds = []\n\n\tneighborBlockParsed.each {\n\t\tsubscribedIds << convertBlockSettingToBlockId(it)\n\t}\n\n\treturn subscribedIds\n}\n\ndef convertBlockSettingToBlockId(setting) {\n\tdef id = setting.substring(0, setting.indexOf(\" \"))\n\tdef name = allBlocks()[id]\n\tlog.debug \"id: $id, name:${name}\"\n\treturn id\n}\n\ndef allBlocksParsed() {\n\tallBlocks().collect { k, v -> \"${k} ${v}\" }\n}\n\ndef allBlocks() {\n\t[\n\t\t\"0\": \"Air\",\n\t\t\"1\": \"Stone\",\n\t\t\"2\": \"Grass\",\n\t\t\"3\": \"Dirt\",\n\t\t\"4\": \"Cobblestone\",\n\t\t\"5\": \"Oak Wood Plank\",\n\t\t\"5:1\": \"Spruce Wood Plank\",\n\t\t\"5:2\": \"Birch Wood Plank\",\n\t\t\"5:3\": \"Jungle Wood Plank\",\n\t\t\"6\": \"Oak Sapling\",\n\t\t\"6:1\": \"Spruce Sapling\",\n\t\t\"6:2\": \"Birch Sapling\",\n\t\t\"6:3\": \"Jungle Sapling\",\n\t\t\"7\": \"Bedrock\",\n\t\t\"8\": \"Water\",\n\t\t\"9\": \"Stationary Water\",\n\t\t\"10\": \"Lava\",\n\t\t\"11\": \"Stationary Lava\",\n\t\t\"12\": \"Sand\",\n\t\t\"13\": \"Gravel\",\n\t\t\"14\": \"Gold Ore\",\n\t\t\"15\": \"Iron Ore\",\n\t\t\"16\": \"Coal Ore\",\n\t\t\"17\": \"Oak Wood\",\n\t\t\"17:1\": \"Spruce Wood\",\n\t\t\"17:2\": \"Birch Wood\",\n\t\t\"17:3\": \"Jungle Wood\",\n\t\t\"18\": \"Oak Leaves\",\n\t\t\"18:1\": \"Spruce Leaves\",\n\t\t\"18:2\": \"Birch Leaves\",\n\t\t\"18:3\": \"Jungle Leaves\",\n\t\t\"19\": \"Sponge\",\n\t\t\"20\": \"Glass\",\n\t\t\"21\": \"Lapis Lazuli Ore\",\n\t\t\"22\": \"Lapis Lazuli Block\",\n\t\t\"23\": \"Dispenser\",\n\t\t\"24\": \"Sandstone\",\n\t\t\"24:1\": \"Chiseled Sandstone\",\n\t\t\"24:2\": \"Smooth Sandstone\",\n\t\t\"25\": \"Note Block\",\n\t\t\"26\": \"Bed Block\",\n\t\t\"27\": \"Powered Rail\",\n\t\t\"28\": \"Detector Rail\",\n\t\t\"29\": \"Sticky Piston\",\n\t\t\"30\": \"Web\",\n\t\t\"31\": \"Dead Shrub\",\n\t\t\"31:1\": \"Grass\",\n\t\t\"31:2\": \"Fern\",\n\t\t\"32\": \"Dead Shrub\",\n\t\t\"33\": \"Piston\",\n\t\t\"34\": \"Piston Head\",\n\t\t\"35\": \"White Wool\",\n\t\t\"35:1\": \"Orange Wool\",\n\t\t\"35:2\": \"Magenta Wool\",\n\t\t\"35:3\": \"Light Blue Wool\",\n\t\t\"35:4\": \"Yellow Wool\",\n\t\t\"35:5\": \"Lime Wool\",\n\t\t\"35:6\": \"Pink Wool\",\n\t\t\"35:7\": \"Gray Wool\",\n\t\t\"35:8\": \"Light Gray Wool\",\n\t\t\"35:9\": \"Cyan Wool\",\n\t\t\"35:10\": \"Purple Wool\",\n\t\t\"35:11\": \"Blue Wool\",\n\t\t\"35:12\": \"Brown Wool\",\n\t\t\"35:13\": \"Green Wool\",\n\t\t\"35:14\": \"Red Wool\",\n\t\t\"35:15\": \"Black Wool\",\n\t\t\"37\": \"Dandelion\",\n\t\t\"38\": \"Rose\",\n\t\t\"39\": \"Brown Mushroom\",\n\t\t\"40\": \"Red Mushroom\",\n\t\t\"41\": \"Gold Block\",\n\t\t\"42\": \"Iron Block\",\n\t\t\"43\": \"Double Stone Slab\",\n\t\t\"43:1\": \"Double Sandstone Slab\",\n\t\t\"43:2\": \"Double Wooden Slab\",\n\t\t\"43:3\": \"Double Cobblestone Slab\",\n\t\t\"43:4\": \"Double Brick Slab\",\n\t\t\"43:5\": \"Double Stone Brick Slab\",\n\t\t\"43:6\": \"Double Nether Brick Slab\",\n\t\t\"43:7\": \"Double Quartz Slab\",\n\t\t\"44\": \"Stone Slab\",\n\t\t\"44:1\": \"Sandstone Slab\",\n\t\t\"44:2\": \"Wooden Slab\",\n\t\t\"44:3\": \"Cobblestone Slab\",\n\t\t\"44:4\": \"Brick Slab\",\n\t\t\"44:5\": \"Stone Brick Slab\",\n\t\t\"44:6\": \"Nether Brick Slab\",\n\t\t\"44:7\": \"Quartz Slab\",\n\t\t\"45\": \"Brick\",\n\t\t\"46\": \"TNT\",\n\t\t\"47\": \"Bookshelf\",\n\t\t\"48\": \"Mossy Cobblestone\",\n\t\t\"49\": \"Obsidian\",\n\t\t\"50\": \"Torch\",\n\t\t\"51\": \"Fire\",\n\t\t\"52\": \"Monster Spawner\",\n\t\t\"53\": \"Oak Wood Stairs\",\n\t\t\"54\": \"Chest\",\n\t\t\"55\": \"Redstone Wire\",\n\t\t\"56\": \"Diamond Ore\",\n\t\t\"57\": \"Diamond Block\",\n\t\t\"58\": \"Workbench\",\n\t\t\"59\": \"Wheat Crops\",\n\t\t\"60\": \"Soil\",\n\t\t\"61\": \"Furnace\",\n\t\t\"62\": \"Burning Furnace\",\n\t\t\"63\": \"Sign Post\",\n\t\t\"64\": \"Wooden Door Block\",\n\t\t\"65\": \"Ladder\",\n\t\t\"66\": \"Rails\",\n\t\t\"67\": \"Cobblestone Stairs\",\n\t\t\"68\": \"Wall Sign\",\n\t\t\"69\": \"Lever\",\n\t\t\"70\": \"Stone Pressure Plate\",\n\t\t\"71\": \"Iron Door Block\",\n\t\t\"72\": \"Wooden Pressure Plate\",\n\t\t\"73\": \"Redstone Ore\",\n\t\t\"74\": \"Glowing Redstone Ore\",\n\t\t\"75\": \"Redstone Torch(off)\",\n\t\t\"76\": \"Redstone Torch(on)\",\n\t\t\"77\": \"Stone Button\",\n\t\t\"78\": \"Snow\",\n\t\t\"79\": \"Ice\",\n\t\t\"80\": \"Snow Block\",\n\t\t\"81\": \"Cactus\",\n\t\t\"82\": \"Clay\",\n\t\t\"83\": \"Sugar Cane\",\n\t\t\"84\": \"Jukebox\",\n\t\t\"85\": \"Fence\",\n\t\t\"86\": \"Pumpkin\",\n\t\t\"87\": \"Netherrack\",\n\t\t\"88\": \"Soul Sand\",\n\t\t\"89\": \"Glowstone\",\n\t\t\"90\": \"Portal\",\n\t\t\"91\": \"Jack - O - Lantern\",\n\t\t\"92\": \"Cake Block\",\n\t\t\"93\": \"Redstone Repeater Block(off)\",\n\t\t\"94\": \"Redstone Repeater Block(on)\",\n\t\t\"95\": \"Locked Chest\",\n\t\t\"96\": \"Trapdoor\",\n\t\t\"97\": \"Stone(Silverfish)\",\n\t\t\"97:1\": \"Cobblestone(Silverfish)\",\n\t\t\"97:2\": \"Stone Brick(Silverfish)\",\n\t\t\"98\": \"Stone Brick\",\n\t\t\"98:1\": \"Mossy Stone Brick\",\n\t\t\"98:2\": \"Cracked Stone Brick\",\n\t\t\"98:3\": \"Chiseled Stone Brick\",\n\t\t\"99\": \"Red Mushroom Cap\",\n\t\t\"100\": \"Brown Mushroom Cap\",\n\t\t\"101\": \"Iron Bars\",\n\t\t\"102\": \"Glass Pane\",\n\t\t\"103\": \"Melon Block\",\n\t\t\"104\": \"Pumpkin Stem\",\n\t\t\"105\": \"Melon Stem\",\n\t\t\"106\": \"Vines\",\n\t\t\"107\": \"Fence Gate\",\n\t\t\"108\": \"Brick Stairs\",\n\t\t\"109\": \"Stone Brick Stairs\",\n\t\t\"110\": \"Mycelium\",\n\t\t\"111\": \"Lily Pad\",\n\t\t\"112\": \"Nether Brick\",\n\t\t\"113\": \"Nether Brick Fence\",\n\t\t\"114\": \"Nether Brick Stairs\",\n\t\t\"115\": \"Nether Wart\",\n\t\t\"116\": \"Enchantment Table\",\n\t\t\"117\": \"Brewing Stand\",\n\t\t\"118\": \"Cauldron\",\n\t\t\"119\": \"End Portal\",\n\t\t\"120\": \"End Portal Frame\",\n\t\t\"121\": \"End Stone\",\n\t\t\"122\": \"Dragon Egg\",\n\t\t\"123\": \"Redstone Lamp(inactive)\",\n\t\t\"124\": \"Redstone Lamp(active)\",\n\t\t\"125\": \"Double Oak Wood Slab\",\n\t\t\"125:1\": \"Double Spruce Wood Slab\",\n\t\t\"125:2\": \"Double Birch Wood Slab\",\n\t\t\"125:3\": \"Double Jungle Wood Slab\",\n\t\t\"126\": \"Oak Wood Slab\",\n\t\t\"126:1\": \"Spruce Wood Slab\",\n\t\t\"126:2\": \"Birch Wood Slab\",\n\t\t\"126:3\": \"Jungle Wood Slab\",\n\t\t\"127\": \"Cocoa Plant\",\n\t\t\"128\": \"Sandstone Stairs\",\n\t\t\"129\": \"Emerald Ore\",\n\t\t\"130\": \"Ender Chest\",\n\t\t\"131\": \"Tripwire Hook\",\n\t\t\"132\": \"Tripwire\",\n\t\t\"133\": \"Emerald Block\",\n\t\t\"134\": \"Spruce Wood Stairs\",\n\t\t\"135\": \"Birch Wood Stairs\",\n\t\t\"136\": \"Jungle Wood Stairs\",\n\t\t\"137\": \"Command Block\",\n\t\t\"138\": \"Beacon Block\",\n\t\t\"139\": \"Cobblestone Wall\",\n\t\t\"139:1\": \"Mossy Cobblestone Wall\",\n\t\t\"140\": \"Flower Pot\",\n\t\t\"141\": \"Carrots\",\n\t\t\"142\": \"Potatoes\",\n\t\t\"143\": \"Wooden Button\",\n\t\t\"144\": \"Mob Head\",\n\t\t\"145\": \"Anvil\",\n\t\t\"146\": \"Trapped Chest\",\n\t\t\"147\": \"Weighted Pressure Plate(light)\",\n\t\t\"148\": \"Weighted Pressure Plate(heavy)\",\n\t\t\"149\": \"Redstone Comparator(inactive)\",\n\t\t\"150\": \"Redstone Comparator(active)\",\n\t\t\"151\": \"Daylight Sensor\",\n\t\t\"152\": \"Redstone Block\",\n\t\t\"153\": \"Nether Quartz Ore\",\n\t\t\"154\": \"Hopper\",\n\t\t\"155\": \"Quartz Block\",\n\t\t\"155:1\": \"Chiseled Quartz Block\",\n\t\t\"155:2\": \"Pillar Quartz Block\",\n\t\t\"156\": \"Quartz Stairs\",\n\t\t\"157\": \"Activator Rail\",\n\t\t\"158\": \"Dropper\",\n\t\t\"159\": \"White Stained Clay\",\n\t\t\"159:1\": \"Orange Stained Clay\",\n\t\t\"159:2\": \"Magenta Stained Clay\",\n\t\t\"159:3\": \"Light Blue Stained Clay\",\n\t\t\"159:4\": \"Yellow Stained Clay\",\n\t\t\"159:5\": \"Lime Stained Clay\",\n\t\t\"159:6\": \"Pink Stained Clay\",\n\t\t\"159:7\": \"Gray Stained Clay\",\n\t\t\"159:8\": \"Light Gray Stained Clay\",\n\t\t\"159:9\": \"Cyan Stained Clay\",\n\t\t\"159:10\": \"Purple Stained Clay\",\n\t\t\"159:11\": \"Blue Stained Clay\",\n\t\t\"159:12\": \"Brown Stained Clay\",\n\t\t\"159:13\": \"Green Stained Clay\",\n\t\t\"159:14\": \"Red Stained Clay\",\n\t\t\"159:15\": \"Black Stained Clay\",\n\t\t\"170\": \"Hay Bale\",\n\t\t\"171\": \"White Carpet\",\n\t\t\"171:1\": \"Orange Carpet\",\n\t\t\"171:2\": \"Magenta Carpet\",\n\t\t\"171:3\": \"Light Blue Carpet\",\n\t\t\"171:4\": \"Yellow Carpet\",\n\t\t\"171:5\": \"Lime Carpet\",\n\t\t\"171:6\": \"Pink Carpet\",\n\t\t\"171:7\": \"Gray Carpet\",\n\t\t\"171:8\": \"Light Gray Carpet\",\n\t\t\"171:9\": \"Cyan Carpet\",\n\t\t\"171:10\": \"Purple Carpet\",\n\t\t\"171:11\": \"Blue Carpet\",\n\t\t\"171:12\": \"Brown Carpet\",\n\t\t\"171:13\": \"Green Carpet\",\n\t\t\"171:14\": \"Red Carpet\",\n\t\t\"171:15\": \"Black Carpet\",\n\t\t\"172\": \"Hardened Clay\",\n\t\t\"173\": \"Block of Coal\",\n\t\t\"256\": \"Iron Shovel\",\n\t\t\"257\": \"Iron Pickaxe\",\n\t\t\"258\": \"Iron Axe\",\n\t\t\"259\": \"Flint and Steel\",\n\t\t\"260\": \"Apple\",\n\t\t\"261\": \"Bow\",\n\t\t\"262\": \"Arrow\",\n\t\t\"263\": \"Coal\",\n\t\t\"263:1\": \"Charcoal\",\n\t\t\"264\": \"Diamond\",\n\t\t\"265\": \"Iron Ingot\",\n\t\t\"266\": \"Gold Ingot\",\n\t\t\"267\": \"Iron Sword\",\n\t\t\"268\": \"Wooden Sword\",\n\t\t\"269\": \"Wooden Shovel\",\n\t\t\"270\": \"Wooden Pickaxe\",\n\t\t\"271\": \"Wooden Axe\",\n\t\t\"272\": \"Stone Sword\",\n\t\t\"273\": \"Stone Shovel\",\n\t\t\"274\": \"Stone Pickaxe\",\n\t\t\"275\": \"Stone Axe\",\n\t\t\"276\": \"Diamond Sword\",\n\t\t\"277\": \"Diamond Shovel\",\n\t\t\"278\": \"Diamond Pickaxe\",\n\t\t\"279\": \"Diamond Axe\",\n\t\t\"280\": \"Stick\",\n\t\t\"281\": \"Bowl\",\n\t\t\"282\": \"Mushroom Soup\",\n\t\t\"283\": \"Gold Sword\",\n\t\t\"284\": \"Gold Shovel\",\n\t\t\"285\": \"Gold Pickaxe\",\n\t\t\"286\": \"Gold Axe\",\n\t\t\"287\": \"String\",\n\t\t\"288\": \"Feather\",\n\t\t\"289\": \"Sulphur\",\n\t\t\"290\": \"Wooden Hoe\",\n\t\t\"291\": \"Stone Hoe\",\n\t\t\"292\": \"Iron Hoe\",\n\t\t\"293\": \"Diamond Hoe\",\n\t\t\"294\": \"Gold Hoe\",\n\t\t\"295\": \"Wheat Seeds\",\n\t\t\"296\": \"Wheat\",\n\t\t\"297\": \"Bread\",\n\t\t\"298\": \"Leather Helmet\",\n\t\t\"299\": \"Leather Chestplate\",\n\t\t\"300\": \"Leather Leggings\",\n\t\t\"301\": \"Leather Boots\",\n\t\t\"302\": \"Chainmail Helmet\",\n\t\t\"303\": \"Chainmail Chestplate\",\n\t\t\"304\": \"Chainmail Leggings\",\n\t\t\"305\": \"Chainmail Boots\",\n\t\t\"306\": \"Iron Helmet\",\n\t\t\"307\": \"Iron Chestplate\",\n\t\t\"308\": \"Iron Leggings\",\n\t\t\"309\": \"Iron Boots\",\n\t\t\"310\": \"Diamond Helmet\",\n\t\t\"311\": \"Diamond Chestplate\",\n\t\t\"312\": \"Diamond Leggings\",\n\t\t\"313\": \"Diamond Boots\",\n\t\t\"314\": \"Gold Helmet\",\n\t\t\"315\": \"Gold Chestplate\",\n\t\t\"316\": \"Gold Leggings\",\n\t\t\"317\": \"Gold Boots\",\n\t\t\"318\": \"Flint\",\n\t\t\"319\": \"Raw Porkchop\",\n\t\t\"320\": \"Cooked Porkchop\",\n\t\t\"321\": \"Painting\",\n\t\t\"322\": \"Golden Apple\",\n\t\t\"322:1\": \"Enchanted Golden Apple\",\n\t\t\"323\": \"Sign\",\n\t\t\"324\": \"Wooden Door\",\n\t\t\"325\": \"Bucket\",\n\t\t\"326\": \"Water Bucket\",\n\t\t\"327\": \"Lava Bucket\",\n\t\t\"328\": \"Minecart\",\n\t\t\"329\": \"Saddle\",\n\t\t\"330\": \"Iron Door\",\n\t\t\"331\": \"Redstone\",\n\t\t\"332\": \"Snowball\",\n\t\t\"333\": \"Boat\",\n\t\t\"334\": \"Leather\",\n\t\t\"335\": \"Milk Bucket\",\n\t\t\"336\": \"Clay Brick\",\n\t\t\"337\": \"Clay Balls\",\n\t\t\"338\": \"Sugarcane\",\n\t\t\"339\": \"Paper\",\n\t\t\"340\": \"Book\",\n\t\t\"341\": \"Slimeball\",\n\t\t\"342\": \"Storage Minecart\",\n\t\t\"343\": \"Powered Minecart\",\n\t\t\"344\": \"Egg\",\n\t\t\"345\": \"Compass\",\n\t\t\"346\": \"Fishing Rod\",\n\t\t\"347\": \"Clock\",\n\t\t\"348\": \"Glowstone Dust\",\n\t\t\"349\": \"Raw Fish\",\n\t\t\"350\": \"Cooked Fish\",\n\t\t\"351\": \"Ink Sack\",\n\t\t\"351:1\": \"Rose Red\",\n\t\t\"351:2\": \"Cactus Green\",\n\t\t\"351:3\": \"Coco Beans\",\n\t\t\"351:4\": \"Lapis Lazuli\",\n\t\t\"351:5\": \"Purple Dye\",\n\t\t\"351:6\": \"Cyan Dye\",\n\t\t\"351:7\": \"Light Gray Dye\",\n\t\t\"351:8\": \"Gray Dye\",\n\t\t\"351:9\": \"Pink Dye\",\n\t\t\"351:10\": \"Lime Dye\",\n\t\t\"351:11\": \"Dandelion Yellow\",\n\t\t\"351:12\": \"Light Blue Dye\",\n\t\t\"351:13\": \"Magenta Dye\",\n\t\t\"351:14\": \"Orange Dye\",\n\t\t\"351:15\": \"Bone Meal\",\n\t\t\"352\": \"Bone\",\n\t\t\"353\": \"Sugar\",\n\t\t\"354\": \"Cake\",\n\t\t\"355\": \"Bed\",\n\t\t\"356\": \"Redstone Repeater\",\n\t\t\"357\": \"Cookie\",\n\t\t\"358\": \"Map\",\n\t\t\"359\": \"Shears\",\n\t\t\"360\": \"Melon\",\n\t\t\"361\": \"Pumpkin Seeds\",\n\t\t\"362\": \"Melon Seeds\",\n\t\t\"363\": \"Raw Beef\",\n\t\t\"364\": \"Steak\",\n\t\t\"365\": \"Raw Chicken\",\n\t\t\"366\": \"Cooked Chicken\",\n\t\t\"367\": \"Rotten Flesh\",\n\t\t\"368\": \"Ender Pearl\",\n\t\t\"369\": \"Blaze Rod\",\n\t\t\"370\": \"Ghast Tear\",\n\t\t\"371\": \"Gold Nugget\",\n\t\t\"372\": \"Nether Wart Seeds\",\n\t\t\"373\": \"Potion\",\n\t\t\"374\": \"Glass Bottle\",\n\t\t\"375\": \"Spider Eye\",\n\t\t\"376\": \"Fermented Spider Eye\",\n\t\t\"377\": \"Blaze Powder\",\n\t\t\"378\": \"Magma Cream\",\n\t\t\"379\": \"Brewing Stand\",\n\t\t\"380\": \"Cauldron\",\n\t\t\"381\": \"Eye of Ender\",\n\t\t\"382\": \"Glistering Melon\",\n\t\t\"383:50\": \"Spawn Creeper\",\n\t\t\"383:51\": \"Spawn Skeleton\",\n\t\t\"383:52\": \"Spawn Spider\",\n\t\t\"383:54\": \"Spawn Zombie\",\n\t\t\"383:55\": \"Spawn Slime\",\n\t\t\"383:56\": \"Spawn Ghast\",\n\t\t\"383:57\": \"Spawn Pigman\",\n\t\t\"383:58\": \"Spawn Enderman\",\n\t\t\"383:59\": \"Spawn Cave Spider\",\n\t\t\"383:60\": \"Spawn Silverfish \",\n\t\t\"383:61\": \"Spawn Blaze\",\n\t\t\"383:62\": \"Spawn Magma Cube \",\n\t\t\"383:65\": \"Spawn Bat\",\n\t\t\"383:66\": \"Spawn Witch\",\n\t\t\"383:90\": \"Spawn Pig\",\n\t\t\"383:91\": \"Spawn Sheep\",\n\t\t\"383:92\": \"Spawn Cow\",\n\t\t\"383:93\": \"Spawn Chicken\",\n\t\t\"383:94\": \"Spawn Squid\",\n\t\t\"383:95\": \"Spawn Wolf\",\n\t\t\"383:96\": \"Spawn Mooshroom\",\n\t\t\"383:98\": \"Spawn Ocelot\",\n\t\t\"383:100\": \"Spawn Horse\",\n\t\t\"383:120\": \"Spawn Villager\",\n\t\t\"384\": \"Bottle o' Enchanting\",\n\t\t\"385\": \"Fire Charge\",\n\t\t\"386\": \"Book and Quill\",\n\t\t\"387\": \"Written Book\",\n\t\t\"388\": \"Emerald\",\n\t\t\"389\": \"Item Frame\",\n\t\t\"390\": \"Flower Pot\",\n\t\t\"391\": \"Carrots\",\n\t\t\"392\": \"Potato\",\n\t\t\"393\": \"Baked Potato\",\n\t\t\"394\": \"Poisonous Potato\",\n\t\t\"395\": \"Map\",\n\t\t\"396\": \"Golden Carrot\",\n\t\t\"397\": \"Mob Head (Skeleton)\",\n\t\t\"397:1\": \"Mob Head (Wither Skeleton)\",\n\t\t\"397:2\": \"Mob Head (Zombie)\",\n\t\t\"397:3\": \"Mob Head (Human)\",\n\t\t\"397:4\": \"Mob Head (Creeper)\",\n\t\t\"398\": \"Carrot on a Stick\",\n\t\t\"399\": \"Nether Star\",\n\t\t\"400\": \"Pumpkin Pie\",\n\t\t\"401\": \"Firework Rocket\",\n\t\t\"402\": \"Firework Star\",\n\t\t\"403\": \"Enchanted Book\",\n\t\t\"404\": \"Redstone Comparator\",\n\t\t\"405\": \"Nether Brick\",\n\t\t\"406\": \"Nether Quartz\",\n\t\t\"407\": \"Minecart with TNT\",\n\t\t\"408\": \"Minecart with Hopper\",\n\t\t\"417\": \"Iron Horse Armor\",\n\t\t\"418\": \"Gold Horse Armor\",\n\t\t\"419\": \"Diamond Horse Armor\",\n\t\t\"420\": \"Lead\",\n\t\t\"421\": \"Name Tag\"\n\t]\n}",
        "docstring": "A SmartApp that notifies you when things are happening around your SmartBlocks"
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\t//initialize()\n\tlistDevices()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\t//unsubscribe()\n\t//unschedule()\n\tinitialize()\n\n\tlistDevices()\n}\n\n\ndef poll(childDevice)\n{\n\tlog.debug \"In poll\"\n\tlog.debug childDevice\n\n\t//login()\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tlog.debug dni\n\n\tdef deviceType = null\n\n\tstate.deviceDataArr.each() {\n\t\tif (it.id == dni) {\n\t\t\tdeviceType = it.type\n\t\t}\n\t}\n\n\tlog.debug \"device type is: ${deviceType}\"\n\n\tswitch(deviceType) {\t//outlets are polled in unique method not here\n\n\t\tcase \"sensor_pod\":\n\t\t\tlog.debug \"Polling sensor_pod\"\n\t\t\tgetSensorPodUpdate(childDevice)\n\t\t\tlog.debug \"sensor pod status updated\"\n\t\t\tbreak\n\n\t\tcase \"piggy_bank\":\n\t\t\tlog.debug \"Polling piggy_bank\"\n\t\t\tgetPiggyBankUpdate(childDevice)\n\t\t\tlog.debug \"piggy bank status updated\"\n\t\t\tbreak\n\n\t\tcase \"eggtray\":\n\t\t\tlog.debug \"Polling eggtray\"\n\t\t\tgetEggtrayUpdate(childDevice)\n\t\t\tlog.debug \"eggtray status updated\"\n\t\t\tbreak\n\n\t}\n\tupdateWinkSubscriptions()\n}\n\ndef cToF(temp) {\n\treturn temp * 1.8 + 32\n}\n\ndef fToC(temp) {\n\treturn (temp - 32) / 1.8\n}\n\ndef dollarize(int money)\n{\n\tdef value = money.toString()\n\n\tif ( value.length() == 1 ) {\n\t\tvalue = \"00\" + value\n\t}\n\n\tif ( value.length() == 2 ) {\n\t\tvalue = \"0\" + value\n\t}\n\n\tdef newval = value.substring(0, value.length() - 2) + \".\" + value.substring(value.length()-2, value.length())\n\tvalue = newval\n\n\tdef pattern = \"\\$0.00\"\n\tdef moneyform = new DecimalFormat(pattern)\n\tString output = moneyform.format(value.toBigDecimal())\n\n\treturn output\n}\n\ndef debugEvent(message, displayEvent) {\n\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent (results)\n\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START NIMBUS SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef createNimbusChildren(deviceData)\n{\n\tlog.debug \"In createNimbusChildren\"\n\n\tdef nimbusName = deviceData.name\n\tdef deviceFile = \"Quirky-Wink-Nimbus\"\n\tdef index = 1\n\tdeviceData.dials.each {\n\t\tlog.debug \"creating dial device for ${it.dial_id}\"\n\t\tdef dialName = \"Dial ${index}\"\n\t\tdef dialLabel = \"${nimbusName} ${dialName}\"\n\t\tcreateChildDevice( deviceFile, it.dial_id, dialName, dialLabel )\n\t\tindex++\n\t}\n}\n\ndef cloud_clockEventHandler()\n{\n\tlog.debug \"In Nimbus Event Handler...\"\n\n\tdef json = request.JSON\n\tdef dials = json.dials\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n\n\tif ( dials ) {\n\t\tdials.each() {\n\t\t\tdef childDevice = getChildDevice(it.dial_id)\n\t\t\tchildDevice?.sendEvent( name : \"dial\", value : it.label , unit : \"\" )\n\t\t\tchildDevice?.sendEvent( name : \"info\", value : it.name , unit : \"\" )\n\t\t}\n\t}\n}\n\ndef pollNimbus(dni)\n{\n\n\tlog.debug \"In pollNimbus using dni # ${dni}\"\n\n\t//login()\n\n\tdef dials = null\n\n\tapiGet(\"/users/me/wink_devices\") { response ->\n\n\t\tresponse.data.data.each() {\n\t\t\tif (it.cloud_clock_id  ) {\n\t\t\t\tlog.debug \"Found Nimbus #\" + it.cloud_clock_id\n\t\t\t\tdials   = it.dials\n\t\t\t\t//log.debug dials\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( dials ) {\n\t\tdials.each() {\n\t\t\tdef childDevice = getChildDevice(it.dial_id)\n\n\t\t\tchildDevice?.sendEvent( name : \"dial\", value : it.label , unit : \"\" )\n\t\t\tchildDevice?.sendEvent( name : \"info\", value : it.name , unit : \"\" )\n\n\t\t\t//Change the tile/icon to what info is being displayed\n\t\t\tswitch(it.name) {\n\t\t\t\tcase \"Weather\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-weather\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Traffic\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-traffic\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Time\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-time\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Twitter\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-twitter\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Calendar\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-calendar\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Email\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-mail\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Facebook\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-facebook\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Instagram\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-instagram\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Fitbit\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-fitbit\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Egg Minder\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.egg-minder.quirky-egg-device\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Porkfolio\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.porkfolio.quirky-porkfolio-side\")\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t\tchildDevice.save()\n\t\t}\n\t}\n\treturn\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START EGG TRAY SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getEggtrayUpdate(childDevice)\n{\n\tlog.debug \"In getEggtrayUpdate\"\n\n\tapiGet(\"/eggtrays/\" + childDevice.device.deviceNetworkId) { response ->\n\n\t\tdef data = response.data.data\n\t\tdef freshnessPeriod = data.freshness_period\n\t\tdef trayName = data.name\n\t\tlog.debug data\n\n\t\tint totalEggs = 0\n\t\tint oldEggs = 0\n\n\t\tdef now = new Date()\n\t\tdef nowUnixTime = now.getTime()/1000\n\n\t\tdata.eggs.each() { it ->\n\t\t\tif (it != 0)\n\t\t\t{\n\t\t\t\ttotalEggs++\n\n\t\t\t\tdef eggArriveDate = it\n\t\t\t\tdef eggStaleDate = eggArriveDate + freshnessPeriod\n\t\t\t\tif ( nowUnixTime > eggStaleDate ){\n\t\t\t\t\toldEggs++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint freshEggs = totalEggs - oldEggs\n\n\t\tif ( oldEggs > 0 ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"haveBadEgg\")\n\t\t\tdef msg = \"${trayName} says: \"\n\t\t\tmsg+= \"Did you know that all it takes is one bad egg? \"\n\t\t\tmsg+= \"And it looks like I found one.\\n\\n\"\n\t\t\tmsg+= \"You should probably run an Egg Report before you use any eggs.\"\n\t\t\tsendNotificationEvent(msg)\n\t\t}\n\t\tif ( totalEggs == 0 ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"noEggs\")\n\t\t\tsendNotificationEvent(\"${trayName} says:\\n'Oh no, I'm out of eggs!'\")\n\t\t\tsendNotificationEvent(msg)\n\t\t}\n\t\tif ( (freshEggs == totalEggs) && (totalEggs != 0) ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"goodEggs\")\n\t\t}\n\t\tchildDevice?.sendEvent( name : \"totalEggs\", value : totalEggs , unit : \"\" )\n\t\tchildDevice?.sendEvent( name : \"freshEggs\", value : freshEggs , unit : \"\" )\n\t\tchildDevice?.sendEvent( name : \"oldEggs\", value : oldEggs , unit : \"\" )\n\t}\n}\n\ndef runEggReport(childDevice)\n{\n\tapiGet(\"/eggtrays/\" + childDevice.device.deviceNetworkId) { response ->\n\n\t\tdef data = response.data.data\n\t\tdef trayName = data.name\n\t\tdef freshnessPeriod = data.freshness_period\n\t\tdef now = new Date()\n\t\tdef nowUnixTime = now.getTime()/1000\n\n\t\tdef eggArray = []\n\n\t\tdef i = 0\n\n\t\tdata.eggs.each()  { it ->\n\t\t\tif (it != 0 ) {\n\t\t\t\tdef eggArriveDate = it\n\t\t\t\tdef eggStaleDate = eggArriveDate + freshnessPeriod\n\t\t\t\tif ( nowUnixTime > eggStaleDate ){\n\t\t\t\t\teggArray.push(\"Bad  \")\n\t\t\t\t} else {\n\t\t\t\t\teggArray.push(\"Good \")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teggArray.push(\"Empty\")\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tdef msg = \" Egg Report for ${trayName}\\n\\n\"\n\t\tmsg+= \"#7:${eggArray[6]}    #14:${eggArray[13]}\\n\"\n\t\tmsg+= \"#6:${eggArray[5]}    #13:${eggArray[12]}\\n\"\n\t\tmsg+= \"#5:${eggArray[4]}    #12:${eggArray[11]}\\n\"\n\t\tmsg+= \"#4:${eggArray[3]}    #11:${eggArray[10]}\\n\"\n\t\tmsg+= \"#3:${eggArray[2]}    #10:${eggArray[9]}\\n\"\n\t\tmsg+= \"#2:${eggArray[1]}      #9:${eggArray[8]}\\n\"\n\t\tmsg+= \"#1:${eggArray[0]}      #8:${eggArray[7]}\\n\"\n\t\tmsg+= \"                 +\\n\"\n\t\tmsg+= \"              ===\\n\"\n\t\tmsg+= \"              ===\"\n\n\t\tsendNotificationEvent(msg)\n\t}\n}\n\ndef eggtrayEventHandler()\n{\n\tlog.debug \"In  eggtrayEventHandler...\"\n\n\tdef json = request.JSON\n\tdef dni = getChildDevice(json.eggtray_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni) //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START PIGGY BANK SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getPiggyBankUpdate(childDevice)\n{\n\tapiGet(\"/piggy_banks/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef status = response.data.data\n\t\tdef alertData = status.triggers\n\n\t\tif (( alertData.enabled ) && ( state.lastCheckTime )) {\n\t\t\tif ( alertData.triggered_at[0].toInteger() > state.lastCheckTime ) {\n\t\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"active\",unit:\"\")\n\t\t\t} else {\n\t\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"inactive\",unit:\"\")\n\t\t\t}\n\t\t}\n\n\t\tchildDevice?.sendEvent(name:\"goal\",value:dollarize(status.savings_goal),unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"balance\",value:dollarize(status.balance),unit:\"\")\n\n\t\tdef now = new Date()\n\t\tdef longTime = now.getTime()/1000\n\t\tstate.lastCheckTime = longTime.toInteger()\n\t}\n}\n\ndef piggy_bankEventHandler()\n{\n\tlog.debug \"In  piggy_bankEventHandler...\"\n\n\tdef json = request.JSON\n\tdef dni = getChildDevice(json.piggy_bank_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni) //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START SENSOR POD SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getSensorPodUpdate(childDevice)\n{\n\tapiGet(\"/sensor_pods/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef status = response.data.data.last_reading\n\n\t\tstatus.loudness ? childDevice?.sendEvent(name:\"sound\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"sound\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.brightness ? childDevice?.sendEvent(name:\"light\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"light\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.vibration ? childDevice?.sendEvent(name:\"acceleration\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.external_power ? childDevice?.sendEvent(name:\"powerSource\",value:\"powered\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"powerSource\",value:\"battery\",unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"humidity\",value:status.humidity,unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"battery\",value:(status.battery * 100).toInteger(),unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"temperature\",value:cToF(status.temperature),unit:\"F\")\n\t}\n}\n\ndef sensor_podEventHandler()\n{\n\tlog.debug \"In  sensor_podEventHandler...\"\n\n\tdef json = request.JSON\n\t//log.debug json\n\tdef dni = getChildDevice(json.sensor_pod_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni)   //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START POWERSTRIP SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\n\ndef powerstripEventHandler()\n{\n\tlog.debug \"In Powerstrip Event Handler...\"\n\n\tdef json = request.JSON\n\tdef outlets = json.outlets\n\n\toutlets.each() {\n\t\tdef dni = getChildDevice(it.outlet_id)\n\t\tpollOutlet(dni)   //sometimes events are stale, poll for all latest states\n\t}\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\ndef pollOutlet(childDevice)\n{\n\tlog.debug \"In pollOutlet\"\n\n\t//login()\n\n\tlog.debug \"Polling powerstrip\"\n\tapiGet(\"/outlets/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef data = response.data.data\n\t\tdata.powered ? childDevice?.sendEvent(name:\"switch\",value:\"on\") :\n\t\t\tchildDevice?.sendEvent(name:\"switch\",value:\"off\")\n\t}\n}\n\ndef on(childDevice)\n{\n\t//login()\n\n\tapiPut(\"/outlets/\" + childDevice.device.deviceNetworkId, [powered : true]) { response ->\n\t\tdef data = response.data.data\n\t\tlog.debug \"Sending 'on' to device\"\n\t}\n}\n\ndef off(childDevice)\n{\n\t//login()\n\n\tapiPut(\"/outlets/\" + childDevice.device.deviceNetworkId, [powered : false]) { response ->\n\t\tdef data = response.data.data\n\t\tlog.debug \"Sending 'off' to device\"\n\t}\n}\n\ndef createPowerstripChildren(deviceData)\n{\n\tlog.debug \"In createPowerstripChildren\"\n\n\tdef powerstripName = deviceData.name\n\tdef deviceFile = \"Quirky Wink Powerstrip\"\n\n\tdeviceData.outlets.each {\n\t\tcreateChildDevice( deviceFile, it.outlet_id, it.name, \"$powerstripName ${it.name}\" )\n\t}\n}\n\nprivate Boolean canInstallLabs()\n{\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware)\n{\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions()\n{\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Connect your Quirky to SmartThings."
    },
    {
        "code": "def installed() {\n\tdebugOut \"Installed with settings: ${settings}\"\n\n\tunschedule()\n\tunsubscribe()\n\n\tsetupBulbs()\n\n\tdef cron = \"0 11 23 * * ?\"\n\tlog.debug \"schedule('$cron', syncronizeDevices)\"\n\tschedule(cron, syncronizeDevices)\n}\n\ndef updated() {\n\tdebugOut \"Updated with settings: ${settings}\"\n\n\tunschedule()\n\n\tsetupBulbs()\n\n\tdef cron = \"0 11 23 * * ?\"\n\tlog.debug \"schedule('$cron', syncronizeDevices)\"\n\tschedule(cron, syncronizeDevices)\n}\n\ndef uninstalled()\n{\n\tunschedule() //in case we have hanging runIn()'s\n}\n\nprivate removeChildDevices(delete)\n{\n\tdebugOut \"deleting ${delete.size()} bulbs\"\n\tdebugOut \"deleting ${delete}\"\n\tdelete.each {\n\t\tdeleteChildDevice(it.device.deviceNetworkId)\n\t}\n}\n\ndef uninstallFromChildDevice(childDevice)\n{\n\tdef errorMsg = \"uninstallFromChildDevice was called and \"\n\tif (!settings.selectedBulbs) {\n\t\tdebugOut errorMsg += \"had empty list passed in\"\n\t\treturn\n\t}\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tif ( !dni ) {\n\t\tdebugOut errorMsg += \"could not find dni of device\"\n\t\treturn\n\t}\n\n\tdef newDeviceList = settings.selectedBulbs - dni\n\tapp.updateSetting(\"selectedBulbs\", newDeviceList)\n\n\tdebugOut errorMsg += \"completed succesfully\"\n}\n\n\ndef setupBulbs() {\n\tdebugOut \"In setupBulbs\"\n\n\tdef bulbs = state.devices\n\tdef deviceFile = \"TCP Bulb\"\n\n\tselectedBulbs.each { did ->\n\t\t//see if this is a selected bulb and install it if not already\n\t\tdef d = getChildDevice(did)\n\n\t\tif(!d) {\n\t\t\tdef newBulb = bulbs.find { (it.did) == did }\n\t\t\td = addChildDevice(\"wackford\", deviceFile, did, null, [name: \"${newBulb?.name}\", label: \"${newBulb?.name}\", completedSetup: true])\n\n\t\t\t/*if ( isRoom(did) ) { //change to the multi light group icon for a room device\n\t\t\t\td.setIcon(\"switch\", \"on\",  \"st.lights.multi-light-bulb-on\")\n\t\t\t\td.setIcon(\"switch\", \"off\",  \"st.lights.multi-light-bulb-off\")\n\t\t\t\td.save()\n\t\t\t}*/\n\n\t\t} else {\n\t\t\tdebugOut \"We already added this device\"\n\t\t}\n\t}\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !selectedBulbs?.contains(it.deviceNetworkId) }\n\tremoveChildDevices(delete)\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//syncronizeDevices()\n}\n\ndef initialize() {\n\n\tatomicState.token = \"\"\n\n\tgetToken()\n\n\tif ( atomicState.token == \"error\" ) {\n\t\treturn dynamicPage(name:\"chooseBulbs\", title:\"TCP Login Failed!\\r\\nTap 'Done' to try again\", nextPage:\"\", install:false, uninstall: false) {\n\t\t\tsection(\"\") {}\n\t\t}\n\t} else {\n\t\t\"we're good to go\"\n\t\tdebugOut \"We have Token.\"\n\t}\n\n\t//getGatewayData() //we really don't need anything from the gateway\n\n\tdeviceDiscovery()\n\n\tdef options = devicesDiscovered() ?: []\n\n\tdef msg = \"\"\"Tap 'Done' after you have selected the desired devices.\"\"\"\n\n\treturn dynamicPage(name:\"chooseBulbs\", title:\"TCP and SmartThings Connected!\", nextPage:\"\", install:true, uninstall: true) {\n\t\tsection(\"Tap Below to View Device List\") {\n\t\t\tinput \"selectedBulbs\", \"enum\", required:false, title:\"Select Bulb/Fixture\", multiple:true, options:options\n\t\t\tparagraph msg\n\t\t}\n\t}\n}\n\ndef deviceDiscovery() {\n\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token></gip>\"\n\n\tdef Params = [\n\t\tcmd: \"RoomGetCarousel\",\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tdef cmd = toQueryString(Params)\n\n\tdef rooms = \"\"\n\n\tapiPost(cmd) { response ->\n\t\trooms = response.data.gip.room\n\t}\n\n\tdebugOut \"rooms data = ${rooms}\"\n\n\tdef devices = []\n\tdef bulbIndex = 1\n\tdef lastRoomName = null\n\tdef deviceList = []\n\n\tif ( rooms[1] == null ) {\n\t\tdef roomId = rooms.rid\n\t\tdef roomName = rooms.name\n\t\tdevices  = rooms.device\n\t\tif ( devices[1] != null ) {\n\t\t\tdebugOut \"Room Device Data: did:${roomId} roomName:${roomName}\"\n\t\t\t//deviceList += [\"name\" : \"${roomName}\", \"did\" : \"${roomId}\", \"type\" : \"room\"]\n\t\t\tdevices.each({\n\t\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t\t})\n\t\t} else {\n\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t}\n\t} else {\n\t\trooms.each({\n\t\t\tdevices  = it.device\n\t\t\tdef roomName = it.name\n\t\t\tif ( devices[1] != null ) {\n\t\t\t\tdef roomId = it?.rid\n\t\t\t\tdebugOut \"Room Device Data: did:${roomId} roomName:${roomName}\"\n\t\t\t\t//deviceList += [\"name\" : \"${roomName}\", \"did\" : \"${roomId}\", \"type\" : \"room\"]\n\t\t\t\tdevices.each({\n\t\t\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tdebugOut \"Bulb Device Data: did:${devices?.did} room:${roomName} BulbName:${devices?.name}\"\n\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${devices?.name}\", \"did\" : \"${devices?.did}\", \"type\" : \"bulb\"]\n\t\t\t}\n\t\t})\n\t}\n\tdevices = [\"devices\" : deviceList]\n\tstate.devices = devices.devices\n}\n\nMap devicesDiscovered() {\n\tdef devices =  state.devices\n\tdef map = [:]\n\tif (devices instanceof java.util.Map) {\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.did\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t} else { //backwards compatable\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.did\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t}\n\tmap\n}\n\ndef getGatewayData() {\n\tdebugOut \"In getGatewayData\"\n\n\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token></gip>\"\n\n\tdef qParams = [\n\t\tcmd: \"GatewayGetInfo\",\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tdef cmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"the gateway reponse is ${response.data.gip.gateway}\"\n\t}\n\n}\n\ndef getToken() {\n\n\tatomicState.token = \"\"\n\n\tif (password) {\n\t\tdef hashedPassword = generateMD5(password)\n\n\t\tdef data = \"<gip><version>1</version><email>${username}</email><password>${hashedPassword}</password></gip>\"\n\n\t\tdef qParams = [\n\t\t\tcmd : \"GWRLogin\",\n\t\t\tdata: \"${data}\",\n\t\t\tfmt : \"json\"\n\t\t]\n\n\t\tdef cmd = toQueryString(qParams)\n\n\t\tapiPost(cmd) { response ->\n\t\t\tdef status = response.data.gip.rc\n\n\t\t\t//sendNotificationEvent(\"Get token status ${status}\")\n\n\t\t\tif (status != \"200\") {//success code = 200\n\t\t\t\tdef errorText = response.data.gip.error\n\t\t\t\tdebugOut \"Error logging into TCP Gateway. Error = ${errorText}\"\n\t\t\t\tatomicState.token = \"error\"\n\t\t\t} else {\n\t\t\t\tatomicState.token = response.data.gip.token\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.warn \"Unable to log into TCP Gateway. Error = Password is null\"\n\t\tatomicState.token = \"error\"\n\t}\n}\n\ndef apiPost(String data, Closure callback) {\n\t//debugOut \"In apiPost with data: ${data}\"\n\tdef params = [\n\t\turi: apiUrl(),\n\t\tbody: data\n\t]\n\n\thttpPost(params) {\n\t\tresponse ->\n\t\t\tdef rc = response.data.gip.rc\n\n\t\t\tif ( rc == \"200\" ) {\n\t\t\t\tdebugOut (\"Return Code = ${rc} = Command Succeeded.\")\n\t\t\t\tcallback.call(response)\n\n\t\t\t} else if ( rc == \"401\" ) {\n\t\t\t\tdebugOut \"Return Code = ${rc} = Error: User not logged in!\" //Error code from gateway\n\t\t\t\tlog.debug \"Refreshing Token\"\n\t\t\t\tgetToken()\n\t\t\t\t//callback.call(response) //stubbed out so getToken works (we had race issue)\n\n\t\t\t} else {\n\t\t\t\tlog.error \"Return Code = ${rc} = Error!\" //Error code from gateway\n\t\t\t\tsendNotificationEvent(\"TCP Lighting is having Communication Errors. Error code = ${rc}. Check that TCP Gateway is online\")\n\t\t\t\tcallback.call(response)\n\t\t\t}\n\t}\n}\n\n\n//this is not working. TCP power reporting is broken. Leave it here for future fix\ndef calculateCurrentPowerUse(deviceCapability, usePercentage) {\n\tdebugOut \"In calculateCurrentPowerUse()\"\n\n\tdebugOut \"deviceCapability: ${deviceCapability}\"\n\tdebugOut \"usePercentage: ${usePercentage}\"\n\n\tdef calcPower = usePercentage * 1000\n\tdef reportPower = calcPower.round(1) as String\n\n\tdebugOut \"report power = ${reportPower}\"\n\n\treturn reportPower\n}\n\ndef generateSha256(String s) {\n\n\tMessageDigest digest = MessageDigest.getInstance(\"SHA-256\")\n\tdigest.update(s.bytes)\n\tnew BigInteger(1, digest.digest()).toString(16).padLeft(40, '0')\n}\n\ndef generateMD5(String s) {\n\tMessageDigest digest = MessageDigest.getInstance(\"MD5\")\n\tdigest.update(s.bytes);\n\tnew BigInteger(1, digest.digest()).toString(16).padLeft(32, '0')\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef checkDevicesOnline(bulbs) {\n\tdebugOut \"In checkDevicesOnline()\"\n\n\tdef onlineBulbs = []\n\tdef thisBulb = []\n\n\tbulbs.each {\n\t\tdef dni = it?.did\n\t\tthisBulb = it\n\n\t\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did></gip>\"\n\n\t\tdef qParams = [\n\t\t\tcmd: \"DeviceGetInfo\",\n\t\t\tdata: \"${data}\",\n\t\t\tfmt: \"json\"\n\t\t]\n\n\t\tdef cmd = toQueryString(qParams)\n\n\t\tdef bulbData = []\n\n\t\tapiPost(cmd) { response ->\n\t\t\tbulbData = response.data.gip\n\t\t}\n\n\t\tif ( bulbData?.offline == \"1\" ) {\n\t\t\tdebugOut \"${it?.name} is offline with offline value of ${bulbData?.offline}\"\n\n\t\t} else {\n\t\t\tdebugOut \"${it?.name} is online with offline value of ${bulbData?.offline}\"\n\t\t\tonlineBulbs += thisBulb\n\t\t}\n\t}\n\treturn onlineBulbs\n}\n\ndef syncronizeDevices() {\n\tdebugOut \"In syncronizeDevices\"\n\n\tdef update = getChildDevices().findAll { selectedBulbs?.contains(it.deviceNetworkId) }\n\n\tupdate.each {\n\t\tdef dni = getChildDevice( it.deviceNetworkId )\n\t\tdebugOut \"dni = ${dni}\"\n\n\t\tif (isRoom(dni)) {\n\t\t\tpollRoom(dni)\n\t\t} else {\n\t\t\tpoll(dni)\n\t\t}\n\t}\n}\n\nboolean isRoom(dni) {\n\tdef device = state.devices.find() {(( it.type == 'room') && (it.did == \"${dni}\"))}\n}\n\nboolean isBulb(dni) {\n\tdef device = state.devices.find() {(( it.type == 'bulb') && (it.did == \"${dni}\"))}\n}\n\ndef debugEvent(message, displayEvent) {\n\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent (results)\n\n}\n\ndef debugOut(msg) {\n\t//log.debug msg\n\t//sendNotificationEvent(msg) //Uncomment this for troubleshooting only\n}\n\n\n/**************************************************************************\n Child Device Call In Methods\n **************************************************************************/\ndef on(childDevice) {\n\tdebugOut \"On request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><rid>${dni}</rid><type>power</type><value>1</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><did>${dni}</did><type>power</type><value>1</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"ON result: ${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\ndef off(childDevice) {\n\tdebugOut \"Off request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><rid>${dni}</rid><type>power</type><value>0</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><did>${dni}</did><type>power</type><value>0</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\ndef setLevel(childDevice, value) {\n\tdebugOut \"setLevel request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><rid>${dni}</rid><type>level</type><value>${value}</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did><type>level</type><value>${value}</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\n// Really not called from child, but called from poll() if it is a room\ndef pollRoom(dni) {\n\tdebugOut \"In pollRoom\"\n\tdef data = \"\"\n\tdef cmd = \"\"\n\tdef roomDeviceData = []\n\n\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><rid>${dni}</rid><fields>name,power,control,status,state</fields></gip>\"\n\tcmd = \"RoomGetDevices\"\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\troomDeviceData = response.data.gip\n\t}\n\n\tdebugOut \"Room Data: ${roomDeviceData}\"\n\n\tdef totalPower = 0\n\tdef totalLevel = 0\n\tdef cnt = 0\n\tdef onCnt = 0 //used to tally on/off states\n\n\troomDeviceData.device.each({\n\t\tif ( getChildDevice(it.did) ) {\n\t\t\ttotalPower += it.other.bulbpower.toInteger()\n\t\t\ttotalLevel += it.level.toInteger()\n\t\t\tonCnt += it.state.toInteger()\n\t\t\tcnt += 1\n\t\t}\n\t})\n\n\tdef avgLevel = totalLevel/cnt\n\tdef usingPower = totalPower * (avgLevel / 100) as float\n\tdef room = getChildDevice( dni )\n\n\t//the device is a room but we use same type file\n\tsendEvent( dni, [name: \"setBulbPower\",value:\"${totalPower}\"] ) //used in child device calcs\n\n\t//if all devices in room are on, room is on\n\tif ( cnt == onCnt ) { // all devices are on\n\t\tsendEvent( dni, [name: \"switch\",value:\"on\"] )\n\t\tsendEvent( dni, [name: \"power\",value:usingPower.round(1)] )\n\n\t} else { //if any device in room is off, room is off\n\t\tsendEvent( dni, [name: \"switch\",value:\"off\"] )\n\t\tsendEvent( dni, [name: \"power\",value:0.0] )\n\t}\n\n\tdebugOut \"Room Using Power: ${usingPower.round(1)}\"\n}\n\ndef poll(childDevice) {\n\tdebugOut \"In poll() with ${childDevice}\"\n\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tdef bulbData = []\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tpollRoom(dni)\n\t\treturn\n\t}\n\n\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did></gip>\"\n\tcmd = \"DeviceGetInfo\"\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tbulbData = response.data.gip\n\t}\n\n\tdebugOut \"This Bulbs Data Return = ${bulbData}\"\n\n\tdef bulb = getChildDevice( dni )\n\n\t//set the devices power max setting to do calcs within the device type\n\tif ( bulbData.other.bulbpower )\n\t\tsendEvent( dni, [name: \"setBulbPower\",value:\"${bulbData.other.bulbpower}\"] )\n\n\tif (( bulbData.state == \"1\" ) && ( bulb?.currentValue(\"switch\") != \"on\" ))\n\t\tsendEvent( dni, [name: \"switch\",value:\"on\"] )\n\n\tif (( bulbData.state == \"0\" ) && ( bulb?.currentValue(\"switch\") != \"off\" ))\n\t\tsendEvent( dni, [name: \"switch\",value:\"off\"] )\n\n\t//if ( bulbData.level != bulb?.currentValue(\"level\")) {\n\t//\tsendEvent( dni, [name: \"level\",value: \"${bulbData.level}\"] )\n\t//    sendEvent( dni, [name: \"setLevel\",value: \"${bulbData.level}\"] )\n\t//}\n\n\tif (( bulbData.state == \"1\" ) && ( bulbData.other.bulbpower )) {\n\t\tdef levelSetting = bulbData.level as float\n\t\tdef bulbPowerMax = bulbData.other.bulbpower as float\n\t\tdef calculatedPower = bulbPowerMax * (levelSetting / 100)\n\t\tsendEvent( dni, [name: \"power\", value: calculatedPower.round(1)] )\n\t}\n\n\tif (( bulbData.state == \"0\" ) && ( bulbData.other.bulbpower ))\n\t\tsendEvent( dni, [name: \"power\", value: 0.0] )\n}",
        "docstring": "Connect your TCP bulbs to SmartThings using Cloud to Cloud integration. You must create a remote login acct on TCP Mobile App."
    },
    {
        "code": "def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\n/**\n * The updated event will be pushed to a WeatherBug Home Service to notify the system to take appropriate action.\n * Data that will be sent includes the list of devices, and location data\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    log.debug \"Updated with state: ${state}\"\n\tlog.debug \"Updated with location ${location} ${location.id} ${location.name}\"\n    unsubscribe()\n    initialize()\n\tdef postParams = [\n\t\turi: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive/smartapp/update',\n\t\tbody:  [ \n\t\t\t\"Devices\": devices, \n\t\t\t\"Location\":[\n\t\t\t\t\"Id\": location.id, \n\t\t\t\t\"Latitude\":location.latitude,\n\t\t\t\t\"Longitude\":location.longitude,\n\t\t\t\t\"ZipCode\":location.zipCode,\n\t\t\t\t\"Name\":location.name\n\t\t\t]\n\t   ]\n    ]\n    sendToWeatherBug(postParams)\n}\n\n/*\n* Subscribe to changes on the thermostat attributes\n*/\ndef initialize() {\n\tlog.trace \"initialize enter\"\n    subscribe(thermostatDevice, \"heatingSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"coolingSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatMode\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatFanMode\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatOperatingState\", pushLatest)\n    subscribe(thermostatDevice, \"temperature\", pushLatest)\n}\n\n/**\n * The uninstall event will be pushed to a WeatherBug Home Service to notify the system to take appropriate action.\n * Data that will be sent includes the list of devices, and location data\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef uninstalled() {\n\tlog.trace \"uninstall entered\"\n    def postParams = [\n    \turi: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive/smartapp/delete',\n        body:  [ \n        \t\"Devices\": devices, \n            \"Location\":[\n                \"Id\": location.id, \n                \"Latitude\":location.latitude,\n                \"Longitude\":location.longitude,\n                \"ZipCode\":location.zipCode,\n                \"Name\":location.name\n            ]\n       ]\n    ]\n    sendToWeatherBug(postParams)\n}\n\n/**\n * This method will push the latest thermostat data to the WeatherBug Home Service so it can store\n * and display the data to the WeatherBug user.  Data pushed includes the thermostat data as well\n * as location id.\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef pushLatest(evt) {\n\tdef unixTime = (int)((new Date().getTime() / 1000))\n    def device = thermostatDevice.find{ it.id == evt.deviceId}\n    def postParams = [\n        uri: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive',\n        body: [\n        \tDeviceId: evt.deviceId, \n            LocationId: location.id,\n            ReportType: 2, \n            ReportList: [ \n        \t\t[Key: \"Temperature\", Value: GetOrDefault(device, \"temperature\")], \n                [Key: \"ThermostatSetpoint\", Value: GetOrDefault(device, \"thermostatSetpoint\")],\n        \t\t[Key: \"CoolingSetpoint\", Value: GetOrDefault(device, \"coolingSetpoint\")],\n        \t\t[Key: \"HeatingSetpoint\", Value: GetOrDefault(device, \"heatingSetpoint\")],\n                [Key: \"ThermostatMode\", Value: GetOrDefault(device, \"thermostatMode\")],\n                [Key: \"ThermostatFanMode\", Value: GetOrDefault(device, \"thermostatFanMode\")],\n                [Key: \"ThermostatOperatingState\", Value: GetOrDefault(device, \"thermostatOperatingState\")]\n        \t], \n            UnixTime: unixTime\n        ]\n    ]\n    log.debug postParams\n    sendToWeatherBug(postParams)\n}\n\n/*\n* This method attempts to get the value of a device attribute, but if an error occurs null is returned\n* @return The device attribute value, or null\n*/\ndef GetOrDefault(device, attrib)\n{\n\tdef val\n \ttry{\n    \tval = device.latestValue(attrib)\n    \n    }catch(ex)\n    {\n        log.debug \"Failed to get attribute \" + attrib + \" from device \" + device\n        val = null\n    }\n    return val\n}\n\n/*\n* Convenience method that sends data to WeatherBug, logging any exceptions that may occur\n* Privacy Policy: http://weatherbughome.com/privacy/\n*/\ndef sendToWeatherBug(postParams)\n{\n \ttry{\n    \tlog.debug postParams\n        httpPostJson(postParams) { resp ->\n        \tresp.headers.each {\n           log.debug \"${it.name} : ${it.value}\"\n        }\n        log.debug \"response contentType: ${resp.contentType}\"\n        log.debug \"response data: ${resp.data}\"\n        }\n        log.debug \"Communication with WeatherBug succeeded\";\n    \n    }catch(ex)\n    {\n        log.debug \"Communication with WeatherBug failed.\\n${ex}\";\n    }\n}",
        "docstring": "WeatherBug Home"
    }
]