[
    {
        "code": "}\n}\n\ndef configurations()\n{\n\tdynamicPage(name: \"configurations\", title: \"Configurations...\", uninstall: true, nextPage: \"options\")\n    \t{\n\t\tsection(title: \"Turn ON lights on movement when...\")\n        \t{\n\t\t\tinput \"dark\", \"bool\", title: \"It is dark?\", required: true\n            input \"sun\", \"bool\", title: \"Between sunset and surise?\", required: true\n\t\t\t}\n\t\tsection(title: \"More options...\", hidden: hideOptionsSection(), hideable: true)\n        \t{\n\t\t\tdef timeLabel = timeIntervalLabel()\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time:\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : null\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week:\", multiple: true, required: false, options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tinput \"modes\", \"mode\", title: \"Only when mode is:\", multiple: true, required: false\n\t\t\t}\n\t\tsection (\"Assign a name\")\n        \t{\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\t}\n\t\t}\n}\n\ndef options()\n{\n\tif (dark == true && sun == true)\n    \t{\n\t\tdynamicPage(name: \"options\", title: \"Lights will turn ON on movement when it is dark and between sunset and sunrise...\", install: true, uninstall: true)\n    \t\t{\n\t\t\tsection(\"Control these light(s)...\")\n    \t\t\t{\n\t\t\t\tinput \"lights\", \"capability.switch\", title: \"Light(s)?\", multiple: true, required: false\n    \t\t\t}    \n    \t\tsection(\"Control these dimmer(s)...\")\n    \t\t\t{ \n        \t\tinput \"dimmers\", \"capability.switchLevel\", title: \"Dimmer(s)?\", multiple: true, required:false\n        \t\tinput \"level\", \"number\", title: \"How bright?\", required:false, description: \"0% to 100%\"\n\t\t\t\t}\n\t\t\tsection(\"Turning ON when it's dark and there's movement...\")\n    \t\t\t{\n\t\t\t\tinput \"motionSensor\", \"capability.motionSensor\", title: \"Where?\", multiple: true, required: true\n\t\t\t\t} \n\t\t\tsection(\"And then OFF when it's light or there's been no movement for...\")\n    \t\t\t{\n\t\t\t\tinput \"delayMinutes\", \"number\", title: \"Minutes?\", required: false\n\t\t\t\t}\n\t\t\tsection(\"Using this light sensor...\")\n    \t\t\t{\n\t\t\t\tinput \"lightSensor\", \"capability.illuminanceMeasurement\",title: \"Light Sensor?\", multiple: false, required: true\n        \t\tinput \"luxLevel\", \"number\", title: \"Illuminance threshold? (default 50 lux)\",defaultValue: \"50\", required: false\n\t\t\t\t}\n\t\t\tsection (\"And between sunset and sunrise...\")\n    \t\t\t{\n\t\t\t\tinput \"sunriseOffsetValue\", \"text\", title: \"Sunrise offset\", required: false, description: \"00:00\"\n\t\t\t\tinput \"sunriseOffsetDir\", \"enum\", title: \"Before or After\", required: false, metadata: [values: [\"Before\",\"After\"]]\n        \t\tinput \"sunsetOffsetValue\", \"text\", title: \"Sunset offset\", required: false, description: \"00:00\"\n\t\t\t\tinput \"sunsetOffsetDir\", \"enum\", title: \"Before or After\", required: false, metadata: [values: [\"Before\",\"After\"]]\n\t\t\t\t}\n\t\t\tsection (\"Zip code (optional, defaults to location coordinates when location services are enabled)...\")\n        \t\t{\n\t\t\t\tinput \"zipCode\", \"text\", title: \"Zip Code?\", required: false, description: \"Local Zip Code\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse if (dark == true && sun == false)\n    \t{\n    \tdynamicPage(name: \"options\", title: \"Lights will turn ON on movement when it is dark...\", install: true, uninstall: true)\n    \t\t{\n\t\t\tsection(\"Control these light(s)...\")\n    \t\t\t{\n\t\t\t\tinput \"lights\", \"capability.switch\", title: \"Light(s)?\", multiple: true, required: false\n    \t\t\t}    \n    \t\tsection(\"Control these dimmer(s)...\")\n    \t\t\t{ \n        \t\tinput \"dimmers\", \"capability.switchLevel\", title: \"Dimmer(s)?\", multiple: true, required:false\n        \t\tinput \"level\", \"number\", title: \"How bright?\", required:false, description: \"0% to 100%\"\n\t\t\t\t}\n\t\t\tsection(\"Turning ON when it's dark and there's movement...\")\n    \t\t\t{\n\t\t\t\tinput \"motionSensor\", \"capability.motionSensor\", title: \"Where?\", multiple: true, required: true\n\t\t\t\t} \n\t\t\tsection(\"And then OFF when it's light or there's been no movement for...\")\n    \t\t\t{\n\t\t\t\tinput \"delayMinutes\", \"number\", title: \"Minutes?\", required: false\n\t\t\t\t}\n\t\t\tsection(\"Using this light sensor...\")\n    \t\t\t{\n\t\t\t\tinput \"lightSensor\", \"capability.illuminanceMeasurement\",title: \"Light Sensor?\", multiple: false, required: true\n        \t\tinput \"luxLevel\", \"number\", title: \"Illuminance threshold? (default 50 lux)\",defaultValue: \"50\", required: false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    else if (sun == true && dark == false)\n    \t{\n    \tdynamicPage(name: \"options\", title: \"Lights will turn ON on movement between sunset and sunrise...\", install: true, uninstall: true)\n    \t\t{\n\t\t\tsection(\"Control these light(s)...\")\n    \t\t\t{\n\t\t\t\tinput \"lights\", \"capability.switch\", title: \"Light(s)?\", multiple: true, required: false\n    \t\t\t}    \n    \t\tsection(\"Control these dimmer(s)...\")\n    \t\t\t{ \n        \t\tinput \"dimmers\", \"capability.switchLevel\", title: \"Dimmer(s)?\", multiple: true, required:false\n        \t\tinput \"level\", \"number\", title: \"How bright?\", required:false, description: \"0% to 100%\"\n\t\t\t\t}\n\t\t\tsection(\"Turning ON there's movement...\")\n    \t\t\t{\n\t\t\t\tinput \"motionSensor\", \"capability.motionSensor\", title: \"Where?\", multiple: true, required: true\n\t\t\t\t} \n\t\t\tsection(\"And then OFF there's been no movement for...\")\n    \t\t\t{\n\t\t\t\tinput \"delayMinutes\", \"number\", title: \"Minutes?\", required: false\n\t\t\t\t}\n\t\t\tsection (\"Between sunset and sunrise...\")\n    \t\t\t{\n\t\t\t\tinput \"sunriseOffsetValue\", \"text\", title: \"Sunrise offset\", required: false, description: \"00:00\"\n\t\t\t\tinput \"sunriseOffsetDir\", \"enum\", title: \"Before or After\", required: false, metadata: [values: [\"Before\",\"After\"]]\n        \t\tinput \"sunsetOffsetValue\", \"text\", title: \"Sunset offset\", required: false, description: \"00:00\"\n\t\t\t\tinput \"sunsetOffsetDir\", \"enum\", title: \"Before or After\", required: false, metadata: [values: [\"Before\",\"After\"]]\n\t\t\t\t}\n\t\t\tsection (\"Zip code (optional, defaults to location coordinates when location services are enabled)...\")\n        \t\t{\n\t\t\t\tinput \"zipCode\", \"text\", title: \"Zip Code?\", required: false, description: \"Local Zip Code\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n    \t{\n    \tdynamicPage(name: \"options\", title: \"Lights will turn ON on movement...\", install: true, uninstall: true)\n    \t\t{\n\t\t\tsection(\"Control these light(s)...\")\n    \t\t\t{\n\t\t\t\tinput \"lights\", \"capability.switch\", title: \"Light(s)?\", multiple: true, required: false\n    \t\t\t}    \n    \t\tsection(\"Control these dimmer(s)...\")\n    \t\t\t{ \n        \t\tinput \"dimmers\", \"capability.switchLevel\", title: \"Dimmer(s)?\", multiple: true, required:false\n        \t\tinput \"level\", \"number\", title: \"How bright?\", required:false, description: \"0% to 100%\"\n\t\t\t\t}\n\t\t\tsection(\"Turning ON when there's movement...\")\n    \t\t\t{\n\t\t\t\tinput \"motionSensor\", \"capability.motionSensor\", title: \"Where?\", multiple: true, required: true\n\t\t\t\t} \n\t\t\tsection(\"And then OFF when there's been no movement for...\")\n    \t\t\t{\n\t\t\t\tinput \"delayMinutes\", \"number\", title: \"Minutes?\", required: false\n\t\t\t\t}\n\t\t\t}\n    \t}\n}\n\ndef installed()\n{\n\tlog.debug \"Installed with settings: ${settings}.\"\n\tinitialize()\n}\n\ndef updated()\n{\n\tlog.debug \"Updated with settings: ${settings}.\"\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize()\n{\n\tsubscribe(motionSensor, \"motion\", motionHandler)\n    if (lights != null && lights != \"\" && dimmers != null && dimmers != \"\")\n    \t{\n        log.debug \"$lights subscribing...\"\n    \tsubscribe(lights, \"switch\", lightsHandler)\n        log.debug \"$dimmers subscribing...\"\n    \tsubscribe(dimmers, \"switch\", dimmersHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$lights and $dimmers will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$lights and $dimmers will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$lights and $dimmers will turn ON when movement detected...\"\n            }\n    \t}\n    else if (lights != null && lights != \"\")\n    \t{\n        log.debug \"$lights subscribing...\"\n    \tsubscribe(lights, \"switch\", lightsHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$lights will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$lights will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$lights will turn ON when movement detected...\"\n            }\n    \t}\n\telse if (dimmers != null && dimmers != \"\")\n    \t{\n        log.debug \"$dimmers subscribing...\"\n    \tsubscribe(dimmers, \"switch\", dimmersHandler)\n        if (dark == true && lightSensor != null && lightSensor != \"\")\n    \t\t{\n        \tlog.debug \"$dimmers will turn ON when movement detected and when it is dark...\"\n\t\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t\t\t}\n\t\tif (sun == true)\n    \t\t{\n        \tlog.debug \"$dimmers will turn ON when movement detected between sunset and sunrise...\"\n\t\t\tastroCheck()\n        \tsubscribe(location, \"position\", locationPositionChange)\n            subscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n            subscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\t\t}\n        else if (dark != true && sun != true)\n            {\n            log.debug \"$dimmers will turn ON when movement detected...\"\n            }\n    \t}\n        log.debug \"Determinating lights and dimmers current value...\"\n        if (lights != null && lights != \"\")\n        \t{\n            if (lights.currentValue(\"switch\").toString().contains(\"on\"))\n                {\n                state.lightsState = \"on\"\n                log.debug \"Lights $state.lightsState.\"\n                }\n            else if (lights.currentValue(\"switch\").toString().contains(\"off\"))\n                {\n                state.lightsState = \"off\"\n                log.debug \"Lights $state.lightsState.\"\n                }\n            else\n                {\n                log.debug \"ERROR!\"\n                }\n\t\t\t}\n\t\tif (dimmers != null && dimmers != \"\")\n        \t{\n            if (dimmers.currentValue(\"switch\").toString().contains(\"on\"))\n                {\n                state.dimmersState = \"on\"\n                log.debug \"Dimmers $state.dimmersState.\"\n                }\n            else if (dimmers.currentValue(\"switch\").toString().contains(\"off\"))\n                {\n                state.dimmersState = \"off\"\n                log.debug \"Dimmers $state.dimmersState.\"\n                }\n            else\n                {\n                log.debug \"ERROR!\"\n                }\n\t\t\t}\n}\n            \ndef locationPositionChange(evt)\n{\n\tlog.trace \"locationChange()\"\n\tastroCheck()\n}\n\ndef sunriseSunsetTimeHandler(evt)\n{\n\tstate.lastSunriseSunsetEvent = now()\n\tlog.debug \"SmartNightlight.sunriseSunsetTimeHandler($app.id)\"\n\tastroCheck()\n}\n\ndef motionHandler(evt)\n{\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"active\")\n    \t{\n        unschedule(turnOffLights)\n    \tunschedule(turnOffDimmers)\n        if (dark == true && sun == true)\n        \t{\n            if (darkOk == true && sunOk == true)\n            \t{\n                log.debug \"Lights and Dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark or because $motionSensor detected motion between sunset and sunrise...\"\n                if (lights != null && lights != \"\")\n                    {\n                    log.debug \"Lights: $lights will turn ON...\"\n                    turnOnLights()\n                    }\n                if (dimmers != null && dimmers != \"\")\n                    {\n                    log.debug \"Dimmers: $dimmers will turn ON...\"\n                    turnOnDimmers()\n                    }\n\t\t\t\t}\n\t\t\telse if (darkOk == true && sunOk != true)\n            \t{\n                log.debug \"Lights and Dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark...\"\n                if (lights != null && lights != \"\")\n                    {\n                    log.debug \"Lights: $lights will turn ON...\"\n                    turnOnLights()\n                    }\n                if (dimmers != null && dimmers != \"\")\n                    {\n                    log.debug \"Dimmers: $dimmers will turn ON...\"\n                    turnOnDimmers()\n                    }\n\t\t\t\t}\n\t\t\telse if (darkOk != true && sunOk == true)\n            \t{\n                log.debug \"Lights and dimmers will turn ON because $motionSensor detected motion between sunset and sunrise...\"\n                if (lights != null && lights != \"\")\n                    {\n                    log.debug \"Lights: $lights will turn ON...\"\n                    turnOnLights()\n                    }\n                if (dimmers != null && dimmers != \"\")\n                    {\n                    log.debug \"Dimmers: $dimmers will turn ON...\"\n                    turnOnDimmers()\n                    }\n\t\t\t\t}\n\t\t\telse\n            \t{\n\t\t\t\tlog.debug \"Lights and dimmers will not turn ON because $lightSensor is too bright or because time not between sunset and surise.\"\n                }\n\t\t\t}\n\t\telse if (dark == true && sun != true)\n        \t{\n            if (darkOk == true)\n            \t{\n                log.debug \"Lights and dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark...\"\n                if (lights != null && lights != \"\")\n                    {\n                    log.debug \"Lights: $lights will turn ON...\"\n                    turnOnLights()\n                    }\n                if (dimmers != null && dimmers != \"\")\n                    {\n                    log.debug \"Dimmers: $dimmers will turn ON...\"\n                    turnOnDimmers()\n                    }\n\t\t\t\t}\n\t\t\telse\n            \t{\n\t\t\t\tlog.debug \"Lights and dimmers will not turn ON because $lightSensor is too bright.\"\n                }\n        \t}\n\t\telse if (dark != true && sun == true)\n        \t{\n            if (sunOk == true)\n            \t{\n                log.debug \"Lights and dimmers will turn ON because $motionSensor detected motion between sunset and sunrise...\"\n                if (lights != null && lights != \"\")\n                    {\n                    log.debug \"Lights: $lights will turn ON...\"\n                    turnOnLights()\n                    }\n                if (dimmers != null && dimmers != \"\")\n                    {\n                    log.debug \"Dimmers: $dimmers will turn ON...\"\n                    turnOnDimmers()\n                    }\n\t\t\t\t}\n\t\t\telse\n            \t{\n\t\t\t\tlog.debug \"Lights and dimmers will not turn ON because time not between sunset and surise.\"\n                }\n        \t}\n\t\telse if (dark != true && sun != true)\n        \t{\n            log.debug \"Lights and dimmers will turn ON because $motionSensor detected motion...\"\n            if (lights != null && lights != \"\")\n\t\t\t\t{\n\t\t\t\tlog.debug \"Lights: $lights will turn ON...\"\n\t\t\t\tturnOnLights()\n\t\t\t\t}\n\t\t\tif (dimmers != null && dimmers != \"\")\n            \t{\n\t\t\t\tlog.debug \"Dimmers: $dimmers will turn ON...\"\n\t\t\t\tturnOnDimmers()\n\t\t\t\t}\n        \t}\n\t\t}\n\telse if (evt.value == \"inactive\")\n    \t{\n        unschedule(turnOffLights)\n    \tunschedule(turnOffDimmers)\n\t\tif (state.lightsState != \"off\" || state.dimmersState != \"off\")\n        \t{\n            log.debug \"Lights and/or dimmers are not OFF.\"\n\t\t\tif (delayMinutes)\n            \t{\n                def delay = delayMinutes * 60\n                if (dark == true && sun == true)\n                    {\n                    log.debug \"Lights and dimmers will turn OFF in $delayMinutes minute(s) after turning ON when dark or between sunset and sunrise...\"\n                    if (lights != null && lights != \"\")\n                        {\n                        log.debug \"Lights: $lights will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffLights)\n                        }\n                     if (dimmers != null && dimmers != \"\")\n                        {\n                        log.debug \"Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffDimmers)\n                        }\n                    }\n                else if (dark == true && sun != true)\n                    {\n                    log.debug \"Lights and dimmers will turn OFF in $delayMinutes minute(s) after turning ON when dark...\"\n                    if (lights != null && lights != \"\")\n                        {\n                        log.debug \"Lights: $lights will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffLights)\n                        }\n                     if (dimmers != null && dimmers != \"\")\n                        {\n                        log.debug \"Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffDimmers)\n                        }\n                    }\n                else if (dark != true && sun == true)\n                    {\n                    log.debug \"Lights and dimmers will turn OFF in $delayMinutes minute(s) between sunset and sunrise...\"\n                    if (lights != null && lights != \"\")\n                        {\n                        log.debug \"Lights: $lights will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffLights)\n                        }\n                     if (dimmers != null && dimmers != \"\")\n                        {\n                        log.debug \"Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffDimmers)\n                        }\n                    }\n                else if (dark != true && sun != true)\n                    {\n                    log.debug \"Lights and dimmers will turn OFF in $delayMinutes minute(s)...\"\n                    if (lights != null && lights != \"\")\n                        {\n                        log.debug \"Lights: $lights will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffLights)\n                        }\n                    if (dimmers != null && dimmers != \"\")\n                        {\n                        log.debug \"Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)...\"\n                        runIn(delay, turnOffDimmers)\n                        }\n                    }\n                }\n\t\t\telse\n        \t\t{\n        \t\tlog.debug \"Lights and dimmers will stay ON because no turn OFF delay was set...\"\n\t\t\t\t}\n            }\n\t\telse if (state.lightsState == \"off\" && state.dimmersState == \"off\")\n        \t{\n        \tlog.debug \"Lights and dimmers are already OFF and will not turn OFF in $delayMinutes minute(s).\"\n\t\t\t}\n\t\t}\n}\n\ndef lightsHandler(evt)\n{\n\tlog.debug \"Lights Handler $evt.name: $evt.value\"\n    if (evt.value == \"on\")\n    \t{\n        log.debug \"Lights: $lights now ON.\"\n        unschedule(turnOffLights)\n        state.lightsState = \"on\"\n        }\n\telse if (evt.value == \"off\")\n    \t{\n        log.debug \"Lights: $lights now OFF.\"\n        unschedule(turnOffLights)\n        state.lightsState = \"off\"\n        }\n}\n\ndef dimmersHandler(evt)\n{\n\tlog.debug \"Dimmer Handler $evt.name: $evt.value\"\n    if (evt.value == \"on\")\n    \t{\n        log.debug \"Dimmers: $dimmers now ON.\"\n        unschedule(turnOffDimmers)\n        state.dimmersState = \"on\"\n        }\n\telse if (evt.value == \"off\")\n    \t{\n        log.debug \"Dimmers: $dimmers now OFF.\"\n        unschedule(turnOffDimmers)\n        state.dimmersState = \"off\"\n        }\n}\n\ndef illuminanceHandler(evt)\n{\n\tlog.debug \"$evt.name: $evt.value, lastStatus lights: $state.lightsState, lastStatus dimmers: $state.dimmersState, motionStopTime: $state.motionStopTime\"\n\tunschedule(turnOffLights)\n    unschedule(turnOffDimmers)\n    if (evt.integerValue > 999)\n    \t{\n        log.debug \"Lights and dimmers will turn OFF because illuminance is superior to 999 lux...\"\n        if (lights != null && lights != \"\")\n\t\t\t{\n\t\t\tlog.debug \"Lights: $lights will turn OFF...\"\n\t\t\tturnOffLights()\n\t\t\t}\n\t\tif (dimmers != null && dimmers != \"\")\n\t\t\t{\n\t\t\tlog.debug \"Dimmers: $dimmers will turn OFF...\"\n\t\t\tturnOffDimmers()\n\t\t\t}\n\t\t}\n\telse if (evt.integerValue > ((luxLevel != null && luxLevel != \"\") ? luxLevel : 50))\n\t\t{\n\t\tlog.debug \"Lights and dimmers will turn OFF because illuminance is superior to $luxLevel lux...\"\n        if (lights != null && lights != \"\")\n\t\t\t{\n\t\t\tlog.debug \"Lights: $lights will turn OFF...\"\n\t\t\tturnOffLights()\n\t\t\t}\n\t\tif (dimmers != null && dimmers != \"\")\n\t\t\t{\n\t\t\tlog.debug \"Dimmers: $dimmers will turn OFF...\"\n\t\t\tturnOffDimmers()\n\t\t\t}\n\t\t}\n}\n\ndef turnOnLights()\n{\n\tif (allOk)\n    \t{\n        if (state.lightsState != \"on\")\n            {\n            log.debug \"Turning ON lights: $lights...\"\n            lights?.on()\n            state.lightsState = \"on\"\n            }\n        else\n            {\n            log.debug \"Lights: $lights already ON.\"\n            }\n\t\t}\n\telse\n    \t{\n        log.debug \"Time, days of the week or mode out of range! $lights will not turn ON.\"\n        }\n}\n\ndef turnOnDimmers()\n{\n\tif (allOk)\n    \t{\n        if (state.dimmersState != \"on\")\n            {\n            log.debug \"Turning ON dimmers: $dimmers...\"\n            settings.dimmers?.setLevel(level)\n            state.dimmersState = \"on\"\n            }\n        else\n            {\n            log.debug \"Dimmers: $dimmers already ON.\"\n            }\n\t\t}\n\telse\n    \t{\n        log.debug \"Time, days of the week or mode out of range! $dimmers will not turn ON.\"\n        }\n}\n\n\ndef turnOffLights()\n{\n\tif (allOk)\n    \t{\n        if (state.lightsState != \"off\")\n            {\n            log.debug \"Turning OFF lights: $lights...\"\n            lights?.off()\n            state.lightsState = \"on\"\n            }\n        else\n            {\n            log.debug \"Lights: $lights already OFF.\"\n            }\n\t\t}\n\telse\n    \t{\n        log.debug \"Time, day of the week or mode out of range! $lights will not turn OFF.\"\n        }\n}\n\ndef turnOffDimmers()\n{\n\tif (allOk)\n    \t{\n        if (state.dimmersState != \"off\")\n            {\n            log.debug \"Turning OFF dimmers: $dimmers...\"\n            dimmers?.off()\n            state.dimmersState = \"off\"\n            }\n        else\n            {\n            log.debug \"Dimmers: $dimmers already OFF.\"\n            }\n\t\t}\n\telse\n    \t{\n        log.debug \"Time, day of the week or mode out of range! $dimmers will not turn OFF.\"\n        }\n}\n\ndef astroCheck()\n{\n\tdef s = getSunriseAndSunset(zipCode: zipCode, sunriseOffset: sunriseOffset, sunsetOffset: sunsetOffset)\n\tstate.riseTime = s.sunrise.time\n\tstate.setTime = s.sunset.time\n\tlog.debug \"Sunrise: ${new Date(state.riseTime)}($state.riseTime), Sunset: ${new Date(state.setTime)}($state.setTime)\"\n}\n\nprivate getDarkOk()\n{\n\tdef result\n\tif (dark == true && lightSensor != null && lightSensor != \"\")\n        {\n\t\tresult = lightSensor.currentIlluminance < ((luxLevel != null && luxLevel != \"\") ? luxLevel : 50)\n\t\t}\n\tlog.trace \"darkOk = $result\"\n\tresult\n}\n\nprivate getSunOk()\n{\n\tdef result\n\tif (sun == true)\n    \t{\n\t\tdef t = now()\n\t\tresult = t < state.riseTime || t > state.setTime\n\t\t}\n\tlog.trace \"sunOk = $result\"\n\tresult\n}\n\nprivate getSunriseOffset()\n{\n\tsunriseOffsetValue ? (sunriseOffsetDir == \"Before\" ? \"-$sunriseOffsetValue\" : sunriseOffsetValue) : null\n}\n\nprivate getSunsetOffset()\n{\n\tsunsetOffsetValue ? (sunsetOffsetDir == \"Before\" ? \"-$sunsetOffsetValue\" : sunsetOffsetValue) : null\n}\n\nprivate getAllOk()\n{\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk()\n{\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk()\n{\n\tdef result = true\n\tif (days)\n    \t{\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone)\n        \t{\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t\t}\n\t\telse\n        \t{\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk()\n{\n\tdef result = true\n\tif (starting && ending)\n    \t{\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate hideOptionsSection()\n{\n\t(starting || ending || days || modes) ? false : true\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}",
        "docstring": "Turn ON light(s) and/or dimmer(s) when there's movement and the room is dark with illuminance threshold and/or between sunset and sunrise. Then turn OFF after X minute(s) when the brightness of the room is above the illuminance threshold or turn OFF after X minute(s) when there is no movement."
    },
    {
        "code": "section(\"When I touch the app turn these lights on…\"){\n\t\tinput \"switcheson\", \"capability.switch\", multiple: true, required:false\n\t}\n    section(\"Lock theses locks...\") {\n\t\tinput \"lock1\",\"capability.lock\", multiple: true\n    }\n\tsection(\"And change to this mode...\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n   section(\"After so many seconds (optional)\"){\n\t\tinput \"waitfor\", \"number\", title: \"Off after (default 120)\", required: true\n\t}\n}\n\n\ndef installed()\n{\n\tlog.debug \"Installed with settings: ${settings}\"\n\tlog.debug \"Current mode = ${location.mode}\"\n\tsubscribe(app, appTouch)\n}\n\n\ndef updated()\n{\n\tlog.debug \"Updated with settings: ${settings}\"\n\tlog.debug \"Current mode = ${location.mode}\"\n\tunsubscribe()\n\tsubscribe(app, appTouch)\n}\n\ndef appTouch(evt) {\n\tlog.debug \"changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes\"\n    if (location.mode != newMode) {\n   \t\t\tsetLocationMode(newMode)\n\t\t\tlog.debug \"Changed the mode to '${newMode}'\"\n    }\telse {\n    \tlog.debug \"New mode is the same as the old mode, leaving it be\"\n    \t}\n    log.debug \"appTouch: $evt\"\n    lock1.lock()\n    switcheson.on()\n    def delay = (waitfor != null && waitfor != \"\") ? waitfor * 1000 : 120000\n\tswitchesoff.off(delay: delay)\n}",
        "docstring": "Some on, some off with delay for bedtime, Lock The Doors"
    },
    {
        "code": "section(\"Which doors and windows should I check?\"){\n\t\t\tinput \"doors\", \"capability.contactSensor\", multiple: true\n        }\n        \n\t\tsection(\"Which light switches will I be turning off?\") {\n\t\t\tinput \"theSwitches\", \"capability.switch\", Title: \"Which?\", multiple: true, required: false\n            input \"minutes\", \"number\", Title: \"After how many minutes?\", required: true\n\t\t}\n    \tsection(\"Should I say 'Goodnight' to Hello Home?\") {\n        \tinput \"sayPhrase\", \"enum\", metadata:[values:[\"Yes\",\"No\"]]\n        }\n}\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\ninitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(trigger, \"switch.on\", switchOnHandler)\t\t\t\t// User should set up on Ubi that when the choosen\n}    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// trigger is said, Ubi turns on this virtual switch.\n\ndef switchOnHandler(evt) {\n    log.debug \"trigger turned on!\"\n    \n    def timeDelay = minutes * 60\t\t\t\t\t\t\t\t\t// convert minutes to seconds.\n    runIn (timeDelay, lightsOut)\t\t\t\t\t\t\t\t\t// schedule the lights out procedure\n\n\tdef phrase = \"\"\t\t\t\t\t\t\t\t\t\t\t\t\t// Make sure Phrase is empty at the start of each run.\n\n    doors.each { doorOpen ->\t\t\t\t\t\t\t\t\t\t// cycles through all contact sensor devices selected\n    \tif (doorOpen.currentContact == \"open\") {\t\t\t\t\t// if the current selected device is open, then:\n            log.debug \"$doorOpen.displayName\"\t\t\t\t\t\t// echo to the simulator the device's name\n    \t\tdef toReplace = doorOpen.displayName\t\t\t\t\t// make variable 'toReplace' = the devices name.\n\t\t\tdef replaced = toReplace.replaceAll(' ', '%20')\t\t\t// make variable 'replaced' = 'toReplace' with all the space changed to %20\n\t\t\tlog.debug replaced\t\t\t\t\t\t\t\t\t\t// echo to the simulator the new name.\n            \n            phrase = phrase.replaceAll('%20And%20', '%20')\t\t\t// Remove any previously added \"and's\" to make it sound natural.\n\n\t\t\tif (phrase == \"\") {\t\t\t\t\t\t\t\t\t\t// If Phrase is empty (ie, this is the first name to be added)...\n            \tphrase = \"The%20\" + replaced \t\t\t\t\t\t// ...then add \"The%20\" plus the device name.\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t// If Phrase isn't empty...\n            \tphrase = phrase + \",%20And%20The%20\" + replaced\t\t// ...then add \",%20And%20The%20\".\n\t\t\t}\n            \n            log.debug phrase  \t\t\t\t\t\t\t\t\t\t// Echo the current version of 'Phrase'            \n        }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Closes the IF statement.\n    }    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Closes the doors.each cycle\n    \t\n    if (phrase == \"\") {\n    \tphrase = \"The%20house%20is%20ready%20for%20night.\"\n    \t}\n    else {\n    \tphrase = \"You%20have%20left%20\" + phrase + \"open\"\n    }\n    \n    httpGet(\"https://portal.theubi.com/webapi/behaviour?access_token=${behaviorToken}&variable=${phrase}\")\n          \t\t\t\t// send the http request and push the device name (replaced) as the variable.\n\t\t\t\t\t\t// On the Ubi side you need to setup a custom behavior (which you've already done to get the token)\n                        // and have say something like: \"Hold on!  The ${variable} is open!\"  Ubi will then take 'replaced'\n                        // from this http request and insert it into the phrase that it says.\n    \t    \n\tif (sayPhrase == \"Yes\") {\t\t\t\t\t\t\t\t\t\t// If the user selected to say Goodnight...\n        location.helloHome.execute(\"Good Night!\")\t\t\t\t\t// ...say goodnight to Hello Home.\n    }\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Close the switchOnHandler Process\n\ndef lightsOut() {\n\tlog.debug \"Turning off trigger\"\n\ttrigger.off()\t\t\t\t\t\t\t\t\t\t\t\t\t// Turn off the trigger tile button for next run\n\tif (theSwitches == \"\") {} else {\t\t\t\t\t\t\t\t// If the user didn't enter any light to turn off, do nothing...\n\t    log.debug \"Turning off switches\"\t\t\t\t\t\t\t// ...but if the user did enter lights, then turn them\n\t\ttheSwitches.off()\t\t\t\t\t\t\t\t\t\t\t// off here.\n    }\n}",
        "docstring": "An app to coordinate bedtime activities between Ubi and SmartThings.  This app will activate when a Virtual Tile is triggers (Setup custom behavior in Ubi to turn on this tile when you say goodnight to ubi).  This app will then turn off selected lights after a specified number of minutes.  It will also check if any doors or windows are open.  If they are, Ubi will tell you which ones are open.  Finally, the app will say goodnight to hello home if requested."
    },
    {
        "code": "section(\"Jenkins Username\") {\n        input \"jenkinsUsername\", \"text\", title: \"Jenkins Username\"\n    }\n    section(\"Jenkins Password\") {\n        input \"jenkinsPassword\", \"password\", title: \"Jenkins Password\"\n    }\n    section(\"On Failed Build Turn On...\") {\n        input \"switches\", \"capability.switch\", multiple: true, required: false\n    }\n    section(\"Or Change These Bulbs...\") {\n        input \"hues\", \"capability.colorControl\", title: \"Which Hue Bulbs?\", required: false, multiple: true\n        input \"colorSuccess\", \"enum\", title: \"Hue Color On Success?\", required: false, multiple: false, options: getHueColors().keySet() as String[]\n        input \"colorFail\", \"enum\", title: \"Hue Color On Fail?\", required: false, multiple: false, options: getHueColors().keySet() as String[]\n        input \"lightLevelSuccess\", \"number\", title: \"Light Level On Success?\", required: false\n        input \"lightLevelFail\", \"number\", title: \"Light Level On Fail?\", required: false\n    }\n    section(\"Additional settings\", hideable: true, hidden: true) {\n        paragraph(\"Default check time is 15 Minutes\")\n        input \"refreshInterval\", \"decimal\", title: \"Check Server... (minutes)\",\n                description: \"Enter time in minutes\", defaultValue: 15, required: false\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\n/** Constants for Hue Colors */\nMap getHueColors() {\n    return [Red: 0, Green: 39, Blue: 70, Yellow: 25, Orange: 10, Purple: 75, Pink: 83]\n}\n\n/** Constant for Saturation */\nint getSaturation() {\n    return 100;\n}\n\n/** Constant for Level */\nint getMaxLevel() {\n    return 100;\n}\n\ndef initialize() {\n    def successColor = [switch: \"on\", hue: getHueColors()[colorSuccess], saturation: getSaturation(), level: lightLevelSuccess ?: getMaxLevel()]\n    def failColor = [switch: \"on\", hue: getHueColors()[colorFail], saturation: getSaturation(), level: lightLevelFail ?: getMaxLevel()]\n    state.successColor = successColor\n    state.failColor = failColor\n    log.debug \"successColor: ${successColor}, failColor: ${failColor}\"\n    \n    checkServer()\n    \n    def cron = \"* */${refreshInterval ?: 15} * * * ?\"\n    schedule(cron, checkServer)\n}\n\ndef checkServer() {\n    log.debug \"Checking Server Now\"\n\n\tdef successColor = state.successColor\n    def failColor = state.failColor\n\n    def basicCredentials = \"${jenkinsUsername}:${jenkinsPassword}\"\n    def encodedCredentials = basicCredentials.encodeAsBase64().toString()\n    def basicAuth = \"Basic ${encodedCredentials}\"\n\n    def head = [\"Authorization\": basicAuth]\n\n    log.debug \"Auth ${head}\"\n\n\tdef host = jenkinsUrl.contains(\"lastBuild/api/json\") ? jenkinsUrl : \"${jenkinsUrl}/lastBuild/api/json\"\n\n    httpGet(uri: host, headers: [\"Authorization\": \"${basicAuth}\"]) { resp ->\n    \tdef buildError = (resp.data.result == \"FAILURE\")\n        def buildSuccess = (resp.data.result == \"SUCCESS\")\n        log.debug \"Build Success? ${buildSuccess}\"\n        if (buildError) {\n            switches?.on()\n            hues?.setColor(failColor)\n        } else if (buildSuccess) {\n            switches?.off()\n            hues?.setColor(successColor)\n        } // else in some other state, probably building, do nothing.\n\n    }\n}",
        "docstring": "Turn off and on devices based on the state that your Jenkins Build is in."
    },
    {
        "code": "}\n    page(name: \"instructionPage\", title: \"Device Discovery\", install: true) {\n        section() {\n            paragraph \"Now the process is complete return to the Devices section of the Detected Screen. From there and you can add actions to each of your device panels, including launching SmartThings routines.\"\n        }\n    }\n}\n\nmappings {\n  path(\"/structureinfo\") {\n    action: [\n      GET: \"structureInfo\"\n    ]\n  }\n  path(\"/helloactions\") {\n    action: [\n      GET: \"helloActions\"\n    ]\n  }\n  path(\"/helloactions/:label\") {\n    action: [\n      PUT: \"executeAction\"\n    ]\n  }\n\n  path(\"/switch/:id/:command\") {\n    action: [\n      PUT: \"updateSwitch\"\n    ]\n  }\n\n  path(\"/thermostat/:id/:command\") {\n    action: [\n      PUT: \"updateThermostat\"\n    ]\n  }\n\n  path(\"/windowshade/:id/:command\") {\n    action: [\n      PUT: \"updateWindowShade\"\n    ]\n  }\n  path(\"/acquiredata/:id\") {\n    action: [\n      GET: \"acquiredata\"\n    ]\n  }\n}\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// subscribe to attributes, devices, locations, etc.\n}\ndef helloActions() {\n\tdef actions = location.helloHome?.getPhrases()*.label\n    if(!actions) {\n    \treturn []\n    }\n\treturn actions\n}\ndef executeAction() {\n    def actions = location.helloHome?.getPhrases()*.label\n    def a = actions?.find() { it == params.label }\n    if (!a) {\n        httpError(400, \"invalid label $params.label\")\n        return\n    }\n    location.helloHome?.execute(params.label)\n}\n/*  this is the primary function called to query at the structure and its devices */\ndef structureInfo() { //list all devices\n\tdef list = [:]\n    def currId = location.id\n    list[currId] = [:]\n    list[currId].name = location.name\n    list[currId].id = location.id\n    list[currId].temperatureScale = location.temperatureScale\n    list[currId].devices = [:]\n  \n    def setValues = {\n   \t\tif (params.brief) {\n            return [id: it.id, name: it.displayName]\n        }\n        def newList = [id: it.id, name: it.displayName, suppCapab: it.capabilities.collect {\n            \"$it.name\"\n        }, suppAttributes: it.supportedAttributes.collect {\n            \"$it.name\"      \n        }, suppCommands: it.supportedCommands.collect {\n            \"$it.name\"      \n        }]\n\n        return newList\n    }\n    switches?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n    thermostats?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n    windowShades?.each {\n      list[currId].devices[it.id] = setValues(it)\n    }\n\n    return list\n\n}\n/*  This function returns all of the current values of the specified Devices attributes */\ndef acquiredata() {\n\tdef resp = [:]\n    if (!params.id) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def dev = switches.find() { it.id == params.id } ?: windowShades.find() { it.id == params.id } ?:\n    \tthermostats.find() { it.id == params.id }    \n   \n    if (!dev) {\n    \thttpError(400, \"invalid id $params.id\")\n        return    \n    }\n    def att = dev.supportedAttributes\n    att.each {\n    \tresp[it.name] = dev.currentValue(\"$it.name\")\n    }\n    return resp\n}\n\nvoid updateSwitch() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef sw = switches.find() { it.id == params.id }\n    if (!sw) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    switch(command) {\n        case \"on\":\n        \tif ( sw.currentSwitch != \"on\" ) {\n            \tsw.on()\n            }\n            break\n        case \"off\":\n        \tif ( sw.currentSwitch != \"off\" ) {\n            \tsw.off()\n            }\n            break\n        default:\n            httpError(400, \"$command is not a valid\")\n    }\n}\n\n\nvoid updateThermostat() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef therm = thermostats.find() { it.id == params.id }\n    if (!therm || !command) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def passComm = [\n        \"off\",\n        \"heat\",\n        \"emergencyHeat\",\n        \"cool\",\n        \"fanOn\",\n        \"fanAuto\",\n        \"fanCirculate\",\n        \"auto\"\n\n\t]\n    def passNumParamComm = [\n    \t\"setHeatingSetpoint\",\n    \t\"setCoolingSetpoint\",   \n    ]\n    def passStringParamComm = [\n        \"setThermostatMode\",\n        \"setThermostatFanMode\",\n\t]\n    if (command in passComm) {\n    \ttherm.\"$command\"()\t\n    } else if (command in passNumParamComm && params.p1 && params.p1.isFloat()) {\n    \ttherm.\"$command\"(Float.parseFloat(params.p1))\t\n    } else if (command in passStringParamComm && params.p1) {\n    \ttherm.\"$command\"(params.p1)\t\n    } else {\n    \thttpError(400, \"$command is not a valid command\")\n    }\n}\n\nvoid updateWindowShade() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\tdef ws = windowShades.find() { it.id == params.id }\n    if (!ws || !command) {\n    \thttpError(400, \"invalid id $params.id\")\n        return\n    }\n    def passComm = [\n\t\t\"open\",\n        \"close\",\n        \"presetPosition\",\n\t]\n    if (command in passComm) {\n    \tws.\"$command\"()\t\t\n    } else {\n    \thttpError(400, \"$command is not a valid command\")\n    }\n}\n// TODO: implement event handlers",
        "docstring": "Act as an endpoint so user's of Gidjit can quickly access and control their devices and execute routines. Users can do this quickly as Gidjit filters these actions  based on their environment"
    },
    {
        "code": "}\n\ndef installed() {\n  log.debug \"Installed with settings: ${settings}\"\n\n  initialize()\n}\n\ndef initialize() {\n}\n\ndef uninstalled() {\n  removeChildDevices(getChildDevices())\n}\n\nmappings {\n  path(\"/beacons\") {\n    action: [\n    DELETE: \"clearBeacons\",\n    POST:   \"addBeacon\"\n    ]\n  }\n\n  path(\"/beacons/:id\") {\n    action: [\n    PUT: \"updateBeacon\",\n    DELETE: \"deleteBeacon\"\n    ]\n  }\n}\n\nvoid clearBeacons() {\n  removeChildDevices(getChildDevices())\n}\n\nvoid addBeacon() {\n  def beacon = request.JSON?.beacon\n  if (beacon) {\n    def beaconId = \"BeaconThings\"\n    if (beacon.major) {\n      beaconId = \"$beaconId-${beacon.major}\"\n      if (beacon.minor) {\n        beaconId = \"$beaconId-${beacon.minor}\"\n      }\n    }\n    log.debug \"adding beacon $beaconId\"\n    def d = addChildDevice(\"com.obycode\", \"BeaconThing\", beaconId,  null, [label:beacon.name, name:\"BeaconThing\", completedSetup: true])\n    log.debug \"addChildDevice returned $d\"\n\n    if (beacon.present) {\n      d.arrive(beacon.present)\n    }\n    else if (beacon.presence) {\n      d.setPresence(beacon.presence)\n    }\n  }\n}\n\nvoid updateBeacon() {\n  log.debug \"updating beacon ${params.id}\"\n  def beaconDevice = getChildDevice(params.id)\n  // def children = getChildDevices()\n  // def beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n  if (!beaconDevice) {\n    log.debug \"Beacon not found directly\"\n    def children = getChildDevices()\n    beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n    if (!beaconDevice) {\n      log.debug \"Beacon not found in list either\"\n      return\n    }\n  }\n\n  // This could be just updating the presence\n  def presence = request.JSON?.presence\n  if (presence) {\n    log.debug \"Setting ${beaconDevice.label} to $presence\"\n    beaconDevice.setPresence(presence)\n  }\n\n  // It could be someone arriving\n  def arrived = request.JSON?.arrived\n  if (arrived) {\n    log.debug \"$arrived arrived at ${beaconDevice.label}\"\n    beaconDevice.arrived(arrived)\n  }\n\n  // It could be someone left\n  def left = request.JSON?.left\n  if (left) {\n    log.debug \"$left left ${beaconDevice.label}\"\n    beaconDevice.left(left)\n  }\n\n  // or it could be updating the name\n  def beacon = request.JSON?.beacon\n  if (beacon) {\n    beaconDevice.label = beacon.name\n  }\n}\n\nvoid deleteBeacon() {\n  log.debug \"deleting beacon ${params.id}\"\n  deleteChildDevice(params.id)\n  // def children = getChildDevices()\n  // def beaconDevice = children.find{ d -> d.deviceNetworkId == \"${params.id}\" }\n  // if (beaconDevice) {\n  //   deleteChildDevice(beaconDevice.deviceNetworkId)\n  // }\n}\n\nprivate removeChildDevices(delete) {\n  delete.each {\n    deleteChildDevice(it.deviceNetworkId)\n  }\n}",
        "docstring": "SmartApp to interact with the BeaconThings iOS app. Use this app to integrate iBeacons into your smart home."
    },
    {
        "code": "section(\"on this hub...\") {\n        input \"theHub\", \"hub\", multiple: false, required: true\n    }\n\n}\n\ndef installed() {\n    log.debug \"Installed ${app.label} with address '${settings.theAddr}' on hub '${settings.theHub.name}'\"\n\n    initialize()\n}\n\ndef updated() {\n    /*\n\tlog.debug \"Updated ${app.label} with address '${settings.theAddr}' on hub '${settings.theHub.name}'\"\n\n\tdef current = getChildDevices()\n\tlog.debug \"children: $current\"\n\n\tif (app.label != current.label) {\n\t\tlog.debug \"CHANGING name from ${current.label} to ${app.label}\"\n\t\tlog.debug \"label props: ${current.label.getProperties()}\"\n\t\tcurrent.label[0] = app.label\n\t}\n\t*/\n}\n\ndef initialize() {\n    def parts = theAddr.split(\":\")\n    def iphex = convertIPtoHex(parts[0])\n    def porthex = convertPortToHex(parts[1])\n    def dni = \"$iphex:$porthex\"\n    def hubNames = location.hubs*.name.findAll { it }\n    def d = addChildDevice(\"com.obycode\", \"ObyThing Music\", dni, theHub.id, [label:\"${app.label}\", name:\"ObyThing\"])\n    log.trace \"created ObyThing '${d.displayName}' with id $dni\"\n}\n\nprivate String convertIPtoHex(ipAddress) {\n    String hex = ipAddress.tokenize( '.' ).collect {  String.format( '%02X', it.toInteger() ) }.join()\n    return hex\n\n}\n\nprivate String convertPortToHex(port) {\n    String hexport = port.toString().format( '%04X', port.toInteger() )\n    return hexport\n}",
        "docstring": "Use this free SmartApp in conjunction with the ObyThing Music app for your Mac to control and automate music and more with iTunes and SmartThings."
    },
    {
        "code": "section (\"Still at home past\") {\n            input \"timeOfDay\", \"time\", title: \"What time?\", required: true\n        }\n\n        def phrases = location.helloHome?.getPhrases()*.label\n        if (phrases) {\n            phrases.sort()\n            section(\"Perform this action\") {\n                input \"wfhPhrase\", \"enum\", title: \"\\\"Hello, Home\\\" action\", required: true, options: phrases\n            }\n        }\n\n        section (title: \"More options\", hidden: hideOptions(), hideable: true) {\n            input \"sendPushMessage\", \"bool\", title: \"Send a push notification?\"\n            input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n            input \"days\", \"enum\", title: \"Set for specific day(s) of the week\", multiple: true, required: false,\n                options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n        }\n\n        section([mobileOnly:true]) {\n            label title: \"Assign a name\", required: false\n            mode title: \"Set for specific mode(s)\", required: false\n        }\n    }\n}\n\ndef installed() {\n    initialize()\n}\n\ndef updated() {\n    unschedule()\n    initialize()\n}\n\ndef initialize() {\n    schedule(timeToday(timeOfDay, location?.timeZone), \"checkPresence\")\n    if (customName) {\n      app.setTitle(customName)\n    }\n}\n\ndef checkPresence() {\n    if (daysOk && modeOk) {\n        if (person.latestValue(\"presence\") == \"present\") {\n            log.debug \"${person} is present, triggering WFH action.\"\n            location.helloHome.execute(settings.wfhPhrase)\n            def message = \"${location.name} executed '${settings.wfhPhrase}' because ${person} is home.\"\n            send(message)\n        }\n    }\n}\n\nprivate send(msg) {\n    if (sendPushMessage != \"No\") {\n        sendPush(msg)\n    }\n\n    if (phone) {\n        sendSms(phone, msg)\n    }\n\n    log.debug msg\n}\n\nprivate getModeOk() {\n    def result = !modes || modes.contains(location.mode)\n    result\n}\n\nprivate getDaysOk() {\n    def result = true\n    if (days) {\n        def df = new java.text.SimpleDateFormat(\"EEEE\")\n        if (location.timeZone) {\n            df.setTimeZone(location.timeZone)\n        }\n        else {\n            df.setTimeZone(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n        }\n        def day = df.format(new Date())\n        result = days.contains(day)\n    }\n    result\n}\n\nprivate hideOptions() {\n    (days || modes)? false: true\n}",
        "docstring": "If after a particular time of day a certain person is still at home, trigger a 'Working From Home' action."
    },
    {
        "code": "}\n\nmappings {\n  \n  path(\"/devices\") {\n    action: [\n      GET: \"listAllDevices\"\n    ]\n  }\n\t\n  path(\"/switches\") {\n    action: [\n      GET: \"listSwitches\"\n    ]\n  }\n  path(\"/switches/:command\") {\n    action: [\n      PUT: \"updateSwitches\"\n    ]\n  }\n  path(\"/switches/:id/:command\") {\n    action: [\n      PUT: \"updateSwitch\"\n    ]\n  }\n   path(\"/locks/:command\") {\n    action: [\n      PUT: \"updateLocks\"\n    ]\n  }\n  path(\"/locks/:id/:command\") {\n    action: [\n      PUT: \"updateLock\"\n    ]\n  }\n  \n   path(\"/devices/:id/:command\") {\n    action: [\n      PUT: \"commandDevice\"\n    ]\n  }\n}\n\n// returns a list of all devices\ndef listAllDevices() {\n   \tdef resp = []\n   \tswitches.each {\n      resp << [name: it.name, label: it.label, value: it.currentValue(\"switch\"), type: \"switch\", id: it.id, hub: it.hub?.name]\n    }\n    \n    locks.each {\n      resp << [name: it.name, label: it.label, value: it.currentValue(\"lock\"), type: \"lock\", id: it.id, hub: it.hub?.name]\n    }\n    return resp\n}\n \n// returns a list like\n// [[name: \"kitchen lamp\", value: \"off\"], [name: \"bathroom\", value: \"on\"]]\ndef listSwitches() {\n    def resp = []\n    switches.each {\n      resp << [name: it.displayName, value: it.currentValue(\"switch\"), type: \"switch\", id: it.id]\n    }\n    return resp\n}\n\nvoid updateLocks() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\n    if (command) {\n\n        // check that the switch supports the specified command\n        // If not, return an error using httpError, providing a HTTP status code.\n        locks.each {\n            if (!it.hasCommand(command)) {\n                httpError(501, \"$command is not a valid command for all switches specified\")\n            } \n        }\n        \n        // all switches have the comand\n        // execute the command on all switches\n        // (note we can do this on the array - the command will be invoked on every element\n        locks.\"$command\"()\n    }\n}\n\nvoid updateLock() {\n    def command = params.command\n    \n    locks.each {\n      \tif (!it.hasCommand(command)) {\n            httpError(400, \"$command is not a valid command for all lock specified\")\n        }\n        \n        if (it.id == params.id) {\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid updateSwitch() {\n    def command = params.command\n    \n    switches.each {\n      \tif (!it.hasCommand(command)) {\n            httpError(400, \"$command is not a valid command for all switches specified\")\n        }\n        \n        if (it.id == params.id) {\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid commandDevice() {\n    def command = params.command\n    def devices = []\n    \n    switches.each {\n    \tdevices << it\n    }\n    \n    locks.each {\n    \tdevices << it\n    }\n    \n    devices.each {\n        if (it.id == params.id) {\n            if (!it.hasCommand(command)) {\n                httpError(400, \"$command is not a valid command for specified device\")\n            }\n            it.\"$command\"()\n        }\n    }\n}\n\nvoid updateSwitches() {\n    // use the built-in request object to get the command parameter\n    def command = params.command\n\n    if (command) {\n\n        // check that the switch supports the specified command\n        // If not, return an error using httpError, providing a HTTP status code.\n        switches.each {\n            if (!it.hasCommand(command)) {\n                httpError(400, \"$command is not a valid command for all switches specified\")\n            } \n        }\n        \n        // all switches have the comand\n        // execute the command on all switches\n        // (note we can do this on the array - the command will be invoked on every element\n        switches.\"$command\"()\n    }\n}\n\n def installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n}",
        "docstring": "Allows Vinli users to connect their car to SmartThings"
    },
    {
        "code": "}\n\nmappings {\n    path(\"/\") {\n        action: [\n            GET: \"index\"\n        ]\n    }\n  path(\"/switches\") {\n  action: [\n    GET: \"listSwitches\",\n    PUT: \"updateSwitches\"\n    ]\n  }\n  path(\"/switches/:id\") {\n  action: [\n    GET: \"showSwitch\",\n    PUT: \"updateSwitch\"\n    ]\n  }\n}\n\ndef installed() {}\n\ndef updated() {}\n\ndef index(){\n    [[url: \"/switches\"]]\n}\n\ndef listSwitches() {\n  switches.collect { device(it,\"switch\") }\n}\nvoid updateSwitches() {\n  updateAll(switches)\n}\ndef showSwitch() {\n  show(switches, \"switch\")\n}\nvoid updateSwitch() {\n  update(switches)\n}\n\nprivate void updateAll(devices) {\n  def command = request.JSON?.command\n  if (command) {\n    switch(command) {\n      case \"on\":\n      devices*.on()\n      break\n      case \"off\":\n      devices*.off()\n      break\n      default:\n      httpError(403, \"Access denied. This command is not supported by current capability.\")\n    }\n  }\n}\n\nprivate void update(devices) {\n  log.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n  def command = request.JSON?.command\n  if (command) {\n  def device = devices.find { it.id == params.id }\n  if (!device) {\n  httpError(404, \"Device not found\")\n  } else {\n  switch(command) {\n  case \"on\":\n  device.on()\n  break\n  case \"off\":\n  device.off()\n  break\n  default:\n  httpError(403, \"Access denied. This command is not supported by current capability.\")\n  }\n  }\n  }\n}\n\nprivate show(devices, name) {\n  def d = devices.find { it.id == params.id }\n  if (!d) {\n  httpError(404, \"Device not found\")\n  }\n  else {\n        device(d, name)\n  }\n}\n\nprivate device(it, name){\n    if(it) {\n  def s = it.currentState(name)\n  [id: it.id, label: it.displayName, name: it.displayName, state: s]\n    }\n}",
        "docstring": "This SmartApp allows you to interact with the switches in your physical graph through Curb."
    },
    {
        "code": "section(\"When to run\") {\n      input(\"weekdays\", \"enum\", title: \"Set Days of Week\", multiple: true, required: true,\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        defaultValue: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"])\n      input(\"hours\", \"enum\", title: \"Select Times of Day\", multiple: true, required: true,\n        options: [[0 : \"12am\"], [1 : \"1am\"], [2 : \"2am\"],\n          [3 : \"3am\"], [4 : \"4am\"], [5 : \"5am\"], [6 : \"6am\"],\n          [7 : \"7am\"], [8 : \"8am\"], [9 : \"9am\"], [10 : \"10am\"],\n          [11 : \"11am\"], [12 : \"12pm\"], [13 : \"1pm\"], [14 : \"2pm\"],\n          [15 : \"3pm\"], [16 : \"4pm\"], [17 : \"5pm\"], [18 : \"6pm\"],\n          [19 : \"7pm\"], [20 : \"8pm\"], [21 : \"9pm\"], [22 : \"10pm\"], [23 : \"11pm\"]])\n    }\n  }\n  page(name: \"pageTwo\", nextPage: \"pageThree\" ) {\n    section(\"Threshold Settings\") {\n      input(\"timeInterval\", \"enum\", title: \"Select Measurement Interval\", multiple: false,\n              options: [[15 : \"15 minutes\"], [30 : \"30 minutes\"], [60 : \"60 minutes\"]],\n              defaultValue: 30)\n      input(\"kwhThreshold\", \"float\", title: \"Set Threshold Usage (kW)\")\n      input(\"safetyMargin\", \"float\", title: \"Set Safety Margin (%)\", defaultValue: 25)\n      input(\"projectionPeriod\", \"float\", title: \"Set Projection Period (%)\", defaultValue: 0)\n      input(\"meter\", \"capability.powerMeter\", title: \"Select Power Meter to Trigger throttling on ('Net' in most cases)\", multiple: false)\n      input(\"circuits\", \"capability.powerMeter\", title: \"Circuits to send alerts on\", multiple:true)\n    }\n  }\n  page(name: \"pageThree\", install: true, uninstall: true) {\n    section(\"Controlled Appliances\") {\n      input(\"thermostats\", \"capability.thermostat\", title: \"Select your Thermostat\", multiple: true, required: false)\n      input(\"switches\", \"capability.switch\", title: \"Select your Load Controllers\", multiple: true, required: false)\n    }\n\n    section(\"Send Push Notification?\") {\n      input( \"sendPush\", \"bool\", required: false, title: \"Send Push Notification?\")\n    }\n  }\n}\n\ndef installed() {\n  resetClocking();\n  initialize();\n}\n\ndef updated() {\n  runAutomation();\n  unsubscribe();\n  initialize();\n}\n\ndef initialize() {\n  subscribe(meter, \"power\", checkEnergyMonitor);\n  runEvery1Minute(runAutomation);\n}\n\n// Returns true if we are in a selected automation time\ndef checkRunning() {\n  def df = new java.text.SimpleDateFormat(\"EEEE\");\n  df.setTimeZone(location.timeZone);\n\n  if (weekdays.contains( df.format(new Date()) )) {\n    // We're in an enabled weekday\n    def hf = new java.text.SimpleDateFormat(\"H\");\n    hf.setTimeZone(location.timeZone);\n\n    if (hours.contains(hf.format(new Date()).toString())) {\n      // We're in an enabled hour\n      return true\n    }\n  }\n  return false\n}\n\n// Creates the message and sends the push notification\ndef sendNotifications() {\n  def devlist = []\n  def count = 0\n  def currentTotal = Float.parseFloat(meter.currentState(\"power\").value)\n  def message = \"Curb Alert: Energy usage is projected to go over selected threshold.\"\n\n  for(c in circuits) {\n    try {\n      if (c.toString() == \"Total Power Usage\") { continue }\n      if (c.toString() == \"Total Power Grid Impact\") { continue }\n      devlist.add([ pct: ((Float.parseFloat(c.currentState(\"power\").value) / currentTotal) * 100).round(), name: c.toString() ])\n      count += count\n    } catch (e) {\n      // sometimes we get circuits with no power value\n      log.debug(e);\n    }\n  }\n  if (devlist.size() > 3) {\n      def sorted = devlist.sort { a, b -> b.pct <=> a.pct }\n      message += \"Your biggest consumers currently are: ${sorted[0].name} ${sorted[0].pct}%, ${sorted[1].name} ${sorted[1].pct}%, and ${sorted[2].name} ${sorted[2].pct}%\"\n  }\n  sendPush(message)\n}\n\n// Resets the absolute time window\ndef resetClocking() {\n  state.readings = []\n  state.usage = 0\n  if (state.throttling == true) {\n    stopThrottlingUsage()\n  }\n}\n\n//\ndef runAutomation() {\n  if ( !enabled ) { return }\n  if ( !checkRunning() ) { return }\n\n  def mf = new java.text.SimpleDateFormat(\"m\")\n  def minute = Integer.parseInt(mf.format(new Date())) % Integer.parseInt(timeInterval)\n  def samples = 0.0\n  state.usage = 0.0\n\n  if (minute == 0) {\n    // This is the first minute of the process, reset variables\n    resetClocking()\n  }\n\n  if (minute < Float.parseFloat(timeInterval) * (Float.parseFloat(projectionPeriod) / 100) ) {\n    //We're in the projection period. Do not throttle\n    return\n  }\n\n  for (int i = 0; i < Integer.parseInt(timeInterval); i++) {\n    if (state.readings[i] != null) {\n      samples = samples + 1.0\n      log.debug(samples)\n      state.usage = state.usage + (state.readings[i] / 1000)\n      log.debug(state.usage)\n    }\n  }\n\n  if (samples != 0.0) {\n    def avgedUsage = minute * ( state.usage / samples ) / Float.parseFloat(timeInterval)\n    log.debug(\"minute: \" + minute)\n    log.debug(\"usage: \" + avgedUsage)\n    def safetyThreshold = ( Float.parseFloat(kwhThreshold) * ( 1 - (Float.parseFloat(safetyMargin) / 100)))\n    log.debug(safetyThreshold)\n    if (avgedUsage > safetyThreshold) {\n      throttleUsage()\n    }\n  }\n\n}\n\n// Saves power reading in circular buffer\ndef checkEnergyMonitor(evt) {\n  def mf = new java.text.SimpleDateFormat(\"m\")\n  def minute = Integer.parseInt(mf.format(new Date())) % Integer.parseInt(timeInterval)\n\n  def power = meter.currentState(\"power\").value\n  state.readings[minute] = Float.parseFloat(power)\n}\n\n// Gets and saves the current controller state for use during state restore\ndef captureContollerStates() {\n  if (!state.throttling) {\n    for (t in thermostats) {\n      state[t.id] = t.currentState(\"thermostatMode\").value\n    }\n    for (s in switches) {\n      state[s.id] = s.currentState(\"switch\").value\n    }\n  }\n}\n\n// Sets thermostats\ndef throttleUsage() {\n  if (state.throttling) {\n    return\n  }\n  captureContollerStates()\n  sendNotifications()\n  state.throttling = true\n\n  for (t in thermostats) {\n    t.off()\n  }\n\n  for (s in switches) {\n    s.off()\n  }\n}\n\n// Restores controller states to previously stored values\ndef stopThrottlingUsage() {\n    state.throttling = false\n    for (t in thermostats) {\n      if (!state[t.id]) {\n        continue\n      }\n      t.setThermostatMode(state[t.id])\n    }\n\n    for (s in switches) {\n      if (!state[s.id]) {\n        continue\n      }\n      state[s.id] == \"on\" ? s.on() : s.off()\n    }\n}",
        "docstring": "Maximize your energy savings with CURB"
    },
    {
        "code": "preferences {\n\n    page(name: \"auth\", title: \"Authorize with Curb\", content: \"authPage\", uninstall: true)\n\n}\n\nmappings {\n    path(\"/oauth/initialize\") {\n        action: [GET: \"oauthInitUrl\"]\n    }\n    path(\"/oauth/callback\") {\n        action: [GET: \"callback\"]\n    }\n}\n\ndef getCurbAuthUrl() { return \"https://energycurb.auth0.com\" }\n\ndef getCurbLoginUrl() { return \"${curbAuthUrl}/authorize\" }\n\ndef getCurbTokenUrl() { return \"${curbAuthUrl}/oauth/token\" }\n\ndef getServerUrl() { return  appSettings.serverUrl ?: apiServerUrl }\n\ndef getCallbackUrl() { return \"${serverUrl}/oauth/callback\" }\n\ndef getBuildRedirectUrl() {\n  return \"${serverUrl}/oauth/initialize?appId=${app.id}&access_token=${state.accessToken}&apiServerUrl=${serverUrl}\"\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    removeChildDevices(getChildDevices())\n\n    initialize()\n}\n\ndef initialize() {\n    log.debug \"Initializing\"\n    unschedule()\n\n    def curbCircuits = getCurbCircuits()\n    log.debug \"Found devices: ${curbCircuits}\"\n    log.debug settings\n    runEvery1Minute(getPowerData)\n    if (settings.energyInterval==\"Hour\" || settings.energyInterval == \"Half Hour\" || settings.energyInterval == \"Fifteen Minutes\")\n    {\n      runEvery1Minute(getKwhData)\n    } else {\n      runEvery1Hour(getKwhData)\n    }\n}\n\ndef uninstalled() {\n    log.debug \"Uninstalling\"\n    removeChildDevices(getChildDevices())\n}\n\ndef authPage() {\n\n    if (!state.accessToken) {\n        state.accessToken = createAccessToken()\n    }\n\n    if (state.authToken) {\n    \tgetCurbLocations()\n        return dynamicPage(name: \"auth\", title: \"Login Successful\", nextPage: \"\", install: true, uninstall: true) {\n            section() {\n                paragraph(\"Select your CURB Location\")\n                input(\n                    name: \"curbLocation\",\n                    type: \"enum\",\n                    title: \"CURB Location\",\n                    options: state.locations\n\n                )\n                input(\n                  name: \"energyInterval\",\n                  type: \"enum\",\n                  title: \"Energy Interval\",\n                  options: [\"Billing Period\", \"Day\", \"Hour\", \"Half Hour\", \"Fifteen Minutes\"],\n                  defaultValue: \"Hour\"\n                  )\n            }\n        }\n    } else {\n        return dynamicPage(name: \"auth\", title: \"Login\", nextPage: \"\", uninstall: false) {\n            section() {\n                paragraph(\"Tap below to log in to the CURB service and authorize SmartThings access\")\n                href url: buildRedirectUrl, style: \"embedded\", required: true, title: \"CURB\", description: \"Click to enter CURB Credentials\"\n            }\n        }\n    }\n}\n\ndef oauthInitUrl() {\n\n    log.debug \"Initializing oauth\"\n    state.oauthInitState = UUID.randomUUID().toString()\n    def oauthParams = [\n        response_type: \"code\",\n        scope: \"offline_access\",\n        audience: \"app.energycurb.com/api\",\n        client_id: appSettings.clientId,\n        connection: \"Users\",\n\n        state: state.oauthInitState,\n        redirect_uri: callbackUrl\n    ]\n    redirect(location: \"${curbLoginUrl}?${toQueryString(oauthParams)}\")\n}\n\ndef callback() {\n\n    log.debug \"Oauth callback: ${params}\"\n    def code = params.code\n    def oauthState = params.state\n    if (oauthState == state.oauthInitState) {\n        def tokenParams = [\n            grant_type: \"authorization_code\",\n            code: code,\n            client_id: appSettings.clientId,\n            client_secret: appSettings.clientSecret,\n            redirect_uri: callbackUrl\n        ]\n\n        asynchttp_v1.post(handleTokenResponse, [uri: curbTokenUrl, body: tokenParams])\n        success()\n    } else {\n        log.error \"callback() failed oauthState != state.oauthInitState\"\n    }\n}\n\ndef handleTokenResponse(resp, data){\n\tstate.refreshToken = resp.json.refresh_token\n    state.authToken = resp.json.access_token\n}\n\nprivate removeChildDevices(delete) {\n    delete.each {\n        deleteChildDevice(it.deviceNetworkId)\n    }\n}\n\ndef updateChildDevice(dni, value) {\n    try {\n        def existingDevice = getChildDevice(dni)\n        existingDevice?.handlePower(value)\n    } catch (e) {\n        log.error \"Error updating device: ${e}\"\n    }\n}\n\ndef createChildDevice(dni, label) {\n    log.debug \"Creating child device with DNI ${dni} and name ${label}\"\n    return addChildDevice(\"curb\", \"CURB Power Meter\", dni, null, [name: \"${dni}\", label: \"${label}\"])\n}\n\ndef getCurbCircuits() {\n    getPowerData(true)\n}\n\ndef getCurbLocations() {\n    log.debug \"Getting curb locations\"\n    def params = [\n        uri: \"http://app.energycurb.com\",\n        path: \"/api/locations\",\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"]\n    ]\n    def allLocations = [:]\n    try {\n        httpGet(params) {\n            resp ->\n            resp.data.each {\n                log.debug \"Found location: ${it}\"\n                allLocations[it.id] = it.label\n            }\n            state.locations = allLocations\n        }\n    } catch (e) {\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef getPowerData(create=false) {\n  log.debug \"Getting data at ${settings.curbLocation} with token: ${state.authToken}\"\n    def params = [\n        uri: \"https://app.energycurb.com\",\n        path: \"/api/aggregate/${settings.curbLocation}/2m/s\",\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"],\n        requestContentType: 'application/json'\n    ]\n    try {\n    \thttpGet(params) { resp ->\n            processData(resp, null, create, false)\n            return resp.data.circuits\n        }\n    } catch (e) {\n    \trefreshAuthToken()\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef getKwhData() {\n  log.debug \"Getting kwh data at ${settings.curbLocation} with token: ${state.authToken}\"\n  def url = \"/api/aggregate/${settings.curbLocation}/\"\n\n  if (settings.energyInterval == \"Hour\"){ url = url + \"1h/m\"}\n  if (settings.energyInterval == \"Billing Period\"){ url = url + \"billing/h\"}\n  if (settings.energyInterval == \"Half Hour\"){ url = url + \"30m/m\"}\n  if (settings.energyInterval == \"Day\"){ url = url + \"24h/h\"}\n  if (settings.energyInterval == \"Fifteen Minutes\"){ url = url + \"15m/m\"}\n\tlog.debug \"KWH FOR: ${url}\"\n    def params = [\n        uri: \"https://app.energycurb.com\",\n        path: url,\n        headers: [\"Authorization\": \"Bearer ${state.authToken}\"],\n        requestContentType: 'application/json'\n    ]\n    try {\n    \thttpGet(params) { resp ->\n            processData(resp, null, false, true)\n            return\n        }\n    } catch (e) {\n    \trefreshAuthToken()\n        log.error \"something went wrong: ${e}\"\n    }\n}\n\ndef processData(resp, data, create=false, energy=false)\n{\n    log.debug \"Processing usage data: ${resp.data}\"\n    if (!isOK(resp)) {\n\n        refreshAuthToken()\n        log.error \"Usage Response Error: ${resp.getErrorMessage()}\"\n        return\n    }\n    def main = 0.0\n    def production = 0.0\n    def all = 0.0\n    def hasProduction = false\n    def hasMains = false\n    if (resp.data) {\n        resp.data.each {\n        \tdef numValue = 0.0\n        \tif(energy){\n            \tnumValue=it.kwhr.floatValue()\n            } else {\n            \tnumValue=it.avg\n            }\n        \tall += numValue\n            if (!it.main && !it.production && it.label != null && it.label != \"\") {\n            \tif (create) { createChildDevice(\"${it.id}\", \"${it.label}\") }\n                energy ?  getChildDevice(\"${it.id}\")?.handleKwhBilling(numValue.floatValue()) : updateChildDevice(\"${it.id}\", numValue)\n            }\n            if (it.grid) {\n              hasMains = true\n              main += numValue\n            }\n            if (it.production) {\n              hasProduction = true\n              production += numValue\n            }\n        }\n\n        if (create) { createChildDevice(\"__NET__\", \"Net Grid Impact\") }\n\n        if (!hasMains) {\n        \tmain = all\n        }\n\n        energy ? getChildDevice(\"__NET__\")?.handleKwhBilling(main) : updateChildDevice(\"__NET__\", main)\n        if (hasProduction) {\n          if (create) { createChildDevice(\"__PRODUCTION__\", \"Production\") }\n          if (create) { createChildDevice(\"__CONSUMPTION__\", \"Consumption\") }\n          energy ? getChildDevice(\"__PRODUCTION__\")?.handleKwhBilling(production) : updateChildDevice(\"__PRODUCTION__\", production)\n          energy ? getChildDevice(\"__CONSUMPTION__\")?.handleKwhBilling(main-production) : updateChildDevice(\"__CONSUMPTION__\", main-production)\n        }\n    }\n    if ( create && !energy){\n    \tgetKwhData()\n    }\n\n}\n\ndef toQueryString(Map m) {\n    return m.collect {\n        k, v -> \"${k}=${URLEncoder.encode(v.toString())}\"\n    }.sort().join(\"&\")\n}\n\ndef refreshAuthToken() {\n\n    log.debug \"Refreshing auth token\"\n    if (!state.refreshToken) {\n\n        log.warn \"Can not refresh OAuth token since there is no refreshToken stored\"\n    } else {\n        def tokenParams = [\n            grant_type: \"refresh_token\",\n            client_id: appSettings.clientId,\n            client_secret: appSettings.clientSecret,\n            refresh_token: state.refreshToken\n\n        ]\n\n        httpPostJson([uri: curbTokenUrl, body: tokenParams]) {\n            resp ->\n                state.authToken = resp.data.access_token\n                log.debug \"Got authToken: ${state.authToken}\"\n        }\n    }\n}\n\n//THIS DEFINES THE SCREEN AFTER AUTHORIZATION:\n\ndef success() {\n  def message = \"\"\"\n        <p>Your Curb account is now connected to SmartThings!</p>\n        <p>Click 'Done' to finish setup.</p>\n    \"\"\"\n  connectionStatus(message)\n}\n\ndef fail() {\n  def message = \"\"\"\n        <p>The connection could not be established!</p>\n        <p>Click 'Done' to return to the menu.</p>\n    \"\"\"\n  connectionStatus(message)\n}\n\ndef connectionStatus(message, redirectUrl = null) {\n  def redirectHtml = \"\"\n  if (redirectUrl) {\n    redirectHtml = \"\"\"\n      <meta http-equiv=\"refresh\" content=\"3; url=${redirectUrl}\" />\n    \"\"\"\n  }\n\n  def html = \"\"\"\n  <!DOCTYPE html>\n  <html>\n\n  <head>\n      <meta name=\"viewport\" content=\"width=640\">\n      <title>Curb & SmartThings connection</title>\n      <style type=\"text/css\">\n          @font-face {\n              font-family: 'Swiss 721 W01 Thin';\n              src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n              src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n              font-weight: normal;\n              font-style: normal;\n          }\n          @font-face {\n              font-family: 'Swiss 721 W01 Light';\n              src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n              src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n              url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n              font-weight: normal;\n              font-style: normal;\n          }\n          .container {\n              width: 90%;\n              padding: 4%;\n              text-align: center;\n          }\n\n          img {\n              vertical-align: middle;\n          }\n          p {\n              font-size: 2.2em;\n              font-family: 'Swiss 721 W01 Thin';\n              text-align: center;\n              color: #666666;\n              padding: 0 40px;\n              margin-bottom: 0;\n          }\n          span {\n              font-family: 'Swiss 721 W01 Light';\n          }\n      </style>\n  </head>\n  <body>\n      <div class=\"container\">\n          <img src=\"http://energycurb.com/wp-content/uploads/2015/12/curb-web-logo.png\" alt=\"curb icon\" />\n          <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n          <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" /> ${message}\n      </div>\n  </body>\n  </html>\n    \"\"\"\n\n  render contentType: 'text/html', data: html\n}\n\n\ndef isOK(response) {\n  response.status in [200, 201]\n}",
        "docstring": "Gain insight into energy usage throughout your home."
    },
    {
        "code": "section(\"Ventilation Fan\") {\n        input \"switches\", \"capability.switch\", title: \"Switches\", required: true, multiple: true\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    state.active = false;\n    subscribe(sensor, \"carbonDioxide\", 'handleLevel')\n}\n\ndef handleLevel(evt) {\n    def co2 = sensor.currentValue(\"carbonDioxide\").toInteger()\n    log.debug \"CO2 Level: ${co2} / ${settings.level} Active: ${state.active}\"\n\n    if(co2 >= settings.level && !state.active) {\n        log.debug \"Turning on\"\n        switches.each { it.on(); }\n        state.active = true;\n    } else if(co2 < settings.level && state.active) {\n        log.debug \"Turning off\"\n        state.active = false;\n        switches.each { it.off(); }\n    }\n}",
        "docstring": "Turn on a switch when CO2 levels are too high"
    },
    {
        "code": "preferences {\n\tpage(name: \"Credentials\", title: \"Fetch OAuth2 Credentials\", content: \"authPage\", install: false)\n\tpage(name: \"listDevices\", title: \"Netatmo Devices\", content: \"listDevices\", install: false)\n}\n\nmappings {\n\tpath(\"/oauth/initialize\") {action: [GET: \"oauthInitUrl\"]}\n\tpath(\"/oauth/callback\") {action: [GET: \"callback\"]}\n}\n\ndef authPage() {\n\t// log.debug \"running authPage()\"\n\n\tdef description\n\tdef uninstallAllowed = false\n\tdef oauthTokenProvided = false\n\n\t// If an access token doesn't exist, create one\n\tif (!atomicState.accessToken) {\n\t\tatomicState.accessToken = createAccessToken()\n        log.debug \"Created access token\"\n\t}\n\n\tif (canInstallLabs()) {\n\n\t\tdef redirectUrl = getBuildRedirectUrl()\n\t\t// log.debug \"Redirect url = ${redirectUrl}\"\n\n\t\tif (atomicState.authToken) {\n\t\t\tdescription = \"Tap 'Next' to select devices\"\n\t\t\tuninstallAllowed = true\n\t\t\toauthTokenProvided = true\n\t\t} else {\n\t\t\tdescription = \"Tap to enter credentials\"\n\t\t}\n\n\t\tif (!oauthTokenProvided) {\n\t\t\tlog.debug \"Showing the login page\"\n\t\t\treturn dynamicPage(name: \"Credentials\", title: \"Authorize Connection\", nextPage:\"listDevices\", uninstall: uninstallAllowed, install:false) {\n\t\t\t\tsection() {\n\t\t\t\t\tparagraph \"Tap below to login to Netatmo and authorize SmartThings access\"\n\t\t\t\t\thref url:redirectUrl, style:\"embedded\", required:false, title:\"Connect to Netatmo\", description:description\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Showing the devices page\"\n\t\t\treturn dynamicPage(name: \"Credentials\", title: \"Connected\", nextPage:\"listDevices\", uninstall: uninstallAllowed, install:false) {\n\t\t\t\tsection() {\n\t\t\t\t\tinput(name:\"Devices\", style:\"embedded\", required:false, title:\"Netatmo is connected to SmartThings\", description:description) \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdef upgradeNeeded = \"\"\"To use SmartThings Labs, your Hub should be completely up to date. To update your Hub, access Location Settings in the Main Menu (tap the gear next to your location name), select your Hub, and choose \"Update Hub\".\"\"\"\n\t\treturn dynamicPage(name:\"Credentials\", title:\"Upgrade needed!\", nextPage:\"\", install:false, uninstall: true) {\n\t\t\tsection {\n\t\t\t\tparagraph \"$upgradeNeeded\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\ndef oauthInitUrl() {\n\t// log.debug \"runing oauthInitUrl()\"\n\n\tatomicState.oauthInitState = UUID.randomUUID().toString()\n\n\tdef oauthParams = [\n\t\tresponse_type: \"code\",\n\t\tclient_id: getClientId(),\n\t\tclient_secret: getClientSecret(),\n\t\tstate: atomicState.oauthInitState,\n\t\tredirect_uri: getCallbackUrl(),\n\t\tscope: \"read_station\"\n\t]\n\n\t// log.debug \"REDIRECT URL: ${getVendorAuthPath() + toQueryString(oauthParams)}\"\n\n\tredirect (location: getVendorAuthPath() + toQueryString(oauthParams))\n}\n\ndef callback() {\n\t// log.debug \"running callback()\"\n\n\tdef code = params.code\n\tdef oauthState = params.state\n\n\tif (oauthState == atomicState.oauthInitState) {\n\n\t\tdef tokenParams = [\n        \tgrant_type: \"authorization_code\",\n\t\t\tclient_secret: getClientSecret(),\n\t\t\tclient_id : getClientId(),\n\t\t\tcode: code,\n\t\t\tscope: \"read_station\",\n            redirect_uri: getCallbackUrl()\n\t\t]\n\n\t\t// log.debug \"TOKEN URL: ${getVendorTokenPath() + toQueryString(tokenParams)}\"\n\n\t\tdef tokenUrl = getVendorTokenPath()\n\t\tdef requestTokenParams = [\n\t\t\turi: tokenUrl,\n\t\t\trequestContentType: 'application/x-www-form-urlencoded',\n\t\t\tbody: tokenParams\n\t\t]\n    \n\t\t// log.debug \"PARAMS: ${requestTokenParams}\"\n\n\t\ttry {\n            httpPost(requestTokenParams) { resp ->\n                //log.debug \"Data: ${resp.data}\"\n                atomicState.refreshToken = resp.data.refresh_token\n                atomicState.authToken = resp.data.access_token\n                // resp.data.expires_in is in milliseconds so we need to convert it to seconds\n                atomicState.tokenExpires = now() + (resp.data.expires_in * 1000)\n            }\n        } catch (e) {\n\t\t\t      log.debug \"callback() failed: $e\"\n        }\n\n\t\t// If we successfully got an authToken run sucess(), else fail()\n\t\tif (atomicState.authToken) {\n\t\t\tsuccess()\n\t\t} else {\n\t\t\tfail()\n\t\t}\n\n\t} else {\n\t\tlog.error \"callback() failed oauthState != atomicState.oauthInitState\"\n\t}\n}\n\ndef success() {\n\tlog.debug \"OAuth flow succeeded\"\n\tdef message = \"\"\"\n\t<p>Success!</p>\n\t<p>Tap 'Done' to continue</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef fail() {\n\tlog.debug \"OAuth flow failed\"\n    atomicState.authToken = null\n\tdef message = \"\"\"\n\t<p>Error</p>\n\t<p>Tap 'Done' to return</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef connectionStatus(message, redirectUrl = null) {\n\tdef redirectHtml = \"\"\n\tif (redirectUrl) {\n\t\tredirectHtml = \"\"\"\n\t\t\t<meta http-equiv=\"refresh\" content=\"3; url=${redirectUrl}\" />\n\t\t\"\"\"\n\t}\n\tdef html = \"\"\"\n\t\t<!DOCTYPE html>\n\t\t<html>\n\t\t<head>\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t<title>Netatmo Connection</title>\n\t\t<style type=\"text/css\">\n\t\t\t* { box-sizing: border-box; }\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t\turl('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t.container {\n\t\t\t\twidth: 100%;\n\t\t\t\tpadding: 40px;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\timg {\n\t\t\t\tvertical-align: middle;\n\t\t\t}\n\t\t\timg:nth-child(2) {\n\t\t\t\tmargin: 0 30px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 2.2em;\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\ttext-align: center;\n\t\t\t\tcolor: #666666;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\t\t\tspan {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t}\n\t\t</style>\n\t\t</head>\n\t\t<body>\n\t\t\t<div class=\"container\">\n\t\t\t\t<img src=\"\"\" + getVendorIcon() + \"\"\" alt=\"Vendor icon\" />\n\t\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t\t\t${message}\n\t\t\t</div>\n        </body>\n        </html>\n\t\"\"\"\n\trender contentType: 'text/html', data: html\n}\n\ndef refreshToken() {\n\t// Check if atomicState has a refresh token\n\tif (atomicState.refreshToken) {\n        log.debug \"running refreshToken()\"\n\n        def oauthParams = [\n            grant_type: \"refresh_token\",\n            refresh_token: atomicState.refreshToken,\n            client_secret: getClientSecret(),\n            client_id: getClientId(),\n        ]\n\n        def tokenUrl = getVendorTokenPath()\n        \n        def requestOauthParams = [\n            uri: tokenUrl,\n            requestContentType: 'application/x-www-form-urlencoded',\n            body: oauthParams\n        ]\n        \n        // log.debug \"PARAMS: ${requestOauthParams}\"\n\n        try {\n            httpPost(requestOauthParams) { resp ->\n            \t//log.debug \"Data: ${resp.data}\"\n                atomicState.refreshToken = resp.data.refresh_token\n                atomicState.authToken = resp.data.access_token\n                // resp.data.expires_in is in milliseconds so we need to convert it to seconds\n                atomicState.tokenExpires = now() + (resp.data.expires_in * 1000)\n                return true\n            }\n        } catch (e) {\n            log.debug \"refreshToken() failed: $e\"\n        }\n\n        // If we didn't get an authToken\n        if (!atomicState.authToken) {\n            return false\n        }\n\t} else {\n    \treturn false\n    }\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.debug \"Initialized with settings: ${settings}\"\n    \n\t// Pull the latest device info into state\n\tgetDeviceList()\n\n\tsettings.devices.each {\n\t\tdef deviceId = it\n\t\tdef detail = state?.deviceDetail[deviceId]\n\n\t\ttry {\n\t\t\tswitch(detail?.type) {\n\t\t\t\tcase 'NAMain':\n\t\t\t\t\tlog.debug \"Base station\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Basestation\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule1':\n\t\t\t\t\tlog.debug \"Outdoor module\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Outdoor Module\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule3':\n\t\t\t\t\tlog.debug \"Rain Gauge\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Rain\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'NAModule4':\n\t\t\t\t\tlog.debug \"Additional module\"\n\t\t\t\t\tcreateChildDevice(\"Netatmo Additional Module\", deviceId, \"${detail.type}.${deviceId}\", detail.module_name)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.error \"Error creating device: ${e}\"\n\t\t}\n\t}\n\n\t// Cleanup any other devices that need to go away\n\tdef delete = getChildDevices().findAll { !settings.devices.contains(it.deviceNetworkId) }\n\tlog.debug \"Delete: $delete\"\n\tdelete.each { deleteChildDevice(it.deviceNetworkId) }\n    \n\t// Run initial poll and schedule future polls\n\tpoll()\n\trunEvery5Minutes(\"poll\")\n}\n\ndef uninstalled() {\n\tlog.debug \"Uninstalling\"\n\tremoveChildDevices(getChildDevices())\n}\n\ndef getDeviceList() {\n\tif (atomicState.authToken) {\n    \n        log.debug \"Getting stations data\"\n\n        def deviceList = [:]\n        state.deviceDetail = [:]\n        state.deviceState = [:]\n\n        apiGet(\"/api/getstationsdata\") { resp ->\n            resp.data.body.devices.each { value ->\n                def key = value._id\n                deviceList[key] = \"${value.station_name}: ${value.module_name}\"\n                state.deviceDetail[key] = value\n                state.deviceState[key] = value.dashboard_data\n                value.modules.each { value2 ->            \n                    def key2 = value2._id\n                    deviceList[key2] = \"${value.station_name}: ${value2.module_name}\"\n                    state.deviceDetail[key2] = value2\n                    state.deviceState[key2] = value2.dashboard_data            \n                }\n            }\n        }\n        \n        return deviceList.sort() { it.value.toLowerCase() }\n        \n\t} else {\n    \treturn null\n  }\n}\n\nprivate removeChildDevices(delete) {\n\tlog.debug \"Removing ${delete.size()} devices\"\n\tdelete.each {\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t}\n}\n\ndef createChildDevice(deviceFile, dni, name, label) {\n\ttry {\n\t\tdef existingDevice = getChildDevice(dni)\n\t\tif(!existingDevice) {\n\t\t\tlog.debug \"Creating child\"\n\t\t\tdef childDevice = addChildDevice(\"dianoga\", deviceFile, dni, null, [name: name, label: label, completedSetup: true])\n\t\t} else {\n\t\t\tlog.debug \"Device $dni already exists\"\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"Error creating device: ${e}\"\n\t}\n}\n\ndef listDevices() {\n\tlog.debug \"Listing devices\"\n\n\tdef devices = getDeviceList()\n\n\tdynamicPage(name: \"listDevices\", title: \"Choose Devices\", install: true) {\n\t\tsection(\"Devices\") {\n\t\t\tinput \"devices\", \"enum\", title: \"Select Devices\", required: false, multiple: true, options: devices\n\t\t}\n\n        section(\"Preferences\") {\n        \tinput \"rainUnits\", \"enum\", title: \"Rain Units\", description: \"Millimeters (mm) or Inches (in)\", required: true, options: [mm:'Millimeters', in:'Inches']\n        }\n\t}\n}\n\ndef apiGet(String path, Map query, Closure callback) {\n\tlog.debug \"running apiGet()\"\n    \n    // If the current time is over the expiration time, request a new token\n\tif(now() >= atomicState.tokenExpires) {\n    \tatomicState.authToken = null\n\t\trefreshToken()\n\t}\n\n\tdef queryParam = [\n    \taccess_token: atomicState.authToken\n    ]\n    \n\tdef apiGetParams = [\n\t\turi: getApiUrl(),\n\t\tpath: path,\n\t\tquery: queryParam\n\t]\n    \n\t// log.debug \"apiGet(): $apiGetParams\"\n\n\ttry {\n\t\thttpGet(apiGetParams) { resp ->\n\t\t\tcallback.call(resp)\n\t\t}\n\t} catch (e) {\n\t\tlog.debug \"apiGet() failed: $e\"\n        // Netatmo API has rate limits so a failure here doesn't necessarily mean our token has expired, but we will check anyways\n        if(now() >= atomicState.tokenExpires) {\n    \t\tatomicState.authToken = null\n\t\t\trefreshToken()\n\t\t}\n\t}\n}\n\ndef apiGet(String path, Closure callback) {\n\tapiGet(path, [:], callback);\n}\n\ndef poll() {\n\tlog.debug \"Polling...\"\n    \n\tgetDeviceList()\n    \n\tdef children = getChildDevices()\n    //log.debug \"State: ${state.deviceState}\"\n\n\tsettings.devices.each { deviceId ->\n\t\tdef detail = state?.deviceDetail[deviceId]\n\t\tdef data = state?.deviceState[deviceId]\n\t\tdef child = children?.find { it.deviceNetworkId == deviceId }\n\n\t\tlog.debug \"Update: $child\";\n\t\tswitch(detail?.type) {\n\t\t\tcase 'NAMain':\n\t\t\t\tlog.debug \"Updating NAMain $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'carbonDioxide', value: data['CO2'])\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tchild?.sendEvent(name: 'pressure', value: data['Pressure'])\n\t\t\t\tchild?.sendEvent(name: 'noise', value: data['Noise'])\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule1':\n\t\t\t\tlog.debug \"Updating NAModule1 $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule3':\n\t\t\t\tlog.debug \"Updating NAModule3 $data\"\n\t\t\t\tchild?.sendEvent(name: 'rain', value: rainToPref(data['Rain']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'rainSumHour', value: rainToPref(data['sum_rain_1']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'rainSumDay', value: rainToPref(data['sum_rain_24']) as float, unit: settings.rainUnits)\n\t\t\t\tchild?.sendEvent(name: 'units', value: settings.rainUnits)\n\t\t\t\tbreak;\n\t\t\tcase 'NAModule4':\n\t\t\t\tlog.debug \"Updating NAModule4 $data\"\n\t\t\t\tchild?.sendEvent(name: 'temperature', value: cToPref(data['Temperature']) as float, unit: getTemperatureScale())\n\t\t\t\tchild?.sendEvent(name: 'carbonDioxide', value: data['CO2'])\n\t\t\t\tchild?.sendEvent(name: 'humidity', value: data['Humidity'])\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\ndef cToPref(temp) {\n\tif(getTemperatureScale() == 'C') {\n    \treturn temp\n    } else {\n\t\treturn temp * 1.8 + 32\n    }\n}\n\ndef rainToPref(rain) {\n\tif(settings.rainUnits == 'mm') {\n    \treturn rain\n    } else {\n    \treturn rain * 0.039370\n    }\n}\n\ndef debugEvent(message, displayEvent) {\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent(results)\n}\n\nprivate Boolean canInstallLabs() {\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware) {\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions() {\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate your Netatmo devices with SmartThings"
    },
    {
        "code": "section(\"Open/Close\") {\n    \tinput(\"sensors\", \"capability.contactSensor\", title: \"Sensors\", multiple: true)\n        input(\"delay\", \"number\", title: \"Delay (seconds)\")\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n    unschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.changed = false\n\tsubscribe(sensors, 'contact', \"sensorChange\")\n}\n\ndef sensorChange(evt) {\n\tlog.debug \"Desc: $evt.value , $state\"\n    if(evt.value == 'open' && !state.changed) {\n    \tunschedule()\n        runIn(delay, 'turnOff')\n    } else if(evt.value == 'closed' && state.changed) {\n    \t// All closed?\n        def isOpen = false\n        for(sensor in sensors) {\n        \tif(sensor.id != evt.deviceId && sensor.currentValue('contact') == 'open') {\n        \t\tisOpen = true\n            }\n        }\n        \n        if(!isOpen) {\n        \tunschedule()\n        \trunIn(delay, 'restore')\n        }\n    }\n}\n\ndef turnOff() {\n\tlog.debug \"Turning off thermostat due to contact open\"\n\tstate.thermostatMode = thermostat.currentValue(\"thermostatMode\")\n\tthermostat.off()\n    state.changed = true\n    log.debug \"State: $state\"\n}\n\ndef restore() {\n    log.debug \"Setting thermostat to $state.thermostatMode\"\n    thermostat.setThermostatMode(state.thermostatMode)\n    state.changed = false\n}",
        "docstring": "Automatically turn off thermostat when windows/doors open. Turn it back on when everything is closed up."
    },
    {
        "code": "section(\"Indoor\") {\n    \tinput \"inTemp\", \"capability.temperatureMeasurement\", title: \"Indoor Thermometer\", required: true\n        input \"minTemp\", \"number\", title: \"Minimum Indoor Temperature\"\n        input \"fans\", \"capability.switch\", title: \"Vent Fan\", multiple: true, required: true\n    }\n    \n    section(\"Thermostat\") {\n    \tinput \"thermostat\", \"capability.thermostat\", title: \"Thermostat\"\n    }\n    \n    section(\"Windows/Doors\") {\n    \tparagraph \"[Optional] Only turn on the fan if at least one of these is open\"\n        input \"checkContacts\", \"enum\", title: \"Check windows/doors\", options: ['Yes', 'No'], required: true \n    \tinput \"contacts\", \"capability.contactSensor\", title: \"Windows/Doors\", multiple: true, required: false\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.fanRunning = false;\n    \n    subscribe(outTemp, \"temperature\", \"checkThings\");\n    subscribe(inTemp, \"temperature\", \"checkThings\");\n    subscribe(thermostat, \"thermostatMode\", \"checkThings\");\n    subscribe(contacts, \"contact\", \"checkThings\");\n}\n\ndef checkThings(evt) {\n\tdef outsideTemp = settings.outTemp.currentTemperature\n    def insideTemp = settings.inTemp.currentTemperature\n    def thermostatMode = settings.thermostat.currentThermostatMode\n    def somethingOpen = settings.checkContacts == 'No' || settings.contacts?.find { it.currentContact == 'open' }\n    \n    log.debug \"Inside: $insideTemp, Outside: $outsideTemp, Thermostat: $thermostatMode, Something Open: $somethingOpen\"\n    \n    def shouldRun = true;\n    \n    if(thermostatMode != 'off') {\n    \tlog.debug \"Not running due to thermostat mode\"\n    \tshouldRun = false;\n    }\n    \n    if(insideTemp < outsideTemp) {\n    \tlog.debug \"Not running due to insideTemp > outdoorTemp\"\n    \tshouldRun = false;\n    }\n    \n    if(insideTemp < settings.minTemp) {\n    \tlog.debug \"Not running due to insideTemp < minTemp\"\n    \tshouldRun = false;\n    }\n    \n    if(!somethingOpen) {\n    \tlog.debug \"Not running due to nothing open\"\n        shouldRun = false\n    }\n    \n    if(shouldRun && !state.fanRunning) {\n    \tfans.on();\n        state.fanRunning = true;\n    } else if(!shouldRun && state.fanRunning) {\n    \tfans.off();\n        state.fanRunning = false;\n    }\n}",
        "docstring": "Toggle a whole house fan (switch) when: Outside is cooler than inside, Inside is above x temp, Thermostat is off"
    },
    {
        "code": "section(\"When the humidity rises above:\") {\n\t\tinput \"humidity1\", \"number\", title: \"Percentage ?\"\n\t}\n    section(\"When the humidity falls below:\") {\n\t\tinput \"humidity2\", \"number\", title: \"Percentage ?\"\n\t}\n    section( \"Notifications\" ) {\n        input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n        input \"phone1\", \"phone\", title: \"Send a Text Message?\", required: false\n    }\n\tsection(\"Control this switch:\") {\n\t\tinput \"switch1\", \"capability.switch\", required: false\n\t}\n}\n\ndef installed() {\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef humidityHandler(evt) {\n\tlog.trace \"humidity: ${evt.value}\"\n    log.trace \"set point: ${humidity1}\"\n\n\tdef currentHumidity = Double.parseDouble(evt.value.replace(\"%\", \"\"))\n\tdef tooHumid = humidity1 \n    def notHumidEnough = humidity2\n\tdef mySwitch = settings.switch1\n\tdef deltaMinutes = 10 \n    \n    def timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last ${deltaMinutes} minutes\"\n\tdef alreadySentSms = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) >= tooHumid } > 1 || recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) <= notHumidEnough } > 1\n    \n\tif (currentHumidity >= tooHumid) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting >= ${tooHumid}\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\t\n\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"Notification already sent within the last ${deltaMinutes} minutes\"\n\t\t\t\n\t\t} else {\n\t\t\tlog.debug \"Humidity Rose Above ${tooHumid}:  sending SMS and activating ${mySwitch}\"\n\t\t\tsend(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n\n    if (currentHumidity <= notHumidEnough) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting <= ${notHumidEnough}\"\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"Notification already sent within the last ${deltaMinutes} minutes\"\n\t\t\t\n\t\t} else {\n\t\t\tlog.debug \"Humidity Fell Below ${notHumidEnough}:  sending SMS and activating ${mySwitch}\"\n\t\t\tsend(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}\")\n\t\t\tswitch1?.off()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n    }\n\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n\n    log.debug msg\n}",
        "docstring": "Notify me when the humidity rises above or falls below the given threshold. It will turn on a switch when it rises above the first threshold and off when it falls below the second threshold."
    },
    {
        "code": "section(\"Turn off a light\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\ndef installed() {\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"$evt.value\"\n\tif (evt.value == \"open\") {\n        state.wasOn = switch1.currentValue(\"switch\") == \"on\"\n\t\tswitch1.off()\n}\t\n\nif (evt.value == \"closed\") {\n\tif(state.wasOn)switch1.on()\n}\n}",
        "docstring": "Turn your lights off when a Contact Sensor is opened and turn them back on when it is closed, ONLY if the Lights were previouly on"
    },
    {
        "code": "}\n\n    section( \"Set the temperature range for your comfort zone...\" ) {\n        input \"minTemp\", \"number\", title: \"Minimum temperature\"\n        input \"maxTemp\", \"number\", title: \"Maximum temperature\"\n    }\n    section( \"Select windows to check...\" ) {\n        input \"sensors\", \"capability.contactSensor\", multiple: true\n    }\n    section( \"Select temperature devices to monitor...\" ) {\n        input \"inTemp\", \"capability.temperatureMeasurement\", title: \"Indoor\"\n        input \"outTemp\", \"capability.temperatureMeasurement\", title: \"Outdoor (optional)\", required: false\n    }\n\n    if (location.channelName != 'samsungtv') {\n        section( \"Set your location\" ) { input \"zipCode\", \"text\", title: \"Zip code\" }\n    }\n\n    section( \"Notifications\" ) {\n        input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n        input \"retryPeriod\", \"number\", title: \"Minutes between notifications:\"\n    }\n}\n\ndef installed() {\n    log.debug \"Installed: $settings\"\n    subscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef updated() {\n    log.debug \"Updated: $settings\"\n    unsubscribe()\n    subscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef temperatureHandler(evt) {\n    def currentOutTemp = null\n    if ( outTemp ) {\n        currentOutTemp = outTemp.latestValue(\"temperature\")\n    } else {\n        log.debug \"No external temperature device set. Checking The Weather Company...\"\n        currentOutTemp = weatherCheck()\n    }\n\n    def currentInTemp = evt.doubleValue\n    def openWindows = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\n    log.trace \"Temp event: $evt\"\n    log.info \"In: $currentInTemp; Out: $currentOutTemp\"\n\n    // Don't spam notifications\n    // *TODO* use state.foo from Severe Weather Alert to do this better\n    if (!retryPeriod) {\n        def retryPeriod = 30\n    }\n    def timeAgo = new Date(now() - (1000 * 60 * retryPeriod).toLong())\n    def recentEvents = inTemp.eventsSince(timeAgo)\n    log.trace \"Found ${recentEvents?.size() ?: 0} events in the last $retryPeriod minutes\"\n\n    // Figure out if we should notify\n    if ( currentInTemp > minTemp && currentInTemp < maxTemp ) {\n        log.info \"In comfort zone: $currentInTemp is between $minTemp and $maxTemp.\"\n        log.debug \"No notifications sent.\"\n    } else if ( currentInTemp > maxTemp ) {\n        // Too warm. Can we do anything?\n\n        def alreadyNotified = recentEvents.count { it.doubleValue > currentOutTemp } > 1\n\n        if ( !alreadyNotified ) {\n            if ( currentOutTemp < maxTemp && !openWindows ) {\n                send( \"Open some windows to cool down the house! Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n            } else if ( currentOutTemp > maxTemp && openWindows ) {\n                send( \"It's gotten warmer outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n            } else {\n                log.debug \"No notifications sent. Everything is in the right place.\"\n            }\n        } else {\n            log.debug \"Already notified! No notifications sent.\"\n        }\n    } else if ( currentInTemp < minTemp ) {\n        // Too cold! Is it warmer outside?\n        def alreadyNotified = recentEvents.count { it.doubleValue < currentOutTemp } > 1\n        if ( !alreadyNotified ) {\n            if ( currentOutTemp > minTemp && !openWindows ) {\n                send( \"Open some windows to warm up the house! Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n            } else if ( currentOutTemp < minTemp && openWindows ) {\n                send( \"It's gotten colder outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n            } else {\n                log.debug \"No notifications sent. Everything is in the right place.\"\n            }\n        } else {\n            log.debug \"Already notified! No notifications sent.\"\n        }\n    }\n}\n\ndef weatherCheck() {\n    def obs = getTwcConditions(zipCode)\n    def currentTemp = obs.temperature\n    if ( currentTemp ) {\n        log.trace \"Temp: $currentTemp (The Weather Company)\"\n        return currentTemp\n    } else {\n        log.warn \"Did not get a temp: $obs\"\n        return false\n    }\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n        sendEvent(linkText:app.label, descriptionText:msg, eventType:\"SOLUTION_EVENT\", displayed: true, name:\"summary\")\n    }\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n    log.info msg\n}",
        "docstring": "Compares two temperatures – indoor vs outdoor, for example – then sends an alert if windows are open (or closed!). If you don't use an external temperature device, your location will be used instead."
    },
    {
        "code": "section( \"Select windows to check...\" ) {\n\t\tinput \"sensors\", \"capability.contactSensor\", multiple: true\n\t}\n\tsection( \"Select temperature devices to monitor...\" ) {\n\t\tinput \"inTemp\", \"capability.temperatureMeasurement\", title: \"Indoor\"\n\t\tinput \"outTemp\", \"capability.temperatureMeasurement\", title: \"Outdoor (optional)\", required: false\n\t}\n\tsection( \"Set your location\" ) {\n\t\tinput \"zipCode\", \"text\", title: \"Zip code\"\n\t}\n\tsection( \"Notifications\" ) {\n\t\tinput \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n\t\tinput \"retryPeriod\", \"number\", title: \"Minutes between notifications:\"\n\t}\n}\n\n\ndef installed() {\n\tlog.debug \"Installed: $settings\"\n\tsubscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\ndef updated() {\n\tlog.debug \"Updated: $settings\"\n\tunsubscribe()\n\tsubscribe( inTemp, \"temperature\", temperatureHandler )\n}\n\n\ndef temperatureHandler(evt) {\n\tdef currentOutTemp = null\n\tif ( outTemp ) {\n\t\tcurrentOutTemp = outTemp.latestValue(\"temperature\")\n\t} else {\n\t\tlog.debug \"No external temperature device set. Checking WUnderground....\"\n\t\tcurrentOutTemp = weatherCheck()\n\t}\n\n\tdef currentInTemp = evt.doubleValue\n\tdef openWindows = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\n\tlog.trace \"Temp event: $evt\"\n\tlog.info \"In: $currentInTemp; Out: $currentOutTemp\"\n\n\t// Don't spam notifications\n\t// *TODO* use state.foo from Severe Weather Alert to do this better\n\tdef retryPeriodInMinutes = retryPeriod ?: 30\n\tdef timeAgo = new Date(now() - (1000 * 60 * retryPeriodInMinutes).toLong())\n\tdef recentEvents = inTemp.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $retryPeriodInMinutes minutes\"\n\n\t// Figure out if we should notify\n\tif ( currentInTemp > minTemp && currentInTemp < maxTemp ) {\n\t\tlog.info \"In comfort zone: $currentInTemp is between $minTemp and $maxTemp.\"\n\t\tlog.debug \"No notifications sent.\"\n\t} else if ( currentInTemp > maxTemp ) {\n\t\t// Too warm. Can we do anything?\n\n\t\tdef alreadyNotified = recentEvents.count { it.doubleValue > currentOutTemp } > 1\n\n\t\tif ( !alreadyNotified ) {\n\t\t\tif ( currentOutTemp < maxTemp && !openWindows ) {\n\t\t\t\tsend( \"Open some windows to cool down the house! Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n\t\t\t} else if ( currentOutTemp > maxTemp && openWindows ) {\n\t\t\t\tsend( \"It's gotten warmer outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n\t\t\t} else {\n\t\t\t\tlog.debug \"No notifications sent. Everything is in the right place.\"\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Already notified! No notifications sent.\"\n\t\t}\n\t} else if ( currentInTemp < minTemp ) {\n\t\t// Too cold! Is it warmer outside?\n\n\t\tdef alreadyNotified = recentEvents.count { it.doubleValue < currentOutTemp } > 1\n\n\t\tif ( !alreadyNotified ) {\n\t\t\tif ( currentOutTemp > minTemp && !openWindows ) {\n\t\t\t\tsend( \"Open some windows to warm up the house! Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n\t\t\t} else if ( currentOutTemp < minTemp && openWindows ) {\n\t\t\t\tsend( \"It's gotten colder outside! You should close these windows: ${openWindows.join(', ')}. Currently ${currentInTemp}°F inside and ${currentOutTemp}°F outside.\" )\n\t\t\t} else {\n\t\t\t\tlog.debug \"No notifications sent. Everything is in the right place.\"\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Already notified! No notifications sent.\"\n\t\t}\n\t}\n}\n\ndef weatherCheck() {\n\tdef json = getWeatherFeature(\"conditions\", zipCode)\n\tdef currentTemp = json?.current_observation?.temp_f\n\n\tif ( currentTemp ) {\n    \tlog.trace \"Temp: $currentTemp (WeatherUnderground)\"\n\t\treturn currentTemp\n\t} else {\n\t\tlog.warn \"Did not get a temp: $json\"\n\t\treturn false\n\t}\n}\n\nprivate send(msg) {\n\tif ( sendPushMessage != \"No\" ) {\n\t\tlog.debug( \"sending push message\" )\n\t\tsendPush( msg )\n        sendEvent(linkText:app.label, descriptionText:msg, eventType:\"SOLUTION_EVENT\", displayed: true, name:\"summary\")\n\t}\n\n\tif ( phone1 ) {\n\t\tlog.debug( \"sending text message\" )\n\t\tsendSms( phone1, msg )\n\t}\n\n\tlog.info msg\n}",
        "docstring": "Compares two temperatures – indoor vs outdoor, for example – then sends an alert if windows are open (or closed!). If you don't use an external temperature device, your zipcode will be used instead."
    },
    {
        "code": "preferences {\n\tpage(name: \"checkAccessToken\")\n}\n\ncards {\n    card(name: \"Encored Energy Service\", type: \"html\", action: \"getHtml\", whitelist: whiteList()) {}\n}\n\n/* This list contains, that url need to be allowed in Smart Energy Service.*/\ndef whiteList() {\n\t[\n    \t\"code.jquery.com\", \n    \t\"ajax.googleapis.com\", \n        \"fonts.googleapis.com\",\n    \t\"code.highcharts.com\", \n    \t\"enertalk-card.encoredtech.com\", \n    \t\"s3-ap-northeast-1.amazonaws.com\",\n        \"s3.amazonaws.com\", \n    \t\"ui-hub.encoredtech.com\",\n        \"enertalk-auth.encoredtech.com\",\n        \"api.encoredtech.com\",\n        \"cdnjs.cloudflare.com\",\n        \"encoredtech.com\",\n        \"itunes.apple.com\"\n    ]\n}\n\n/* url endpoints */\nmappings {\n\tpath(\"/requestCode\") { action: [ GET: \"requestCode\" ] }\n\tpath(\"/receiveToken\") { action: [ GET: \"receiveToken\"] }\n    path(\"/getHtml\") { action: [GET: \"getHtml\"] }\n    path(\"/consoleLog\") { action: [POST: \"consoleLog\"]}\n    path(\"/getInitialData\") { action: [GET: \"getInitialData\"]}\n    path(\"/getEncoredPush\") { action: [POST: \"getEncoredPush\"]}\n}\n\n\n/* This method does two things depends on the existence of Encored access token. :\n* 1. If Encored access token does not exits, it starts the process of getting access token.\n* 2. If Encored access token does exist, it will show a list of configurations, that user need to define values. \n*/\ndef checkAccessToken() {\n\tlog.debug \"Staring the installation\"\n\n    /* Choose the level */    \n    atomicState.env_mode =\"prod\"\n   \n    def lang = clientLocale?.language\n   \n   \t/* getting language settings of user's device.  */\n    if (\"${lang}\" == \"ko\") {\n    \tatomicState.language = \"ko\"\n    } else {\n    \tatomicState.language = \"en\"\n    }\n    \n    /* create tanslation for descriptive and informative strings that can be seen by users. */\n    if (!state.languageString) {\n    \tcreateLocaleStrings() \n    }\n    \n\tif (!atomicState.encoredAccessToken) { /*check if Encored access token does exist.*/\n    \t\n        log.debug \"Encored Access Token does not exist.\"\n        \n        if (!state.accessToken) { /*if smartThings' access token does not exitst*/\n        \tlog.debug \"SmartThings Access Token does not exist.\"\n            \n            createAccessToken() /*request and get access token from smartThings*/\n            \n            /* re-create strings to make sure it's been initialized. */\n            //createLocaleStrings() \n        }\n\n\t\tdef redirectUrl = buildRedirectUrl(\"requestCode\") /* build a redirect url with endpoint \"requestCode\"*/\n        \n        /* These lines will start the OAuth process.\\n*/\n        log.debug \"Start OAuth request.\"\n        return dynamicPage(name: \"checkAccessToken\", nextPage:null, uninstall: true, install:false) {\n            section{\n            \tparagraph state.languageString.\"${atomicState.language}\".desc1\n                href(title: state.languageString.\"${atomicState.language}\".main,\n                     description: state.languageString.\"${atomicState.language}\".desc2,\n                     required: true,\n                     style:\"embedded\",\n                     url: redirectUrl)\n            }\n        }\n    } else {\n    \t/* This part will load the configuration for this application */\n        return dynamicPage(name:\"checkAccessToken\",install:true, uninstall : true) {\n        \tsection(title:state.languageString.\"${atomicState.language}\".title6) {\n            \n            \t/* A push alarm for this application */\n            \tinput(\n                    type: \"boolean\", \n                    name: \"notification\", \n                    title: state.languageString.\"${atomicState.language}\".title1,\n                    required: false,\n                    default: true,\n                    multiple: false\n                )\n                \n                /* A plan that user need to decide */\n                input(\n                \ttype: \"number\", \n                    name: \"energyPlan\", \n                    title: state.languageString.\"${atomicState.language}\".title2,\n                    description : state.languageString.\"${atomicState.language}\".subTitle1,\n                    defaultValue: state.languageString.energyPlan,\n                    range: \"1130..*\",\n                    submitOnChange: true,\n                    required: true, \n                    multiple: false\n                )\n                \n                /* A displaying unit that user need to decide */\n                input(\n                \ttype: \"enum\", \n                    name: \"displayUnit\", \n                    title: state.languageString.\"${atomicState.language}\".title3, \n                    defaultValue : state.languageString.\"${atomicState.language}\".defaultValues.default1,\n                    required: true, \n                    multiple: false, \n                    options: state.languageString.\"${atomicState.language}\".displayUnits\n                )\n                \n                /* A metering date that user should know */\n            \tinput(\n                \ttype: \"enum\", \n                    name: \"meteringDate\", \n                    title: state.languageString.\"${atomicState.language}\".title4,\n                    defaultValue: state.languageString.\"${atomicState.language}\".defaultValues.default2,\n                    required: true, \n                    multiple: false, \n                    options: state.languageString.\"${atomicState.language}\".meteringDays\n                )\n                \n                /* A contract type that user should know */\n                input(\n                \ttype: \"enum\", \n                \tname: \"contractType\", \n                    title: state.languageString.\"${atomicState.language}\".title5,\n                    defaultValue: state.languageString.\"${atomicState.language}\".defaultValues.default3,\n                    required: true, \n                    multiple: false, \n                    options: state.languageString.\"${atomicState.language}\".contractTypes)\n            }\n            \n        }\n    }\n}\n\ndef requestCode(){\n\tlog.debug \"In state of sending a request to Encored for OAuth code.\\n\"\n    \n\t/* Make a parameter to request Encored for a OAuth code. */\n    def oauthParams = \n    [\n\t\tresponse_type: \"code\",\n\t\tscope: \"remote\",\n\t\tclient_id: \"${appSettings.clientId}\",\n        app_version: \"web\",\n\t\tredirect_uri: buildRedirectUrl(\"receiveToken\")\n\t]\n\n    /* Request Encored a code. */\n\tredirect location: \"https://enertalk-auth.encoredtech.com/authorization?${toQueryString(oauthParams)}\"\n}\n\ndef receiveToken(){\n\tlog.debug \"Request Encored to swap code with Encored Aceess Token\"\n\t\n    /* Making a parameter to swap code with a token */\n    def authorization = \"Basic \" + \"${appSettings.clientId}:${appSettings.clientSecret}\".bytes.encodeBase64()\n    def uri = \"https://enertalk-auth.encoredtech.com/token\"\n    def header = [Authorization: authorization, contentType: \"application/json\"]\n    def body = [grant_type: \"authorization_code\", code: params.code]\n\t\n    log.debug \"Swap code with a token\"\n    def encoredTokenParams = makePostParams(uri, header, body)\n    \n    log.debug \"API call to Encored to swap code with a token\"\n    def encoredTokens = getHttpPostJson(encoredTokenParams)\n\t\n    /* make a page to show people if the REST was successful or not. */\n    if (encoredTokens) {\n    \tlog.debug \"Got Encored OAuth token\\n\"\n\t\tatomicState.encoredRefreshToken = encoredTokens.refresh_token\n\t\tatomicState.encoredAccessToken = encoredTokens.access_token\n        \n        success()\n\t} else {\n    \tlog.debug \"Could not get Encored OAuth token\\n\"\n    \tfail()\n    }\n    \n}\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\t\n    /* Make sure uuid is there. */\n    getUUID()\n    \n   \t/* Check uuid and if it does not exist then don't update.*/\n    if (!atomicState.notPaired) {  \n        def theDay = 1\n\n        for(def i=1; i < 28; i++) {\n        \t\n            /* set user choosen option to apropriate value. */\n            if (atomicState.language == \"en\") {\n                if (\"${i}st day of the month\" == settings.meteringDate || \n                    \"${i}nd day of the month\" == settings.meteringDate || \n                    \"${i}rd day of the month\" == settings.meteringDate || \n                    \"${i}th day of the month\" == settings.meteringDate) {\n\n                    theDay = i\n                    i = 28\n\n                } else if (\"Rest of the month\" == settings.meteringDate) {\n                    theDay = 27\n                    i = 28\n                }\n            } else {\n\n                if (settings.meteringDate == \"매월 ${i}일\") {\n\n                    theDay = i\n                    i = 28\n\n                } else if (\"말일\" == settings.meteringDate) {\n                    theDay = 27\n                    i = 28\n                }\n            }\n\n        }\n\t\t\n        /* Set choosen contract to apropriate variable. */\n        def contract = 1\n        if (settings.contractType == \"High voltage\" || settings.contractType == \"주택용 고압\") {\n            contract = 2\n          \t\n            if (settings.energyPlan < 460) {\n            \tsettings.energyPlan = 490\n            }\n        } else {\n        \t\n        \tif (settings.energyPlan < 1130) {\n            \tsettings.energyPlan = 1130\n            }\n        }\n\t\t\n        \n        /* convert bill to milliwatts */\n        def changeToUsageParam = makeGetParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/bill/expectedUsage?bill=${settings.energyPlan}\",\n                                      [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n       def energyPlanUsage = getHttpGetJson(changeToUsageParam, 'CheckEnergyPlanUsage')\n        def epUsage = 0\n        if (energyPlanUsage) {\n            epUsage = energyPlanUsage.usage\n        } \n        \n\t\t/* update the the information depends on the option choosen */\n        def configurationParam = makePostParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/me\",\n                                          [Authorization     : \"Bearer ${atomicState.encoredAccessToken}\"],\n                                          [contractType      : contract, \n                                           meteringDay       : theDay,\n                                           maxLimitUsage     : epUsage])\n        getHttpPutJson(configurationParam)\n    }\n\t\n}\n\ndef initialize() {\n\tlog.debug \"Initializing Application\"\n    \n    def EATValidation = checkEncoreAccessTokenValidation()\n    \n    /* if token exist get user's device id, uuid */\n    if (EATValidation) {\n    \tgetUUID()\n        if (atomicState.uuid) {\n        \t\n            def pushParams = makePostParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/events/push\",\n                                        [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"],\n                                        [type: \"REST\", regId:\"${state.accessToken}__${app.id}\"])\n            getHttpPostJson(pushParams)\n\t\t}\n        \n    } else {\n    \tlog.warning \"Ecored Access Token did not get refreshed!\"\n    }\n        \n    \n    /* add device Type Handler */\n    atomicState.dni = \"EncoredDTH01\"\n    def d = getChildDevice(atomicState.dni)\n    if(!d) {\n        log.debug \"Creating Device Type Handler.\"\n        \n        d = addChildDevice(\"Encored Technologies\", \"EnerTalk Energy Meter\", atomicState.dni, null, [name:\"EnerTalk Energy Meter\", label:name])\n\n    } else {\n        log.debug \"Device already created\"\n    }\n    \n    setSummary()    \n}\n\ndef setSummary() {\n    \n    log.debug \"in setSummary\"\n    def text = \"Successfully installed.\"\n    sendEvent(linkText:count.toString(), descriptionText: app.label,\n              eventType:\"SOLUTION_SUMMARY\",\n              name: \"summary\",\n              value: text,\n              data: [[\"icon\":\"indicator-dot-gray\",\"iconColor\":\"#878787\",\"value\":text]],\n              displayed: false)\n}\n\n// TODO: implement event handlers\n\n/* \tCheck the validation of Encored Access Token (EAT)\n*\tIf it's not valid try refresh Access Token.\n*\tIf the token gets refreshed, it will refresh the value of Encored Access Token\n*\tIf it doesn't get refreshed, then it returns null\n*/\nprivate checkEncoreAccessTokenValidation() {\n\t/* make a parameter to check the validation of Encored access token */\n    def verifyParam = makeGetParams(\"https://enertalk-auth.encoredtech.com/verify\", \n    \t\t\t\t\t\t\t[Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n    /* check the validation */\n    def verified = getHttpGetJson(verifyParam, 'verifyToken')\n\n    log.debug \"verified : ${verified}\"\n\n    /* if Encored Access Token need to be renewed. */\n    if (!verified) {\n        try {\n            refreshAuthToken()\n\n            /* Recheck the renewed Encored access token. */\n            verifyParam.headers = [Authorization: \"Bearer ${atomicState.encoredAccessToken}\"]\n            verified = getHttpGetJson(verifyParam, 'CheckRefresh')\n\n        } catch (groovyx.net.http.HttpResponseException e) {\n            /* If refreshing token raises an error  */\n            log.warn \"Refresh Token Error :  ${e}\"\n        }\n    }\n    \n    return verified\n}\n\n/* Get device UUID, if it does not exist, return false. true otherwise.*/\nprivate getUUID() {\n\tatomicState.uuid = null\n    atomicState.notPaired = true\n    /* Make a parameter to get device id (uuid)*/\n    def uuidParams = makeGetParams( \"https://enertalk-auth.encoredtech.com/uuid\",\n                                   [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n    def deviceUUID = getHttpGetJson(uuidParams, 'UUID')\n    log.debug \"device uuid is : ${deviceUUID}\"\n    if (!deviceUUID) {\n    \treturn false\n    }\n    log.debug \"got here even tho\"\n    atomicState.uuid = deviceUUID.uuid\n    atomicState.notPaired = false\n    return true\n}\n\nprivate createLocaleStrings() {\n   state.domains = [\n   \t\ttest : \"http://api.encoredtech.com\",\n        prod : \"https://api.encoredtech.com:8082/\"\n   ]\n   state.languageString = \n   [\n   \t\tenergyPlan : 30000,\n    \ten : [\n                desc1 : \"Tab below to sign in or sign up to Encored EnerTalk smart energy service and authorize SmartThings access.\",\n                desc2 : \"Click to proceed authorization.\",\n                main : \"EnerTalk\",\n                defaultValues : [\n                                default1 : \"kWh\",\n                                default2 : \"1st day of the month\",\n                                default3 : \"Low voltage\"\n                \t\t\t\t],\n                meteringDays : [\n                            \"1st day of the month\", \n                            \"2nd day of the month\", \n                            \"3rd day of the month\",\n                            \"4th day of the month\",\n                            \"5th day of the month\",\n                            \"6th day of the month\",\n                            \"7th day of the month\",\n                            \"8th day of the month\",\n                            \"9th day of the month\",\n                            \"10th day of the month\",\n                            \"11th day of the month\",\n                            \"12th day of the month\",\n                            \"13th day of the month\",\n                            \"14th day of the month\",\n                            \"15th day of the month\",\n                            \"16th day of the month\",\n                            \"17th day of the month\",\n                            \"18th day of the month\",\n                            \"19th day of the month\",\n                            \"20st day of the month\",\n                            \"21st day of the month\",\n                            \"22nd day of the month\",\n                            \"23rd day of the month\",\n                            \"24th day of the month\",\n                            \"25th day of the month\",\n                            \"26th day of the month\",\n                            \"Rest of the month\"\n                            ],\n                displayUnits : [\"WON(₩)\", \"kWh\"],\n                contractTypes : [\"Low voltage\", \"High voltage\"],\n                title1 : \"Send push notification\",\n                title2 : \"Energy Plan\",\n                subTitle1 : \"Setup your energy plan by won\",\n                title3 : \"Display Unit\",\n                title4 : \"Metering Date\",\n                title5 : \"Contract Type\",\n                title6 : \"User & Notifications\",\n                message1 : \"\"\" <p>Your Encored Account is now connected to SmartThings!</p> <p>Click 'Done' to finish setup.</p> \"\"\",\n                message2 : \"\"\" <p>The connection could not be established!</p> <p>Click 'Done' to return to the menu.</p> \"\"\",\n                message3 : [\n                \t\theader : \"Device is not installed\",\n                        body1 : \"You need to install EnerTalk device at first,\",\n                        body2 : \"and proceed setup and register device.\",\n                        button1 : \"Setup device\",\n                        button2 : \"Not Installed\"\n                \t   ],\n            \tmessage4 : [\n                \t\t\theader : \"Device is not connected.\",\n                            body1 : \"Please check the Wi-Fi network connection\",\n                            body2 : \"and EnerTalk device status.\",\n                            body3 : \"Select ‘Setup Device’ to reset the device.\"\n                \t\t\t]\n            ],\n        ko :[\n                desc1 : \"스마트 에너지 서비스를 이용하시려면 EnerTalk 서비스 가입과 SmartThings 접근 권한이 필요합니다.\",\n                desc2 : \"아래 버튼을 누르면 인증을 시작합니다\",\n                main : \"EnerTalk 인증\",\n                defaultValues : [\n                                default1 : \"kWh\",\n                                default2 : \"매월 1일\",\n                                default3 : \"주택용 저압\"\n                \t\t\t\t],\n                meteringDays : [\n                            \"매월 1일\", \n                            \"매월 2일\", \n                            \"매월 3일\",\n                            \"매월 4일\",\n                            \"매월 5일\",\n                            \"매월 6일\",\n                            \"매월 7일\",\n                            \"매월 8일\",\n                            \"매월 9일\",\n                            \"매월 10일\",\n                            \"매월 11일\",\n                            \"매월 12일\",\n                            \"매월 13일\",\n                            \"매월 14일\",\n                            \"매월 15일\",\n                            \"매월 16일\",\n                            \"매월 17일\",\n                            \"매월 18일\",\n                            \"매월 19일\",\n                            \"매월 20일\",\n                            \"매월 21일\",\n                            \"매월 22일\",\n                            \"매월 23일\",\n                            \"매월 24일\",\n                            \"매월 25일\",\n                            \"매월 26일\",\n                            \"말일\"\n                            ],\n                displayUnits : [\"원(₩)\", \"kWh\"],\n                contractTypes : [\"주택용 저압\", \"주택용 고압\"],\n                title1 : \"알람 설정\",\n                title2 : \"사용 계획 (원)\",\n                subTitle1 : \"월간 계획을 금액으로 입력하세요\",\n                title3 : \"표시 단위\",\n                title4 : \"정기검침일\",\n                title5 : \"계약종별\",\n                title6 : \"사용자 & 알람 설정\",\n                message1 : \"\"\" <p>EnerTalk 계정이 SmartThings와 연결 되었습니다!</p> <p>Done을 눌러 계속 진행해 주세요.</p> \"\"\",\n                message2 : \"\"\" <p>계정 연결이 실패했습니다.</p> <p>Done 버튼을 눌러 다시 시도해주세요.</p> \"\"\",\n                message3 : [\n                \t\theader : \"기기 설치가 필요합니다.\",\n                        body1 : \"가정 내 분전반에 EnerTalk 기기를 먼저 설치하고,\",\n                        body2 : \"아래 버튼을 눌러 기기등록 및 연결을 진행하세요.\",\n                        button1 : \"기기 설정\",\n                        button2 : \"설치필요\"\n                \t   ],\n            \tmessage4 : [\n                \t\t\theader : \"Device is not connected.\",\n                            body1 : \"Please check the Wi-Fi network connection\",\n                            body2 : \"and EnerTalk device status.\",\n                            body3 : \"Select ‘Setup Device’ to reset the device.\"\n                \t\t\t]\n                \n            ]\n    ]\n\n}\n\n/* This method makes a redirect url with a given endpoint */\nprivate buildRedirectUrl(mappingPath) {\n\tlog.debug \"Start : Starting to making a redirect URL with endpoint : /${mappingPath}\"\n    def url = \"https://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/${mappingPath}\"\n    log.debug \"Done : Finished to make a URL : ${url}\"\n    url\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\n/* make a success message. */\nprivate success() {\n\tdef lang = clientLocale?.language\n   \n    if (\"${lang}\" == \"ko\") {\n   \t\tlog.debug \"I was here at first.\"\n    \tatomicState.language = \"ko\"\n    } else {\n  \n    \tatomicState.language = \"en\"\n    }\n\tlog.debug atomicState.language\n\tdef message = atomicState.languageString.\"${atomicState.language}\".message1\n\tconnectionStatus(message)\n}\n\n/* make a failure message. */\nprivate fail() {\n\tdef lang = clientLocale?.language\n   \n    if (\"${lang}\" == \"ko\") {\n   \t\tlog.debug \"I was here at first.\"\n    \tatomicState.language = \"ko\"\n    } else {\n  \n    \tatomicState.language = \"en\"\n    }\n    def message = atomicState.languageString.\"${atomicState.language}\".message2\n    connectionStatus(message)\n}\n\nprivate connectionStatus(message) {\n    def html = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width height=device-height\">\n       \n        <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\n        <title>SmartThings Connection</title>\n        <style type=\"text/css\">\n            @font-face {\n                font-family: 'Swiss 721 W01 Thin';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'Swiss 721 W01 Light';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            body {\n            \tmargin: 0;\n            \twidth : 100%;\n            }\n            .container {\n                width: 100%;\n            \n                /*background: #eee;*/\n                text-align: center;\n            }\n            img {\n                vertical-align: middle;\n                margin-top:20.3125vw;\n               \n            }\n            \n            .encored{\n            \twidth: 25vw;\n                height: 25vw;\n                margin-right : 8.75vw;\n            }\n            .chain {\n            \twidth:6.25vw;\n                height: 6.25vw;\n            }\n            .smartt {\n            \twidth: 25vw;\n                height: 25vw;\n                margin-left: 8.75vw\n            }\n           \t\n            p {\n                font-size: 21px;\n                font-weight: 300;\n                font-family: Roboto;\n                text-align: center;\n                color: #4c4c4e;\n                \n                margin-bottom: 0;\n            }\n        /*\n            p:last-child {\n                margin-top: 0px;\n            }\n        */\n            span {\n                font-family: 'Swiss 721 W01 Light';\n            }\n        </style>\n  \n        </head>\n        <body>\n            <div class=\"container\">\n                <img class=\"encored\" src=\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/appicon_enertalk.png\" alt=\"Encored icon\" />\n                <img class=\"chain\" src=\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/icon_link.svg\" alt=\"connected device icon\" />\n                <img class=\"smartt\" src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n                <p>${message}</p>\n                \n            </div>\n            \n        </body>\n        </html>\n\t\"\"\"\n\trender contentType: 'text/html', data: html\n}\n\nprivate refreshAuthToken() {\n\t/*Refreshing Encored Access Token*/\n    \n    log.debug \"Refreshing Encored Access Token\"\n\tif(!atomicState.encoredRefreshToken) {\n\t\tlog.error \"Encored Refresh Token does not exist!\"\n\t} else {\n    \n    \tdef authorization = \"Basic \" + \"${appSettings.clientId}:${appSettings.clientSecret}\".bytes.encodeBase64()\n    \tdef refreshParam = makePostParams(\"https://enertalk-auth.encoredtech.com/token\",\n        \t\t\t\t\t\t\t\t\t[Authorization: authorization],\n                                            [grant_type: 'refresh_token', refresh_token: \"${atomicState.encoredRefreshToken}\"])\n        \n        def newAccessToken = getHttpPostJson(refreshParam)\n        \n        if (newAccessToken) {\n        \tatomicState.encoredAccessToken = newAccessToken.access_token\n            log.debug \"Successfully got new Encored Access Token.\\n\"\n        } else {\n        \tlog.error \"Was unable to renew Encored Access Token.\\n\"\n        }\n    }\n}\n\nprivate getHttpPutJson(param) {\n\t\n    log.debug \"Put URI : ${param.uri}\"\n\ttry {\n       httpPut(param) { resp ->\n \t\t\tlog.debug \"HTTP Put Success\"\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Put Error : ${e}\"\n    }\n}\n\nprivate getHttpPostJson(param) {\n\tlog.debug \"Post URI : ${param.uri}\"\n   def jsonMap = null\n   try {\n       httpPost(param) { resp ->\n           jsonMap = resp.data\n           log.debug resp.data\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Post Error : ${e}\"\n    }\n    \n    return jsonMap\n}\n\nprivate getHttpGetJson(param, testLog) {\n\tlog.debug \"Get URI : ${param.uri}\"\n   def jsonMap = null\n   try {\n       httpGet(param) { resp ->\n           jsonMap = resp.data\n       }\n    } catch(groovyx.net.http.HttpResponseException e) {\n    \tlog.warn \"HTTP Get Error : ${e}\"\n    }\n    \n    return jsonMap\n\n}\n\nprivate makePostParams(uri, header, body=[]) {\n\treturn [\n    \turi : uri,\n        headers : header,\n        body : body\n    ]\n}\n\nprivate makeGetParams(uri, headers, path=\"\") {\n\treturn [\n    \turi : uri,\n        path : path,\n        headers : headers\n    ]\n}\n\ndef getInitialData() {\n\tdef lang = clientLocale?.language\n    if (\"${lang}\" == \"ko\") {\n    \tlang = \"ko\"\n    } else {\n        lang = \"en\"\n    }\n    atomicState.solutionModuleSettings.language = lang\n\tatomicState.solutionModuleSettings\n}\n\ndef consoleLog() {\n    log.debug \"console log: ${request.JSON.str}\"\n}\n\ndef getHtml() {\n\t\n    /* initializing variables */\n\tdef deviceStatusData = \"\", standbyData = \"\", meData = \"\", meteringData = \"\", rankingData = \"\", lastMonth = \"\", deviceId = \"\"\n\tdef standby = \"\", plan = \"\", start = \"\", end = \"\", meteringDay = \"\", meteringUsage = \"\", percent = \"\", tier = \"\", meteringPeriodBill = \"\"\n    def maxLimitUsageBill, maxLimitUsage = 0\n    def deviceStatus = false\n    def displayUnit = \"watt\"\n    \n    def meteringPeriodBillShow = \"\", meteringPeriodBillFalse = \"collecting data\"\n    def standbyShow = \"\", standbyFalse = \"collecting data\" \n    def rankingShow = \"collecting data\"\n    def tierShow = \"collecting data\"\n    def lastMonthShow = \"\", lastMonthFalse = \"no records\"\n    def planShow = \"\", planFalse = \"set up plan\"\n    \n    def thisMonthUnitOne =\"\", thisMonthUnitTwo = \"\", planUnitOne = \"\", planUnitTwo = \"\", lastMonthUnit = \"\", standbyUnit = \"\"\n    def thisMonthTitle = \"This Month\", tierTitle = \"Billing Tier\", planTitle = \"Energy Goal\", \n    lastMonthTitle = \"Last Month\", rankingTitle = \"Ranking\", standbyTitle = \"Always on\", energyMonitorDeviceTitle = \"EnerTalk Device\" , realtimeTitle = \"Realtime\"\n    def onOff = \"OFF\", rankImage = \"\", tierImage = \"\"\n    \n    def htmlBody = \"\"\n    \n    /* Get the language setting on device. */\n    def lang = clientLocale?.language\n    if (\"${lang}\" == \"ko\") {\n    \tatomicState.language = \"ko\"\n    } else {\n        atomicState.language = \"en\"\n    }\n    \n    if (atomicState.language == \"ko\") {\n        rankingShow = \"데이터 수집 중\"\n        meteringPeriodBillFalse = \"데이터 수집 중\" \n        lastMonthFalse = \"정보가 없습니다\" \n        standbyFalse = \"데이터 수집 중\"\n        planFalse = \"계획을 입력하세요\"\n        thisMonthTitle = \"이번 달\" \n        tierTitle = \"누진단계\" \n        planTitle = \"사용 계획\" \n        lastMonthTitle = \"지난달\" \n        rankingTitle = \"랭킹\" \n        standbyTitle = \"대기전력\" \n        energyMonitorDeviceTitle = \"스마트미터 상태\"\n        realtimeTitle = \"실시간\"\n    }\n    \n    /* check Encored Access Token */\n    def EATValidation = checkEncoreAccessTokenValidation()\n    log.debug EATValidation\n    /* check if uuid already exist or not.*/\n    if (EATValidation && atomicState.notPaired) {\n    \tgetUUID()\n    }\n    \n    /* If token has been verified or refreshed and if uuid exist, call other apis */\n    log.debug atomicState.notPaired\n    if (!atomicState.notPaired) {\n\n        if(EATValidation) {\n            /* make a parameter to get device status */\n            def deviceStatusParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/status\",\n                                                    [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n            /* get device status. */\n            deviceStatusData = getHttpGetJson(deviceStatusParam, 'CheckDeviceStatus')\n            \n\n            /* make a parameter to get standby value.*/\n            def standbyParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/standbyPower\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n            \n            /* get standby value */\n            standbyData = getHttpGetJson(standbyParam, 'CheckStandbyPower')\n            \n            \n\n            /* make a parameter to get user's info. */\n            def meParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/me\",\n                                        [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\t\t\t\n            /* Get user's info */\n            meData = getHttpGetJson(meParam, 'CheckMe')\n\t\t\t\n\t\t\n            /* make a parameter to get energy used since metering date */\n            def meteringParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/meteringUsage\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n            \n            /* Get the value of energy used since metering date. */\n            meteringData = getHttpGetJson(meteringParam, 'CheckMeteringUsage')\n\t\t\t\n            \n            /* make a parameter to get the energy usage ranking of a user. */\n            def rankingParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/ranking/usages/${atomicState.uuid}?state=current&period=monthly\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\t\t\t\n            /* Get user's energy usage rank */\n            rankingData = getHttpGetJson(rankingParam, 'CheckingRanking')\n\t\t\t\n            /* Parse the values from the returned value of api calls. Then use these values to inform user how much they have used or will use. */\n\n            /* parse device status. */\n            if (deviceStatusData) {\n                if (deviceStatusData.status == \"NORMAL\") {\n                    deviceStatus = true\n                }\n            }\n            \n            log.debug \"deiceStatusData : ${deviceStatus} || ${deviceStatusData}\"\n\n            /* Parse standby power. */\n            if (standbyData) {\n                if (standbyData.standbyPower) {\n                    standby = (standbyData.standbyPower / 1000)\n                }\n            }\n\n            /* Parse max limit usage and it's bill from user's info. */\n            if (meData) {\n                if (meData.maxLimitUsageBill) {\n                    maxLimitUsageBill = meData.maxLimitUsageBill\n                    maxLimitUsage = meData.maxLimitUsage\n                }\n            }\n\n            /* Parse the values which have been used since metering date.\n            * The list is :\n            *\tmeteringPeriodBill : A bill for energy usage.\n            *\tplan  : The left amount of bill until it reaches limit.\n            *\tstart : metering date in millisecond e.g. if the metering started on june and 1st, 2015,06,01\n            * \tend\t  : Today's date in millisecond\n            *\tmeteringDay : The day of the metering date. e.g. if the metering date is June 1st, then it will return 1.\n            *\tmeteringUSage : The amount of energy that user has used.\n            * \ttier : the level of energy use, tier exits from 1 to 6.\n            */\t\n            if (meteringData) {\n                if (meteringData.meteringPeriodBill) {\n                    meteringPeriodBill = meteringData.meteringPeriodBill\n                    plan = maxLimitUsageBill - meteringData.meteringPeriodBill\n                    start = meteringData.meteringStart\n                    end = meteringData.meteringEnd\n                    meteringDay = meteringData.meteringDay\n                    meteringUsage = meteringData.meteringPeriodUsage\n                    tier = ((int) (meteringData.meteringPeriodUsage / 100000000) + 1)\n                    if(tier > 6) {\n                        tier = 6\n                    }\n\n                } \n            }\n\n            /* Get ranking data of a user and the percent */\n            if (rankingData) {\n                if (rankingData.user.ranking) {\n                    percent = ((int)((rankingData.user.ranking / rankingData.user.population) * 10))\n                    if (percent > 10) {\n                        percent = 10\n                    }\n                }\n            }\n\n            /* if the start value exist, get last month energy usage. */\n            if (start) {\n                def lastMonthParam = makeGetParams( \"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/meteringUsages?period=monthly&start=${start}&end=${end}\",\n                                                [Authorization: \"Bearer ${atomicState.encoredAccessToken}\", ContentType: \"application/json\"])\n\n                lastMonth = getHttpGetJson(lastMonthParam, 'ChecklastMonth')\n\n            }\n\n            /* I decided to set values to device type handler, on loading solution module. \n            So, users may need to go back to solution module to update their device type handler. */\n            def d = getChildDevice(atomicState.dni)\n            def kWhMonth = Math.round(meteringUsage / 10000) / 100 /* milliwatt to kilowatt*/\n            def planUsed = 0\n            if ( maxLimitUsage > 0 ) {\n                planUsed = Math.round((meteringUsage / maxLimitUsage) * 100) /* get the pecent of used amount against max usage */\n            } else {\n                planUsed = Math.round((meteringUsage/ 1000000) * 100) /* if max was not decided let the used value be percent. e.g. 1kWh = 100% */\n            }\n\n            /* get realtime usage of user's device.*/\n            def realTimeParam = makeGetParams(\"${state.domains.\"${atomicState.env_mode}\"}/1.2/devices/${atomicState.uuid}/realtimeUsage\",\n                                              [Authorization: \"Bearer ${atomicState.encoredAccessToken}\"])\n            def realTimeInfo = getHttpGetJson(realTimeParam, 'CheckRealtimeinfo')\n\n            if (!realTimeInfo) {\n                realTimeInfo = 0\n            } else {\n                realTimeInfo = Math.round(realTimeInfo.activePower / 1000 )\n            }\n\t\t\t\n            \n            \n            /* inserting values to device type handler */\n            \n            d?.sendEvent(name: \"view\", value : \"${kWhMonth}\")\n            if (deviceStatus) {\n\n            \td?.sendEvent(name: \"month\", value : \"${thisMonthTitle} \\n ${kWhMonth} \\n kWh\")\n            } else { \n\n            \td?.sendEvent(name: \"month\", value : \"\\n ${state.languageString.\"${atomicState.language}\".message4.header} \\n\\n \" + \n                \t\t\t\t\t\t\t\t\t\"${state.languageString.\"${atomicState.language}\".message4.body1} \\n \" +\n               \t\t\t\t\t\t\t\t\t\t\"${state.languageString.\"${atomicState.language}\".message4.body2} \\n \" +\n                                                    \"${state.languageString.\"${atomicState.language}\".message4.body3}\")\t\n            }\n            \n            d?.sendEvent(name: \"real\", value : \"${realTimeInfo}w \\n\\n ${realtimeTitle}\")\n            d?.sendEvent(name: \"tier\", value : \"${tier} \\n\\n ${tierTitle}\")\n            d?.sendEvent(name: \"plan\", value : \"${planUsed}% \\n\\n ${planTitle}\")\n          \n            deviceId = d.id\n\n        } else {\n            /* If it finally couldn't get Encored access token. */\n            log.error \"Could not get Encored Access Token. Please try later.\"\n        }\n\n        /* change the display uinit to bill from kWh if user want. */\n        if (settings.displayUnit == \"WON(₩)\" || settings.displayUnit == \"원(₩)\") {\n            displayUnit = \"bill\"\n        }\n\n        if (meteringPeriodBill) {\n            /* reform the value of the bill with the , separator */\n            meteringPeriodBillShow = formatMoney(\"${meteringPeriodBill}\")\n            meteringPeriodBillFalse = \"\"\n            thisMonthUnitOne = \"&#x20A9;\"\n\n            def dayPassed = getDayPassed(start, end, meteringDay)\n            if (atomicState.language == 'ko') {\n                thisMonthUnitTwo = \"/ ${dayPassed}일\"\n            } else {\n                if (dayPassed == 1) {\n                    thisMonthUnitTwo = \"/${dayPassed} day\"\n                } else {\n                    thisMonthUnitTwo = \"/${dayPassed} days\"\n                }\n            }\n        }\n\n        if (plan) {\n            planShow = plan\n            if (plan >= 1000) {planShow = formatMoney(\"${plan}\") }\n            planFalse = \"\"\n            planUnitOne = \"&#x20A9;\"\n\n            if (atomicState.language == 'ko') {\n                planUnitTwo = \"남음\"\n            } else {\n                planUnitTwo = \"left\"\n            }\n\n        }\n\n        /*set the showing units for html.*/\n        log.debug lastMonth\n        if (lastMonth.usages) {\n            lastMonthShow = formatMoney(\"${lastMonth.usages[0].meteringPeriodBill}\")\n            lastMonthFalse = \"\"\n            lastMonthUnit = \"&#x20A9;\"\n       \n        }\n\n        if (standby) {\n            standbyShow = standby\n            standbyFalse = \"\"\n            standbyUnit = \"W\"\n        }\n\n        if (percent) {\n            rankImage = \"<img id=\\\"image-rank\\\" src=\\\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/ranking_${percent}.svg\\\" />\"\n            rankingShow = \"\"\n        }\n\n        if (tier) {\n            tierImage = \"<img id=\\\"image-tier\\\" src=\\\"https://s3-ap-northeast-1.amazonaws.com/smartthings-images/tier_${tier}.svg\\\" />\"\n            tierShow = \"\"\n        }\n\n        if (deviceStatus) {\n            onOff = \"ON\"\n        }\n\n        atomicState.solutionModuleSettings = [\n           auth           : atomicState.encoredAccessToken, \n           deviceState    : deviceStatus, \n           percent        : percent,\n           displayUnit    : displayUnit,\n           language\t\t  : atomicState.language,\n           deviceId\t      : deviceId,\n           pairing\t\t  : true\n        ]\n        \n        htmlBody = \"\"\"\n         <div id=\"real-time\">\n         \t\n            <!-- real-time card -->\n            <div id=\"my-card\"></div>\n            \n            <!-- this month section -->\n            <div class=\"contents head\" id=\"content1\">\n              <p class=\"key\" id=\"korean-this\">${thisMonthTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-this\">${thisMonthUnitOne}</p>\n                <p class=\"value\" id=\"value-this\">${meteringPeriodBillShow}</p>\n                <p class=\"value\" id=\"value-fail\">${meteringPeriodBillFalse}</p>\n                <p class=\"unit second\" id=\"unit-second-this\">${thisMonthUnitTwo}</p>\n              </span> \n            </div>\n            \n            <!-- Billing Tier section -->\n            <div class=\"contents tail\" id=\"content2\">\n              <p class=\"key\" id=\"korean-tier\">${tierTitle}</p>\n              <span class=\"value-block\">\n              \t<div id=\"value-block-tier\">${tierImage}</div>\n                <p class=\"value\" id=\"value-fail\">${tierShow}</p>\n              </span>\n            </div> \n            \n            <!-- Plan section -->\n            <div class=\"contents tail\" id=\"content3\">\n              <p class=\"key\" id=\"korean-plan\">${planTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-plan\">${planUnitOne}</p>\n                <p class=\"value\" id=\"value-plan\">${planShow}</p>\n                <p class=\"value\" id=\"value-fail\">${planFalse}</p>\n                <p class=\"unit second\" id=\"unit-second-plan\"> ${planUnitTwo}</p> \n              </span>\n            </div>\n            \n            <!-- Last Month section -->\n            <div class=\"contents tail\" id=\"content4\">\n              <p class=\"key\" id=\"korean-last\">${lastMonthTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"unit first\" id=\"unit-first-last\">${lastMonthUnit}</p>\n                <p class=\"value\" id=\"value-last\">${lastMonthShow}</p>\n                <p class=\"value\" id=\"value-fail\">${lastMonthFalse}</p>\n              </span>\n            </div>\n\n            <!-- Ranking section -->\n            <div class=\"contents tail\" id=\"content5\">\n              <p class=\"key\" id=\"korean-ranking\">${rankingTitle}</p>\n              <span class=\"value-block\">\n              <div id=\"value-block-rank\">${rankImage}</div>\n              <p class=\"value\" id=\"value-fail\">${rankingShow}</p>\n              </span>\n            </div> \n            \n            <!-- Standby section -->\n            <div class=\"contents tail\" id=\"content6\">\n              <p class=\"key\" id=\"korean-standby\">${standbyTitle}</p>\n              <span class=\"value-block\">\n                <p class=\"value\" id=\"value-standby\">${standbyShow}</p>\n                <p class=\"value\" id=\"value-fail\">${standbyFalse}</p>\n                <p class=\"unit third\" id=\"unit-third-standby\">${standbyUnit}<p>\n              </span>\n            </div>\n            \n            <!-- Device status section -->\n            <div class=\"contents tail\" id=\"content7\">\n              <p class=\"key\" id=\"korean-device\">${energyMonitorDeviceTitle}</p>\n              <span class=\"value-block\">\n                <div class=\"circle\"></div>\n                <p class=\"value last\" id=\"value-ON-OFF\">${onOff}</p>\n              </span>\n            </div>\n            \n          </div>\n          \n          <!-- hidden section -->\n          \n\t\t  <div id=\"this-month\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-this\">${thisMonthTitle}</p>\n              <button class=\"st-show\" id=\"show\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card2\"></div>\n            <div class=\"cards\" id=\"my-card3\"></div>\n          </div>\n          \n          <div id=\"last-month\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-last\">${lastMonthTitle}</p>\n              <button class=\"st-show\" id=\"show2\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card4\"></div>\n          </div>\n          \n          <div id=\"progressive-step\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-tier\">${tierTitle}</p>\n              <button class=\"st-show\" id=\"show3\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card5\"></div>\n          </div>\n          \n          <div id=\"ranking\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-ranking\">${rankingTitle}</p>\n              <button class=\"st-show\" id=\"show4\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card6\"></div>\n          </div>\n          \n          <div id=\"plan\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-plan\">${planTitle}</p>\n              <button class=\"st-show\" id=\"show5\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card7\"></div>\n          </div>\n          \n          <div id=\"standby\">\n            <div class=\"card-header\">\n              <p class=\"st-title\" id=\"korean-title-standby\">${standbyTitle}</p>\n              <button class=\"st-show\" id=\"show6\">X</button>\n            </div>\n            <div class=\"cards\" id=\"my-card8\"></div>\n          </div>\n          <script>\n          \t     \\$(\"#this-month\").slideUp();\n                \\$(\"#last-month\").slideUp();\n                \\$(\"#progressive-step\").slideUp();\n                \\$(\"#ranking\").slideUp();\n                \\$(\"#plan\").slideUp();\n                \\$(\"#standby\").slideUp();\n\n                var UI = new Encored.UI({\n        \n                });\n                UI.renderCard({\n            \t   'cards': [{\n                \t'id': 'ui:h:strealtime:v1', \n                    'params': {\n                                'lang': '${atomicState.language}', \n                                'useDemoLabel': 1, \n                                'displayUnit': '${displayUnit}'\n\t\t\t\t\t}\n\t\t\t\t    }], \n                    'accessToken': '${atomicState.encoredAccessToken}', \n                    'target': document.getElementById(\"my-card\")\n\t\t\t     });\n          </script>\n        <script src=\"${buildResourceUrl('javascript/app.js')}\"></script>\n        \n        \"\"\"\n    } else {\n\t\tlog.debug \"abotu to ask device connection\"\n    \tdef d = getChildDevice(atomicState.dni)\n        /* inserting values to device type handler */ \n\n        d?.sendEvent(name: \"month\", value : \"\\n ${state.languageString.\"${atomicState.language}\".message3.header} \\n\\n ${state.languageString.\"${atomicState.language}\".message3.body1} \\n ${state.languageString.\"${atomicState.language}\".message3.body2}\")\n        deviceId = d.id\n\t\t\n        if (state.language == \"ko\") {\n        \tenergyMonitorDeviceTitle = \"스마트미터 상태\"\t\n        }\n    \t/* need device pairing */\n        atomicState.solutionModuleSettings = [\n        \tdId\t\t: deviceId,\n            pairing\t: false\n        ]\n  \n        htmlBody = \"\"\"\n        \n         \t<div id=\"real-time\">\n        \n            \t<!-- real-time card -->\n                <div id=\"st-pairing-card\">\n                \t<p class=\"st-pairing-card-header\" align=\"center\">${state.languageString.\"${atomicState.language}\".message3.header}</p>\n                \t<p class=\"st-pairing-card-body\" align=\"center\"> ${state.languageString.\"${atomicState.language}\".message3.body1} <br/> ${state.languageString.\"${atomicState.language}\".message3.body2}</p>\n                \t<div id=\"st-deep-link-container\"></div>\n                </div>\n\n\n\n                <!-- Device status section -->\n                <div class=\"contents tail\" id=\"content7\">\n                  <p class=\"key\">${energyMonitorDeviceTitle}</p>\n                  <span class=\"value-block\">\n                    <p class=\"value last\">${state.languageString.\"${atomicState.language}\".message3.button2}</p>\n                  </span>\n                </div>\n            \n          \t</div>\n\t\t  \n          \t<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js\"></script>\n            <script src=\"${buildResourceUrl('javascript/app.js')}\"></script>\n            <script>\n                var ua = navigator.userAgent.toLowerCase();\n                var isAndroid = ua.indexOf(\"android\") > -1; //&& ua.indexOf(\"mobile\");\n                if(!isAndroid) { \n                \t\\$(\"#st-deep-link-container\").html(\"<a id=\\'st-deep-link\\' href=\\'https://itunes.apple.com/kr/app/enertalk-for-home/id1024660780?mt=8\\'><p class=\\'st-deep-text\\'>${state.languageString.\"${state.language}\".message3.button1}</p></a>\");\n\t\t\t\t} else {\n                \t\\$(\"#st-deep-link-container\").html(\"<a id=\\'st-deep-link\\' href=\\'market://details?id=com.ionicframework.enertalkhome874425\\'><p class=\\'st-deep-text\\'>${state.languageString.\"${state.language}\".message3.button1}</p></a>\");\n                };\n            </script>\n        \"\"\"\n    }\n\n    renderHTML() {\n        head {\n        \"\"\"\n        \t<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, height=device-height\">\n            <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\n            <link rel=\"stylesheet\" href=\"${buildResourceUrl('css/app.css')}\" type=\"text/css\">\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/0.7.18/webcomponents-lite.min.js\"></script>\n            <script src=\"https://enertalk-card.encoredtech.com/sdk.js\"></script>\n            <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js\"></script>\n        \"\"\"\n        }\n        body {\n        \thtmlBody\n        }\n    }\n}\n\n\n/* put commas for money or if there are things that need to have a comma separator.*/\nprivate formatMoney(money) {\n\tdef i = money.length()-1\n    def ret = \"\"\n    def commas = ((int) Math.floor(i/3))\n\n    def j = 0\n    def counter = 0\n \n    while (i >= 0) {\n\n        if (counter > 0 && (counter % 3) == 0) {\n        \tret = \"${money[i]},${ret}\"\n            j++\n        } else {\n        \tret = \"${money[i]}${ret}\"\n        }\n        \n        counter++\n\t\ti--\n\t}\n    \n    ret\n}\n\n/* Count how many days have been passed since metering day:\n* \tif metering day < today, it returns today - metering day\n*\telse if metering day > today, it calcualtes how many days have been passed since meterin day and return calculated value.\n*\telse return 1 (today).\n*/\nprivate getDayPassed(start, end, meteringDay){\n    \n    def day = 1\n    def today = new Date(end)\n    def tzDifference = 9 * 60 + today.getTimezoneOffset()\n\ttoday = new Date(today.getTime() + tzDifference * 60 * 1000).getDate();\n    \n    if (today > meteringDay) {\n        day += today - meteringDay;\n       \n    }\n    if (today < meteringDay) {\n        def startDate = new Date(start);\n        def month = startDate.getMonth();\n        def year = startDate.getYear();\n        def lastDate = new Date(year, month, 31).getDate();\n \n        if (lastDate == 1) {\n            day += 30;\n        } else {\n            day += 31;\n        }\n        \n        day = day - meteringDay + today;\n    }\n    \n    day\n}\n\n/* Get Encored push and send the notification. */\ndef getEncoredPush() {\n\n\tbyte[] decoded = \"${params.msg}\".decodeBase64()\n\tdef decodedString = new String(decoded)\n\n    if (settings.notification == \"true\") {\n    \tsendNotification(\"${decodedString}\", [method: \"push\"])\n    } else {\n    \tsendNotificationEvent(\"${decodedString}\")\n    }\n    \n}",
        "docstring": "With visible realtime energy usage status, have good energy habits and enrich your life\\r\\n"
    },
    {
        "code": "section(\"Control these switch levels...\") {\n        input \"switchlevels\", \"capability.switchLevel\", multiple:true, required:false\n    }\n/*    section(\"Control these thermostats...\") {\n        input \"thermostats\", \"capability.thermostat\", multiple:true, required:false\n    }*/\n    section(\"Control the color for these devices...\") {\n        input \"colors\", \"capability.colorControl\", multiple:true, required:false\n    }\n    section(\"Control the color temperature for these devices...\") {\n        input \"kelvin\", \"capability.colorTemperature\", multiple:true, required:false\n    }\n\tsection(\"Control these switches...\") {\n        input \"switches\", \"capability.switch\", multiple:true, required:false\n    }\n    section(\"Control these smoke alarms...\") {\n        input \"smoke_alarms\", \"capability.smokeDetector\", multiple:true, required:false\n    }\n    section(\"Control these window shades...\") {\n        input \"shades\", \"capability.windowShade\", multiple:true, required:false\n    }\n    section(\"Control these garage doors...\") {\n        input \"garage\", \"capability.garageDoorControl\", multiple:true, required:false\n    }\n    section(\"Control these water sensors...\") {\n        input \"water_sensors\", \"capability.waterSensor\", multiple:true, required:false\n    }\n    section(\"Control these motion sensors...\") {\n        input \"motions\", \"capability.motionSensor\", multiple:true, required:false\n    }\n    section(\"Control these presence sensors...\") {\n    \tinput \"presence_sensors\", \"capability.presenceSensor\", multiple:true, required:false\n    }\n\tsection(\"Control these outlets...\") {\n    \tinput \"outlets\", \"capability.outlet\", multiple:true, required:false\n    }\n    section(\"Control these power meters...\") {\n        input \"meters\", \"capability.powerMeter\", multiple:true, required:false\n    }\n    section(\"Control these locks...\") {\n    \tinput \"locks\", \"capability.lock\", multiple:true, required:false\n    }\n    section(\"Control these temperature sensors...\") {\n\t    input \"temperature_sensors\", \"capability.temperatureMeasurement\", multiple:true, required:false\n    }\n    section(\"Control these batteries...\") {\n\t    input \"batteries\", \"capability.battery\", multiple:true, required:false\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n}\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.label, type: type] : null\n}\n\n//API Mapping\nmappings {\n   path(\"/getalldevices\") {\n    action: [\n      \tGET: \"getAllDevices\"\n   ]\n  }\n  /*\n  path(\"/thermostat/setcool/:id/:temp\") {\n    action: [\n      GET: \"setCoolTemp\"\n    ]\n  }\n  path(\"/thermostat/setheat/:id/:temp\") {\n    action: [\n      GET: \"setHeatTemp\"\n    ]\n  }\n  path(\"/thermostat/setfanmode/:id/:mode\") {\n    action: [\n      GET: \"setFanMode\"\n    ]\n  }\n  path(\"/thermostat/setmode/:id/:mode\") {\n    action: [\n      GET: \"setThermostatMode\"\n    ]\n  }\n  path(\"/thermostat/:id\") {\n    action: [\n      GET: \"getThermostatStatus\"\n    ]\n  }\n  */\n  path(\"/light/dim/:id/:dim\") {\n    action: [\n      GET: \"setLevelStatus\"\n    ]\n  }\n  path(\"/light/kelvin/:id/:kelvin\") {\n    action: [\n      GET: \"setKelvin\"\n    ]\n  }\n  path(\"/colorlight/:id/:hue/:sat\") {\n    action: [\n      GET: \"setColor\"\n    ]\n  }\n  path(\"/light/status/:id\") {\n    action: [\n      GET: \"getLightStatus\"\n    ]\n  }\n  path(\"/light/on/:id\") {\n    action: [\n      GET: \"turnOnLight\"\n    ]\n  }\n  path(\"/light/off/:id\") {\n    action: [\n      GET: \"turnOffLight\"\n    ]\n  }\n  path(\"/doorlocks/lock/:id\") {\n    action: [\n      GET: \"lockDoorLock\"\n    ]\n  }\n  path(\"/doorlocks/unlock/:id\") {\n    action: [\n      GET: \"unlockDoorLock\"\n    ]\n  }\n  path(\"/doorlocks/:id\") {\n    action: [\n      GET: \"getDoorLockStatus\"\n    ]\n  }\n  path(\"/contacts/:id\") {\n    action: [\n  \tGET: \"getContactStatus\"\n    ]\n  }\n  path(\"/smoke/:id\") {\n    action: [\n   \tGET: \"getSmokeStatus\"\n\t]\n  }\n    path(\"/shades/open/:id\") {\n    action: [\n      GET: \"openShade\"\n    ]\n  }\n  path(\"/shades/preset/:id\") {\n    action: [\n      GET: \"presetShade\"\n    ]\n  }\n  path(\"/shades/close/:id\") {\n    action: [\n      GET: \"closeShade\"\n    ]\n  }\n  \tpath(\"/shades/:id\") {\n    action: [\n\tGET: \"getShadeStatus\"\n\t]\n}\n    path(\"/garage/open/:id\") {\n    action: [\n      GET: \"openGarage\"\n    ]\n  }\n  path(\"/garage/close/:id\") {\n    action: [\n      GET: \"closeGarage\"\n    ]\n  }\n  \tpath(\"/garage/:id\") {\n    action: [\n  \t\tGET: \"getGarageStatus\"\n  \t]\n  }\n    path(\"/watersensors/:id\") {\n    action: [\n      \t\tGET: \"getWaterSensorStatus\"\n    \t]\n  }\n  \tpath(\"/tempsensors/:id\") {\n    action: [\n      GET: \"getTempSensorsStatus\"\n    ]\n  }\n  path(\"/meters/:id\") {\n    action: [\n      GET: \"getMeterStatus\"\n    ]\n  }\n  path(\"/batteries/:id\") {\n    action: [\n      GET: \"getBatteryStatus\"\n    ]\n  }\n  \tpath(\"/presences/:id\") {\n    action: [\n      GET: \"getPresenceStatus\"\n    ]\n  }\n  \tpath(\"/motions/:id\") {\n    action: [\n      GET: \"getMotionStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id\") {\n    action: [\n      GET: \"getOutletStatus\"\n    ]\n  }\n  \tpath(\"/outlets/turnon/:id\") {\n    action: [\n      GET: \"turnOnOutlet\"\n    ]\n  }\n  path(\"/outlets/turnoff/:id\") {\n    action: [\n      GET: \"turnOffOutlet\"\n    ]\n  }\n  path(\"/switches/turnon/:id\") {\n    action: [\n      GET: \"turnOnSwitch\"\n    ]\n  }\n  path(\"/switches/turnoff/:id\") {\n    action: [\n      GET: \"turnOffSwitch\"\n    ]\n  }\n  path(\"/switches/:id\") {\n    action: [\n      GET: \"getSwitchStatus\"\n    ]\n  }\n}\n\n//API Methods\ndef getAllDevices() {\n    def locks_list = locks.collect{device(it,\"Lock\")}\n    /*def thermo_list = thermostats.collect{device(it,\"Thermostat\")}*/\n    def colors_list = colors.collect{device(it,\"Color\")}\n    def kelvin_list = kelvin.collect{device(it,\"Kelvin\")}\n    def contact_list = contact.collect{device(it,\"Contact Sensor\")}\n    def smokes_list = smoke_alarms.collect{device(it,\"Smoke Alarm\")}\n    def shades_list = shades.collect{device(it,\"Window Shade\")}\n    def garage_list = garage.collect{device(it,\"Garage Door\")}\n    def water_sensors_list = water_sensors.collect{device(it,\"Water Sensor\")}\n    def presences_list = presence_sensors.collect{device(it,\"Presence\")}\n    def motions_list = motions.collect{device(it,\"Motion\")}\n\tdef outlets_list = outlets.collect{device(it,\"Outlet\")}\n    def switches_list = switches.collect{device(it,\"Switch\")}\n    def switchlevels_list = switchlevels.collect{device(it,\"Switch Level\")}\n    def temp_list = temperature_sensors.collect{device(it,\"Temperature\")}\n    def meters_list = meters.collect{device(it,\"Power Meters\")}\n    def battery_list = batteries.collect{device(it,\"Batteries\")}\n    return outlets_list + kelvin_list + colors_list + switchlevels_list + smokes_list + contact_list + water_sensors_list + shades_list + garage_list + locks_list + presences_list + motions_list + switches_list + temp_list + meters_list + battery_list\n}\n\n//thermostat\n/*\ndef setCoolTemp() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(device.hasCommand(\"setCoolingSetpoint\")) {\n            \tdevice.setCoolingSetpoint(params.temp.toInteger());\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setHeatTemp() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(device.hasCommand(\"setHeatingSetpoint\")) {\n            \tdevice.setHeatingSetpoint(params.temp.toInteger());\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setFanMode() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        if(device.hasCommand(\"setThermostatFanMode\")) {\n            \tdevice.setThermostatFanMode(params.mode);\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef setThermostatMode() {\n\tdef device = thermostats.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        if(device.hasCommand(\"setThermostatMode\")) {\n            \tdevice.setThermostatMode(params.mode);\n                return [result_action: \"200\"]\n            }\n            else {\n            \thttpError(510, \"Not supported!\")\n            }\n       }\n}\ndef getThermostatStatus() {\n\tdef device = thermostats.find{ it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [ThermostatOperatingState: device.currentValue('thermostatOperatingState'), ThermostatSetpoint: device.currentValue('thermostatSetpoint'), \n            \t\t\tThermostatFanMode: device.currentValue('thermostatFanMode'), ThermostatMode: device.currentValue('thermostatMode')]\n       \t}\n}\n*/\n//light\ndef turnOnLight() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            device.on();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n    }\n\ndef turnOffLight() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            device.off();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\ndef getLightStatus() {\n\tdef device = switches.find{ it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Status: device.currentValue('switch'), Dim: getLevelStatus(params.id), Color: getColorStatus(params.id), Kelvin: getKelvinStatus(params.id)]\n        }\n}\n\n//color control\ndef setColor() {\n    def device = colors.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \t\n            def map = [hue:params.hue.toInteger(), saturation:params.sat.toInteger()]\n            \n            device.setColor(map);\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n    }\n}\n\ndef getColorStatus(id) {\n\tdef device = colors.find { it.id == id }\n    if (!device) {\n            return [Color: \"none\"]\n        } else {\n        \treturn [hue: device.currentValue('hue'), saturation: device.currentValue('saturation')]\n        }\n}\n\n//kelvin control\ndef setKelvin() {\n    def device = kelvin.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \n            device.setColorTemperature(params.kelvin.toInteger());\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n    }\n}\n\ndef getKelvinStatus(id) {\n\tdef device = kelvin.find { it.id == id }\n    if (!device) {\n            return [kelvin: \"none\"]\n        } else {\n        \treturn [kelvin: device.currentValue('colorTemperature')]\n        }\n}\n\n//switch level\ndef getLevelStatus() {\n\tdef device = switchlevels.find { it.id == params.id }\n    if (!device) {\n            [Level: \"No dimmer\"]\n        } else {\n        \treturn [Level: device.currentValue('level')]\n        }\n}\n\ndef getLevelStatus(id) {\n\tdef device = switchlevels.find { it.id == id }\n    if (!device) {\n            [Level: \"No dimmer\"]\n        } else {\n        \treturn [Level: device.currentValue('level')]\n        }\n}\n\n\ndef setLevelStatus() {\n\tdef device = switchlevels.find { it.id == params.id }\n    def level = params.dim\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdevice.setLevel(level.toInteger())\n        \treturn [result_action: \"200\", Level: device.currentValue('level')]\n        }\n}\n\n\n//contact sensors\ndef getContactStatus() {\n\tdef device = contact.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef args = getTempSensorsStatus(device.id)\n        \treturn [Device_state: device.currentValue('contact')] + args\n        }\n}\n\n//smoke detectors\ndef getSmokeStatus() {\n\tdef device = smoke_alarms.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        def bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('smoke')] + bat\n        }\n}\n\n//garage\ndef getGarageStatus() {\n\tdef device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('door')]\n        }\n}\n\ndef openGarage() {\n    def device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.open();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef closeGarage() {\n\tdef device = garage.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.close();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n//shades\ndef getShadeStatus() {\n\tdef device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('windowShade')]\n        }\n}\n\ndef openShade() {\n    def device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.open();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n    \ndef presetShade() {\n    def device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.presetPosition();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef closeShade() {\n\tdef device = shades.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.close();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\n//water sensor\ndef getWaterSensorStatus() {\n\tdef device = water_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('water')] + bat\n        }\n}\n//batteries\ndef getBatteryStatus() {\n\tdef device = batteries.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.latestValue(\"battery\")]\n        }\n}\n\ndef getBatteryStatus(id) {\n\tdef device = batteries.find { it.id == id }\n    if (!device) {\n            return []\n        } else {\n        \treturn [battery_state: device.latestValue(\"battery\")]\n        }\n}\n\n//LOCKS\ndef getDoorLockStatus() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('lock')] + bat\n        }\n}\n\ndef lockDoorLock() {\n    def device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.lock();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n\ndef unlockDoorLock() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.unlock();\n                  \n            return [Device_id: params.id, result_action: \"200\"]                              \n            }\n    }\n//PRESENCE\ndef getPresenceStatus() {\n\n\tdef device = presence_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        def bat = getBatteryStatus(device.id)\n        \treturn [Device_state: device.currentValue('presence')] + bat\n   }\n}\n\n//MOTION\ndef getMotionStatus() {\n\n\tdef device = motions.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef args = getTempSensorsStatus(device.id)\n        \treturn [Device_state: device.currentValue('motion')] + args\n   }\n}\n\n//OUTLET\ndef getOutletStatus() {\n\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n     def watt = getMeterStatus(device.id)\n       \t\n     return [Device_state: device.currentValue('switch')] + watt\n}\n\ndef getMeterStatus() {\n\n    def device = meters.find { it.id == params.id }\n   \tif (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_id: device.id, Device_type: device.type, Current_watt: device.currentValue(\"power\")]\n  }\n}\n\ndef getMeterStatus(id) {\n\n    def device = meters.find { it.id == id }\n   \tif (!device) {\n            return []\n        } else {\n        \treturn [Current_watt: device.currentValue(\"power\")]\n  }\n}\n\n\ndef turnOnOutlet() {\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n     \n     device.on();\n                  \n     return [Device_id: params.id, result_action: \"200\"]\n}\n\ndef turnOffOutlet() {\n    def device = outlets.find { it.id == params.id }\n    if (!device) {\n            device = switches.find { it.id == params.id }\n            if(!device) {\n            \thttpError(404, \"Device not found\")\n        \t}\n     }\n            \n     device.off();\n                  \n     return [Device_id: params.id, result_action: \"200\"]\n}\n\n//SWITCH\ndef getSwitchStatus() {\n\tdef device = switches.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('switch'), Dim: getLevelStatus(params.id)]\n\t}\n}\n\ndef turnOnSwitch() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.on();\n                  \n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\ndef turnOffSwitch() {\n    def device = switches.find { it.id == params.id }\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            \n            device.off();\n            return [Device_id: params.id, result_action: \"200\"]\n        }\n}\n\n\n//TEMPERATURE\ndef getTempSensorsStatus() {\n    def device = temperature_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n            def scale = [Scale: location.temperatureScale]\n        \treturn [Device_state: device.currentValue('temperature')] + scale + bat\n   }\n}\n\ndef getTempSensorsStatus(id) {\t\n    def device = temperature_sensors.find { it.id == id }\n    if (!device) {\n            return []\n        } else {\n        \tdef bat = getBatteryStatus(device.id)\n            def scale = [Scale: location.temperatureScale]\n        \treturn [temperature: device.currentValue('temperature')] + bat + scale\n   \t\t}\n   }",
        "docstring": "Gideon Smart Home SmartApp allows you to connect and control all of your SmartThings devices through the Gideon app, making your SmartThings devices even smarter."
    },
    {
        "code": "section(\"Control these motion sensors...\") {\n        input \"motions\", \"capability.motionSensor\", multiple:true\n    }\n    section(\"Control these presence sensors...\") {\n    \tinput \"presence_sensors\", \"capability.presenceSensor\", multiple:true\n    }\n    section(\"Control these outlets...\") {\n    \tinput \"outlets\", \"capability.switch\", multiple:true\n    }\n    section(\"Control these locks...\") {\n    \tinput \"locks\", \"capability.lock\", multiple:true\n    }\n    section(\"Control these locks...\") {\n\t    input \"temperature_sensors\", \"capability.temperatureMeasurement\"\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n    subscribe(outlet, \"energy\", outletHandler)\n  \tsubscribe(outlet, \"switch\", outletHandler)\n}\n\n// TODO: implement event handlers\ndef outletHandler(evt) {\n\tlog.debug \"$outlet.currentEnergy\"\n\t//TODO call G API  \n}\n\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.label, type: type] : null\n}\n\n//API Mapping\nmappings {\n\tpath(\"/getalldevices\") {\n    action: [\n      \t\t\tGET: \"getAllDevices\"\n    \t\t]\n  \t}\n\tpath(\"/doorlocks/:id/:command\") {\n    action: [\n      GET: \"updateDoorLock\"\n    ]\n  }\n  \tpath(\"/doorlocks/:id\") {\n    action: [\n      \t\t\tGET: \"getDoorLockStatus\"\n    \t\t]\n  \t}\n  \tpath(\"/tempsensors/:id\") {\n    action: [\n      GET: \"getTempSensorsStatus\"\n    ]\n  }\n  \tpath(\"/presences/:id\") {\n    action: [\n      GET: \"getPresenceStatus\"\n    ]\n  }\n  \tpath(\"/motions/:id\") {\n    action: [\n      GET: \"getMotionStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id\") {\n    action: [\n      GET: \"getOutletStatus\"\n    ]\n  }\n  \tpath(\"/outlets/:id/:command\") {\n    action: [\n      GET: \"updateOutlet\"\n    ]\n  }\n  \tpath(\"/switches/:command\") {\n    action: [\n      PUT: \"updateSwitch\"\n    ]\n  }\n}\n\n//API Methods\ndef getAllDevices() {\n\tdef locks_list = locks.collect{device(it,\"Lock\")}\n    def presences_list = presence_sensors.collect{device(it,\"Presence\")}\n    def motions_list = motions.collect{device(it,\"Motion\")}\n    def outlets_list = outlets.collect{device(it,\"Outlet\")}\n    def switches_list = switches.collect{device(it,\"Switch\")}\n    def temp_list = temperature_sensors.collect{device(it,\"Temperature\")}\n    return [Locks: locks_list, Presences: presences_list, Motions: motions_list, Outlets: outlets_list, Switches: switches_list, Temperatures: temp_list]\n}\n\n//LOCKS\ndef getDoorLockStatus() {\n\tdef device = locks.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('lock')]\n        }\n}\n\ndef updateDoorLock() {\n\tdef command = params.command\n    def device = locks.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentValue('lock') == \"locked\")\n                  device.unlock();\n                else\n                  device.lock();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}\n\n//PRESENCE\ndef getPresenceStatus() {\n\n\tdef device = presence_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('presence')]\n   }\n}\n\n//MOTION\ndef getMotionStatus() {\n\n\tdef device = motions.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('motion')]\n   }\n}\n\n//OUTLET\ndef getOutletStatus() {\n\t\n    def device = outlets.find { it.id == params.id }\n   \tif (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentSwitch, Current_watt: device.currentValue(\"energy\")]\n  }\n}\n\ndef updateOutlet() {\n\t\n    def command = params.command\n    def device = outlets.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentSwitch == \"on\")\n                  device.off();\n                else\n                  device.on();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}                \n\n//SWITCH\ndef updateSwitch() {\n    def command = params.command\n    def device = switches.find { it.id == params.id }\n    if (command){\n        if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n            if(command == \"toggle\")\n            {\n                if(device.currentSwitch == \"on\")\n                  device.off();\n                else\n                  device.on();\n                  \n                return [Device_id: params.id, result_action: \"200\"]\n            }\n        }\n    }\n}\n\n//TEMPERATURE\ndef getTempSensorsStatus() {\n\t\n    def device = temperature_sensors.find { it.id == params.id }\n    if (!device) {\n            httpError(404, \"Device not found\")\n        } else {\n        \treturn [Device_state: device.currentValue('temperature')]\n   }\n}",
        "docstring": "Gideon AI Smart app allows you to connect and control all of your SmartThings devices through the Gideon AI app, making your SmartThings devices even smarter."
    },
    {
        "code": "section(\"Bathroom humidity sensor\") {\n\t\tinput \"bathroom\", \"capability.relativeHumidityMeasurement\", title: \"Which humidity sensor?\"\n\t}\n    section(\"Coffee maker to turn on\") {\n    \tinput \"coffee\", \"capability.switch\", title: \"Which switch?\"\n    }\n    section(\"Humidity level to switch coffee on at\") {\n    \tinput \"relHum\", \"number\", title: \"Humidity level?\", defaultValue: 50\n    }\n}\n\ndef installed() {\n\tsubscribe(bathroom, \"humidity\", coffeeMaker)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(bathroom, \"humidity\", coffeeMaker)\n}\n\ndef coffeeMaker(shower) {\n\tlog.info \"Humidity value: $shower.value\"\n\tif (shower.value.toInteger() > relHum) {\n\t\tcoffee.on()\n    } \n}",
        "docstring": "This app is designed simply to turn on your coffee machine while you are taking a shower."
    },
    {
        "code": "section(\"But not when they open this door?\") {\n      input name: \"openSensor\", type: \"capability.contactSensor\", title: \"Where?\"\n    }\n\n    section(\"Knock Delay (defaults to 5s)?\") {\n      input name: \"knockDelay\", type: \"number\", title: \"How Long?\", required: false\n    }\n\n    section(\"Notifications\") {\n      input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata: [values: [\"Yes\", \"No\"]], required: false\n      if (phone) {\n        input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n      }\n    }\n    section([mobileOnly:true]) {\n      label title: \"Assign a name\", required: false\n      mode title: \"Set for specific mode(s)\"\n    }\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastClosed = 0\n  subscribe(knockSensor, \"acceleration.active\", handleEvent)\n  subscribe(openSensor, \"contact.closed\", doorClosed)\n}\n\ndef doorClosed(evt) {\n  state.lastClosed = now()\n}\n\ndef doorKnock() {\n  if((openSensor.latestValue(\"contact\") == \"closed\") &&\n    (now() - (60 * 1000) > state.lastClosed)) {\n    def kSensor = knockSensor.label ?: knockSensor.name\n    log.debug(\"${kSensor} detected a knock.\")\n    send(kSensor)\n  }\n\n  else {\n    log.debug(\"${knockSensor.label ?: knockSensor.name} knocked, but looks like it was just someone opening the door.\")\n  }\n}\n\ndef handleEvent(evt) {\n  def delay = knockDelay ?: 5\n  runIn(delay, \"doorKnock\")\n}\n\nprivate send(kSensor) {\n  // Pabal translation code and params\n  String code = 'SmartApps_DoorKnocker_V_0001'\n  List params = [\n    [\n      'n': '${knockSensor.name}',\n      'value': kSensor\n    ]\n  ]\n\n  // Legacy push/SMS message and args\n  String msg = \"{{kSensor}} detected a knock.\"\n  Map msgArgs = [kSensor: kSensor]\n\n  Map options = [\n    code: code,\n    params: params,\n    messageArgs: msgArgs,\n    translatable: true\n  ]\n\n  Boolean pushNotification = (sendPushMessage != \"No\")\n\n  if (pushNotification || phone) {\n    log.debug \"Sending Notification\"\n    options += [\n      method: (pushNotification && phone) ? \"both\" : (pushNotification ? \"push\" : \"sms\"),\n      phone: phone\n    ]\n    sendNotification(msg, options)\n  }\n}",
        "docstring": "Alert if door is knocked, but not opened."
    },
    {
        "code": "section(\"Alarms to go off?\") {\n    input \"alarms\", \"capability.alarm\",  title: \"Which Alarms?\",         multiple: true, required: false\n    input \"lights\", \"capability.switch\", title: \"Turn on which lights?\", multiple: true, required: false\n  }\n\n  section(\"Delay for presence lag?\") {\n    input name: \"presenceDelay\", type: \"number\", title: \"Seconds (defaults to 15s)\", required: false\n  }\n\n  section(\"Notifications?\") {\n    input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata: [values: [\"Yes\", \"No\"]], required: false\n    input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n  }\n\n  section(\"Message interval?\") {\n    input name: \"messageDelay\", type: \"number\", title: \"Minutes (default to every message)\", required: false\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastTrigger    = now()\n  state.deviceTriggers = []\n  subscribe(contacts, \"contact.open\",  triggerAlarm)\n  subscribe(motions,  \"motion.active\", triggerAlarm)\n}\n\ndef triggerAlarm(evt) {\n  def presenceDelay = presenceDelay ?: 15\n\n  if(now() - (presenceDelay * 1000) > state.lastTrigger) {\n    log.warn(\"Stale event - ignoring\")\n\n    state.deviceTriggers = []\n  }\n\n  state.deviceTriggers.add(evt.displayName)\n  state.triggerMode = location.mode\n  state.lastTrigger = now()\n\n  log.info(evt.displayName + \" triggered an alarm.  Waiting for presence lag.\")\n  runIn(presenceDelay, \"fireAlarm\")\n}\n\ndef fireAlarm() {\n  if(state.deviceTriggers.size() > 0) {\n    def devices = state.deviceTriggers.unique().join(\", \")\n\n    if(location.mode == state.triggerMode) {\n      log.info(devices + \" alarm triggered and mode hasn't changed.\")\n      send(devices + \" alarm has been triggered!\")\n      lights?.on()\n      alarms?.both()\n    }\n\n    else {\n      log.info(devices + \" alarm triggered, but it looks like you were just coming home.  Ignoring.\")\n    }\n  }\n\n  state.deviceTriggers = []\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}",
        "docstring": "Alerts you if something happens while you're away.  Has a settable grace period to compensate for presence sensors that may take a few seconds to be noticed."
    },
    {
        "code": "section(\"Front Door?\") {\n    input \"sensors\", \"capability.contactSensor\", multiple: true\n  }\n\n  section(\"Hall Light?\") {\n    input \"lights\", \"capability.switch\", title: \"Switch Turned On\", multilple: true\n  }\n\n  section(\"Presence Delay (defaults to 30s)?\") {\n    input name: \"presenceDelay\", type: \"number\", title: \"How Long?\", required: false\n  }\n\n  section(\"Door Contact Delay (defaults to 10s)?\") {\n    input name: \"contactDelay\", type: \"number\", title: \"How Long?\", required: false\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  state.lastClosed = now()\n  subscribe(people, \"presence.present\", presence)\n  subscribe(sensors, \"contact.open\", doorOpened)\n}\n\ndef presence(evt) {\n  def delay = contactDelay ?: 10\n\n  state.lastPresence = now()\n\n  if(now() - (delay * 1000) < state.lastContact) {\n    log.info('Presence was delayed, but you probably still want the light on.')\n    lights?.on()\n  }\n}\n\ndef doorOpened(evt) {\n  def delay = presenceDelay ?: 30\n\n  state.lastContact = now()\n\n  if(now() - (delay * 1000) < state.lastPresence) {\n    log.info('Welcome home!  Let me get that light for you.')\n    lights?.on()\n  }\n}",
        "docstring": "Turn on the hall light if someone comes home (presence) and the door opens."
    },
    {
        "code": "section(\"Change to this mode to...\") {\n    input \"newAwayMode\",    \"mode\", title: \"Everyone is away\"\n    input \"newSunsetMode\",  \"mode\", title: \"At least one person home and nightfall\"\n    input \"newSunriseMode\", \"mode\", title: \"At least one person home and sunrise\"\n  }\n\n  section(\"Away threshold (defaults to 10 min)\") {\n    input \"awayThreshold\", \"decimal\", title: \"Number of minutes\", required: false\n  }\n\n  section(\"Notifications\") {\n    input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  subscribe(people,   \"presence\", presence)\n  subscribe(location, \"sunrise\",  setSunrise)\n  subscribe(location, \"sunset\",   setSunset)\n\n  state.sunMode = location.mode\n}\n\ndef setSunrise(evt) {\n  changeSunMode(newSunriseMode)\n}\n\ndef setSunset(evt) {\n  changeSunMode(newSunsetMode)\n}\n\ndef changeSunMode(newMode) {\n  state.sunMode = newMode\n\n  if(everyoneIsAway() && (location.mode == newAwayMode)) {\n    log.debug(\"Mode is away, not evaluating\")\n  }\n\n  else if(location.mode != newMode) {\n    def message = \"${app.label} changed your mode to '${newMode}'\"\n    send(message)\n    setLocationMode(newMode)\n  }\n\n  else {\n    log.debug(\"Mode is the same, not evaluating\")\n  }\n}\n\ndef presence(evt) {\n  if(evt.value == \"not present\") {\n    log.debug(\"Checking if everyone is away\")\n\n    if(everyoneIsAway()) {\n      log.info(\"Starting ${newAwayMode} sequence\")\n      def delay = (awayThreshold != null && awayThreshold != \"\") ? awayThreshold * 60 : 10 * 60\n      runIn(delay, \"setAway\")\n    }\n  }\n\n  else {\n    if(location.mode != state.sunMode) {\n      log.debug(\"Checking if anyone is home\")\n\n      if(anyoneIsHome()) {\n        log.info(\"Starting ${state.sunMode} sequence\")\n\n        changeSunMode(state.sunMode)\n      }\n    }\n\n    else {\n      log.debug(\"Mode is the same, not evaluating\")\n    }\n  }\n}\n\ndef setAway() {\n  if(everyoneIsAway()) {\n    if(location.mode != newAwayMode) {\n      def message = \"${app.label} changed your mode to '${newAwayMode}' because everyone left home\"\n      log.info(message)\n      send(message)\n      setLocationMode(newAwayMode)\n    }\n\n    else {\n      log.debug(\"Mode is the same, not evaluating\")\n    }\n  }\n\n  else {\n    log.info(\"Somebody returned home before we set to '${newAwayMode}'\")\n  }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\nprivate send(msg) {\n  if(sendPushMessage != \"No\") {\n    log.debug(\"Sending push message\")\n    sendPush(msg)\n  }\n\n  log.debug(msg)\n}",
        "docstring": "When everyone leaves, change mode.  If at least one person home, switch mode based on sun position."
    },
    {
        "code": "}\n\n    if (location.channelName != 'samsungtv') {\n      section( \"Set your location\" ) { input \"zipCode\", \"text\", title: \"Zip code\" }\n    }\n\n    section(\"Things to check?\") {\n      input \"sensors\", \"capability.contactSensor\", multiple: true\n    }\n\n    section(\"Notifications?\") {\n      input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata: [values: [\"Yes\", \"No\"]], required: false\n      if (phone) {\n        input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n      }\n    }\n\n    section(\"Message interval?\") {\n      input name: \"messageDelay\", type: \"number\", title: \"Minutes (default to every message)\", required: false\n    }\n\n    section([mobileOnly:true]) {\n      label title: \"Assign a name\", required: false\n      mode title: \"Set for specific mode(s)\"\n    }\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  unschedule()\n  init()\n}\n\ndef init() {\n  state.lastMessage = 0\n  state.lastCheck = [\"time\": 0, \"result\": false]\n  schedule(\"0 0,30 * * * ?\", scheduleCheck) // Check at top and half-past of every hour\n  subscribe(sensors, \"contact.open\", scheduleCheck)\n}\n\ndef scheduleCheck(evt) {\n  def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n  def plural = open.size() > 1 ? \"are\" : \"is\"\n\n  // Only need to poll if we haven't checked in a while - and if something is left open.\n  if((now() - (30 * 60 * 1000) > state.lastCheck[\"time\"]) && open) {\n    log.info(\"Something's open - let's check the weather.\")\n    def response = getTwcForecast(zipCode)\n    def weather  = isStormy(response)\n    if(weather) {\n      send(\"${open.join(', ')} ${plural} open and ${weather} coming.\")\n    }\n  }\n\n  else if(((now() - (30 * 60 * 1000) <= state.lastCheck[\"time\"]) && state.lastCheck[\"result\"]) && open) {\n    log.info(\"We have fresh weather data, no need to poll.\")\n    send(\"${open.join(', ')} ${plural} open and ${state.lastCheck[\"result\"]} coming.\")\n  }\n\n  else {\n    log.info(\"Everything looks closed, no reason to check weather.\")\n  }\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}\n\nprivate isStormy(forecast) {\n    def result = false\n    if(forecast) {\n        def text = forecast.daypart?.precipType[0][0]\n        if(text) {\n            log.info(\"We got ${text}\")\n            result = text\n        } else {\n            log.info(\"Got forecast, nothing coming soon.\")\n        }\n    } else {\n        log.warn(\"Did not get a forecast: ${forecast}\")\n    }\n    state.lastCheck = [\"time\": now(), \"result\": result]\n    return result\n}",
        "docstring": "Warn if doors or windows are open when inclement weather is approaching."
    },
    {
        "code": "section(\"Temperature monitor?\") {\n    input \"temp\",    \"capability.temperatureMeasurement\", title: \"Temperature Sensor\", required: false\n    input \"maxTemp\", \"number\",                            title: \"Max Temperature (°${location.temperatureScale})\",   required: false\n    input \"minTemp\", \"number\",                            title: \"Min Temperature (°${location.temperatureScale})\",   required: false\n  }\n\n  section(\"When which people are away?\") {\n    input \"people\", \"capability.presenceSensor\", multiple: true\n  }\n\n  section(\"Notifications?\") {\n    input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata: [values: [\"Yes\", \"No\"]], required: false\n    input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n  }\n\n  section(\"Message interval?\") {\n    input name: \"messageDelay\", type: \"number\", title: \"Minutes (default to every message)\", required: false\n  }\n}\n\ndef installed() {\n  init()\n}\n\ndef updated() {\n  unsubscribe()\n  init()\n}\n\ndef init() {\n  subscribe(contact, \"contact.open\",         triggerContact)\n  subscribe(motion,  \"motion.active\",        triggerMotion)\n  subscribe(knock,   \"acceleration.active\",  triggerKnock)\n  subscribe(temp,    \"temperature\",          triggerTemp)\n  subscribe(axis,    \"threeAxis\",            triggerAxis)\n}\n\ndef triggerContact(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${contact.label ?: contact.name} was opened!\")\n  }\n}\n\ndef triggerMotion(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${motion.label ?: motion.name} sensed motion!\")\n  }\n}\n\ndef triggerKnock(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${knock.label ?: knock.name} was knocked!\")\n  }\n}\n\ndef triggerTemp(evt) {\n  def temperature = evt.doubleValue\n\n  if((maxTemp && maxTemp < temperature) ||\n     (minTemp && minTemp > temperature)) {\n    send(\"Safe Watch: ${temp.label ?: temp.name} is ${temperature}\")\n  }\n}\n\ndef triggerAxis(evt) {\n  if(everyoneIsAway()) {\n    send(\"Safe Watch: ${axis.label ?: axis.name} was tilted!\")\n  }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate send(msg) {\n  def delay = (messageDelay != null && messageDelay != \"\") ? messageDelay * 60 * 1000 : 0\n\n  if(now() - delay > state.lastMessage) {\n    state.lastMessage = now()\n    if(sendPushMessage == \"Yes\") {\n      log.debug(\"Sending push message.\")\n      sendPush(msg)\n    }\n\n    if(phone) {\n      log.debug(\"Sending text message.\")\n      sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n  }\n\n  else {\n    log.info(\"Have a message to send, but user requested to not get it.\")\n  }\n}",
        "docstring": "Watch a series of sensors for any anomalies for securing a safe."
    },
    {
        "code": "section(\"Thermostats to monitor\") {\n    input \"thermostats\", \"capability.thermostat\", multiple: true\n  }\n\n  section(\"Notifications\") {\n    input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata: [values: [\"Yes\", \"No\"]], required: false\n    input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n  }\n\n  section(\"Turn thermostat off automatically?\") {\n    input \"turnOffTherm\", \"enum\", metadata: [values: [\"Yes\", \"No\"]], required: false\n  }\n\n  section(\"Delay to wait before turning thermostat off (defaults to 1 minute)\") {\n    input \"turnOffDelay\", \"decimal\", title: \"Number of minutes\", required: false\n  }\n}\n\ndef installed() {\n  subscribe(thermostats, \"thermostatMode\", thermoChange);\n  subscribe(sensors, \"contact.open\", windowChange);\n}\n\ndef updated() {\n  unsubscribe()\n  subscribe(thermostats, \"thermostatMode\", thermoChange);\n  subscribe(sensors, \"contact.open\", windowChange);\n}\n\ndef thermoChange(evt) {\n  if(evt.value == \"heat\" ||\n     evt.value == \"cool\") {\n    def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n\n    if(open) {\n      def plural = open.size() > 1 ? \"are\" : \"is\"\n      send(\"${open.join(', ')} ${plural} still open and the thermostat just came on.\")\n\n      thermoShutOffTrigger()\n    }\n\n    else {\n      log.info(\"Thermostat came on and nothing is open.\");\n    }\n  }\n}\n\ndef windowChange(evt) {\n  def heating = thermostats.findAll { it?.latestValue(\"thermostatMode\") == \"heat\" }\n  def cooling = thermostats.findAll { it?.latestValue(\"thermostatMode\") == \"cool\" }\n\n  if(heating || cooling) {\n    def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n    def tempDirection = heating ? \"heating\" : \"cooling\"\n    def plural = open.size() > 1 ? \"were\" : \"was\"\n    send(\"${open.join(', ')} ${plural} opened and the thermostat is still ${tempDirection}.\")\n\n    thermoShutOffTrigger()\n  }\n}\n\ndef thermoShutOffTrigger() {\n  if(turnOffTherm == \"Yes\") {\n    log.info(\"Starting timer to turn off thermostat\")\n    def delay = (turnOffDelay != null && turnOffDelay != \"\") ? turnOffDelay * 60 : 60\n    state.turnOffTime = now()\n\n    runIn(delay, \"thermoShutOff\")\n  }\n}\n\ndef thermoShutOff() {\n  def open = sensors.findAll { it?.latestValue(\"contact\") == \"open\" }\n  def tempDirection = heating ? \"heating\" : \"cooling\"\n  def plural = open.size() > 1 ? \"are\" : \"is\"\n\n  log.info(\"Checking if we need to turn thermostats off\")\n\n  if(open.size()) {\n    send(\"Thermostats turned off: ${open.join(', ')} ${plural} open and thermostats ${tempDirection}.\")\n    log.info(\"Windows still open, turning thermostats off\")\n    thermostats?.off()\n  }\n\n  else {\n    log.info(\"Looks like everything is shut now - no need to turn off thermostats\")\n  }\n}\n\nprivate send(msg) {\n  if(sendPushMessage != \"No\") {\n    log.debug(\"Sending push message\")\n    sendPush(msg)\n  }\n\n  if(phone) {\n    log.debug(\"Sending text message\")\n    sendSms(phone, msg)\n  }\n\n  log.debug(msg)\n}",
        "docstring": "If your heating or cooling system come on, it gives you notice if there are any windows or doors left open, preventing the system from working optimally."
    },
    {
        "code": "}\n\nmappings {\n\tpath(\"/access_key\") {\n\t\taction: [\n\t\t\tGET: \"getAccessKey\",\n\t\t\tPUT: \"setAccessKey\"\n\t\t]\n\t}\n\tpath(\"/bucket\") {\n\t\taction: [\n\t\t\tGET: \"getBucketKey\",\n\t\t\tPUT: \"setBucketKey\"\n\t\t]\n\t}\n}\n\ndef getAccessKey() {\n\tlog.trace \"get access key\"\n\tif (atomicState.accessKey == null) {\n\t\thttpError(404, \"Access Key Not Found\")\n\t} else {\n\t\t[\n\t\t\taccessKey: atomicState.accessKey\n\t\t]\n\t}\n}\n\ndef getBucketKey() {\n\tlog.trace \"get bucket key\"\n\tif (atomicState.bucketKey == null) {\n\t\thttpError(404, \"Bucket key Not Found\")\n\t} else {\n\t\t[\n\t\t\tbucketKey: atomicState.bucketKey,\n\t\t\tbucketName: atomicState.bucketName\n\t\t]\n\t}\n}\n\ndef setBucketKey() {\n\tlog.trace \"set bucket key\"\n\tdef newBucketKey = request.JSON?.bucketKey\n\tdef newBucketName = request.JSON?.bucketName\n\n\tlog.debug \"bucket name: $newBucketName\"\n\tlog.debug \"bucket key: $newBucketKey\"\n\n\tif (newBucketKey && (newBucketKey != atomicState.bucketKey || newBucketName != atomicState.bucketName)) {\n\t\tatomicState.bucketKey = \"$newBucketKey\"\n\t\tatomicState.bucketName = \"$newBucketName\"\n\t\tatomicState.isBucketCreated = false\n\t}\n\n\ttryCreateBucket()\n}\n\ndef setAccessKey() {\n\tlog.trace \"set access key\"\n\tdef newAccessKey = request.JSON?.accessKey\n\tdef newGrokerSubdomain = request.JSON?.grokerSubdomain\n\n\tif (newGrokerSubdomain && newGrokerSubdomain != \"\" && newGrokerSubdomain != atomicState.grokerSubdomain) {\n\t\tatomicState.grokerSubdomain = \"$newGrokerSubdomain\"\n\t\tatomicState.isBucketCreated = false\n\t}\n\n\tif (newAccessKey && newAccessKey != atomicState.accessKey) {\n\t\tatomicState.accessKey = \"$newAccessKey\"\n\t\tatomicState.isBucketCreated = false\n\t}\n}\n\ndef subscribeToEvents() {\n\tif (accelerometers != null) {\n\t\tsubscribe(accelerometers, \"acceleration\", genericHandler)\n\t}\n\tif (alarms != null) {\n\t\tsubscribe(alarms, \"alarm\", genericHandler)\n\t}\n\tif (batteries != null) {\n\t\tsubscribe(batteries, \"battery\", genericHandler)\n\t}\n\tif (beacons != null) {\n\t\tsubscribe(beacons, \"presence\", genericHandler)\n\t}\n\n\tif (cos != null) {\n\t\tsubscribe(cos, \"carbonMonoxide\", genericHandler)\n\t}\n\tif (colors != null) {\n\t\tsubscribe(colors, \"hue\", genericHandler)\n\t\tsubscribe(colors, \"saturation\", genericHandler)\n\t\tsubscribe(colors, \"color\", genericHandler)\n\t}\n\tif (contacts != null) {\n\t\tsubscribe(contacts, \"contact\", genericHandler)\n\t}\n\tif (energyMeters != null) {\n\t\tsubscribe(energyMeters, \"energy\", genericHandler)\n\t}\n\tif (illuminances != null) {\n\t\tsubscribe(illuminances, \"illuminance\", genericHandler)\n\t}\n\tif (locks != null) {\n\t\tsubscribe(locks, \"lock\", genericHandler)\n\t}\n\tif (motions != null) {\n\t\tsubscribe(motions, \"motion\", genericHandler)\n\t}\n\tif (musicPlayers != null) {\n\t\tsubscribe(musicPlayers, \"status\", genericHandler)\n\t\tsubscribe(musicPlayers, \"level\", genericHandler)\n\t\tsubscribe(musicPlayers, \"trackDescription\", genericHandler)\n\t\tsubscribe(musicPlayers, \"trackData\", genericHandler)\n\t\tsubscribe(musicPlayers, \"mute\", genericHandler)\n\t}\n\tif (powerMeters != null) {\n\t\tsubscribe(powerMeters, \"power\", genericHandler)\n\t}\n\tif (presences != null) {\n\t\tsubscribe(presences, \"presence\", genericHandler)\n\t}\n\tif (humidities != null) {\n\t\tsubscribe(humidities, \"humidity\", genericHandler)\n\t}\n\tif (relaySwitches != null) {\n\t\tsubscribe(relaySwitches, \"switch\", genericHandler)\n\t}\n\tif (sleepSensors != null) {\n\t\tsubscribe(sleepSensors, \"sleeping\", genericHandler)\n\t}\n\tif (smokeDetectors != null) {\n\t\tsubscribe(smokeDetectors, \"smoke\", genericHandler)\n\t}\n\tif (peds != null) {\n\t\tsubscribe(peds, \"steps\", genericHandler)\n\t\tsubscribe(peds, \"goal\", genericHandler)\n\t}\n\tif (switches != null) {\n\t\tsubscribe(switches, \"switch\", genericHandler)\n\t}\n\tif (switchLevels != null) {\n\t\tsubscribe(switchLevels, \"level\", genericHandler)\n\t}\n\tif (temperatures != null) {\n\t\tsubscribe(temperatures, \"temperature\", genericHandler)\n\t}\n\tif (thermostats != null) {\n\t\tsubscribe(thermostats, \"temperature\", genericHandler)\n\t\tsubscribe(thermostats, \"heatingSetpoint\", genericHandler)\n\t\tsubscribe(thermostats, \"coolingSetpoint\", genericHandler)\n\t\tsubscribe(thermostats, \"thermostatSetpoint\", genericHandler)\n\t\tsubscribe(thermostats, \"thermostatMode\", genericHandler)\n\t\tsubscribe(thermostats, \"thermostatFanMode\", genericHandler)\n\t\tsubscribe(thermostats, \"thermostatOperatingState\", genericHandler)\n\t}\n\tif (valves != null) {\n\t\tsubscribe(valves, \"contact\", genericHandler)\n\t}\n\tif (waterSensors != null) {\n\t\tsubscribe(waterSensors, \"water\", genericHandler)\n\t}\n}\n\ndef installed() {\n\tatomicState.version = \"1.1.0\"\n\n\tatomicState.isBucketCreated = false\n\tatomicState.grokerSubdomain = \"groker\"\n\n\tsubscribeToEvents()\n\n\tatomicState.isBucketCreated = false\n\tatomicState.grokerSubdomain = \"groker\"\n\n\tlog.debug \"installed (version $atomicState.version)\"\n}\n\ndef updated() {\n\tatomicState.version = \"1.1.0\"\n\tunsubscribe()\n\n\tif (atomicState.bucketKey != null && atomicState.accessKey != null) {\n\t\tatomicState.isBucketCreated = false\n\t}\n\tif (atomicState.grokerSubdomain == null || atomicState.grokerSubdomain == \"\") {\n\t\tatomicState.grokerSubdomain = \"groker\"\n\t}\n\n\tsubscribeToEvents()\n\n\tlog.debug \"updated (version $atomicState.version)\"\n}\n\ndef uninstalled() {\n\tlog.debug \"uninstalled (version $atomicState.version)\"\n}\n\ndef tryCreateBucket() {\n\n\t// can't ship events if there is no grokerSubdomain\n\tif (atomicState.grokerSubdomain == null || atomicState.grokerSubdomain == \"\") {\n\t\tlog.error \"streaming url is currently null\"\n\t\treturn\n\t}\n\n\t// if the bucket has already been created, no need to continue\n\tif (atomicState.isBucketCreated) {\n\t\treturn\n\t}\n\n\tif (!atomicState.bucketName) {\n    \tatomicState.bucketName = atomicState.bucketKey\n    }\n    if (!atomicState.accessKey) {\n    \treturn\n    }\n\tdef bucketName = \"${atomicState.bucketName}\"\n\tdef bucketKey = \"${atomicState.bucketKey}\"\n\tdef accessKey = \"${atomicState.accessKey}\"\n\n\tdef bucketCreateBody = new JsonSlurper().parseText(\"{\\\"bucketKey\\\": \\\"$bucketKey\\\", \\\"bucketName\\\": \\\"$bucketName\\\"}\")\n\n\tdef bucketCreatePost = [\n\t\turi: \"https://${atomicState.grokerSubdomain}.initialstate.com/api/buckets\",\n\t\theaders: [\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"X-IS-AccessKey\": accessKey\n\t\t],\n\t\tbody: bucketCreateBody\n\t]\n\n\tlog.debug bucketCreatePost\n\n\ttry {\n\t\t// Create a bucket on Initial State so the data has a logical grouping\n\t\thttpPostJson(bucketCreatePost) { resp ->\n\t\t\tlog.debug \"bucket posted\"\n\t\t\tif (resp.status >= 400) {\n\t\t\t\tlog.error \"bucket not created successfully\"\n\t\t\t} else {\n\t\t\t\tatomicState.isBucketCreated = true\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"bucket creation error: $e\"\n\t}\n\n}\n\ndef genericHandler(evt) {\n\tlog.trace \"$evt.displayName($evt.name:$evt.unit) $evt.value\"\n\n\tdef key = \"$evt.displayName($evt.name)\"\n\tif (evt.unit != null) {\n\t\tkey = \"$evt.displayName(${evt.name}_$evt.unit)\"\n\t}\n\tdef value = \"$evt.value\"\n\n\ttryCreateBucket()\n\n\teventHandler(key, value)\n}\n\ndef eventHandler(name, value) {\n\tdef epoch = now() / 1000\n\n\tdef event = new JsonSlurper().parseText(\"{\\\"key\\\": \\\"$name\\\", \\\"value\\\": \\\"$value\\\", \\\"epoch\\\": \\\"$epoch\\\"}\")\n\n\ttryShipEvents(event)\n\t\n\tlog.debug \"Shipped Event: \" + event\n}\n\ndef tryShipEvents(event) {\n\n\tdef grokerSubdomain = atomicState.grokerSubdomain\n\t// can't ship events if there is no grokerSubdomain\n\tif (grokerSubdomain == null || grokerSubdomain == \"\") {\n\t\tlog.error \"streaming url is currently null\"\n\t\treturn\n\t}\n\tdef accessKey = atomicState.accessKey\n\tdef bucketKey = atomicState.bucketKey\n\t// can't ship if access key and bucket key are null, so finish trying\n\tif (accessKey == null || bucketKey == null) {\n\t\treturn\n\t}\n\n\tdef eventPost = [\n\t\turi: \"https://${grokerSubdomain}.initialstate.com/api/events\",\n\t\theaders: [\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"X-IS-BucketKey\": \"${bucketKey}\",\n\t\t\t\"X-IS-AccessKey\": \"${accessKey}\",\n\t\t\t\"Accept-Version\": \"0.0.2\"\n\t\t],\n\t\tbody: event\n\t]\n\n\ttry {\n\t\t// post the events to initial state\n\t\thttpPostJson(eventPost) { resp ->\n\t\t\tlog.debug \"shipped events and got ${resp.status}\"\n\t\t\tif (resp.status >= 400) {\n\t\t\t\tlog.error \"shipping failed... ${resp.data}\"\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"shipping events failed: $e\"\n\t}\n\n}",
        "docstring": "A SmartThings SmartApp to allow SmartThings events to be viewable inside an Initial State Event Bucket in your https://www.initialstate.com account."
    },
    {
        "code": "section(\"Master switch for the toggle reference...\") {\n    \tinput \"masterToggle\", \"capability.switch\", title: \"Reference switch\", required: true, multiple: false\n    }\n    \n    section(\"Toggle lights...\") {\n\t    input \"switchesToToggle\", \"capability.switch\", title: \"These go on/off\", required: true, multiple: true\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(motionToggler, \"motion\", toggleSwitches)\n}\n\n\ndef toggleSwitches(evt) {\n\tlog.debug \"$evt.value\"\n  \n\tif (evt.value == \"active\" && masterToggle.currentSwitch == \"off\") {\n//    \tfor (thisSwitch in switchesToToggle) {\n//        \tlog.debug \"$thisSwitch.label\"\n//  \t\t\tthisSwitch.on()\n\t\tswitchesToToggle.on()\n        masterToggle.on()\n    } else if (evt.value == \"active\" && masterToggle.currentSwitch == \"on\") {\n//    \tfor (thisSwitch in switchesToToggle) {\n//        \tlog.debug \"$thisSwitch.label\"\n//        \tthisSwitch.off()\n\t\tswitchesToToggle.off()\n        masterToggle.off()\n        }\n\n}",
        "docstring": "Toggle lights on/off with a motion sensor"
    },
    {
        "code": "}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(doorSensor, \"doorState\", coopDoorStateHandler)\n}\n\ndef coopDoorStateHandler(evt) {\n\tif (evt.value == \"jammed\"){\n        def msg = \"WARNING ${doorSensor.displayName} door is jammed and did not close!\"\n        log.debug \"WARNING ${doorSensor.displayName} door is jammed and did not close, texting $phone\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(msg, recipients)\n        }\n        else {\n            sendPush(msg)\n            if (phone) {\n                sendSms(phone, msg)\n            }\n        }\n\t}        \n}",
        "docstring": "Sends a SmartThings notification and text messages when your CoopBoss detects a door jam."
    },
    {
        "code": "}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(doorSensor, \"doorState\", coopDoorStateHandler)\n}\n\ndef coopDoorStateHandler(evt) {\n    log.debug \"${evt.descriptionText}, $evt.value\"\n\tdef color = \"White\"\n    def hueColor = 100\n    def saturation = 100\n    Map hClr = [:]\n    hClr.hex = \"#FFFFFF\"\n\n\tswitch(evt.value) {\n    \tcase \"open\":\n        \tcolor = \"Blue\"\n            break;\n        case \"opening\":\n        \tcolor = \"Purple\"\n            break;\n        case \"closed\":\n        \tcolor = \"Green\"\n            break;\n    \tcase \"closing\":\n        \tcolor = \"Pink\"\n            break;\n        case \"jammed\":\n        \tcolor = \"Red\"\n            break;\n        case \"forced close\":\n        \tcolor = \"Orange\"\n            break;\n        case \"unknown\":\n        \tcolor = \"White\"\n            break;        \n    }   \n       \n\tswitch(color) {\n\t\tcase \"White\":\n\t\t\thueColor = 52\n\t\t\tsaturation = 19\n\t\t\tbreak;\n\t\tcase \"Daylight\":\n\t\t\thueColor = 53\n\t\t\tsaturation = 91\n\t\t\tbreak;\n\t\tcase \"Soft White\":\n\t\t\thueColor = 23\n\t\t\tsaturation = 56\n\t\t\tbreak;\n\t\tcase \"Warm White\":\n\t\t\thueColor = 20\n\t\t\tsaturation = 80 //83\n\t\t\tbreak;\n\t\tcase \"Blue\":\n\t\t\thueColor = 70\n            hClr.hex = \"#0000FF\"\n\t\t\tbreak;\n\t\tcase \"Green\":\n\t\t\thueColor = 39\n            hClr.hex = \"#00FF00\"\n\t\t\tbreak;\n\t\tcase \"Yellow\":\n\t\t\thueColor = 25\n            hClr.hex = \"#FFFF00\"            \n\t\t\tbreak;\n\t\tcase \"Orange\":\n\t\t\thueColor = 10\n            hClr.hex = \"#FF6000\"\n\t\t\tbreak;\n\t\tcase \"Purple\":\n\t\t\thueColor = 75\n            hClr.hex = \"#BF7FBF\"\n\t\t\tbreak;\n\t\tcase \"Pink\":\n\t\t\thueColor = 83\n            hClr.hex = \"#FF5F5F\"\n\t\t\tbreak;\n\t\tcase \"Red\":\n\t\t\thueColor = 100\n            hClr.hex = \"#FF0000\"\n\t\t\tbreak;\n\t}    \n    \n    //bulbs*.on()\n    bulbs*.setHue(hueColor)\n\tbulbs*.setSaturation(saturation)   \n    bulbs*.setColor(hClr)\n    \n    //bulbs.each{\n    \t//it.on()  // Turn the bulb on when open (this method does not come directly from the colorControl capability)\n    \t//it.setLevel(100)  // Make sure the light brightness is 100%       \n    \t//it.setHue(hueColor)\n\t\t//it.setSaturation(saturation) \n        //}        \n}",
        "docstring": "Change the color of your Hue bulbs based on your coop's door status."
    },
    {
        "code": "section(\"Choose a humidity sensor...\") {\n\t\tinput \"humidity_sensor\", \"capability.relativeHumidityMeasurement\", title: \"Humidity Sensor\", required: true\n\t}\n\tsection(\"Enter the relative humudity level (%) above which the vent fans will activate:\") {\n\t\tinput \"humidity_a\", \"number\", title: \"Humidity Activation Level\", required: true, defaultValue:70\n\t}\n\tsection(\"Enter the relative humudity level (%) below which the vent fans will deactivate:\") {\n\t\tinput \"humidity_d\", \"number\", title: \"Humidity Deactivation Level\", required: true, defaultValue:65\n\t}\n\n\tsection(\"Select the vent fans to control...\") {\n\t\tinput \"fans\", \"capability.switch\", title: \"Vent Fans\", multiple: true, required: true\n\t}\n\n\tsection(\"Select the vent fan energy meters to monitor...\") {\n\t\tinput \"emeters\", \"capability.energyMeter\", title: \"Energy Meters\", multiple: true, required: false\n\t\tinput \"price_kwh\", \"decimal\", title: \"Cost in cents per kWh (12 is US avg)\", required: true, defaultValue:12\n\t}\n\n\tsection(\"Set notification options:\") {\n        input \"sendPushMessage\", \"bool\", title: \"Push notifications\", required:true, defaultValue:false\n        input \"phone\", \"phone\", title: \"Send text messages to\", required: false\n    }\n\n}\n\n\ndef installed() {\n\n\tlog.debug \"${app.label} installed with settings: ${settings}\"\n\n\tstate.app_enabled = false\n\tstate.fan_control_enabled = false\n\n\tstate.fansOn = false\n\tstate.fansOnTime = now()\n\tstate.fansLastRunTime = 0\n\n\tinitialize()\n\n}\n\n\ndef uninstalled()\n{\n\n   \tsend(\"${app.label} uninstalled.\")\n    \n\tstate.app_enabled = false\n\n\tset_fans(false)\n\n\tstate.fan_control_enabled = false\n\n}\n\n\ndef updated() {\n\n\tlog.debug \"${app.label} updated with settings: ${settings}\"\n\n\tunsubscribe()\n\n\tinitialize()\n\n}\n\n\ndef initialize() {\n\n\tif (settings.fan_control_enabled) {\n\t\tif(state.fan_control_enabled == false) {\n\t\t\tsend(\"Vent Fan Control Enabled.\")\n        } else {\n        \tlog.debug \"Vent Fan Control Enabled.\"\n        }\n\n\t\tstate.fan_control_enabled = true\n\t} else {\n\t\tif(state.fan_control_enabled == true) {\n\t\t\tsend(\"Vent Fan Control Disabled.\")\n        } else {\n        \tlog.debug \"Vent Fan Control Disabled.\"\n        }\n\n\t\tstate.fan_control_enabled = false\n\t}\n\n\tif (settings.app_enabled) {\n\t\tif(state.app_enabled == false) {\n\t\t\tsend(\"${app.label} Enabled.\")\n        } else {\n        \tlog.debug \"${app.label} Enabled.\"\n        }\n\n\t\tsubscribe(humidity_sensor, \"humidity\", \"handleThings\")\n\n\t\tstate.app_enabled = true\n\t} else {\n\t\tif(state.app_enabled == true) {\n\t\t\tsend(\"${app.label} Disabled.\")\n        } else {\n        \tlog.debug \"${app.label} Disabled.\"\n        }\n\n\t\tstate.app_enabled = false\n    }\n\n    handleThings()\n\n}\n\n\ndef handleThings(evt) {\n\n\n\tlog.debug \"handleThings()\"\n\n\tif(evt) {\n\t\tlog.debug \"$evt.descriptionText\"\n    }\n        \n\tdef h = 0.0 as BigDecimal\n\tif (settings.app_enabled) {\n\t    h = settings.humidity_sensor.currentValue('humidity')\n/*\n\t\t//Simulator is broken and requires this work around for testing.\t\n\t\tif (settings.humidity_sensor.latestState('humidity')) {\n        \tlog.debug settings.humidity_sensor.latestState('humidity').stringValue[0..-2]\n        \th = settings.humidity_sensor.latestState('humidity').stringValue[0..-2].toBigDecimal()\n        } else {\n        \th = 20\n        }        \n*/\n\t}\n\n\tlog.debug \"Humidity: $h%, Activate: $humidity_a%, Deactivate: $humidity_d%\"\n\n    def activateFans = false\n    def deactivateFans = false\n    \n\tif (settings.app_enabled) {\n        \n\t\tif (state.fansOn) {\n            if (h > humidity_d) {\n                log.debug \"Humidity not sufficient to deactivate vent fans: $h > $humidity_d\"\n            } else {\n                log.debug \"Humidity sufficient to deactivate vent fans: $h <= $humidity_d\"\n                deactivateFans = true\n            }\n        } else {\n            if (h < humidity_a) {\n                log.debug \"Humidity not sufficient to activate vent fans: $h < $humidity_a\"\n            } else {\n                log.debug \"Humidity sufficient to activate vent fans: $h >= $humidity_a\"\n                activateFans = true\n            }\n        }\n\t}\n\n\tif(activateFans) {\n\t\tset_fans(true)\n    }\n\tif(deactivateFans) {\n\t\tset_fans(false)\n    }\n\n}\n\n\ndef set_fans(fan_state) {\n\n\tif (fan_state) {\n    \tif (state.fansOn == false) {\n            send(\"${app.label} fans On.\")\n            state.fansOnTime = now()\n            if (settings.fan_control_enabled) {\n                if (emeters) {\n                    emeters.reset()\n                }\n                fans.on()\n            } else {\n                send(\"${app.label} fan control is disabled.\")\n            }\n            state.fansOn = true\n\t\t} else {\n            log.debug \"${app.label} fans already On.\"\n\t\t}        \n    } else {\n    \tif (state.fansOn == true) {\n\t    \tsend(\"${app.label} fans Off.\")\n            state.fansLastRunTime = (now() - state.fansOnTime)\n\n\t\t    BigInteger ms = new java.math.BigInteger(state.fansLastRunTime)\n\t\t\tint seconds = (BigInteger) (((BigInteger) ms / (1000I))                  % 60I)\n\t\t\tint minutes = (BigInteger) (((BigInteger) ms / (1000I * 60I))            % 60I)\n\t\t\tint hours   = (BigInteger) (((BigInteger) ms / (1000I * 60I * 60I))      % 24I)\n\t\t\tint days    = (BigInteger)  ((BigInteger) ms / (1000I * 60I * 60I * 24I))\n\n\t\t\tdef sb = String.format(\"${app.label} cycle: %d:%02d:%02d:%02d\", days, hours, minutes, seconds)\n\t\t\t\n\t\t    send(sb)\n\n\t\t\tif (settings.fan_control_enabled) {\n    \t    \tfans.off()\n                if (emeters) {\n                    log.debug emeters.currentValue('energy')\n                    //TODO: How to ensure latest (most accurate) energy reading?\n                    emeters.poll() //[configure, refresh, on, off, poll, reset]\n//                    emeters.refresh() //[configure, refresh, on, off, poll, reset]\n                    state.fansLastRunEnergy = emeters.currentValue('energy').sum()\n                    state.fansLastRunCost = ((state.fansLastRunEnergy * price_kwh) / 100.0) \n                    send(\"${app.label} cycle: ${state.fansLastRunEnergy}kWh @ \\$${state.fansLastRunCost}\")\n                }\n\t        } else {\n    \t    \tsend(\"${app.label} fan control is disabled.\")\n            }\n\t        state.fansOn = false\n            state.fansHoldoff = now()\n        } else {\n            log.debug \"${app.label} fans already Off.\"\n        }\n    }\n\n}\n\n\nprivate send(msg) {\n\n\tif (sendPushMessage) {\n        sendPush(msg)\n    }\n\n    if (phone) {\n        sendSms(phone, msg)\n    }\n\n    log.debug(msg)\n}",
        "docstring": "When the humidity reaches a specified level, activate one or more vent fans until the humidity is reduced to a specified level."
    },
    {
        "code": "section(\"Send a message when you press and hold the button...\") {\n    \tinput \"warnMessage\", \"text\", title: \"Warning Message\"\n    }\n    section(\"Or text message to these numbers (optional)\") {\n    \tinput (\"phone1\", \"contact\", required: false) {\n        \tinput \"phone1\", \"phone\", required: false\n        }\n        input (\"phone2\", \"contact\", required: false) {\n        \tinput \"phone2\", \"phone\", required: false\n        }\n        input (\"phone3\", \"contact\", required: false) {\n        \tinput \"phone3\", \"phone\", required: false\n        }\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(jawbone, \"sleeping\", sendit)\n}\n\ndef sendit(evt) {\n\tlog.debug \"$evt.value: $evt\"\n\tsendMessage()\n}\n\ndef sendMessage() {\n\tlog.debug \"Sending Message\"\n\tdef msg = warnMessage\n    log.info msg\n    if (phone1) {\n        sendSms phone1, msg\n    }\n    if (phone2) {\n        sendSms phone2, msg\n    }\n    if (phone3) {\n        sendSms phone3, msg\n    }\n    if (!phone1 && !phone2 && !phone3) {\n    \tsendPush msg\n    }\n}",
        "docstring": "Send push notifications or text messages with your Jawbone Up when you hold the button."
    },
    {
        "code": "preferences {\n    page(name: \"Credentials\", title: \"Jawbone UP\", content: \"authPage\", install: false)\n}\n\nmappings {\n\tpath(\"/receivedToken\") { action: [ POST: \"receivedToken\", GET: \"receivedToken\"] }\n\tpath(\"/receiveToken\") { action: [ POST: \"receiveToken\", GET: \"receiveToken\"] }\n\tpath(\"/hookCallback\") { action: [ POST: \"hookEventHandler\", GET: \"hookEventHandler\"] }\n  path(\"/oauth/initialize\") {action: [GET: \"oauthInitUrl\"]}\n\tpath(\"/oauth/callback\") { action: [ GET: \"callback\" ] }\n}\n\ndef getServerUrl() { return \"https://graph.api.smartthings.com\" }\ndef getBuildRedirectUrl() { \"${serverUrl}/oauth/initialize?appId=${app.id}&access_token=${state.accessToken}&apiServerUrl=${apiServerUrl}\" }\ndef buildRedirectUrl(page) { return buildActionUrl(page) }\n\ndef callback() {\n\tdef redirectUrl = null\n\tif (params.authQueryString) {\n\t\tredirectUrl = URLDecoder.decode(params.authQueryString.replaceAll(\".+&redirect_url=\", \"\"))\n\t\tlog.debug \"redirectUrl: ${redirectUrl}\"\n\t} else {\n\t\tlog.warn \"No authQueryString\"\n\t}\n\n\tif (state.JawboneAccessToken) {\n\t\tlog.debug \"Access token already exists\"\n\t\tsetup()\n\t\tsuccess()\n\t} else {\n\t\tdef code = params.code\n\t\tif (code) {\n\t\t\tif (code.size() > 6) {\n\t\t\t\t// Jawbone code\n\t\t\t\tlog.debug \"Exchanging code for access token\"\n\t\t\t\treceiveToken(redirectUrl)\n\t\t\t} else {\n\t\t\t\t// SmartThings code, which we ignore, as we don't need to exchange for an access token.\n\t\t\t\t// Instead, go initiate the Jawbone OAuth flow.\n\t\t\t\tlog.debug \"Executing callback redirect to auth page\"\n\t\t\t    state.oauthInitState = UUID.randomUUID().toString()\n\t\t\t    def oauthParams = [response_type: \"code\", client_id: appSettings.clientId, scope: \"move_read sleep_read\", redirect_uri: \"${serverUrl}/oauth/callback\"]\n\t\t\t\tredirect(location: \"https://jawbone.com/auth/oauth2/auth?${toQueryString(oauthParams)}\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"This code should be unreachable\"\n\t\t\tsuccess()\n\t\t}\n\t}\n}\n\ndef authPage() {\n    log.debug \"authPage\"\n    def description = null\n    if (state.JawboneAccessToken == null) {\n\t\tif (!state.accessToken) {\n\t\t\tlog.debug \"About to create access token\"\n\t\t\tcreateAccessToken()\n\t\t}\n        description = \"Click to enter Jawbone Credentials\"\n        def redirectUrl = buildRedirectUrl\n        log.debug \"RedirectURL = ${redirectUrl}\"\n        def donebutton= state.JawboneAccessToken != null\n        return dynamicPage(name: \"Credentials\", title: \"Jawbone UP\", nextPage: null, uninstall: true, install: donebutton) {\n\t\t\t\t\t\t\t section { paragraph title: \"Note:\", \"This device has not been officially tested and certified to “Work with SmartThings”. You can connect it to your SmartThings home but performance may vary and we will not be able to provide support or assistance.\" }\n               section { href url:redirectUrl, style:\"embedded\", required:true, title:\"Jawbone UP\", state: hast ,description:description }\n        }\n    } else {\n        description = \"Jawbone Credentials Already Entered.\"\n        return dynamicPage(name: \"Credentials\", title: \"Jawbone UP\", uninstall: true, install:true) {\n               section { href url: buildRedirectUrl(\"receivedToken\"), style:\"embedded\", state: \"complete\", title:\"Jawbone UP\", description:description }\n        }\n    }\n}\n\ndef oauthInitUrl() {\n    log.debug \"oauthInitUrl\"\n    state.oauthInitState = UUID.randomUUID().toString()\n    def oauthParams = [ response_type: \"code\", client_id: appSettings.clientId, scope: \"move_read sleep_read\", redirect_uri: \"${serverUrl}/oauth/callback\" ]\n\tredirect(location: \"https://jawbone.com/auth/oauth2/auth?${toQueryString(oauthParams)}\")\n}\n\ndef receiveToken(redirectUrl = null) {\n\tlog.debug \"receiveToken\"\n    def oauthParams = [ client_id: appSettings.clientId, client_secret: appSettings.clientSecret, grant_type: \"authorization_code\", code: params.code ]\n    def params = [\n      uri: \"https://jawbone.com/auth/oauth2/token?${toQueryString(oauthParams)}\",\n    ]\n    httpGet(params) { response ->\n    \tlog.debug \"${response.data}\"\n\t\tlog.debug \"Setting access token to ${response.data.access_token}, refresh token to ${response.data.refresh_token}\"\n    \tstate.JawboneAccessToken = response.data.access_token\n\t\tstate.refreshToken = response.data.refresh_token\n    }\n\n\tsetup()\n\tif (state.JawboneAccessToken) {\n\t\tsuccess()\n\t} else {\n\t\tdef message = \"\"\"\n\t\t\t<p>The connection could not be established!</p>\n\t\t\t<p>Click 'Done' to return to the menu.</p>\n\t\t\"\"\"\n\t\tconnectionStatus(message)\n\t}\n}\n\ndef success() {\n\tdef message = \"\"\"\n\t\t<p>Your Jawbone Account is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef receivedToken() {\n\tdef message = \"\"\"\n\t\t<p>Your Jawbone Account is already connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef connectionStatus(message, redirectUrl = null) {\n\tdef redirectHtml = \"\"\n\tif (redirectUrl) {\n\t\tredirectHtml = \"\"\"\n\t\t\t<meta http-equiv=\"refresh\" content=\"3; url=${redirectUrl}\" />\n\t\t\"\"\"\n\t}\n\n    def html = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta name=\"viewport\" content=\"width=640\">\n        <title>SmartThings Connection</title>\n        <style type=\"text/css\">\n            @font-face {\n                font-family: 'Swiss 721 W01 Thin';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'Swiss 721 W01 Light';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            .container {\n                width: 560px;\n                padding: 40px;\n                /*background: #eee;*/\n                text-align: center;\n            }\n            img {\n                vertical-align: middle;\n            }\n            img:nth-child(2) {\n                margin: 0 30px;\n            }\n            p {\n                font-size: 2.2em;\n                font-family: 'Swiss 721 W01 Thin';\n                text-align: center;\n                color: #666666;\n                padding: 0 40px;\n                margin-bottom: 0;\n            }\n        /*\n            p:last-child {\n                margin-top: 0px;\n            }\n        */\n            span {\n                font-family: 'Swiss 721 W01 Light';\n            }\n        </style>\n\t\t${redirectHtml}\n        </head>\n        <body>\n            <div class=\"container\">\n                <img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSMuoEIQ7gQhFtc02vXkybwmH0o7L1cs5mtbcJye0mgNqop_LOZbg\" alt=\"Jawbone UP icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n                ${message}\n            </div>\n        </body>\n        </html>\n\t\"\"\"\n\trender contentType: 'text/html', data: html\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef validateCurrentToken() {\n\tlog.debug \"validateCurrentToken\"\n    def url = \"https://jawbone.com/nudge/api/v.1.1/users/@me/refreshToken\"\n    def requestBody = \"secret=${appSettings.clientSecret}\"\n\n\ttry {\n\t\thttpPost(uri: url, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ],  body: requestBody) {response ->\n\t    \tif (response.status == 200) {\n\t\t\t\tlog.debug \"${response.data}\"\n\t\t\t\tlog.debug \"Setting refresh token\"\n\t     \t\tstate.refreshToken = response.data.data.refresh_token\n\t        }\n\t    }\n\t} catch (groovyx.net.http.HttpResponseException e) {\n        if (e.statusCode == 401) { // token is expired\n        \tlog.debug \"Access token is expired\"\n        \tif (state.refreshToken) { // if we have this we are okay\n    \t\t\tdef oauthParams = [client_id: appSettings.clientId, client_secret: appSettings.clientSecret, grant_type: \"refresh_token\", refresh_token: state.refreshToken]\n        \t\tdef tokenUrl = \"https://jawbone.com/auth/oauth2/token?${toQueryString(oauthParams)}\"\n        \t\tdef params = [\n          \t\t\turi: tokenUrl\n        \t\t]\n        \t\thttpGet(params) { refreshResponse ->\n\t\t\t\t\tdef data = refreshResponse.data\n\t\t\t\t\tlog.debug \"Status: ${refreshResponse.status}, data: ${data}\"\n\t\t\t\t\tif (data.error) {\n\t\t\t\t\t\tif (data.error == \"access_denied\") {\n\t\t\t\t\t\t\t// User has removed authorization (probably)\n\t\t\t\t\t\t\tlog.warn \"Access denied, because: ${data.error_description}\"\n\t\t\t\t\t\t\tstate.remove(\"JawboneAccessToken\")\n\t\t\t\t\t\t\tstate.remove(\"refreshToken\")\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.debug \"Setting access token\"\n\t\t\t\t\t\tstate.JawboneAccessToken = data.access_token\n\t\t\t\t\t\tstate.refreshToken = data.refresh_token\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t} catch (java.net.SocketTimeoutException e) {\n\t\tlog.warn \"Connection timed out, not much we can do here\"\n\t}\n}\n\ndef initialize() {\n    log.debug \"Callback URL - Webhook\"\n\tdef localServerUrl = getApiServerUrl()\n\tdef hookUrl = \"${localServerUrl}/api/token/${state.accessToken}/smartapps/installations/${app.id}/hookCallback\"\n    def webhook = \"https://jawbone.com/nudge/api/v.1.1/users/@me/pubsub?webhook=$hookUrl\"\n\thttpPost(uri: webhook, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ])\n}\n\ndef setup() {\n\t// make sure this is going to work\n\tvalidateCurrentToken()\n\n\tif (state.JawboneAccessToken) {\n\t\tdef urlmember = \"https://jawbone.com/nudge/api/users/@me/\"\n\t\tdef member = null\n\t\thttpGet(uri: urlmember, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) {response ->\n\t\t    member = response.data.data\n\t\t}\n\n\t\tif (member) {\n\t\t\tstate.member = member\n\t\t\tdef externalId = \"${app.id}.${member.xid}\"\n\n\t\t\t// find the appropriate child device based on my app id and the device network id\n\t\t\tdef deviceWrapper = getChildDevice(\"${externalId}\")\n\n\t\t\t// invoke the generatePresenceEvent method on the child device\n\t\t\tlog.debug \"Device $externalId: $deviceWrapper\"\n\t\t\tif (!deviceWrapper) {\n\t\t\t  \tdef childDevice = addChildDevice('juano2310', \"Jawbone User\", \"${app.id}.${member.xid}\",null,[name:\"Jawbone UP - \" + member.first, completedSetup: true])\n\t\t\t    if (childDevice) {\n\t\t\t       \tlog.debug \"Child Device Successfully Created\"\n\t\t\t        childDevice?.generateSleepingEvent(false)\n                    pollChild(childDevice)\n\t\t\t    }\n\t\t\t}\n\t\t}\n\n\t\tinitialize()\n\t}\n}\n\ndef installed() {\n\n\tif (!state.accessToken) {\n\t\tlog.debug \"About to create access token\"\n\t\tcreateAccessToken()\n\t}\n\n\tif (state.JawboneAccessToken) {\n\t\tsetup()\n\t}\n}\n\ndef updated() {\n\n\tif (!state.accessToken) {\n\t\tlog.debug \"About to create access token\"\n\t\tcreateAccessToken()\n\t}\n\n\tif (state.JawboneAccessToken) {\n\t\tsetup()\n\t}\n}\n\ndef uninstalled() {\n\tif (state.JawboneAccessToken) {\n\t\ttry {\n\t\t\thttpDelete(uri: \"https://jawbone.com/nudge/api/v.1.0/users/@me/PartnerAppMembership\", headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) { response ->\n\t\t\t\tlog.debug \"Success disconnecting Jawbone from SmartThings\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tlog.error \"Error disconnecting Jawbone from SmartThings: ${e.statusCode}\"\n\t\t}\n\t}\n}\n\ndef pollChild(childDevice) {\n\t\tdef childMap = [ value: \"$childDevice.device.deviceNetworkId}\"]\n\n\t\tdef params = [\n\t\t\t\turi: 'https://jawbone.com',\n\t\t\t\tpath: '/nudge/api/users/@me/goals',\n\t\t\t\theaders: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ],\n\t\t\t\tcontentType: 'application/json'\n\t\t]\n\n\t\tasynchttp_v1.get('responseGoals', params, childMap)\n\n\t\tdef params2 = [\n\t\t\t\turi: 'https://jawbone.com',\n\t\t\t\tpath: '/nudge/api/users/@me/moves',\n\t\t\t\theaders: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ],\n\t\t\t\tcontentType: 'application/json'\n\t\t]\n\n\t\tasynchttp_v1.get('responseMoves', params2, childMap)\n}\n\ndef responseGoals(response, dni) {\n\tif (response.hasError()) {\n\t\t\tlog.error \"response has error: $response.errorMessage\"\n\t} else {\n\t\t\tdef goals\n\t\t\ttry {\n\t\t\t\t\t// json response already parsed into JSONElement object\n\t\t\t\t\tgoals = response.json.data\n\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"error parsing json from response: $e\"\n\t\t\t}\n\t\t\tif (goals) {\n\t\t\t\tdef childDevice = getChildDevice(dni.value)\n\t\t\t\tlog.debug \"Goal = ${goals.move_steps} Steps\"\n\t\t\t\tchildDevice?.sendEvent(name:\"goal\", value: goals.move_steps)\n\t\t\t} else {\n\t\t\t\t\tlog.debug \"did not get json results from response body: $response.data\"\n\t\t\t}\n\t}\n}\n\ndef responseMoves(response, dni) {\n\tif (response.hasError()) {\n\t\t\tlog.error \"response has error: $response.errorMessage\"\n\t} else {\n\t\t\tdef moves\n\t\t\ttry {\n\t\t\t\t\t// json response already parsed into JSONElement object\n\t\t\t\t\tmoves = response.json.data.items[0]\n\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"error parsing json from response: $e\"\n\t\t\t}\n\t\t\tif (moves) {\n\t\t\t\tdef childDevice = getChildDevice(dni.value)\n\t\t\t\tlog.debug \"Moves = ${moves.details.steps} Steps\"\n\t\t\t\tchildDevice?.sendEvent(name:\"steps\", value: moves.details.steps)\n\t\t\t} else {\n\t\t\t\t\tlog.debug \"did not get json results from response body: $response.data\"\n\t\t\t}\n\t}\n}\n\ndef setColor (steps,goal,childDevice) {\n    def result = steps * 100 / goal\n    if (result < 25)\n    \tchildDevice?.sendEvent(name:\"steps\", value: \"steps\", label: steps)\n    else if ((result >= 25) && (result < 50))\n        childDevice?.sendEvent(name:\"steps\", value: \"steps1\", label: steps)\n    else if ((result >= 50) && (result < 75))\n        childDevice?.sendEvent(name:\"steps\", value: \"steps1\", label: steps)\n    else if (result >= 75)\n        childDevice?.sendEvent(name:\"steps\", value: \"stepsgoal\", label: steps)\n}\n\ndef hookEventHandler() {\n    // log.debug \"In hookEventHandler method.\"\n    log.debug \"request = ${request}\"\n\n    def json = request.JSON\n\n    // get some stuff we need\n    def userId = json.events.user_xid[0]\n    def\tjson_type = json.events.type[0]\n\t  def json_action = json.events.action[0]\n\n    //log.debug json\n    log.debug \"Userid = ${userId}\"\n    log.debug \"Notification Type: \" + json_type\n    log.debug \"Notification Action: \" + json_action\n\n    // find the appropriate child device based on my app id and the device network id\n    def externalId = \"${app.id}.${userId}\"\n    def childDevice = getChildDevice(\"${externalId}\")\n\n    if (childDevice) {\n    \tswitch (json_action) {\n\t        case \"enter_sleep_mode\":\n            \tchildDevice?.generateSleepingEvent(true)\n                break\n            case \"exit_sleep_mode\":\n            \tchildDevice?.generateSleepingEvent(false)\n                break\n            case \"creation\":\n                childDevice?.sendEvent(name:\"steps\", value: 0)\n          \t\tbreak\n            case \"updation\":\n                def urlgoals = \"https://jawbone.com/nudge/api/users/@me/goals\"\n                def urlmoves = \"https://jawbone.com/nudge/api/users/@me/moves\"\n                def goals = null\n                def moves = null\n                httpGet(uri: urlgoals, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) {response ->\n \t               goals = response.data.data\n                }\n                httpGet(uri: urlmoves, headers: [\"Authorization\": \"Bearer ${state.JawboneAccessToken}\" ]) {response ->\n                   moves = response.data.data.items[0]\n                }\n                log.debug \"Goal = ${goals.move_steps} Steps\"\n        \t\t\t\tlog.debug \"Steps = ${moves.details.steps} Steps\"\n                childDevice?.sendEvent(name:\"steps\", value: moves.details.steps)\n                childDevice?.sendEvent(name:\"goal\", value: goals.move_steps)\n                //setColor(moves.details.steps,goals.move_steps,childDevice)\n                break\n\t\t\tcase \"deletion\":\n\t\t\t\tapp.delete()\n\t\t\t\tbreak\n\t\t}\n    }\n    else {\n            log.debug \"Couldn't find child device associated with Jawbone.\"\n    }\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}",
        "docstring": "Connect your Jawbone UP to SmartThings"
    },
    {
        "code": "section(\"And on when there's been no movement for...\"){\n\t\tinput \"minutes1\", \"number\", title: \"Minutes?\"\n\t}\n\tsection(\"Turn off/on light(s)...\"){\n\t\tinput \"switches\", \"capability.switch\", multiple: true\n\t}\n}\n\n\ndef installed()\n{\n\tsubscribe(motion1, \"motion\", motionHandler)\n\tschedule(\"0 * * * * ?\", \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion\", motionHandler)\n\tunschedule()\n\tschedule(\"0 * * * * ?\", \"scheduleCheck\")\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"turning on lights\"\n\t\tswitches.off()\n\t\tstate.inactiveAt = null\n\t} else if (evt.value == \"inactive\") {\n\t\tif (!state.inactiveAt) {\n\t\t\tstate.inactiveAt = now()\n\t\t}\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check, ts = ${state.inactiveAt}\"\n\tif (state.inactiveAt) {\n\t\tdef elapsed = now() - state.inactiveAt\n\t\tdef threshold = 1000 * 60 * minutes1\n\t\tif (elapsed >= threshold) {\n\t\t\tlog.debug \"turning off lights\"\n\t\t\tswitches.on()\n\t\t\tstate.inactiveAt = null\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"${elapsed / 1000} sec since motion stopped\"\n\t\t}\n\t}\n}",
        "docstring": "Turns off a device if there is motion"
    },
    {
        "code": "section(\"Select the door contact sensor:\") {\n            input \"contact\", \"capability.contactSensor\", required: true\n        }\n        section(\"Automatically lock the door when closed...\") {\n            input \"minutesLater\", \"number\", title: \"Delay (in minutes):\", required: true\n        }\n        section(\"Automatically unlock the door when open...\") {\n            input \"secondsLater\", \"number\", title: \"Delay (in seconds):\", required: true\n        }\n        if (location.contactBookEnabled || phoneNumber) {\n            section(\"Notifications\") {\n                input(\"recipients\", \"contact\", title: \"Send notifications to\", required: false) {\n                    input \"phoneNumber\", \"phone\", title: \"Warn with text message (optional)\", description: \"Phone Number\", required: false\n                }\n            }\n        }\n        section([mobileOnly:true]) {\n            label title: \"Assign a name\", required: false\n            mode title: \"Set for specific mode(s)\"\n        }\n    }\n}\n\ndef installed(){\n    initialize()\n}\n\ndef updated(){\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize(){\n    log.debug \"Settings: ${settings}\"\n    subscribe(lock1, \"lock\", doorHandler, [filterEvents: false])\n    subscribe(lock1, \"unlock\", doorHandler, [filterEvents: false])  \n    subscribe(contact, \"contact.open\", doorHandler)\n    subscribe(contact, \"contact.closed\", doorHandler)\n}\n\ndef lockDoor(){\n    log.debug \"Locking the door.\"\n    lock1.lock()\n    if(location.contactBookEnabled) {\n        if ( recipients ) {\n            log.debug ( \"Sending Push Notification...\" ) \n            sendNotificationToContacts( \"${lock1} locked after ${contact} was closed for ${minutesLater} minutes!\", recipients)\n        }\n    }\n    if (phoneNumber) {\n        log.debug(\"Sending text message...\")\n        sendSms( phoneNumber, \"${lock1} locked after ${contact} was closed for ${minutesLater} minutes!\")\n    }\n}\n\ndef unlockDoor(){\n    log.debug \"Unlocking the door.\"\n    lock1.unlock()\n    if(location.contactBookEnabled) {\n        if ( recipients ) {\n            log.debug ( \"Sending Push Notification...\" ) \n            sendNotificationToContacts( \"${lock1} unlocked after ${contact} was opened for ${secondsLater} seconds!\", recipients)\n        }\n    }\n    if ( phoneNumber ) {\n        log.debug(\"Sending text message...\")\n        sendSms( phoneNumber, \"${lock1} unlocked after ${contact} was opened for ${secondsLater} seconds!\")\n    }\n}\n\ndef doorHandler(evt){\n    if ((contact.latestValue(\"contact\") == \"open\") && (evt.value == \"locked\")) { // If the door is open and a person locks the door then...  \n        //def delay = (secondsLater) // runIn uses seconds\n        runIn( secondsLater, unlockDoor )   // ...schedule (in minutes) to unlock...  We don't want the door to be closed while the lock is engaged. \n    }\n    else if ((contact.latestValue(\"contact\") == \"open\") && (evt.value == \"unlocked\")) { // If the door is open and a person unlocks it then...\n        unschedule( unlockDoor ) // ...we don't need to unlock it later.\n    }\n    else if ((contact.latestValue(\"contact\") == \"closed\") && (evt.value == \"locked\")) { // If the door is closed and a person manually locks it then...\n        unschedule( lockDoor ) // ...we don't need to lock it later.\n    }   \n    else if ((contact.latestValue(\"contact\") == \"closed\") && (evt.value == \"unlocked\")) { // If the door is closed and a person unlocks it then...\n       //def delay = (minutesLater * 60) // runIn uses seconds\n        runIn( (minutesLater * 60), lockDoor ) // ...schedule (in minutes) to lock.\n    }\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"open\")) { // If a person opens an unlocked door...\n        unschedule( lockDoor ) // ...we don't need to lock it later.\n    }\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"closed\")) { // If a person closes an unlocked door...\n        //def delay = (minutesLater * 60) // runIn uses seconds\n        runIn( (minutesLater * 60), lockDoor ) // ...schedule (in minutes) to lock.\n    }\n    else { //Opening or Closing door when locked (in case you have a handle lock)\n        log.debug \"Unlocking the door.\"\n        lock1.unlock()\n        if(location.contactBookEnabled) {\n            if ( recipients ) {\n                log.debug ( \"Sending Push Notification...\" ) \n                sendNotificationToContacts( \"${lock1} unlocked after ${contact} was opened or closed when ${lock1} was locked!\", recipients)\n            }\n        }\n        if ( phoneNumber ) {\n            log.debug(\"Sending text message...\")\n            sendSms( phoneNumber, \"${lock1} unlocked after ${contact} was opened or closed when ${lock1} was locked!\")\n        }\n    }\n}",
        "docstring": "Automatically locks a specific door after X minutes when closed  and unlocks it when open after X seconds."
    },
    {
        "code": "section(\"Configure your Weather Underground credentials\") {\n        input \"weatherID\", \"text\", title: \"Weather Station ID\", required: true\n        input \"password\", \"password\", title: \"Weather Underground password\", required: true\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\n\ndef initialize() {\n\n    /*\n      Check to see if the sensor is reporting temperature, then run the updateCurrentWeather\n      every 10 minutes\n    */\n    if (temp.currentTemperature) {\n        runEvery5Minutes(updateCurrentWeather)\n    }\n}\n\n\n/*\n  Updates the Weather Underground Personal Weather Station (PWS) Upload Protocol\n  Reference: http://wiki.wunderground.com/index.php/PWS_-_Upload_Protocol\n*/\ndef updateCurrentWeather() {\n\n    // Logs of the current data from the sensor\n    log.trace \"Temp: \" + temp.currentTemperature\n    log.trace \"Humidity: \" + humidity.currentHumidity\n    log.trace \"Dew Point: \" + calculateDewPoint(temp.currentTemperature, humidity.currentHumidity)\n\n    // Builds the URL that will be sent to Weather Underground to update your PWS\n    def params = [\n        uri: \"http://weatherstation.wunderground.com\",\n        path: \"/weatherstation/updateweatherstation.php\",\n        query: [\n            \"ID\": weatherID,\n            \"PASSWORD\": password,\n            \"dateutc\": \"now\",\n            \"tempf\": temp.currentTemperature,\n            \"humidity\": humidity.currentHumidity,\n            \"dewptf\": calculateDewPoint(temp.currentTemperature, humidity.currentHumidity),\n            \"action\": \"updateraw\",\n            \"softwaretype\": \"SmartThings\"\n        ]\n    ]\n    \n    try {\n        // Make the HTTP request using httpGet()\n        httpGet(params) { resp -> // This is how we define the \"return data\". Can also use $it.\n            log.debug \"response data: ${resp.data}\"\n        }\n    } catch (e) {\n        log.error \"something went wrong: $e\"\n    }\n\n}\n\n// Calculates dewpoint based on temperature and humidity\ndef calculateDewPoint(t, rh) {\n    def dp = 243.04 * ( Math.log(rh / 100) + ( (17.625 * t) / (243.04 + t) ) ) / (17.625 - Math.log(rh / 100) - ( (17.625 * t) / (243.04 + t) ) ) \n    // Format the response for Weather Underground\n    return new DecimalFormat(\"##.##\").format(dp)\n}",
        "docstring": "Connect your SmartSense Temp/Humidity sensor to your Weather Underground Personal Weather Station."
    },
    {
        "code": "section(\"Remind me to take my medicine at\"){\n        input \"reminderTime\", \"time\", title: \"Time\"\n    }\n    \n    // NOTE: Use REAL device - virtual device causes compilation errors\n    section(\"My LED Light\"){\n    \tinput \"deviceLight\", \"capability.colorControl\", title: \"Smart light\"\n    }\n\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n        \n\tinitialize()\n}\n\ndef initialize() {\n\n    // will stop LED notification incase it was set by med reminder\n    subscribe(deviceContactSensor, \"contact\", contactHandler)\n\n    // how many minutes to look in the past from the reminder time, for an open draw\n    state.minutesToCheckOpenDraw = 60\n    \n    // is true when LED notification is set after exceeding 10 minutes past reminder time\n    state.ledNotificationTriggered = false\n    \n    // Set a timer to run once a day to notify if draw wasn't opened yet\n    schedule(reminderTime, checkOpenDrawInPast)\n   \n}\n\n// Should turn off any LED notification on OPEN state\ndef contactHandler(evt){\n\tif (evt.value == \"open\") {\n        // if LED notification triggered, reset it.\n        log.debug \"Cabinet opened\"\n        if (state.ledNotificationTriggered) {\n            resetLEDNotification()\n        }\n\t}\n}\n\n// If the draw was NOT opened within 60 minutes of the timer send notification out.\ndef checkOpenDrawInPast(){\n\tlog.debug \"Checking past 60 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 60 minutes for any OPENED status\n    def cabinetOpened = isOpened(state.minutesToCheckOpenDraw)\n\tlog.debug \"Cabinet found opened: $cabinetOpened\"\n    \n    // if it's opened, then do nothing and assume they took their meds\n    if (!cabinetOpened) {    \n    \tsendNotification(\"Hi, please remember to take your meds in the cabinet\")\n       \n       // if no open activity, send out notification and set new reminder    \n        def reminderTimePlus10 = new Date(now() + (10 * 60000))\n\n        // needs to be scheduled if draw wasn't already opened\n        runOnce(reminderTimePlus10, checkOpenDrawAfterReminder)\n    }\n}\n\n// If the draw was NOT opened after 10 minutes past reminder, use LED notification\ndef checkOpenDrawAfterReminder(){\n\tlog.debug \"Checking additional 10 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 10 minutes for any OPENED status\n    def cabinetOpened = isOpened(10)    \n    \n   \tlog.debug \"Cabinet found opened: $cabinetOpened\"\n        \n    // if no open activity, blink lights\n    if (!cabinetOpened) {\n    \tlog.debug \"Set LED to Notification color\"\n        setLEDNotification()\n    }\n    \n}\n\n// Helper function for sending out an app notification\ndef sendNotification(msg){\n        log.debug \"Message Sent: $msg\"\n        sendPush(msg)\n}\n\n// Check if the sensor has been opened since the minutes entered\n// Return true if opened found, else false.\ndef isOpened(minutes){\n    // query last X minutes of activity log    \n    def previousDateTime = new Date(now() - (minutes * 60000))\n    \n    // capture all events recorded\n    def evts = deviceContactSensor.eventsSince(previousDateTime)   \n    def cabinetOpened = false\n    if (evts.size() > 0) {\n        evts.each{\n            if(it.value == \"open\") {\n                cabinetOpened = true \n            }\n        }\n\t}\n    \n    return cabinetOpened\n}\n\n// Saves current color and sets the light to RED\ndef setLEDNotification(){\n\n\tstate.ledNotificationTriggered = true\n    \n\t// turn light back off when reset is called if it was originally off\n \tstate.ledState = deviceLight.currentValue(\"switch\")\n\n\t// set light to RED and store original color until stopped    \n    state.origColor = deviceLight.currentValue(\"hue\")\n    deviceLight.on()\n    deviceLight.setHue(100)\n    \n    log.debug \"LED set to RED. Original color stored: $state.origColor\"\n\n}\n\n// Sets the color back to the original saved color\ndef resetLEDNotification(){\n\n\tstate.ledNotificationTriggered = false\n    \n    // return color to original\n    log.debug \"Reset LED color to: $state.origColor\"\n    if (state.origColor != null) {\n    \tdeviceLight.setHue(state.origColor)\n    }\n    \n    // if the light was turned on just for the notification, turn it back off now\n    if (state.ledState == \"off\") {\n    \tdeviceLight.off()\n    }\n\n}",
        "docstring": "This supports devices with capabilities of ContactSensor and ColorControl (LED). It sends an in-app and ambient light notification if you forget to open the drawer or cabinet where meds are stored. A reminder will be set to a single time per day. If the draw or cabinet isn't opened within 60 minutes of that reminder, an in-app message will be sent. If the draw or cabinet still isn't opened after an additional 10 minutes, then an LED light turns red until the draw or cabinet is opened"
    },
    {
        "code": "section(\"Temperature Threshold\"){\n    \tinput \"tempThreshold\", \"number\", title: \"Temperature Threshold\"\n    }\n\n    section(\"Remind me to take my medicine at\"){\n        input \"reminderTime\", \"time\", title: \"Time\"\n    }\n    \n    // NOTE: Use REAL device - virtual device causes compilation errors\n    section(\"My LED Light\"){\n    \tinput \"deviceLight\", \"capability.colorControl\", title: \"Smart light\"\n    }    \n\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n        \n\tinitialize()\n}\n\ndef initialize() {\n\t// will notify when temp exceeds max\n    subscribe(deviceTemperatureMeasurement, \"temperature\", tempHandler)\n\n    // will stop LED notification incase it was set by med reminder\n    subscribe(deviceAccelerationSensor, \"acceleration.active\", motionHandler)\n    \n    // how many minutes to look in the past from the reminder time\n    state.minutesToCheckPriorToReminder = 60\n    \n    // Set a timer to run once a day to notify if draw wasn't opened yet\n    schedule(reminderTime, checkMotionInPast)\n}\n\n\n// If temp > 39 then send an app notification out.\ndef tempHandler(evt){\n\tif (evt.doubleValue > tempThreshold) {\n    \tlog.debug \"Fridge temp of $evt.value exceeded threshold\"\n   \t\tsendNotification(\"WARNING: Fridge temp is $evt.value with threshold of $tempThreshold\")\n\t}\n}\n\n// Should turn off any LED notification once motion detected\ndef motionHandler(evt){\n    // always call out to stop any possible LED notification\n\tlog.debug \"Medication moved. Send stop LED notification\"\n    resetLEDNotification()\n}\n\n// If no motion detected within 60 minutes of the timer send notification out.\ndef checkMotionInPast(){\n\tlog.debug \"Checking past 60 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 60 minutes for any OPENED status\n    def movement = isMoved(state.minutesToCheckPriorToReminder)\n\tlog.debug \"Motion found: $movement\"\n    \n    // if there was movement, then do nothing and assume they took their meds\n    if (!movement) {    \n    \tsendNotification(\"Hi, please remember to take your meds in the fridge\")\n    \n        // if no movement, send out notification and set new reminder    \n        def reminderTimePlus10 = new Date(now() + (10 * 60000))\n\n        // needs to be scheduled if draw wasn't already opened\n        runOnce(reminderTimePlus10, checkMotionAfterReminder)\n    }\n}\n\n// If still no movement after 10 minutes past reminder, use LED notification\ndef checkMotionAfterReminder(){\n\tlog.debug \"Checking additional 10 minutes of activity from $reminderTime\"\n    \n    // check activity of sensor for past 10 minutes for any OPENED status\n    def movement = isMoved(10)    \n    \n   \tlog.debug \"Motion found: $movement\"\n        \n    // if no open activity, blink lights\n    if (!movement) {\n    \tlog.debug \"Notify LED API\"\n        setLEDNotification()\n    }\n    \n}\n\n// Helper function for sending out an app notification\ndef sendNotification(msg){\n        log.debug \"Message Sent: $msg\"\n        sendPush(msg)\n}\n\n// Check if the accelerometer has been activated since the minutes entered\n// Return true if active, else false.\ndef isMoved(minutes){\n    // query last X minutes of activity log    \n    def previousDateTime = new Date(now() - (minutes * 60000))\n    \n    // capture all events recorded\n    def evts = deviceAccelerationSensor.eventsSince(previousDateTime)   \n    def motion = false\n    if (evts.size() > 0) {\n        evts.each{\n            if(it.value == \"active\") {\n                motion = true \n            }\n        }\n\t}\n    \n    return motion\n}\n\n// Saves current color and sets the light to RED\ndef setLEDNotification(){\n\n\t// turn light back off when reset is called if it was originally off\n \tstate.ledState = deviceLight.currentValue(\"switch\")\n\n\t// set light to RED and store original color until stopped    \n    state.origColor = deviceLight.currentValue(\"hue\")\n    deviceLight.on()\n    deviceLight.setHue(100)\n    \n    log.debug \"LED set to RED. Original color stored: $state.origColor\"\n\n}\n\n// Sets the color back to the original saved color\ndef resetLEDNotification(){\n\n    // return color to original\n    log.debug \"Reset LED color to: $state.origColor\"\n    deviceLight.setHue(state.origColor)\n    \n    // if the light was turned on just for the notification, turn it back off now\n    if (state.ledState == \"off\") {\n    \tdeviceLight.off()\n    }\n}",
        "docstring": "This only supports devices with capabilities TemperatureMeasurement, AccelerationSensor and ColorControl (LED). Supports two use cases. First, will notifies via in-app if the fridge where meds are stored exceeds a temperature threshold set in degrees. Secondly, sends an in-app and ambient light notification if you forget to take your meds by sensing movement of the medicine box in the fridge. A reminder will be set to a single time per day. If the box isn't moved within 60 minutes of that reminder, an in-app message will be sent. If the box still isn't moved after an additional 10 minutes, then an LED light turns red until the box is moved"
    },
    {
        "code": "if (masterInList) {\n        \tsection (\"**WARNING**\"){\n            \tparagraph \"You have included the Master Light in the Slave Group. This will cause a loop in execution. Please remove this device from the Slave Group.\", image: \"https://raw.githubusercontent.com/MichaelStruck/SmartThingsPublic/master/img/caution.png\"\n            }\n        }\n        section(\"Master Light\") {\n\t\t\tinput \"master\", \"capability.colorControl\", title: \"Colored Light\", required: true\n\t\t}\n\t\tsection(\"Lights that follow the master settings\") {\n\t\t\tinput \"slaves\", \"capability.colorControl\", title: \"Colored Lights\",  multiple: true, required: true, submitOnChange: true\n\t\t}\n    \tsection([mobileOnly:true], \"Options\") {\n\t\t\tinput \"randomYes\", \"bool\",title: \"When Master Turned On, Randomize Color\", defaultValue: false\n\t\t\thref \"pageAbout\", title: \"About ${textAppName()}\", description: \"Tap to get application version, license and instructions\"\n        }\n\t}\n}\n\ndef pageAbout() {\n    dynamicPage(name: \"pageAbout\", title: \"About ${textAppName()}\", install: false, uninstall: true, nextPage: null) {\n        section {\n            paragraph \"${textVersion()}\\n${textCopyright()}\\n\\n${textLicense()}\\n\"\n        }\n        section(\"Instructions\") {\n            paragraph textHelp()\n        }\n    }\n}\n\ndef installed() {\n\tinit()\n}\n\ndef updated(){\n\tunsubscribe()\n    init()\n}\n\ndef init() {\n\tsubscribe(master, \"switch\", onOffHandler)\n\tsubscribe(master, \"level\", colorHandler)\n    subscribe(master, \"hue\", colorHandler)\n    subscribe(master, \"saturation\", colorHandler)\n    subscribe(master, \"colorTemperature\", tempHandler)\n}\n//-----------------------------------\ndef onOffHandler(evt){\n\tif (slaves && master) {\n\t\tif (!slaves?.id.find{it==master?.id}){\n\t\tif (master?.currentValue(\"switch\") == \"on\"){\n\t\t    if (randomYes) getRandomColorMaster()\n\t\t\t\telse slaves?.on()\n\t\t}\n\t\telse {\n\t\t    slaves?.off()\n\t\t}\n\t\t}\n\t}\n}\n\ndef colorHandler(evt) {\n\tif (slaves && master) {\n\t\tif (!slaves?.id?.find{it==master?.id} && master?.currentValue(\"switch\") == \"on\"){\n\t\t\tlog.debug \"Changing Slave units H,S,L\"\n\t\t\tdef dimLevel = master?.currentValue(\"level\")\n\t\t\tdef hueLevel = master?.currentValue(\"hue\")\n\t\t\tdef saturationLevel = master.currentValue(\"saturation\")\n\t\t\tdef newValue = [hue: hueLevel, saturation: saturationLevel, level: dimLevel as Integer]\n\t\t\tslaves?.setColor(newValue)\n\t\t}\n\t}\n}\n\ndef getRandomColorMaster(){\n    def hueLevel = Math.floor(Math.random() *1000)\n    def saturationLevel = Math.floor(Math.random() * 100)\n    def dimLevel = master?.currentValue(\"level\")\n\tdef newValue = [hue: hueLevel, saturation: saturationLevel, level: dimLevel as Integer]\n    log.debug hueLevel\n    log.debug saturationLevel\n    master.setColor(newValue)\n    slaves?.setColor(newValue)\n}\n\ndef tempHandler(evt){\n\tif (slaves && master) {\n\t    if (!slaves?.id?.find{it==master?.id} && master?.currentValue(\"switch\") == \"on\"){\n\t\tif (evt.value != \"--\") {\n\t\t    log.debug \"Changing Slave color temp based on Master change\"\n\t\t    def tempLevel = master.currentValue(\"colorTemperature\")\n\t\t    slaves?.setColorTemperature(tempLevel)\n\t\t}\n\t\t}\n\t}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Color Coordinator\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 1.1.2 (4/27/2018)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright © 2018 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"This application will allow you to control the settings of multiple colored lights with one control. \" +\n        \"Simply choose a master control light, and then choose the lights that will follow the settings of the master, \"+\n        \"including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.\"\n}",
        "docstring": "Ties multiple colored lights to one specific light's settings"
    },
    {
        "code": "section (\"Scheduling scenarios...\") {\n        \thref(name: \"toA_Scenario\", page: \"A_Scenario\", title: getTitle (titleA, \"A\"), description: schedDesc(timeOnA1,timeOffA1,timeOnA2,timeOffA2,timeOnA3,timeOffA3,timeOnA4,timeOffA4, modeA, daysA), state: greyOut(timeOnA1,timeOnA2,timeOnA3,timeOnA4))\n        \thref(name: \"toB_Scenario\", page: \"B_Scenario\", title: getTitle (titleB, \"B\"), description: schedDesc(timeOnB1,timeOffB1,timeOnB2,timeOffB2,timeOnB3,timeOffB3,timeOnB4,timeOffB4, modeB, daysB), state: greyOut(timeOnB1,timeOnB2,timeOnB3,timeOnB4))\n        \thref(name: \"toC_Scenario\", page: \"C_Scenario\", title: getTitle (titleC, \"C\"), description: schedDesc(timeOnC1,timeOffC1,timeOnC2,timeOffC2,timeOnC3,timeOffC3,timeOnC4,timeOffC4, modeC, daysC), state: greyOut(timeOnC1,timeOnC2,timeOnC3,timeOnC4))\n        \thref(name: \"toD_Scenario\", page: \"D_Scenario\", title: getTitle (titleD, \"D\"), description: schedDesc(timeOnD1,timeOffD1,timeOnD2,timeOffD2,timeOnD3,timeOffD3,timeOnD4,timeOffD4, modeD, daysD), state: greyOut(timeOnD1,timeOnD2,timeOnD3,timeOnD4))\n        }\n        section([mobileOnly:true], \"Options\") {\n\t\t\tlabel(title: \"Assign a name\", required: false, defaultValue: \"Smart Home Ventilation\")\n\t\t\thref \"pageAbout\", title: \"About ${textAppName()}\", description: \"Tap to get application version, license and instructions\"\n        }\n    }\n}\n//----Scheduling Pages\npage(name: \"A_Scenario\", title: getTitle (titleA, \"A\")) {\n    \tsection{\n\t\t\tinput \"timeOnA1\", title: \"Schedule 1 time to turn on\", \"time\", required: false\n        \tinput \"timeOffA1\", title: \"Schedule 1 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n\t\t\tinput \"timeOnA2\", title: \"Schedule 2 time to turn on\", \"time\", required: false\n        \tinput \"timeOffA2\", title: \"Schedule 2 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnA3\", title: \"Schedule 3 time to turn on\", \"time\", required: false\n        \tinput \"timeOffA3\", title: \"Schedule 3 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnA4\", title: \"Schedule 4 time to turn on\", \"time\", required: false\n        \tinput \"timeOffA4\", title: \"Schedule 4 time to turn off\", \"time\", required: false\n\t\t}\n\t\tsection (\"Options\") {\n    \t\tinput \"titleA\", title: \"Assign a scenario name\", \"text\", required: false\n            input \"modeA\", \"mode\", required: false, multiple: true, title: \"Run in specific mode(s)\", description: \"Choose Modes\"\n\t\t   \tinput \"daysA\", \"enum\", multiple: true, title: \"Run on specific day(s)\", description: \"Choose Days\", required: false, options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t}\n    }\n\npage(name: \"B_Scenario\", title: getTitle (titleB, \"B\")) {\n    \tsection{\n\t\t\tinput \"timeOnB1\", title: \"Schedule 1 time to turn on\", \"time\", required: false\n        \tinput \"timeOffB1\", title: \"Schedule 1 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n\t\t\tinput \"timeOnB2\", title: \"Schedule 2 time to turn on\", \"time\", required: false\n        \tinput \"timeOffB2\", title: \"Schedule 2 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnB3\", title: \"Schedule 3 time to turn on\", \"time\", required: false\n        \tinput \"timeOffB3\", title: \"Schedule 3 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnB4\", title: \"Schedule 4 time to turn on\", \"time\", required: false\n        \tinput \"timeOffB4\", title: \"Schedule 4 time to turn off\", \"time\", required: false\n\t\t}\n\t\tsection(\"Options\") {\n    \t\tinput \"titleB\", title: \"Assign a scenario name\", \"text\", required: false\n            input \"modeB\", \"mode\", required: false, multiple: true, title: \"Run in specific mode(s)\", description: \"Choose Modes\"\n\t\t   \tinput \"daysB\", \"enum\", multiple: true, title: \"Run on specific day(s)\", description: \"Choose Days\", required: false, options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t}\n    }\n\npage(name: \"C_Scenario\", title: getTitle (titleC, \"C\")) {\n    \tsection{\n\t\t\tinput \"timeOnC1\", title: \"Schedule 1 time to turn on\", \"time\", required: false\n        \tinput \"timeOffC1\", title: \"Schedule 1 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n\t\t\tinput \"timeOnC2\", title: \"Schedule 2 time to turn on\", \"time\", required: false\n        \tinput \"timeOffC2\", title: \"Schedule 2 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnC3\", title: \"Schedule 3 time to turn on\", \"time\", required: false\n        \tinput \"timeOffC3\", title: \"Schedule 3 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnC4\", title: \"Schedule 4 time to turn on\", \"time\", required: false\n        \tinput \"timeOffC4\", title: \"Schedule 4 time to turn off\", \"time\", required: false\n\t\t}\n\t\tsection(\"Options\") {\n    \t\tinput \"titleC\", title: \"Assign a scenario name\", \"text\", required: false\n            input \"modeC\", \"mode\", required: false, multiple: true, title: \"Run in specific mode(s)\", description: \"Choose Modes\"\n\t\t   \tinput \"daysC\", \"enum\", multiple: true, title: \"Run on specific day(s)\", description: \"Choose Days\", required: false, options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t}\n    }\n\n\npage(name: \"D_Scenario\", title: getTitle (titleD, \"D\")) {\n    \tsection{\n\t\t\tinput \"timeOnD1\", title: \"Schedule 1 time to turn on\", \"time\", required: false\n        \tinput \"timeOffD1\", title: \"Schedule 1 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n\t\t\tinput \"timeOnD2\", title: \"Schedule 2 time to turn on\", \"time\", required: false\n        \tinput \"timeOffD2\", title: \"Schedule 2 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnD3\", title: \"Schedule 3 time to turn on\", \"time\", required: false\n        \tinput \"timeOffD3\", title: \"Schedule 3 time to turn off\", \"time\", required: false\n\t\t}\n    \tsection{\n        \tinput \"timeOnD4\", title: \"Schedule 4 time to turn on\", \"time\", required: false\n        \tinput \"timeOffD4\", title: \"Schedule 4 time to turn off\", \"time\", required: false\n\t\t}\n        section(\"Options\") {\n    \t\tinput \"titleD\", title: \"Assign a scenario name\", \"text\", required: false\n            input \"modeD\", \"mode\", required: false, multiple: true, title: \"Run in specific mode(s)\", description: \"Choose Modes\"\n\t\t   \tinput \"daysD\", \"enum\", multiple: true, title: \"Run on specific day(s)\", description: \"Choose Days\", required: false, options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t}\n    }\n\n\npage(name: \"pageAbout\", title: \"About ${textAppName()}\") {\n        section {\n            paragraph \"${textVersion()}\\n${textCopyright()}\\n\\n${textLicense()}\\n\"\n        }\n        section(\"Instructions\") {\n            paragraph textHelp()\n        }\n}\n\n// Install and initiate\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    init()\n}\n\ndef updated() {\n    unschedule()\n    turnOffSwitch() //Turn off all switches if the schedules are changed while in mid-schedule\n    unsubscribe()\n    log.debug \"Updated with settings: ${settings}\"\n    init()\n}\n\ndef init() {\n\tdef midnightTime = timeToday(\"2000-01-01T00:01:00.999-0000\", location.timeZone)\n    schedule (midnightTime, midNight)\n\tsubscribe(location, \"mode\", locationHandler)\n    startProcess()\n}\n\n// Common methods\n\ndef startProcess () {\n    createDayArray()\n\tstate.dayCount=state.data.size()\n    if (state.dayCount){\n\t\tstate.counter = 0\n        startDay()\n    }\n}\n\ndef startDay() {\n\tdef start = convertEpoch(state.data[state.counter].start)\n\tdef stop = convertEpoch(state.data[state.counter].stop)\n\n    runOnce(start, turnOnSwitch, [overwrite: true])\n    runOnce(stop, incDay, [overwrite: true])\n}\n\ndef incDay() {\n    turnOffSwitch()\n    if (state.modeChange) {\n    \tstartProcess()\n    }\n    else {\n    \tstate.counter = state.counter + 1\n    \tif (state.counter < state.dayCount) {\n    \t\tstartDay()\n    \t}\n    }\n}\n\ndef locationHandler(evt) {\n\tdef result = false\n    state.modeChange = true\n    switches.each {\n    \tif (it.currentValue(\"switch\")==\"on\"){\n           result = true\n        }\n    }\n\tif (!result) {\n    \tstartProcess()\n    }\n}\n\ndef midNight(){\n    startProcess()\n}\n\ndef turnOnSwitch() {\n    switches.on()\n    log.debug \"Home ventilation switches are on.\"\n}\n\ndef turnOffSwitch() {\n    switches.each {\n    \tif (it.currentValue(\"switch\")==\"on\"){\n\t\t\tit.off()\n        }\n    }\n    log.debug \"Home ventilation switches are off.\"\n}\n\ndef schedDesc(on1, off1, on2, off2, on3, off3, on4, off4, modeList, dayList) {\n\tdef title = \"\"\n\tdef dayListClean = \"On \"\n    def modeListClean =\"Scenario runs in \"\n    if (dayList && dayList.size() < 7) {\n    \tdef dayListSize = dayList.size()\n        for (dayName in dayList) {\n        \tdayListClean = \"${dayListClean}\"+\"${dayName}\"\n    \t\tdayListSize = dayListSize -1\n            if (dayListSize) {\n            \tdayListClean = \"${dayListClean}, \"\n            }\n        }\n\t}\n    else {\n    \tdayListClean = \"Every day\"\n    }\n    if (modeList) {\n    \tdef modeListSize = modeList.size()\n        def modePrefix =\"modes\"\n        if (modeListSize == 1) {\n        \tmodePrefix = \"mode\"\n        }\n        for (modeName in modeList) {\n        \tmodeListClean = \"${modeListClean}\"+\"'${modeName}'\"\n    \t\tmodeListSize = modeListSize -1\n            if (modeListSize) {\n            \tmodeListClean = \"${modeListClean}, \"\n            }\n            else {\n            \tmodeListClean = \"${modeListClean} ${modePrefix}\"\n        \t}\n        }\n\t}\n    else {\n    \tmodeListClean = \"${modeListClean}all modes\"\n    }\n    if (on1 && off1){\n    \ttitle += \"Schedule 1: ${humanReadableTime(on1)} to ${humanReadableTime(off1)}\"\n    }\n    if (on2 && off2) {\n    \ttitle += \"\\nSchedule 2: ${humanReadableTime(on2)} to ${humanReadableTime(off2)}\"\n    }\n    if (on3 && off3) {\n    \ttitle += \"\\nSchedule 3: ${humanReadableTime(on3)} to ${humanReadableTime(off3)}\"\n    }\n    if (on4 && off4) {\n    \ttitle += \"\\nSchedule 4: ${humanReadableTime(on4)} to ${humanReadableTime(off4)}\"\n    }\n    if (on1 || on2 || on3 || on4) {\n    \ttitle += \"\\n$modeListClean\"\n    \ttitle += \"\\n$dayListClean\"\n    }\n\n    if (!on1 && !on2 && !on3 && !on4) {\n    \ttitle=\"Click to configure scenario\"\n    }\n    title\n}\n\ndef greyOut(on1, on2, on3, on4){\n    def result = on1 || on2 || on3 || on4 ? \"complete\" : \"\"\n}\n\npublic humanReadableTime(dateTxt) {\n\tnew Date().parse(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", dateTxt).format(\"h:mm a\", timeZone(dateTxt))\n}\n\npublic convertEpoch(epochDate) {\n    new Date(epochDate).format(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", location.timeZone)\n}\n\nprivate getTitle(txt, scenario) {\n    def title = txt ? txt : \"Scenario ${scenario}\"\n}\n\nprivate daysOk(dayList) {\n\tdef result = true\n    if (dayList) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = dayList.contains(day)\n\t}\n    result\n}\n\nprivate timeOk(starting, ending) {\n    if (starting && ending) {\n        def currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n        if (start < stop && start >= currTime && stop>=currTime) {\n        \tstate.data << [start:start, stop:stop]\n        }\n    }\n}\n\ndef createDayArray() {\n\tstate.modeChange = false\n    state.data = []\n    if (modeA && modeA.contains(location.mode)) {\n        if (daysOk(daysA)){\n            timeOk(timeOnA1, timeOffA1)\n\t\t\ttimeOk(timeOnA2, timeOffA2)\n\t\t\ttimeOk(timeOnA3, timeOffA3)\n\t\t\ttimeOk(timeOnA4, timeOffA4)\n        }\n    }\n    if (modeB && modeB.contains(location.mode)) {\n        if (daysOk(daysB)){\n\t\t\ttimeOk(timeOnB1, timeOffB1)\n            timeOk(timeOnB2, timeOffB2)\n            timeOk(timeOnB3, timeOffB3)\n            timeOk(timeOnB4, timeOffB4)\n        }\n    }\n    if (modeC && modeC.contains(location.mode)) {\n        if (daysOk(daysC)){\n            timeOk(timeOnC1, timeOffC1)\n            timeOk(timeOnC2, timeOffC2)\n            timeOk(timeOnC3, timeOffC3)\n            timeOk(timeOnC4, timeOffC4)\n        }\n    }\n    if (modeD && modeD.contains(location.mode)) {\n        if (daysOk(daysD)){\n           timeOk(timeOnD1, timeOffD1)\n           timeOk(timeOnD2, timeOffD2)\n           timeOk(timeOnD3, timeOffD3)\n           timeOk(timeOnD4, timeOffD4)\n        }\n    }\n    state.data.sort{it.start}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Smart Home Ventilation\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 2.1.2 (05/31/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright © 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different \" +\n        \"venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended \"+\n        \"that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  \" +\n        \"avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule \" +\n        \"at 12:15 am or later.\"\n}",
        "docstring": "Allows for setting up various schedule scenarios for turning on and off home ventilation switches."
    },
    {
        "code": "def phrases = location.helloHome?.getPhrases()*.label\n\t\t\tif (phrases) {\n        \t\tphrases.sort()\n\t\t\t\tsection(\"Perform which phrase when...\") {\n\t\t\t\t\tinput \"phrase_on\", \"enum\", title: \"Switch is on\", options: phrases, required: false\n\t\t\t\t\tinput \"phrase_off\", \"enum\", title: \"Switch is off\", options: phrases, required: false\n\t\t\t\t}\n\t\t\t}\n\t\tsection(\"Change to which mode when...\") {\n\t\t\tinput \"onMode\", \"mode\", title: \"Switch is on\", required: false\n\t\t\tinput \"offMode\", \"mode\", title: \"Switch is off\", required: false \n\t\t}\n\t\tsection([mobileOnly:true], \"Options\") {\n\t\t\tlabel(title: \"Assign a name\", required: false)\n    \t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t\thref \"pageAbout\", title: \"About ${textAppName()}\", description: \"Tap to get application version, license and instructions\"\n\t\t}\n    }\n}\n\npage(name: \"pageAbout\", title: \"About ${textAppName()}\") {\n        section {\n            paragraph \"${textVersion()}\\n${textCopyright()}\\n\\n${textLicense()}\\n\"\n        }\n        section(\"Instructions\") {\n            paragraph textHelp()\n        }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\" && (phrase_on || onMode)) {\n    \tif (phrase_on){\n        \tlocation.helloHome.execute(settings.phrase_on)\n        }\n        if (onMode) {\n        \tchangeMode(onMode)\n        }\n    } \n    else if (evt.value == \"off\" && (phrase_off || offMode)) {\n    \tif (phrase_off){\n        \tlocation.helloHome.execute(settings.phrase_off)\n    \t}\n        if (offMode) {\n        \tchangeMode(offMode)\n        }\n    }\n}\n\ndef changeMode(newMode) {\n\tif (location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t} else {\n\t\t\tlog.debug \"Unable to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n\tdef text = \"Switch Activates Home Phrase or Mode\"\n}\t\n\nprivate def textVersion() {\n    def text = \"Version 1.0.1 (06/20/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright © 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n\t\t\"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n\t\t\"you may not use this file except in compliance with the License. \"+\n\t\t\"You may obtain a copy of the License at\"+\n\t\t\"\\n\\n\"+\n\t\t\"    http://www.apache.org/licenses/LICENSE-2.0\"+\n\t\t\"\\n\\n\"+\n\t\t\"Unless required by applicable law or agreed to in writing, software \"+\n\t\t\"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n\t\t\"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n\t\t\"See the License for the specific language governing permissions and \"+\n\t\t\"limitations under the License.\"\n}\n\nprivate def textHelp() {\n\tdef text =\n    \t\"Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT. \"+\n\t\t\"Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. \"+\n\t\t\"Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.\" \n}",
        "docstring": "Ties a Hello, Home phrase or mode to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "def phrases = location.helloHome?.getPhrases()*.label\n\t\tif (phrases) {\n        \tphrases.sort()\n\t\t\tsection(\"Perform the following phrase when...\") {\n\t\t\t\tlog.trace phrases\n\t\t\t\tinput \"phrase_on\", \"enum\", title: \"Switch is on\", required: true, options: phrases\n\t\t\t\tinput \"phrase_off\", \"enum\", title: \"Switch is off\", required: true, options: phrases\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\") {\n    \tlocation.helloHome.execute(settings.phrase_on)\n    } else {\n    \tlocation.helloHome.execute(settings.phrase_off)\n    }\n}",
        "docstring": "Ties a Hello, Home phrase to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "section(\"Change to a new mode when...\") {\n\t\t\tinput \"onMode\", \"mode\", title: \"Switch is on\", required: false\n\t\t\tinput \"offMode\", \"mode\", title: \"Switch is off\", required: false \n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe(controlSwitch, \"switch\", \"switchHandler\")\n}\n\ndef switchHandler(evt) {\n\tif (evt.value == \"on\") {\n    \tchangeMode(onMode)\n    } else {\n    \tchangeMode(offMode)\n    }\n}\n\ndef changeMode(newMode) {\n\n\tif (newMode && location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t}\n\t\telse {\n\t\tlog.debug \"Unable to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}",
        "docstring": "Ties a mode to a switch's state. Perfect for use with IFTTT."
    },
    {
        "code": "}\n        section {\n            href \"pageSetupScenarioB\", title: getTitle(ScenarioNameB, 2), description: getDesc(B_timeStart, B_sonos, B_day, B_mode), state: greyOut(ScenarioNameB, B_sonos, B_timeStart, B_alarmOn, B_alarmType)\n            if (ScenarioNameB && B_sonos && B_timeStart  && B_alarmType){\n                input \"B_alarmOn\", \"bool\", title: \"Enable this alarm?\", defaultValue: \"false\", submitOnChange:true\n            }\n        }\n        section {\n            href \"pageSetupScenarioC\", title: getTitle(ScenarioNameC, 3), description: getDesc(C_timeStart, C_sonos, C_day, C_mode), state: greyOut(ScenarioNameC, C_sonos, C_timeStart, C_alarmOn, C_alarmType)\n            if (ScenarioNameC && C_sonos && C_timeStart && C_alarmType){\n                input \"C_alarmOn\", \"bool\", title: \"Enable this alarm?\", defaultValue: \"false\", submitOnChange:true\n            }\n        }\n        section {\n            href \"pageSetupScenarioD\", title: getTitle(ScenarioNameD, 4), description: getDesc(D_timeStart, D_sonos, D_day, D_mode), state: greyOut(ScenarioNameD, D_sonos, D_timeStart, D_alarmOn, D_alarmType)\n            if (ScenarioNameD && D_sonos && D_timeStart && D_alarmType){\n                input \"D_alarmOn\", \"bool\", title: \"Enable this alarm?\", defaultValue: \"false\", submitOnChange:true\n            }\n        }\n        section([title:\"Options\", mobileOnly:true]) {\n            input \"alarmSummary\", \"bool\", title: \"Enable Alarm Summary\", defaultValue: \"false\", submitOnChange:true\n            if (alarmSummary) {\n                href \"pageAlarmSummary\", title: \"Alarm Summary Settings\", description: \"Tap to configure alarm summary settings\", state: \"complete\"\n            }\n            input \"zipCode\", \"text\", title: \"Zip Code\", required: false\n            label title:\"Assign a name\", required: false\n            href \"pageAbout\", title: \"About ${textAppName()}\", description: \"Tap to get application version, license and instructions\"\n        }\n    }\n}\n\npage(name: \"pageAlarmSummary\", title: \"Alarm Summary Settings\") {\n    section {\n           input \"summarySonos\", \"capability.musicPlayer\", title: \"Choose a Sonos speaker\", required: false\n        input \"summaryVolume\", \"number\", title: \"Set the summary volume\", description: \"0-100%\", required: false\n        input \"summaryDisabled\", \"bool\", title: \"Include disabled or unconfigured alarms in summary\", defaultValue: \"false\"\n        input \"summaryMode\", \"mode\", title: \"Speak summary only during the following modes...\", multiple: true, required: false\n    }\n}\n//Show \"pageSetupScenarioA\" page\ndef pageSetupScenarioA() {\n    dynamicPage(name: \"pageSetupScenarioA\") {\n        section(\"Alarm settings\") {\n            input \"ScenarioNameA\", \"text\", title: \"Scenario Name\", multiple: false, required: true\n            input \"A_sonos\", \"capability.musicPlayer\", title: \"Choose a Sonos speaker\", required: true, submitOnChange:true\n            input \"A_volume\", \"number\", title: \"Alarm volume\", description: \"0-100%\", required: false\n            input \"A_timeStart\", \"time\", title: \"Time to trigger alarm\", required: true\n            input \"A_day\", \"enum\", options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], title: \"Alarm on certain days of the week...\", multiple: true, required: false\n            input \"A_mode\", \"mode\", title: \"Alarm only during the following modes...\", multiple: true, required: false\n            input \"A_alarmType\", \"enum\", title: \"Select a primary alarm type...\", multiple: false, required: true, options: [[1:\"Alarm sound (up to 20 seconds)\"],[2:\"Voice Greeting\"],[3:\"Music track/Internet Radio\"]], submitOnChange:true\n\n            if (A_alarmType != \"3\") {\n                if (A_alarmType == \"1\"){\n                    input \"A_secondAlarm\", \"enum\", title: \"Select a second alarm after the first is completed\", multiple: false, required: false, options: [[1:\"Voice Greeting\"],[2:\"Music track/Internet Radio\"]], submitOnChange:true\n                }\n                if (A_alarmType == \"2\"){\n                    input \"A_secondAlarmMusic\", \"bool\", title: \"Play a track after voice greeting\", defaultValue: \"false\", required: false, submitOnChange:true\n                }\n            }\n        }\n        if (A_alarmType == \"1\"){\n            section (\"Alarm sound options\"){\n                input \"A_soundAlarm\", \"enum\", title: \"Play this sound...\", required:false, multiple: false, options: [[1:\"Alien-8 seconds\"],[2:\"Bell-12 seconds\"], [3:\"Buzzer-20 seconds\"], [4:\"Fire-20 seconds\"], [5:\"Rooster-2 seconds\"], [6:\"Siren-20 seconds\"]]\n                input \"A_soundLength\", \"number\", title: \"Maximum time to play sound (empty=use sound default)\", description: \"1-20\", required: false\n               }\n        }\n        if (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\")) {\n            section (\"Voice greeting options\") {\n                input \"A_wakeMsg\", \"text\", title: \"Wake voice message\", defaultValue: \"Good morning! It is %time% on %day%, %date%.\", required: false\n                href \"pageWeatherSettingsA\", title: \"Weather Reporting Settings\", description: getWeatherDesc(A_weatherReport, A_includeSunrise, A_includeSunset, A_includeTemp, A_humidity, A_localTemp), state: greyOut1(A_weatherReport, A_includeSunrise, A_includeSunset, A_includeTemp, A_humidity, A_localTemp)\n            }\n        }\n           if (A_alarmType == \"3\" || (A_alarmType == \"1\" && A_secondAlarm ==\"2\") || (A_alarmType == \"2\" && A_secondAlarmMusic)){\n            section (\"Music track/internet radio options\"){\n                input \"A_musicTrack\", \"enum\", title: \"Play this track/internet radio station\", required:false, multiple: false, options: songOptions(A_sonos, 1)\n            }\n          }\n        section(\"Devices to control in this alarm scenario\") {\n            input \"A_switches\", \"capability.switch\",title: \"Control the following switches...\", multiple: true, required: false, submitOnChange:true\n            href \"pageDimmersA\", title: \"Dimmer Settings\", description: dimmerDesc(A_dimmers), state: greyOutOption(A_dimmers), submitOnChange:true\n            href \"pageThermostatsA\", title: \"Thermostat Settings\", description: thermostatDesc(A_thermostats, A_temperatureH, A_temperatureC), state: greyOutOption(A_thermostats), submitOnChange:true\n            if ((A_switches || A_dimmers || A_thermostats) && (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\"))){\n                input \"A_confirmSwitches\", \"bool\", title: \"Confirm switches/thermostats status in voice message\", defaultValue: \"false\"\n            }\n        }\n        section (\"Other actions at alarm time\"){\n            def phrases = location.helloHome?.getPhrases()*.label\n            if (phrases) {\n                phrases.sort()\n                input \"A_phrase\", \"enum\", title: \"Alarm triggers the following phrase\", required: false, options: phrases, multiple: false, submitOnChange:true\n                if (A_phrase  && (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\"))){\n                    input \"A_confirmPhrase\", \"bool\", title: \"Confirm Hello, Home phrase in voice message\", defaultValue: \"false\"\n                }\n            }\n            input \"A_triggerMode\", \"mode\", title: \"Alarm triggers the following mode\", required: false, submitOnChange:true\n               if (A_triggerMode  && (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\"))){\n                input \"A_confirmMode\", \"bool\", title: \"Confirm mode in voice message\", defaultValue: \"false\"\n            }\n        }\n    }\n}\n\npage(name: \"pageDimmersA\", title: \"Dimmer Settings\") {\n    section {\n           input \"A_dimmers\", \"capability.switchLevel\", title: \"Dim the following...\", multiple: true, required: false\n        input \"A_level\", \"enum\", options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],title: \"Set dimmers to this level\", multiple: false, required: false\n    }\n}\n\npage(name: \"pageThermostatsA\", title: \"Thermostat Settings\") {\n    section {\n           input \"A_thermostats\", \"capability.thermostat\", title: \"Thermostat to control...\", multiple: false, required: false\n    }\n    section {\n        input \"A_temperatureH\", \"number\", title: \"Heating setpoint\", required: false, description: \"Temperature when in heat mode\"\n        input \"A_temperatureC\", \"number\", title: \"Cooling setpoint\", required: false, description: \"Temperature when in cool mode\"\n    }\n}\n\ndef pageWeatherSettingsA() {\n    dynamicPage(name: \"pageWeatherSettingsA\", title: \"Weather Reporting Settings\") {\n        section {\n            input \"A_includeTemp\", \"bool\", title: \"Speak current temperature (from local forecast)\", defaultValue: \"false\"\n            input \"A_localTemp\", \"capability.temperatureMeasurement\", title: \"Speak local temperature (from device)\", required: false, multiple: false\n            input \"A_humidity\", \"capability.relativeHumidityMeasurement\", title: \"Speak local humidity (from device)\", required: false, multiple: false\n            input \"A_weatherReport\", \"bool\", title: \"Speak today's weather forecast\", defaultValue: \"false\"\n            input \"A_includeSunrise\", \"bool\", title: \"Speak today's sunrise\", defaultValue: \"false\"\n            input \"A_includeSunset\", \"bool\", title: \"Speak today's sunset\", defaultValue: \"false\"\n        }\n    }\n}\n\n//Show \"pageSetupScenarioB\" page\ndef pageSetupScenarioB() {\n    dynamicPage(name: \"pageSetupScenarioB\") {\n        section(\"Alarm settings\") {\n            input \"ScenarioNameB\", \"text\", title: \"Scenario Name\", multiple: false, required: true\n            input \"B_sonos\", \"capability.musicPlayer\", title: \"Choose a Sonos speaker\", required: true, submitOnChange:true\n            input \"B_volume\", \"number\", title: \"Alarm volume\", description: \"0-100%\", required: false\n            input \"B_timeStart\", \"time\", title: \"Time to trigger alarm\", required: true\n            input \"B_day\", \"enum\", options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], title: \"Alarm on certain days of the week...\", multiple: true, required: false\n            input \"B_mode\", \"mode\", title: \"Alarm only during the following modes...\", multiple: true, required: false\n            input \"B_alarmType\", \"enum\", title: \"Select a primary alarm type...\", multiple: false, required: true, options: [[1:\"Alarm sound (up to 20 seconds)\"],[2:\"Voice Greeting\"],[3:\"Music track/Internet Radio\"]], submitOnChange:true\n\n            if (B_alarmType != \"3\") {\n                if (B_alarmType == \"1\"){\n                    input \"B_secondAlarm\", \"enum\", title: \"Select a second alarm after the first is completed\", multiple: false, required: false, options: [[1:\"Voice Greeting\"],[2:\"Music track/Internet Radio\"]], submitOnChange:true\n                }\n                if (B_alarmType == \"2\"){\n                    input \"B_secondAlarmMusic\", \"bool\", title: \"Play a track after voice greeting\", defaultValue: \"false\", required: false, submitOnChange:true\n                }\n            }\n        }\n        if (B_alarmType == \"1\"){\n            section (\"Alarm sound options\"){\n                input \"B_soundAlarm\", \"enum\", title: \"Play this sound...\", required:false, multiple: false, options: [[1:\"Alien-8 seconds\"],[2:\"Bell-12 seconds\"], [3:\"Buzzer-20 seconds\"], [4:\"Fire-20 seconds\"], [5:\"Rooster-2 seconds\"], [6:\"Siren-20 seconds\"]]\n                input \"B_soundLength\", \"number\", title: \"Maximum time to play sound (empty=use sound default)\", description: \"1-20\", required: false\n               }\n        }\n        if (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\")){\n            section (\"Voice greeting options\") {\n                input \"B_wakeMsg\", \"text\", title: \"Wake voice message\", defaultValue: \"Good morning! It is %time% on %day%, %date%.\", required: false\n                href \"pageWeatherSettingsB\", title: \"Weather Reporting Settings\", description: getWeatherDesc(B_weatherReport, B_includeSunrise, B_includeSunset, B_includeTemp, B_humidity, B_localTemp), state: greyOut1(B_weatherReport, B_includeSunrise, B_includeSunset, B_includeTemp, B_humidity, B_localTemp)\n            }\n        }\n           if (B_alarmType == \"3\" || (B_alarmType == \"1\" && B_secondAlarm ==\"2\") || (B_alarmType == \"2\" && B_secondAlarmMusic)){\n            section (\"Music track/internet radio options\"){\n                input \"B_musicTrack\", \"enum\", title: \"Play this track/internet radio station\", required:false, multiple: false, options: songOptions(B_sonos, 1)\n            }\n          }\n        section(\"Devices to control in this alarm scenario\") {\n            input \"B_switches\", \"capability.switch\",title: \"Control the following switches...\", multiple: true, required: false, submitOnChange:true\n            href \"pageDimmersB\", title: \"Dimmer Settings\", description: dimmerDesc(B_dimmers), state: greyOutOption(B_dimmers), submitOnChange:true\n            href \"pageThermostatsB\", title: \"Thermostat Settings\", description: thermostatDesc(B_thermostats, B_temperatureH, B_temperatureC), state: greyOutOption(B_thermostats), submitOnChange:true\n            if ((B_switches || B_dimmers || B_thermostats) && (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\"))){\n                input \"B_confirmSwitches\", \"bool\", title: \"Confirm switches/thermostats status in voice message\", defaultValue: \"false\"\n            }\n        }\n        section (\"Other actions at alarm time\"){\n            def phrases = location.helloHome?.getPhrases()*.label\n            if (phrases) {\n                phrases.sort()\n                input \"B_phrase\", \"enum\", title: \"Alarm triggers the following phrase\", required: false, options: phrases, multiple: false, submitOnChange:true\n                if (B_phrase  && (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\"))){\n                    input \"B_confirmPhrase\", \"bool\", title: \"Confirm Hello, Home phrase in voice message\", defaultValue: \"false\"\n                }\n            }\n            input \"B_triggerMode\", \"mode\", title: \"Alarm triggers the following mode\", required: false, submitOnChange:true\n               if (B_triggerMode  && (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\"))){\n                input \"B_confirmMode\", \"bool\", title: \"Confirm mode in voice message\", defaultValue: \"false\"\n            }\n        }\n    }\n}\n\npage(name: \"pageDimmersB\", title: \"Dimmer Settings\") {\n    section {\n           input \"B_dimmers\", \"capability.switchLevel\", title: \"Dim the following...\", multiple: true, required: false\n        input \"B_level\", \"enum\", options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],title: \"Set dimmers to this level\", multiple: false, required: false\n    }\n}\n\npage(name: \"pageThermostatsB\", title: \"Thermostat Settings\") {\n    section {\n           input \"B_thermostats\", \"capability.thermostat\", title: \"Thermostat to control...\", multiple: false, required: false\n    }\n    section {\n        input \"B_temperatureH\", \"number\", title: \"Heating setpoint\", required: false, description: \"Temperature when in heat mode\"\n        input \"B_temperatureC\", \"number\", title: \"Cooling setpoint\", required: false, description: \"Temperature when in cool mode\"\n    }\n}\n\ndef pageWeatherSettingsB() {\n    dynamicPage(name: \"pageWeatherSettingsB\", title: \"Weather Reporting Settings\") {\n        section {\n            input \"B_includeTemp\", \"bool\", title: \"Speak current temperature (from local forecast)\", defaultValue: \"false\"\n            input \"B_localTemp\", \"capability.temperatureMeasurement\", title: \"Speak local temperature (from device)\", required: false, multiple: false\n            input \"B_humidity\", \"capability.relativeHumidityMeasurement\", title: \"Speak local humidity (from device)\", required: false, multiple: false\n            input \"B_weatherReport\", \"bool\", title: \"Speak today's weather forecast\", defaultValue: \"false\"\n            input \"B_includeSunrise\", \"bool\", title: \"Speak today's sunrise\", defaultValue: \"false\"\n            input \"B_includeSunset\", \"bool\", title: \"Speak today's sunset\", defaultValue: \"false\"\n        }\n    }\n}\n\n//Show \"pageSetupScenarioC\" page\ndef pageSetupScenarioC() {\n    dynamicPage(name: \"pageSetupScenarioC\") {\n        section(\"Alarm settings\") {\n            input \"ScenarioNameC\", \"text\", title: \"Scenario Name\", multiple: false, required: true\n            input \"C_sonos\", \"capability.musicPlayer\", title: \"Choose a Sonos speaker\", required: true, submitOnChange:true\n            input \"C_volume\", \"number\", title: \"Alarm volume\", description: \"0-100%\", required: false\n            input \"C_timeStart\", \"time\", title: \"Time to trigger alarm\", required: true\n            input \"C_day\", \"enum\", options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], title: \"Alarm on certain days of the week...\", multiple: true, required: false\n            input \"C_mode\", \"mode\", title: \"Alarm only during the following modes...\", multiple: true, required: false\n            input \"C_alarmType\", \"enum\", title: \"Select a primary alarm type...\", multiple: false, required: true, options: [[1:\"Alarm sound (up to 20 seconds)\"],[2:\"Voice Greeting\"],[3:\"Music track/Internet Radio\"]], submitOnChange:true\n\n            if (C_alarmType != \"3\") {\n                if (C_alarmType == \"1\"){\n                    input \"C_secondAlarm\", \"enum\", title: \"Select a second alarm after the first is completed\", multiple: false, required: false, options: [[1:\"Voice Greeting\"],[2:\"Music track/Internet Radio\"]], submitOnChange:true\n                }\n                if (C_alarmType == \"2\"){\n                    input \"C_secondAlarmMusic\", \"bool\", title: \"Play a track after voice greeting\", defaultValue: \"false\", required: false, submitOnChange:true\n                }\n            }\n        }\n        if (C_alarmType == \"1\"){\n            section (\"Alarm sound options\"){\n                input \"C_soundAlarm\", \"enum\", title: \"Play this sound...\", required:false, multiple: false, options: [[1:\"Alien-8 seconds\"],[2:\"Bell-12 seconds\"], [3:\"Buzzer-20 seconds\"], [4:\"Fire-20 seconds\"], [5:\"Rooster-2 seconds\"], [6:\"Siren-20 seconds\"]]\n                input \"C_soundLength\", \"number\", title: \"Maximum time to play sound (empty=use sound default)\", description: \"1-20\", required: false\n               }\n        }\n\n        if (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\")) {\n            section (\"Voice greeting options\") {\n                input \"C_wakeMsg\", \"text\", title: \"Wake voice message\", defaultValue: \"Good morning! It is %time% on %day%, %date%.\", required: false\n                href \"pageWeatherSettingsC\", title: \"Weather Reporting Settings\", description: getWeatherDesc(C_weatherReport, C_includeSunrise, C_includeSunset, C_includeTemp, A_humidity, C_localTemp), state: greyOut1(C_weatherReport, C_includeSunrise, C_includeSunset, C_includeTemp, C_humidity, C_localTemp)            }\n        }\n\n           if (C_alarmType == \"3\" || (C_alarmType == \"1\" && C_secondAlarm ==\"2\") || (C_alarmType == \"2\" && C_secondAlarmMusic)){\n            section (\"Music track/internet radio options\"){\n                input \"C_musicTrack\", \"enum\", title: \"Play this track/internet radio station\", required:false, multiple: false, options: songOptions(C_sonos, 1)\n            }\n          }\n        section(\"Devices to control in this alarm scenario\") {\n            input \"C_switches\", \"capability.switch\",title: \"Control the following switches...\", multiple: true, required: false, submitOnChange:true\n            href \"pageDimmersC\", title: \"Dimmer Settings\", description: dimmerDesc(C_dimmers), state: greyOutOption(C_dimmers), submitOnChange:true\n            href \"pageThermostatsC\", title: \"Thermostat Settings\", description: thermostatDesc(C_thermostats, C_temperatureH, C_temperatureC), state: greyOutOption(C_thermostats), submitOnChange:true\n            if ((C_switches || C_dimmers || C_thermostats) && (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\"))){\n                input \"C_confirmSwitches\", \"bool\", title: \"Confirm switches/thermostats status in voice message\", defaultValue: \"false\"\n            }\n        }\n        section (\"Other actions at alarm time\"){\n            def phrases = location.helloHome?.getPhrases()*.label\n            if (phrases) {\n                phrases.sort()\n                input \"C_phrase\", \"enum\", title: \"Alarm triggers the following phrase\", required: false, options: phrases, multiple: false, submitOnChange:true\n                if (C_phrase  && (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\"))){\n                    input \"C_confirmPhrase\", \"bool\", title: \"Confirm Hello, Home phrase in voice message\", defaultValue: \"false\"\n                }\n            }\n            input \"C_triggerMode\", \"mode\", title: \"Alarm triggers the following mode\", required: false, submitOnChange:true\n               if (C_triggerMode  && (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\"))){\n                input \"C_confirmMode\", \"bool\", title: \"Confirm mode in voice message\", defaultValue: \"false\"\n            }\n        }\n    }\n}\n\npage(name: \"pageDimmersC\", title: \"Dimmer Settings\") {\n    section {\n           input \"C_dimmers\", \"capability.switchLevel\", title: \"Dim the following...\", multiple: true, required: false\n        input \"C_level\", \"enum\", options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],title: \"Set dimmers to this level\", multiple: false, required: false\n    }\n}\n\npage(name: \"pageThermostatsC\", title: \"Thermostat Settings\") {\n    section {\n           input \"C_thermostats\", \"capability.thermostat\", title: \"Thermostat to control...\", multiple: false, required: false\n    }\n    section {\n        input \"C_temperatureH\", \"number\", title: \"Heating setpoint\", required: false, description: \"Temperature when in heat mode\"\n        input \"C_temperatureC\", \"number\", title: \"Cooling setpoint\", required: false, description: \"Temperature when in cool mode\"\n    }\n}\n\ndef pageWeatherSettingsC() {\n    dynamicPage(name: \"pageWeatherSettingsC\", title: \"Weather Reporting Settings\") {\n        section {\n            input \"C_includeTemp\", \"bool\", title: \"Speak current temperature (from local forecast)\", defaultValue: \"false\"\n            input \"C_localTemp\", \"capability.temperatureMeasurement\", title: \"Speak local temperature (from device)\", required: false, multiple: false\n            input \"C_humidity\", \"capability.relativeHumidityMeasurement\", title: \"Speak local humidity (from device)\", required: false, multiple: false\n            input \"C_weatherReport\", \"bool\", title: \"Speak today's weather forecast\", defaultValue: \"false\"\n            input \"C_includeSunrise\", \"bool\", title: \"Speak today's sunrise\", defaultValue: \"false\"\n            input \"C_includeSunset\", \"bool\", title: \"Speak today's sunset\", defaultValue: \"false\"\n        }\n    }\n}\n\n//Show \"pageSetupScenarioD\" page\ndef pageSetupScenarioD() {\n    dynamicPage(name: \"pageSetupScenarioD\") {\n        section(\"Alarm settings\") {\n            input \"ScenarioNameD\", \"text\", title: \"Scenario Name\", multiple: false, required: true\n            input \"D_sonos\", \"capability.musicPlayer\", title: \"Choose a Sonos speaker\", required: true, submitOnChange:true\n            input \"D_volume\", \"number\", title: \"Alarm volume\", description: \"0-100%\", required: false\n            input \"D_timeStart\", \"time\", title: \"Time to trigger alarm\", required: true\n            input \"D_day\", \"enum\", options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], title: \"Alarm on certain days of the week...\", multiple: true, required: false\n            input \"D_mode\", \"mode\", title: \"Alarm only during the following modes...\", multiple: true, required: false\n            input \"D_alarmType\", \"enum\", title: \"Select a primary alarm type...\", multiple: false, required: true, options: [[1:\"Alarm sound (up to 20 seconds)\"],[2:\"Voice Greeting\"],[3:\"Music track/Internet Radio\"]], submitOnChange:true\n\n            if (D_alarmType != \"3\") {\n                if (D_alarmType == \"1\"){\n                    input \"D_secondAlarm\", \"enum\", title: \"Select a second alarm after the first is completed\", multiple: false, required: false, options: [[1:\"Voice Greeting\"],[2:\"Music track/Internet Radio\"]], submitOnChange:true\n                }\n                if (D_alarmType == \"2\"){\n                    input \"D_secondAlarmMusic\", \"bool\", title: \"Play a track after voice greeting\", defaultValue: \"false\", required: false, submitOnChange:true\n                }\n            }\n        }\n        if (D_alarmType == \"1\"){\n            section (\"Alarm sound options\"){\n                input \"D_soundAlarm\", \"enum\", title: \"Play this sound...\", required:false, multiple: false, options: [[1:\"Alien-8 seconds\"],[2:\"Bell-12 seconds\"], [3:\"Buzzer-20 seconds\"], [4:\"Fire-20 seconds\"], [5:\"Rooster-2 seconds\"], [6:\"Siren-20 seconds\"]]\n                input \"D_soundLength\", \"number\", title: \"Maximum time to play sound (empty=use sound default)\", description: \"1-20\", required: false\n               }\n        }\n\n        if (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\")) {\n            section (\"Voice greeting options\") {\n                input \"D_wakeMsg\", \"text\", title: \"Wake voice message\", defaultValue: \"Good morning! It is %time% on %day%, %date%.\", required: false\n                href \"pageWeatherSettingsD\", title: \"Weather Reporting Settings\", description: getWeatherDesc(D_weatherReport, D_includeSunrise, D_includeSunset, D_includeTemp, D_humidity, D_localTemp), state: greyOut1(D_weatherReport, D_includeSunrise, D_includeSunset, D_includeTemp, D_humidity, D_localTemp)            }\n        }\n\n           if (D_alarmType == \"3\" || (D_alarmType == \"1\" && D_secondAlarm ==\"2\") || (D_alarmType == \"2\" && D_secondAlarmMusic)){\n            section (\"Music track/internet radio options\"){\n                input \"D_musicTrack\", \"enum\", title: \"Play this track/internet radio station\", required:false, multiple: false, options: songOptions(D_sonos, 1)\n            }\n          }\n        section(\"Devices to control in this alarm scenario\") {\n            input \"D_switches\", \"capability.switch\",title: \"Control the following switches...\", multiple: true, required: false, submitOnChange:true\n            href \"pageDimmersD\", title: \"Dimmer Settings\", description: dimmerDesc(D_dimmers), state: greyOutOption(D_dimmers), submitOnChange:true\n            href \"pageThermostatsD\", title: \"Thermostat Settings\", description: thermostatDesc(D_thermostats, D_temperatureH, D_temperatureC), state: greyOutOption(D_thermostats), submitOnChange:true\n            if ((D_switches || D_dimmers || D_thermostats) && (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\"))){\n                input \"D_confirmSwitches\", \"bool\", title: \"Confirm switches/thermostats status in voice message\", defaultValue: \"false\"\n            }\n        }\n        section (\"Other actions at alarm time\"){\n            def phrases = location.helloHome?.getPhrases()*.label\n            if (phrases) {\n                phrases.sort()\n                input \"D_phrase\", \"enum\", title: \"Alarm triggers the following phrase\", required: false, options: phrases, multiple: false, submitOnChange:true\n                if (D_phrase  && (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\"))){\n                    input \"D_confirmPhrase\", \"bool\", title: \"Confirm Hello, Home phrase in voice message\", defaultValue: \"false\"\n                }\n            }\n            input \"D_triggerMode\", \"mode\", title: \"Alarm triggers the following mode\", required: false, submitOnChange:true\n               if (D_triggerMode  && (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\"))){\n                input \"D_confirmMode\", \"bool\", title: \"Confirm mode in voice message\", defaultValue: \"false\"\n            }\n        }\n    }\n}\n\npage(name: \"pageDimmersD\", title: \"Dimmer Settings\") {\n    section {\n           input \"D_dimmers\", \"capability.switchLevel\", title: \"Dim the following...\", multiple: true, required: false\n        input \"D_level\", \"enum\", options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],title: \"Set dimmers to this level\", multiple: false, required: false\n    }\n}\n\npage(name: \"pageThermostatsD\", title: \"Thermostat Settings\") {\n    section {\n           input \"D_thermostats\", \"capability.thermostat\", title: \"Thermostat to control...\", multiple: false, required: false\n    }\n    section {\n        input \"D_temperatureH\", \"number\", title: \"Heating setpoint\", required: false, description: \"Temperature when in heat mode\"\n        input \"D_temperatureC\", \"number\", title: \"Cooling setpoint\", required: false, description: \"Temperature when in cool mode\"\n    }\n}\n\ndef pageWeatherSettingsD() {\n    dynamicPage(name: \"pageWeatherSettingsD\", title: \"Weather Reporting Settings\") {\n        section {\n            input \"D_includeTemp\", \"bool\", title: \"Speak current temperature (from local forecast)\", defaultValue: \"false\"\n            input \"D_localTemp\", \"capability.temperatureMeasurement\", title: \"Speak local temperature (from device)\", required: false, multiple: false\n            input \"D_humidity\", \"capability.relativeHumidityMeasurement\", title: \"Speak local humidity (from device)\", required: false, multiple: false\n            input \"D_weatherReport\", \"bool\", title: \"Speak today's weather forecast\", defaultValue: \"false\"\n            input \"D_includeSunrise\", \"bool\", title: \"Speak today's sunrise\", defaultValue: \"false\"\n            input \"D_includeSunset\", \"bool\", title: \"Speak today's sunset\", defaultValue: \"false\"\n        }\n    }\n}\n\npage(name: \"pageAbout\", title: \"About ${textAppName()}\") {\n        section {\n            paragraph \"${textVersion()}\\n${textCopyright()}\\n\\n${textLicense()}\\n\"\n        }\n        section(\"Instructions\") {\n            paragraph textHelp()\n        }\n}\n\n//--------------------------------------\n\ndef installed() {\n    initialize()\n}\n\ndef updated() {\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    if (A_alarmType ==\"1\"){\n        alarmSoundUri(A_soundAlarm, A_soundLength, 1)\n    }\n    if (B_alarmType ==\"1\"){\n        alarmSoundUri(B_soundAlarm, B_soundLength, 2)\n    }\n    if (C_alarmType ==\"1\"){\n        alarmSoundUri(C_soundAlarm, C_soundLength, 3)\n    }\n    if (D_alarmType ==\"1\"){\n        alarmSoundUri(D_soundAlarm, D_soundLength, 4)\n    }\n\n    if (alarmSummary && summarySonos) {\n        subscribe(app, appTouchHandler)\n    }\n    if (ScenarioNameA && A_timeStart && A_sonos && A_alarmOn && A_alarmType){\n        schedule (A_timeStart, alarm_A)\n        if (A_musicTrack){\n            saveSelectedSong(A_sonos, A_musicTrack, 1)\n        }\n    }\n    if (ScenarioNameB && B_timeStart && B_sonos &&B_alarmOn && B_alarmType){\n        schedule (B_timeStart, alarm_B)\n        if (B_musicTrack){\n            saveSelectedSong(B_sonos, B_musicTrack, 2)\n        }\n    }\n    if (ScenarioNameC && C_timeStart && C_sonos && C_alarmOn && C_alarmType){\n        schedule (C_timeStart, alarm_C)\n        if (C_musicTrack){\n            saveSelectedSong(C_sonos, C_musicTrack, 3)\n        }\n    }\n    if (ScenarioNameD && D_timeStart && D_sonos && D_alarmOn && D_alarmType){\n        schedule (D_timeStart, alarm_D)\n        if (D_musicTrack){\n            saveSelectedSong(D_sonos, D_musicTrack, 4)\n        }\n    }\n}\n\n//--------------------------------------\n\ndef alarm_A() {\n    if ((!A_mode || A_mode.contains(location.mode)) && getDayOk(A_day)) {\n        if (A_switches || A_dimmers || A_thermostats) {\n            def dimLevel = A_level as Integer\n            A_switches?.on()\n            A_dimmers?.setLevel(dimLevel)\n            if (A_thermostats) {\n                def thermostatState = A_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    A_thermostats.setHeatingSetpoint(A_temperatureH)\n                    A_thermostats.setCoolingSetpoint(A_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    A_thermostats.setHeatingSetpoint(A_temperatureH)\n                    log.info \"Set $A_thermostats Heat $A_temperatureH°\"\n                }\n                else {\n                    A_thermostats.setCoolingSetpoint(A_temperatureC)\n                    log.info \"Set $A_thermostats Cool $A_temperatureC°\"\n                }\n               }\n        }\n        if (A_phrase) {\n            location.helloHome.execute(A_phrase)\n        }\n\n        if (A_triggerMode && location.mode != A_triggerMode) {\n            if (location.modes?.find{it.name == A_triggerMode}) {\n                setLocationMode(A_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${A_triggerMode}'\"\n            }\n        }\n\n        if (A_volume) {\n                A_sonos.setLevel(A_volume)\n        }\n\n        if (A_alarmType == \"2\" || (A_alarmType == \"1\" && A_secondAlarm ==\"1\")) {\n            state.fullMsgA = \"\"\n            if (A_wakeMsg) {\n                   getGreeting(A_wakeMsg, 1)\n            }\n\n            if (A_weatherReport || A_humidity || A_includeTemp || A_localTemp) {\n                getWeatherReport(1, A_weatherReport, A_humidity, A_includeTemp, A_localTemp)\n            }\n\n            if (A_includeSunrise || A_includeSunset) {\n                getSunriseSunset(1, A_includeSunrise, A_includeSunset)\n            }\n\n            if ((A_switches || A_dimmers || A_thermostats) && A_confirmSwitches) {\n                getOnConfimation(A_switches, A_dimmers, A_thermostats, 1)\n               }\n\n            if (A_phrase && A_confirmPhrase) {\n                getPhraseConfirmation(1, A_phrase)\n            }\n\n            if (A_triggerMode && A_confirmMode){\n                getModeConfirmation(A_triggerMode, 1)\n            }\n\n            state.soundA = textToSpeech(state.fullMsgA, true)\n        }\n\n        if (A_alarmType == \"1\"){\n            if (A_secondAlarm == \"1\" && state.soundAlarmA){\n                A_sonos.playSoundAndTrack (state.soundAlarmA.uri, state.soundAlarmA.duration, state.soundA.uri)\n            }\n            if (A_secondAlarm == \"2\" && state.selectedSongA && state.soundAlarmA){\n                A_sonos.playSoundAndTrack (state.soundAlarmA.uri, state.soundAlarmA.duration, state.selectedSongA)\n            }\n            if (!A_secondAlarm){\n                A_sonos.playTrack(state.soundAlarmA.uri)\n            }\n        }\n\n        if (A_alarmType == \"2\") {\n            if (A_secondAlarmMusic && state.selectedSongA){\n                A_sonos.playSoundAndTrack (state.soundA.uri, state.soundA.duration, state.selectedSongA)\n            }\n            else {\n                A_sonos.playTrack(state.soundA.uri)\n            }\n        }\n\n        if (A_alarmType == \"3\") {\n               A_sonos.playTrack(state.selectedSongA)\n        }\n    }\n}\n\ndef alarm_B() {\n    if ((!B_mode || B_mode.contains(location.mode)) && getDayOk(B_day)) {\n        if (B_switches || B_dimmers || B_thermostats) {\n            def dimLevel = B_level as Integer\n            B_switches?.on()\n            B_dimmers?.setLevel(dimLevel)\n            if (B_thermostats) {\n                def thermostatState = B_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    B_thermostats.setHeatingSetpoint(B_temperatureH)\n                    B_thermostats.setCoolingSetpoint(B_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    B_thermostats.setHeatingSetpoint(B_temperatureH)\n                    log.info \"Set $B_thermostats Heat $B_temperatureH°\"\n                }\n                else {\n                    B_thermostats.setCoolingSetpoint(B_temperatureC)\n                    log.info \"Set $B_thermostats Cool $B_temperatureC°\"\n                }\n               }\n        }\n        if (B_phrase) {\n            location.helloHome.execute(B_phrase)\n        }\n\n        if (B_triggerMode && location.mode != B_triggerMode) {\n            if (location.modes?.find{it.name == B_triggerMode}) {\n                setLocationMode(B_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${B_triggerMode}'\"\n            }\n        }\n\n        if (B_volume) {\n                B_sonos.setLevel(B_volume)\n        }\n\n        if (B_alarmType == \"2\" || (B_alarmType == \"1\" && B_secondAlarm ==\"1\")) {\n            state.fullMsgB = \"\"\n            if (B_wakeMsg) {\n                   getGreeting(B_wakeMsg, 2)\n            }\n\n            if (B_weatherReport || B_humidity || B_includeTemp || B_localTemp) {\n                getWeatherReport(2, B_weatherReport, B_humidity, B_includeTemp, B_localTemp)\n            }\n\n            if (B_includeSunrise || B_includeSunset) {\n                getSunriseSunset(2, B_includeSunrise, B_includeSunset)\n            }\n\n            if ((B_switches || B_dimmers || B_thermostats) && B_confirmSwitches) {\n                getOnConfimation(B_switches, B_dimmers, B_thermostats, 2)\n               }\n\n            if (B_phrase && B_confirmPhrase) {\n                getPhraseConfirmation(2, B_phrase)\n            }\n\n            if (B_triggerMode && B_confirmMode){\n                getModeConfirmation(B_triggerMode, 2)\n            }\n\n            state.soundB = textToSpeech(state.fullMsgB, true)\n        }\n\n        if (B_alarmType == \"1\"){\n            if (B_secondAlarm == \"1\" && state.soundAlarmB) {\n                B_sonos.playSoundAndTrack (state.soundAlarmB.uri, state.soundAlarmB.duration, state.soundB.uri)\n            }\n            if (B_secondAlarm == \"2\" && state.selectedSongB && state.soundAlarmB){\n                B_sonos.playSoundAndTrack (state.soundAlarmB.uri, state.soundAlarmB.duration, state.selectedSongB)\n            }\n            if (!B_secondAlarm){\n                B_sonos.playTrack(state.soundAlarmB.uri)\n            }\n        }\n\n        if (B_alarmType == \"2\") {\n            if (B_secondAlarmMusic && state.selectedSongB){\n                B_sonos.playSoundAndTrack (state.soundB.uri, state.soundB.duration, state.selectedSongB)\n            }\n            else {\n                B_sonos.playTrack(state.soundB.uri)\n            }\n        }\n\n        if (B_alarmType == \"3\") {\n               B_sonos.playTrack(state.selectedSongB)\n        }\n    }\n}\n\ndef alarm_C() {\n    if ((!C_mode || C_mode.contains(location.mode)) && getDayOk(C_day)) {\n        if (C_switches || C_dimmers || C_thermostats) {\n            def dimLevel = C_level as Integer\n            C_switches?.on()\n            C_dimmers?.setLevel(dimLevel)\n            if (C_thermostats) {\n                def thermostatState = C_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    C_thermostats.setHeatingSetpoint(C_temperatureH)\n                    C_thermostats.setCoolingSetpoint(C_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    C_thermostats.setHeatingSetpoint(C_temperatureH)\n                    log.info \"Set $C_thermostats Heat $C_temperatureH°\"\n                }\n                else {\n                    C_thermostats.setCoolingSetpoint(C_temperatureC)\n                    log.info \"Set $C_thermostats Cool $C_temperatureC°\"\n                }\n               }\n        }\n        if (C_phrase) {\n            location.helloHome.execute(C_phrase)\n        }\n\n        if (C_triggerMode && location.mode != C_triggerMode) {\n            if (location.modes?.find{it.name == C_triggerMode}) {\n                setLocationMode(C_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${C_triggerMode}'\"\n            }\n        }\n\n        if (C_volume) {\n                C_sonos.setLevel(C_volume)\n        }\n\n        if (C_alarmType == \"2\" || (C_alarmType == \"1\" && C_secondAlarm ==\"1\")) {\n            state.fullMsgC = \"\"\n            if (C_wakeMsg) {\n                   getGreeting(C_wakeMsg, 3)\n            }\n\n            if (C_weatherReport || C_humidity || C_includeTemp || C_localTemp) {\n                getWeatherReport(3, C_weatherReport, C_humidity, C_includeTemp, C_localTemp)\n            }\n\n            if (C_includeSunrise || C_includeSunset) {\n                getSunriseSunset(3, C_includeSunrise, C_includeSunset)\n            }\n\n            if ((C_switches || C_dimmers || C_thermostats) && C_confirmSwitches) {\n                getOnConfimation(C_switches, C_dimmers, C_thermostats, 3)\n               }\n\n            if (C_phrase && C_confirmPhrase) {\n                getPhraseConfirmation(3, C_phrase)\n            }\n\n            if (C_triggerMode && C_confirmMode){\n                getModeConfirmation(C_triggerMode, 3)\n            }\n\n            state.soundC = textToSpeech(state.fullMsgC, true)\n        }\n\n        if (C_alarmType == \"1\"){\n            if (C_secondAlarm == \"1\" && state.soundAlarmC){\n                C_sonos.playSoundAndTrack (state.soundAlarmC.uri, state.soundAlarmC.duration, state.soundC.uri)\n            }\n            if (C_secondAlarm == \"2\" && state.selectedSongC && state.soundAlarmC){\n                C_sonos.playSoundAndTrack (state.soundAlarmC.uri, state.soundAlarmC.duration, state.selectedSongC)\n            }\n            if (!C_secondAlarm){\n                C_sonos.playTrack(state.soundAlarmC.uri)\n            }\n        }\n\n        if (C_alarmType == \"2\") {\n            if (C_secondAlarmMusic && state.selectedSongC){\n                C_sonos.playSoundAndTrack (state.soundC.uri, state.soundC.duration, state.selectedSongC)\n            }\n            else {\n                C_sonos.playTrack(state.soundC.uri)\n            }\n        }\n\n        if (C_alarmType == \"3\") {\n               C_sonos.playTrack(state.selectedSongC)\n        }\n    }\n}\n\ndef alarm_D() {\n    if ((!D_mode || D_mode.contains(location.mode)) && getDayOk(D_day)) {\n        if (D_switches || D_dimmers || D_thermostats) {\n            def dimLevel = D_level as Integer\n            D_switches?.on()\n            D_dimmers?.setLevel(dimLevel)\n            if (D_thermostats) {\n                def thermostatState = D_thermostats.currentThermostatMode\n                if (thermostatState == \"auto\") {\n                    D_thermostats.setHeatingSetpoint(D_temperatureH)\n                    D_thermostats.setCoolingSetpoint(D_temperatureC)\n                }\n                else if (thermostatState == \"heat\") {\n                    D_thermostats.setHeatingSetpoint(D_temperatureH)\n                    log.info \"Set $D_thermostats Heat $D_temperatureH°\"\n                }\n                else {\n                    D_thermostats.setCoolingSetpoint(D_temperatureC)\n                    log.info \"Set $D_thermostats Cool $D_temperatureC°\"\n                }\n               }\n        }\n        if (D_phrase) {\n            location.helloHome.execute(D_phrase)\n        }\n\n        if (D_triggerMode && location.mode != D_triggerMode) {\n            if (location.modes?.find{it.name == D_triggerMode}) {\n                setLocationMode(D_triggerMode)\n            }\n            else {\n                log.debug \"Unable to change to undefined mode '${D_triggerMode}'\"\n            }\n        }\n\n        if (D_volume) {\n                D_sonos.setLevel(D_volume)\n        }\n\n        if (D_alarmType == \"2\" || (D_alarmType == \"1\" && D_secondAlarm ==\"1\")) {\n            state.fullMsgD = \"\"\n            if (D_wakeMsg) {\n                   getGreeting(D_wakeMsg, 4)\n            }\n\n            if (D_weatherReport || D_humidity || D_includeTemp || D_localTemp) {\n                getWeatherReport(4, D_weatherReport, D_humidity, D_includeTemp, D_localTemp)\n            }\n\n            if (D_includeSunrise || D_includeSunset) {\n                getSunriseSunset(4, D_includeSunrise, D_includeSunset)\n            }\n\n            if ((D_switches || D_dimmers || D_thermostats) && D_confirmSwitches) {\n                getOnConfimation(D_switches, D_dimmers, D_thermostats, 4)\n               }\n\n            if (D_phrase && D_confirmPhrase) {\n                getPhraseConfirmation(4, D_phrase)\n            }\n\n            if (D_triggerMode && D_confirmMode){\n                getModeConfirmation(D_triggerMode, 4)\n            }\n\n            state.soundD = textToSpeech(state.fullMsgD, true)\n        }\n\n        if (D_alarmType == \"1\"){\n            if (D_secondAlarm == \"1\" && state.soundAlarmD){\n                D_sonos.playSoundAndTrack (state.soundAlarmD.uri, state.soundAlarmD.duration, state.soundD.uri)\n            }\n            if (D_secondAlarm == \"2\" && state.selectedSongD && state.soundAlarmD){\n                D_sonos.playSoundAndTrack (state.soundAlarmD.uri, state.soundAlarmD.duration, state.selectedSongD)\n            }\n            if (!D_secondAlarm){\n                D_sonos.playTrack(state.soundAlarmD.uri)\n            }\n        }\n\n        if (D_alarmType == \"2\") {\n            if (D_secondAlarmMusic && state.selectedSongD){\n                D_sonos.playSoundAndTrack (state.soundD.uri, state.soundD.duration, state.selectedSongD)\n            }\n            else {\n                D_sonos.playTrack(state.soundD.uri)\n            }\n        }\n\n        if (D_alarmType == \"3\") {\n               D_sonos.playTrack(state.selectedSongD)\n        }\n    }\n}\n\ndef appTouchHandler(evt){\n    if (!summaryMode || summaryMode.contains(location.mode)) {\n        state.summaryMsg = \"The following is a summary of the alarm settings. \"\n        getSummary (A_alarmOn, ScenarioNameA, A_timeStart, 1)\n        getSummary (B_alarmOn, ScenarioNameB, B_timeStart, 2)\n        getSummary (C_alarmOn, ScenarioNameC, C_timeStart, 3)\n        getSummary (D_alarmOn, ScenarioNameD, D_timeStart, 4)\n\n        log.debug \"Summary message = ${state.summaryMsg}\"\n        def summarySound = textToSpeech(state.summaryMsg, true)\n        if (summaryVolume) {\n            summarySonos.setLevel(summaryVolume)\n        }\n        summarySonos.playTrack(summarySound.uri)\n    }\n}\n\ndef getSummary (alarmOn, scenarioName, timeStart, num){\n    if (alarmOn && scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num}, ${scenarioName}, set for ${parseDate(timeStart,\"\", \"h:mm a\" )}, is enabled. \"\n    }\n    else if (summaryDisabled && !alarmOn && scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num}, ${scenarioName}, set for ${parseDate(timeStart,\"\", \"h:mm a\")}, is disabled. \"\n    }\n    else if (summaryDisabled && !scenarioName) {\n        state.summaryMsg = \"${state.summaryMsg} Alarm ${num} is not configured. \"\n    }\n}\n\n//--------------------------------------\n\ndef getDesc(timeStart, sonos, day, mode) {\n    def desc = \"Tap to set alarm\"\n    if (timeStart) {\n        desc = \"Alarm set to \" + parseDate(timeStart,\"\", \"h:mm a\") +\" on ${sonos}\"\n\n        def dayListSize = day ? day.size() : 7\n\n        if (day && dayListSize < 7) {\n            desc = desc + \" on\"\n            for (dayName in day) {\n                 desc = desc + \" ${dayName}\"\n                dayListSize = dayListSize -1\n                if (dayListSize) {\n                    desc = \"${desc}, \"\n                }\n            }\n        }\n        else {\n            desc = desc + \" every day\"\n        }\n\n        if (mode) {\n            def modeListSize = mode.size()\n            def modePrefix =\" in the following modes: \"\n            if (modeListSize == 1) {\n                modePrefix = \" in the following mode: \"\n            }\n            desc = desc + \"${modePrefix}\"\n               for (modeName in mode) {\n                desc = desc + \"'${modeName}'\"\n                modeListSize = modeListSize -1\n                if (modeListSize) {\n                    desc = \"${desc}, \"\n                }\n                else {\n                    desc = \"${desc}\"\n                }\n            }\n        }\n         else {\n            desc = desc + \" in all modes\"\n        }\n    }\n    desc\n}\ndef greyOut(scenario, sonos, alarmTime, alarmOn, alarmType){\n    def result = scenario && sonos  && alarmTime && alarmOn && alarmType ? \"complete\" : \"\"\n}\n\ndef greyOut1(param1, param2, param3, param4, param5, param6){\n    def result = param1 || param2 || param3 || param4 || param5 || param6 ? \"complete\" : \"\"\n}\n\ndef getWeatherDesc(param1, param2, param3, param4, param5, param6) {\n    def title = param1 || param2 || param3 || param4 || param5 || param6 ? \"Tap to edit weather reporting options\" : \"Tap to setup weather reporting options\"\n}\n\ndef greyOutOption(param){\n    def result = param ? \"complete\" : \"\"\n}\n\ndef getTitle(scenario, num) {\n    def title = scenario ? scenario : \"Alarm ${num} not configured\"\n}\n\ndef dimmerDesc(dimmer){\n    def desc = dimmer ? \"Tap to edit dimmer settings\" : \"Tap to set dimmer setting\"\n}\n\ndef thermostatDesc(thermostat, heating, cooling){\n    def tempText\n    if (heating || cooling){\n        if (heating){\n            tempText = \"${heating} heat\"\n        }\n        if (cooling){\n            tempText = \"${cooling} cool\"\n        }\n        if (heating && cooling) {\n            tempText =\"${heating} heat / ${cooling} cool\"\n        }\n    }\n    else {\n        tempText=\"Tap to edit thermostat settings\"\n    }\n\n    def desc = thermostat ? \"${tempText}\" : \"Tap to set thermostat settings\"\n    return desc\n}\n\nprivate getDayOk(dayList) {\n    def result = true\n    if (dayList) {\n        result = dayList.contains(getDay())\n    }\n    result\n}\n\nprivate getDay(){\n    def df = new java.text.SimpleDateFormat(\"EEEE\")\n    if (location.timeZone) {\n        df.setTimeZone(location.timeZone)\n    }\n    else {\n        df.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n    }\n    def day = df.format(new Date())\n}\n\nprivate parseDate(date, epoch, type){\n    def parseDate = \"\"\n    if (epoch){\n        long longDate = Long.valueOf(epoch).longValue()\n        parseDate = new Date(longDate).format(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", location.timeZone)\n    }\n    else {\n        parseDate = date\n    }\n    new Date().parse(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", parseDate).format(\"${type}\", timeZone(parseDate))\n}\n\nprivate getSunriseSunset(scenario, includeSunrise, includeSunset){\n    if (location.timeZone || zipCode) {\n        def todayDate = new Date()\n        def s = getSunriseAndSunset(zipcode: zipCode, date: todayDate)\n        def riseTime = parseDate(\"\", s.sunrise.time, \"h:mm a\")\n        def setTime = parseDate (\"\", s.sunset.time, \"h:mm a\")\n           def msg = \"\"\n        def currTime = now()\n        def verb1 = currTime >= s.sunrise.time ? \"rose\" : \"will rise\"\n        def verb2 = currTime >= s.sunset.time ? \"set\" : \"will set\"\n\n        if (includeSunrise && includeSunset) {\n            msg = \"The sun ${verb1} this morning at ${riseTime} and ${verb2} at ${setTime}. \"\n        }\n        else if (includeSunrise && !includeSunset) {\n            msg = \"The sun ${verb1} this morning at ${riseTime}. \"\n        }\n        else if (!includeSunrise && includeSunset) {\n            msg = \"The sun ${verb2} tonight at ${setTime}. \"\n        }\n        compileMsg(msg, scenario)\n    }\n    else {\n        msg = \"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive sunset and sunrise information. \"\n        compileMsg(msg, scenario)\n    }\n}\n\nprivate getGreeting(msg, scenario) {\n    def day = getDay()\n    def time = parseDate(\"\", now(), \"h:mm a\")\n    def month = parseDate(\"\", now(), \"MMMM\")\n    def year = parseDate(\"\", now(), \"yyyy\")\n    def dayNum = parseDate(\"\", now(), \"dd\")\n    msg = msg.replace('%day%', day)\n    msg = msg.replace('%date%', \"${month} ${dayNum}, ${year}\")\n    msg = msg.replace('%time%', \"${time}\")\n    msg = \"${msg} \"\n    compileMsg(msg, scenario)\n}\n\nprivate getWeatherReport(scenario, weatherReport, humidity, includeTemp, localTemp) {\n    if (location.timeZone || zipCode) {\n        def isMetric = location.temperatureScale == \"C\"\n        def sb = new StringBuilder()\n\n        if (includeTemp){\n            def current = getTwcConditions(zipCode)\n            sb << \"The current temperature is ${Math.round(current.temperature)} degrees. \"\n        }\n\n        if (localTemp){\n            sb << \"The local temperature is ${Math.round(localTemp.currentTemperature)} degrees. \"\n        }\n\n        if (humidity) {\n            sb << \"The local relative humidity is ${humidity.currentValue(\"humidity\")}%. \"\n        }\n\n        if (weatherReport) {\n            def weather = getTwcForecast(zipCode)\n            sb << \"Today's forecast is \"\n            sb << weather.daypart[0].narrative[0]\n        }\n\n        def msg = sb.toString()\n        msg = msg.replaceAll(/([0-9]+)C/,'$1 degrees')\n        msg = msg.replaceAll(/([0-9]+)F/,'$1 degrees')\n        compileMsg(msg, scenario)\n    }\n    else {\n        msg = \"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.\"\n        compileMsg(msg, scenario)\n    }\n}\n\nprivate getOnConfimation(switches, dimmers, thermostats, scenario) {\n    def msg = \"\"\n    if ((switches || dimmers) && !thermostats) {\n        msg = \"All switches\"\n    }\n    if (!switches && !dimmers && thermostats) {\n        msg = \"All Thermostats\"\n    }\n    if ((switches || dimmers) && thermostats) {\n        msg = \"All switches and thermostats\"\n    }\n    msg = \"${msg} are now on and set. \"\n    compileMsg(msg, scenario)\n}\n\nprivate getPhraseConfirmation(scenario, phrase) {\n    def msg=\"The Smart Things Hello Home phrase, ${phrase}, has been activated. \"\n    compileMsg(msg, scenario)\n}\n\nprivate getModeConfirmation(mode, scenario) {\n    def msg=\"The Smart Things mode is now being set to, ${mode}. \"\n    compileMsg(msg, scenario)\n}\n\nprivate compileMsg(msg, scenario) {\n    log.debug \"msg = ${msg}\"\n    if (scenario == 1) {state.fullMsgA = state.fullMsgA + \"${msg}\"}\n    if (scenario == 2) {state.fullMsgB = state.fullMsgB + \"${msg}\"}\n    if (scenario == 3) {state.fullMsgC = state.fullMsgC + \"${msg}\"}\n    if (scenario == 4) {state.fullMsgD = state.fullMsgD + \"${msg}\"}\n}\n\nprivate alarmSoundUri(selection, length, scenario){\n    def soundUri = \"\"\n       def soundLength = \"\"\n    switch(selection) {\n        case \"1\":\n            soundLength = length >0 && length < 8 ? length : 8\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmAlien.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"2\":\n            soundLength = length >0 && length < 12 ? length : 12\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmBell.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"3\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmBuzzer.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"4\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmFire.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"5\":\n            soundLength = length >0 && length < 2 ? length : 2\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmRooster.mp3\", duration: \"${soundLength}\"]\n            break\n        case \"6\":\n            soundLength = length >0 && length < 20 ? length : 20\n            soundUri = [uri: \"https://raw.githubusercontent.com/MichaelStruck/SmartThings/master/Other-SmartApps/Talking-Alarm-Clock/AlarmSounds/AlarmSiren.mp3\", duration: \"${soundLength}\"]\n            break\n    }\n    if (scenario == 1) {state.soundAlarmA = soundUri}\n    if (scenario == 2) {state.soundAlarmB = soundUri}\n    if (scenario == 3) {state.soundAlarmC = soundUri}\n    if (scenario == 4) {state.soundAlarmD = soundUri}\n}\n\n//Sonos Aquire Track from SmartThings code\nprivate songOptions(sonos, scenario) {\n    if (sonos){\n    // Make sure current selection is in the set\n        def options = new LinkedHashSet()\n        if (scenario == 1){\n            if (state.selectedSongA?.station) {\n                options << state.selectedSongA.station\n            }\n            else if (state.selectedSongA?.description) {\n                options << state.selectedSongA.description\n            }\n        }\n        if (scenario == 2){\n            if (state.selectedSongB?.station) {\n                options << state.selectedSongB.station\n            }\n            else if (state.selectedSongB?.description) {\n                options << state.selectedSongB.description\n            }\n        }\n        if (scenario == 3){\n            if (state.selectedSongC?.station) {\n                options << state.selectedSongC.station\n            }\n            else if (state.selectedSongC?.description) {\n                options << state.selectedSongC.description\n            }\n        }\n        if (scenario == 4){\n            if (state.selectedSongD?.station) {\n                options << state.selectedSongD.station\n            }\n            else if (state.selectedSongD?.description) {\n                options << state.selectedSongD.description\n            }\n        }\n        // Query for recent tracks\n        def states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n        def dataMaps = states.collect{it.jsonValue}\n        options.addAll(dataMaps.collect{it.station})\n\n        log.trace \"${options.size()} songs in list\"\n        options.take(20) as List\n    }\n}\n\nprivate saveSelectedSong(sonos, song, scenario) {\n    try {\n        def thisSong = song\n        log.info \"Looking for $thisSong\"\n        def songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n        log.info \"Searching ${songs.size()} records\"\n\n        def data = songs.find {s -> s.station == thisSong}\n        log.info \"Found ${data?.station}\"\n        if (data) {\n            if (scenario == 1) {state.selectedSongA = data}\n            if (scenario == 2) {state.selectedSongB = data}\n            if (scenario == 3) {state.selectedSongC = data}\n            if (scenario == 4) {state.selectedSongD = data}\n            log.debug \"Selected song for Scenario ${scenario} = ${data}\"\n        }\n        else if (song == state.selectedSongA?.station || song == state.selectedSongB?.station || song == state.selectedSongC?.station || song == state.selectedSongD?.station) {\n            log.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n        }\n         else {\n            log.warn \"Selected song '$song' not found\"\n        }\n    }\n    catch (Throwable t) {\n        log.error t\n    }\n}\n\n//Version/Copyright/Information/Help\n\nprivate def textAppName() {\n    def text = \"Talking Alarm Clock\"\n}\n\nprivate def textVersion() {\n    def text = \"Version 1.4.5 (06/17/2015)\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright © 2015 Michael Struck\"\n}\n\nprivate def textLicense() {\n    def text =\n        \"Licensed under the Apache License, Version 2.0 (the 'License'); \"+\n        \"you may not use this file except in compliance with the License. \"+\n        \"You may obtain a copy of the License at\"+\n        \"\\n\\n\"+\n        \"    http://www.apache.org/licenses/LICENSE-2.0\"+\n        \"\\n\\n\"+\n        \"Unless required by applicable law or agreed to in writing, software \"+\n        \"distributed under the License is distributed on an 'AS IS' BASIS, \"+\n        \"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \"+\n        \"See the License for the specific language governing permissions and \"+\n        \"limitations under the License.\"\n}\n\nprivate def textHelp() {\n    def text =\n        \"Within each alarm scenario, choose a Sonos speaker, an alarm time and alarm type along with \" +\n        \"switches, dimmers and thermostat to control when the alarm is triggered. Hello, Home phrases and modes can be triggered at alarm time. \"+\n        \"You also have the option of setting up different alarm sounds, tracks and a personalized spoken greeting that can include a weather report. \" +\n        \"Variables that can be used in the voice greeting include %day%, %time% and %date%.\\n\\n\"+\n        \"From the main SmartApp convenience page, tapping the 'Talking Alarm Clock' icon (if enabled within the app) will \"+\n        \"speak a summary of the alarms enabled or disabled without having to go into the application itself. This \" +\n        \"functionality is optional and can be configured from the main setup page.\"\n}",
        "docstring": "Control up to 4 waking schedules using a Sonos speaker as an alarm."
    },
    {
        "code": "section(\"Turn off when there is no motion and presence\") {\n    input \"motionSensor\", \"capability.motionSensor\", title: \"Choose motion sensor\"\n    input \"presenceSensors\", \"capability.presenceSensor\", title: \"Choose presence sensors\", multiple: true\n  }\n  section(\"Delay before turning off\") {\n    input \"delayMins\", \"number\", title: \"Minutes of inactivity?\"\n  }\n}\n\ndef installed() {\n  subscribe(motionSensor, \"motion\", motionHandler)\n  subscribe(presenceSensors, \"presence\", presenceHandler)\n}\n\ndef updated() {\n  unsubscribe()\n  subscribe(motionSensor, \"motion\", motionHandler)\n  subscribe(presenceSensors, \"presence\", presenceHandler)\n}\n\ndef motionHandler(evt) {\n  log.debug \"handler $evt.name: $evt.value\"\n  if (evt.value == \"inactive\") {\n    runIn(delayMins * 60, scheduleCheck, [overwrite: true])\n  }\n}\n\ndef presenceHandler(evt) {\n  log.debug \"handler $evt.name: $evt.value\"\n  if (evt.value == \"not present\") {\n    runIn(delayMins * 60, scheduleCheck, [overwrite: true])\n  }\n}\n\ndef isActivePresence() {\n  // check all the presence sensors, make sure none are present\n  def noPresence = presenceSensors.find{it.currentPresence == \"present\"} == null\n  !noPresence\n}\n\ndef scheduleCheck() {\n  log.debug \"scheduled check\"\n  def motionState = motionSensor.currentState(\"motion\")\n    if (motionState.value == \"inactive\") {\n      def elapsed = now() - motionState.rawDateCreated.time\n      def threshold = 1000 * 60 * delayMins - 1000\n      if (elapsed >= threshold) {\n        if (!isActivePresence()) {\n          log.debug \"Motion has stayed inactive since last check ($elapsed ms) and no presence:  turning lights off\"\n          switches.off()\n        } else {\n          log.debug \"Presence is active: do nothing\"\n        }\n      } else {\n        log.debug \"Motion has not stayed inactive long enough since last check ($elapsed ms): do nothing\"\n      }\n    } else {\n      log.debug \"Motion is active: do nothing\"\n    }\n}",
        "docstring": "Turn lights off when no motion and presence is detected for a set period of time."
    },
    {
        "code": "}\n\ndef getInputs() {\n\tdef inputList = []\n\tinputList += contactSensors ?: []\n\tinputList += garageDoors ?: []\n\tinputList += locks ?: []\n\tinputList += cameras ?: []\n\tinputList += motionSensors ?: []\n\tinputList += presenceSensors ?: []\n\tinputList += switches ?: []\n\tinputList += thermostats ?: []\n\tinputList += waterSensors ?: []\n\treturn inputList\n}\n\n\n//API external Endpoints\nmappings {\n\tpath(\"/devices\") {\n\t\taction: [\n\t\t\t\tGET: \"getDevices\"\n\t\t]\n\t}\n\tpath(\"/devices/:id\") {\n\t\taction: [\n\t\t\t\tGET: \"getDevice\"\n\t\t]\n\t}\n\tpath(\"/update/:id\") {\n\t\taction: [\n\t\t\t\tPUT: \"updateDevice\"\n\t\t]\n\t}\n\tpath(\"/deviceSubscription\") {\n\t\taction: [\n\t\t\t\tPOST  : \"registerDeviceChange\",\n\t\t\t\tDELETE: \"unregisterDeviceChange\"\n\t\t]\n\t}\n\tpath(\"/locationSubscription\") {\n\t\taction: [\n\t\t\t\tPOST  : \"registerDeviceGraph\",\n\t\t\t\tDELETE: \"unregisterDeviceGraph\"\n\t\t]\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installing with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updating with settings: ${settings}\"\n\n\t//Initialize state variables if didn't exist.\n\tif (state.deviceSubscriptionMap == null) {\n\t\tstate.deviceSubscriptionMap = [:]\n\t\tlog.debug \"deviceSubscriptionMap created.\"\n\t}\n\tif (state.locationSubscriptionMap == null) {\n\t\tstate.locationSubscriptionMap = [:]\n\t\tlog.debug \"locationSubscriptionMap created.\"\n\t}\n\tif (state.verificationKeyMap == null) {\n\t\tstate.verificationKeyMap = [:]\n\t\tlog.debug \"verificationKeyMap created.\"\n\t}\n\n\tunsubscribe()\n\tregisterAllDeviceSubscriptions()\n}\n\ndef initialize() {\n\tlog.debug \"Initializing with settings: ${settings}\"\n\tstate.deviceSubscriptionMap = [:]\n\tlog.debug \"deviceSubscriptionMap created.\"\n\tstate.locationSubscriptionMap = [:]\n\tlog.debug \"locationSubscriptionMap created.\"\n\tstate.verificationKeyMap = [:]\n\tlog.debug \"verificationKeyMap created.\"\n\tregisterAllDeviceSubscriptions()\n}\n\n/*** Subscription Functions  ***/\n\n//Subscribe events for all devices\ndef registerAllDeviceSubscriptions() {\n\tregisterChangeHandler(inputs)\n}\n\n//Subscribe to events from a list of devices\ndef registerChangeHandler(myList) {\n\tmyList.each { myDevice ->\n\t\tdef theAtts = myDevice.supportedAttributes\n\t\ttheAtts.each { att ->\n\t\t\tsubscribe(myDevice, att.name, deviceEventHandler)\n\t\t\tlog.info \"Registering for ${myDevice.displayName}.${att.name}\"\n\t\t}\n\t}\n}\n\n//Endpoints function: Subscribe to events from a specific device\ndef registerDeviceChange() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\tdef deviceId = params.deviceId\n\tdef myDevice = findDevice(deviceId)\n\n\tif (myDevice == null) {\n\t\thttpError(404, \"Cannot find device with device ID ${deviceId}.\")\n\t}\n\n\tdef theAtts = myDevice.supportedAttributes\n\ttry {\n\t\ttheAtts.each { att ->\n\t\t\tsubscribe(myDevice, att.name, deviceEventHandler)\n\t\t}\n\t\tlog.info \"Subscribing for ${myDevice.displayName}\"\n\n\t\tif (subscriptionEndpt != null) {\n\t\t\tif (state.deviceSubscriptionMap[deviceId] == null) {\n\t\t\t\tstate.deviceSubscriptionMap.put(deviceId, [subscriptionEndpt])\n\t\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t} else if (!state.deviceSubscriptionMap[deviceId].contains(subscriptionEndpt)) {\n\t\t\t\t// state.deviceSubscriptionMap[deviceId] << subscriptionEndpt\n                // For now, we will only have one subscription endpoint per device\n\t\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\t\tstate.deviceSubscriptionMap.put(deviceId, [subscriptionEndpt])\n\t\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t}\n\n\t\t\tif (params.key != null) {\n\t\t\t\tstate.verificationKeyMap[subscriptionEndpt] = params.key\n\t\t\t\tlog.info \"Added verification key: ${params.key} for ${subscriptionEndpt}\"\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current subscription map is ${state.deviceSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n\treturn [\"succeed\"]\n}\n\n//Endpoints function: Unsubscribe to events from a specific device\ndef unregisterDeviceChange() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\tdef deviceId = params.deviceId\n\tdef myDevice = findDevice(deviceId)\n\n\tif (myDevice == null) {\n\t\thttpError(404, \"Cannot find device with device ID ${deviceId}.\")\n\t}\n\n\ttry {\n\t\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\t\tif (state.deviceSubscriptionMap[deviceId]?.contains(subscriptionEndpt)) {\n\t\t\t\tif (state.deviceSubscriptionMap[deviceId].size() == 1) {\n\t\t\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\t\t} else {\n\t\t\t\t\tstate.deviceSubscriptionMap[deviceId].remove(subscriptionEndpt)\n\t\t\t\t}\n\t\t\t\tstate.verificationKeyMap.remove(subscriptionEndpt)\n\t\t\t\tlog.info \"Removed subscription URL: ${subscriptionEndpt} for ${myDevice.displayName}\"\n\t\t\t}\n\t\t} else {\n\t\t\tstate.deviceSubscriptionMap.remove(deviceId)\n\t\t\tlog.info \"Unsubscriping for ${myDevice.displayName}\"\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current subscription map is ${state.deviceSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n}\n\n//Endpoints function: Subscribe to device additiona/removal updated in a location\ndef registerDeviceGraph() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\n\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\tsubscribe(location, \"DeviceCreated\", locationEventHandler, [filterEvents: false])\n\t\tsubscribe(location, \"DeviceUpdated\", locationEventHandler, [filterEvents: false])\n\t\tsubscribe(location, \"DeviceDeleted\", locationEventHandler, [filterEvents: false])\n\n\t\tif (state.locationSubscriptionMap[location.id] == null) {\n\t\t\tstate.locationSubscriptionMap.put(location.id, [subscriptionEndpt])\n\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t} else if (!state.locationSubscriptionMap[location.id].contains(subscriptionEndpt)) {\n\t\t\tstate.locationSubscriptionMap[location.id] << subscriptionEndpt\n\t\t\tlog.info \"Added subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t}\n\n\t\tif (params.key != null) {\n\t\t\tstate.verificationKeyMap[subscriptionEndpt] = params.key\n\t\t\tlog.info \"Added verification key: ${params.key} for ${subscriptionEndpt}\"\n\t\t}\n\n\t\tlog.info \"Current location subscription map is ${state.locationSubscriptionMap}\"\n\t\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n\t\treturn [\"succeed\"]\n\t} else {\n\t\thttpError(400, \"missing input parameter: subscriptionURL\")\n\t}\n}\n\n//Endpoints function: Unsubscribe to events from a specific device\ndef unregisterDeviceGraph() {\n\tdef subscriptionEndpt = params.subscriptionURL\n\n\ttry {\n\t\tif (subscriptionEndpt != null && subscriptionEndpt != \"undefined\") {\n\t\t\tif (state.locationSubscriptionMap[location.id]?.contains(subscriptionEndpt)) {\n\t\t\t\tif (state.locationSubscriptionMap[location.id].size() == 1) {\n\t\t\t\t\tstate.locationSubscriptionMap.remove(location.id)\n\t\t\t\t} else {\n\t\t\t\t\tstate.locationSubscriptionMap[location.id].remove(subscriptionEndpt)\n\t\t\t\t}\n\t\t\t\tstate.verificationKeyMap.remove(subscriptionEndpt)\n\t\t\t\tlog.info \"Removed subscription URL: ${subscriptionEndpt} for Location ${location.name}\"\n\t\t\t}\n\t\t} else {\n\t\t\thttpError(400, \"missing input parameter: subscriptionURL\")\n\t\t}\n\t} catch (e) {\n\t\thttpError(500, \"something went wrong: $e\")\n\t}\n\n\tlog.info \"Current location subscription map is ${state.locationSubscriptionMap}\"\n\tlog.info \"Current verification key map is ${state.verificationKeyMap}\"\n}\n\n//When events are triggered, send HTTP post to web socket servers\ndef deviceEventHandler(evt) {\n\tdef evtDevice = evt.device\n\tdef evtDeviceType = getDeviceType(evtDevice)\n\tdef deviceData = [];\n\n\tif (evtDeviceType == \"thermostat\") {\n\t\tdeviceData = [name: evtDevice.displayName, id: evtDevice.id, status: evtDevice.status, deviceType: evtDeviceType, manufacturer: evtDevice.manufacturerName, model: evtDevice.modelName, attributes: deviceAttributeList(evtDevice, evtDeviceType), locationMode: getLocationModeInfo(), locationId: location.id]\n\t} else {\n\t\tdeviceData = [name: evtDevice.displayName, id: evtDevice.id, status: evtDevice.status, deviceType: evtDeviceType, manufacturer: evtDevice.manufacturerName, model: evtDevice.modelName, attributes: deviceAttributeList(evtDevice, evtDeviceType), locationId: location.id]\n\t}\n    \n    if(evt.data != null){\n\t\tdef evtData = parseJson(evt.data)\n\t\tlog.info \"Received event for ${evtDevice.displayName}, data: ${evtData},  description: ${evt.descriptionText}\"\n\t}\n\n\tdef params = [body: deviceData]\n\n\t//send event to all subscriptions urls\n\tlog.debug \"Current subscription urls for ${evtDevice.displayName} is ${state.deviceSubscriptionMap[evtDevice.id]}\"\n\tstate.deviceSubscriptionMap[evtDevice.id].each {\n\t\tparams.uri = \"${it}\"\n\t\tif (state.verificationKeyMap[it] != null) {\n\t\t\tdef key = state.verificationKeyMap[it]\n            params.headers = [Signature: ComputHMACValue(key, groovy.json.JsonOutput.toJson(params.body))]\n\t\t}\n\t\tlog.trace \"POST URI: ${params.uri}\"\n        log.trace \"Headers: ${params.headers}\"\n\t\tlog.trace \"Payload: ${params.body}\"\n\t\ttry {\n\t\t\thttpPostJson(params) { resp ->\n\t\t\t\tlog.trace \"response status code: ${resp.status}\"\n\t\t\t\tlog.trace \"response data: ${resp.data}\"\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error \"something went wrong: $e\"\n\t\t}\n\t}\n}\n\ndef locationEventHandler(evt) {\n\tlog.info \"Received event for location ${location.name}/${location.id}, Event: ${evt.name}, description: ${evt.descriptionText}, apiServerUrl: ${apiServerUrl(\"\")}\"\n\tswitch (evt.name) {\n\t\tcase \"DeviceCreated\":\n\t\tcase \"DeviceDeleted\":\n\t\t\tdef evtDevice = evt.device\n\t\t\tdef evtDeviceType = getDeviceType(evtDevice)\n\t\t\tdef params = [body: [eventType: evt.name, deviceId: evtDevice.id, locationId: location.id]]\n\n\t\t\tif (evt.name == \"DeviceDeleted\" && state.deviceSubscriptionMap[deviceId] != null) {\n\t\t\t\tstate.deviceSubscriptionMap.remove(evtDevice.id)\n\t\t\t}\n\n\t\t\tstate.locationSubscriptionMap[location.id].each {\n\t\t\t\tparams.uri = \"${it}\"\n\t\t\t\tif (state.verificationKeyMap[it] != null) {\n\t\t\t\t\tdef key = state.verificationKeyMap[it]\n                    params.headers = [Signature: ComputHMACValue(key, groovy.json.JsonOutput.toJson(params.body))]\n\t\t\t\t}\n\t\t\t\tlog.trace \"POST URI: ${params.uri}\"\n\t\t\t\tlog.trace \"Headers: ${params.headers}\"\n\t\t\t\tlog.trace \"Payload: ${params.body}\"\n\t\t\t\ttry {\n\t\t\t\t\thttpPostJson(params) { resp ->\n\t\t\t\t\t\tlog.trace \"response status code: ${resp.status}\"\n\t\t\t\t\t\tlog.trace \"response data: ${resp.data}\"\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlog.error \"something went wrong: $e\"\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"DeviceUpdated\":\n\t\tdefault:\n\t\t\tbreak\n\t}\n}\n\nprivate ComputHMACValue(key, data) {\n\ttry {\n    \tlog.debug \"data hased: ${data}\"\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA1\")\n\t\tMac mac = Mac.getInstance(\"HmacSHA1\")\n\t\tmac.init(secretKeySpec)\n\t\tbyte[] digest = mac.doFinal(data.getBytes(\"UTF-8\"))\n\t\treturn byteArrayToString(digest)\n\t} catch (InvalidKeyException e) {\n\t\tlog.error \"Invalid key exception while converting to HMac SHA1\"\n\t}\n}\n\nprivate def byteArrayToString(byte[] data) {\n\tBigInteger bigInteger = new BigInteger(1, data)\n\tString hash = bigInteger.toString(16)\n\treturn hash\n}\n\n/*** Device Query/Update Functions  ***/\n\n//Endpoints function: return all device data in json format\ndef getDevices() {\n\tdef deviceData = []\n\tinputs?.each {\n\t\tdef deviceType = getDeviceType(it)\n\t\tif (deviceType == \"thermostat\") {\n\t\t\tdeviceData << [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType), locationMode: getLocationModeInfo()]\n\t\t} else {\n\t\t\tdeviceData << [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType)]\n\t\t}\n\t}\n\n\tlog.debug \"getDevices, return: ${deviceData}\"\n\treturn deviceData\n}\n\n//Endpoints function: get device data\ndef getDevice() {\n\tdef it = findDevice(params.id)\n\tdef deviceType = getDeviceType(it)\n\tdef device\n\tif (deviceType == \"thermostat\") {\n\t\tdevice = [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType), locationMode: getLocationModeInfo()]\n\t} else {\n\t\tdevice = [name: it.displayName, id: it.id, status: it.status, deviceType: deviceType, manufacturer: it.manufacturerName, model: it.modelName, attributes: deviceAttributeList(it, deviceType)]\n\t}\n\n\tlog.debug \"getDevice, return: ${device}\"\n\treturn device\n}\n\n//Endpoints function: update device data\nvoid updateDevice() {\n\tdef device = findDevice(params.id)\n\trequest.JSON.each {\n\t\tdef command = it.key\n\t\tdef value = it.value\n\t\tif (command) {\n\t\t\tdef commandList = mapDeviceCommands(command, value)\n\t\t\tcommand = commandList[0]\n\t\t\tvalue = commandList[1]\n\n\t\t\tif (command == \"setAwayMode\") {\n\t\t\t\tlog.info \"Setting away mode to ${value}\"\n\t\t\t\tif (location.modes?.find { it.name == value }) {\n\t\t\t\t\tlocation.setMode(value)\n\t\t\t\t}\n\t\t\t} else if (command == \"thermostatSetpoint\") {\n\t\t\t\tswitch (device.currentThermostatMode) {\n\t\t\t\t\tcase \"cool\":\n\t\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\t\tdevice.setCoolingSetpoint(value)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase \"heat\":\n\t\t\t\t\tcase \"emergency heat\":\n\t\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\t\tdevice.setHeatingSetpoint(value)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\thttpError(501, \"this mode: ${device.currentThermostatMode} does not allow changing thermostat setpoint.\")\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (!device) {\n\t\t\t\tlog.error \"updateDevice, Device not found\"\n\t\t\t\thttpError(404, \"Device not found\")\n\t\t\t} else if (!device.hasCommand(command)) {\n\t\t\t\tlog.error \"updateDevice, Device does not have the command\"\n\t\t\t\thttpError(404, \"Device does not have such command\")\n\t\t\t} else {\n\t\t\t\tif (command == \"setColor\") {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\tdevice.\"$command\"(hex: value)\n\t\t\t\t} else if (value.isNumber()) {\n\t\t\t\t\tdef intValue = value as Integer\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${intValue}(int)]\"\n\t\t\t\t\tdevice.\"$command\"(intValue)\n\t\t\t\t} else if (value) {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}, ${value}]\"\n\t\t\t\t\tdevice.\"$command\"(value)\n\t\t\t\t} else {\n\t\t\t\t\tlog.info \"Update: ${device.displayName}, [${command}]\"\n\t\t\t\t\tdevice.\"$command\"()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*** Private Functions ***/\n\n//Return current location mode info\nprivate getLocationModeInfo() {\n\treturn [mode: location.mode, supported: location.modes.name]\n}\n\n//Map each device to a type given it's capabilities\nprivate getDeviceType(device) {\n\tdef deviceType\n\tdef capabilities = device.capabilities\n\tlog.debug \"capabilities: [${device}, ${capabilities}]\"\n\tlog.debug \"supported commands: [${device}, ${device.supportedCommands}]\"\n\n\t//Loop through the device capability list to determine the device type.\n\tcapabilities.each { capability ->\n\t\tswitch(capability.name.toLowerCase())\n\t\t{\n\t\t\tcase \"switch\":\n\t\t\t\tdeviceType = \"switch\"\n\n\t\t\t\t//If the device also contains \"Switch Level\" capability, identify it as a \"light\" device.\n\t\t\t\tif (capabilities.any { it.name.toLowerCase() == \"switch level\" }) {\n\n\t\t\t\t\t//If the device also contains \"Power Meter\" capability, identify it as a \"dimmerSwitch\" device.\n\t\t\t\t\tif (capabilities.any { it.name.toLowerCase() == \"power meter\" }) {\n\t\t\t\t\t\tdeviceType = \"dimmerSwitch\"\n\t\t\t\t\t\treturn deviceType\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeviceType = \"light\"\n\t\t\t\t\t\treturn deviceType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"garageDoorControl\":\n\t\t\t\tdeviceType = \"garageDoor\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"lock\":\n\t\t\t\tdeviceType = \"lock\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"video camera\":\n\t\t\t\tdeviceType = \"camera\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"thermostat\":\n\t\t\t\tdeviceType = \"thermostat\"\n\t\t\t\treturn deviceType\n\t\t\tcase \"acceleration sensor\":\n\t\t\tcase \"contact sensor\":\n\t\t\tcase \"motion sensor\":\n\t\t\tcase \"presence sensor\":\n\t\t\tcase \"water sensor\":\n\t\t\t\tdeviceType = \"genericSensor\"\n\t\t\t\treturn deviceType\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn deviceType\n}\n\n//Return a specific device give the device ID.\nprivate findDevice(deviceId) {\n\treturn inputs?.find { it.id == deviceId }\n}\n\n//Return a list of device attributes\nprivate deviceAttributeList(device, deviceType) {\n\tdef attributeList = [:]\n\tdef allAttributes = device.supportedAttributes\n\tallAttributes.each { attribute ->\n\t\ttry {\n\t\t\tdef currentState = device.currentState(attribute.name)\n\t\t\tif (currentState != null) {\n\t\t\t\tswitch (attribute.name) {\n\t\t\t\t\tcase 'temperature':\n\t\t\t\t\t\tattributeList.putAll([(attribute.name): currentState.value, 'temperatureScale': location.temperatureScale])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tattributeList.putAll([(attribute.name): currentState.value])\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (deviceType == \"genericSensor\") {\n\t\t\t\t\tdef key = attribute.name + \"_lastUpdated\"\n\t\t\t\t\tattributeList.putAll([(key): currentState.isoDate])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattributeList.putAll([(attribute.name): null]);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tattributeList.putAll([(attribute.name): null]);\n\t\t}\n\t}\n\treturn attributeList\n}\n\n//Map device command and value. \n//input command and value are from UWP,\n//returns resultCommand and resultValue that corresponds with function and value in SmartApps\nprivate mapDeviceCommands(command, value) {\n\tlog.debug \"mapDeviceCommands: [${command}, ${value}]\"\n\tdef resultCommand = command\n\tdef resultValue = value\n\tswitch (command) {\n\t\tcase \"switch\":\n\t\t\tif (value == 1 || value == \"1\" || value == \"on\") {\n\t\t\t\tresultCommand = \"on\"\n\t\t\t\tresultValue = \"\"\n\t\t\t} else if (value == 0 || value == \"0\" || value == \"off\") {\n\t\t\t\tresultCommand = \"off\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\tbreak\n\t// light attributes\n\t\tcase \"level\":\n\t\t\tresultCommand = \"setLevel\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"hue\":\n\t\t\tresultCommand = \"setHue\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"saturation\":\n\t\t\tresultCommand = \"setSaturation\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"colorTemperature\":\n\t\t\tresultCommand = \"setColorTemperature\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"color\":\n\t\t\tresultCommand = \"setColor\"\n\t\t\tresultValue = value\n\t// thermostat attributes\n\t\tcase \"hvacMode\":\n\t\t\tresultCommand = \"setThermostatMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"fanMode\":\n\t\t\tresultCommand = \"setThermostatFanMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"awayMode\":\n\t\t\tresultCommand = \"setAwayMode\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"coolingSetpoint\":\n\t\t\tresultCommand = \"setCoolingSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"heatingSetpoint\":\n\t\t\tresultCommand = \"setHeatingSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t\tcase \"thermostatSetpoint\":\n\t\t\tresultCommand = \"thermostatSetpoint\"\n\t\t\tresultValue = value\n\t\t\tbreak\n\t// lock attributes\n\t\tcase \"locked\":\n\t\t\tif (value == 1 || value == \"1\" || value == \"lock\") {\n\t\t\t\tresultCommand = \"lock\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\telse if (value == 0 || value == \"0\" || value == \"unlock\") {\n\t\t\t\tresultCommand = \"unlock\"\n\t\t\t\tresultValue = \"\"\n\t\t\t}\n\t\t\tbreak\n\t\tdefault:\n\t\t\tbreak\n\t}\n\n\treturn [resultCommand, resultValue]\n}",
        "docstring": "SmartApp for end to end SmartThings scenarios via OpenT2T"
    },
    {
        "code": "preferences {\n    page(name: \"auth\", title: \"Step 1 of 2\", nextPage:\"deviceList\", content:\"authPage\")\n    page(name: \"deviceList\", title: \"Step 2 of 2\", install:true, uninstall:false){\n        section {\n            input \"plantlinksensors\", \"capability.sensor\", title: \"Select PlantLink sensors\", multiple: true\n        }\n    }\n}\n\nmappings {\n    path(\"/swapToken\") {\n        action: [\n                GET: \"swapToken\"\n        ]\n    }\n}\n\ndef authPage(){\n    if(!atomicState.accessToken){\n        createAccessToken()\n        atomicState.accessToken = state.accessToken\n    }\n\n    def redirectUrl = oauthInitUrl()\n    def uninstallAllowed = false\n    def oauthTokenProvided = false\n    if(atomicState.authToken){\n        uninstallAllowed = true\n        oauthTokenProvided = true\n    }\n\n    if (!oauthTokenProvided) {\n        return dynamicPage(name: \"auth\", title: \"Step 1 of 2\", nextPage:null, uninstall:uninstallAllowed) {\n            section(){\n                href(name:\"login\",\n                     url:redirectUrl, \n                     style:\"embedded\",\n                     title:\"PlantLink\", \n                     image:\"https://dashboard.myplantlink.com/images/PLlogo.png\", \n                     description:\"Tap to login to myplantlink.com\")\n            }\n        }\n    }else{\n        return dynamicPage(name: \"auth\", title: \"Step 1 of 2 - Completed\", nextPage:\"deviceList\", uninstall:uninstallAllowed) {\n            section(){\n               paragraph \"You are logged in to myplantlink.com, tap next to continue\", image: iconUrl\n               href(url:redirectUrl, title:\"Or\", description:\"tap to switch accounts\")\n            }\n        }\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef uninstalled() {\n    if (plantlinksensors){\n        plantlinksensors.each{ sensor_device ->\n            sensor_device.setInstallSmartApp(\"needSmartApp\")\n        }\n    }\n}\n\ndef initialize() {\n    atomicState.attached_sensors = [:]\n    if (plantlinksensors){\n        subscribe(plantlinksensors, \"moisture_status\", moistureHandler)\n        subscribe(plantlinksensors, \"battery_status\", batteryHandler)\n        plantlinksensors.each{ sensor_device ->\n            sensor_device.setStatusIcon(\"Waiting on First Measurement\")\n            sensor_device.setInstallSmartApp(\"connectedToSmartApp\")\n        }\n    }\n}\n\ndef dock_sensor(device_serial, expected_plant_name) {\n    def docking_body_json_builder = new JsonBuilder([version: '1c', smartthings_device_id: device_serial])\n    def docking_params = [\n            uri        : appSettings.https_plantLinkServer,\n            path       : \"/api/v1/smartthings/links\",\n            headers    : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n            contentType: \"application/json\",\n            body: docking_body_json_builder.toString()\n    ]\n    def plant_post_body_map = [\n            plant_type_key: 999999,\n            soil_type_key : 1000004\n    ]\n    def plant_post_params = [\n            uri        : appSettings.https_plantLinkServer,\n            path       : \"/api/v1/plants\",\n            headers    : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n            contentType: \"application/json\",\n    ]\n    log.debug \"Creating new plant on myplantlink.com - ${expected_plant_name}\"\n    try {\n        httpPost(docking_params) { docking_response ->\n            if (parse_api_response(docking_response, \"Docking a link\")) {\n                if (docking_response.data.plants.size() == 0) {\n                    log.debug \"creating plant for - ${expected_plant_name}\"\n                    plant_post_body_map[\"name\"] = expected_plant_name\n                    plant_post_body_map['links_key'] = [docking_response.data.key]\n                    def plant_post_body_json_builder = new JsonBuilder(plant_post_body_map)\n                    plant_post_params[\"body\"] = plant_post_body_json_builder.toString()\n                    try {\n                        httpPost(plant_post_params) { plant_post_response ->\n                            if(parse_api_response(plant_post_response, 'creating plant')){\n                                def attached_map = atomicState.attached_sensors\n                                attached_map[device_serial] = plant_post_response.data\n                                atomicState.attached_sensors = attached_map\n                            }\n                        }\n                    } catch (Exception f) {\n                        log.debug \"call failed $f\"\n                    }\n                } else {\n                    def plant = docking_response.data.plants[0]\n                    def attached_map = atomicState.attached_sensors\n                    attached_map[device_serial] = plant\n                    atomicState.attached_sensors = attached_map\n                    checkAndUpdatePlantIfNeeded(plant, expected_plant_name)\n                }\n            }\n        }\n    } catch (Exception e) {\n        log.debug \"call failed $e\"\n    }\n    return true\n}\n\ndef checkAndUpdatePlantIfNeeded(plant, expected_plant_name){\n    def plant_put_params = [\n        uri : appSettings.https_plantLinkServer,\n        headers : [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n        contentType : \"application/json\"\n    ]\n    if (plant.name != expected_plant_name) {\n        log.debug \"updating plant for - ${expected_plant_name}\"\n        plant_put_params[\"path\"] = \"/api/v1/plants/${plant.key}\"\n        def plant_put_body_map = [\n            name: expected_plant_name\n        ]\n        def plant_put_body_json_builder = new JsonBuilder(plant_put_body_map)\n        plant_put_params[\"body\"] = plant_put_body_json_builder.toString()\n        try {\n            httpPut(plant_put_params) { plant_put_response ->\n                parse_api_response(plant_put_response, 'updating plant name')\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef moistureHandler(event){\n    def expected_plant_name = \"SmartThings - ${event.displayName}\"\n    def device_serial = getDeviceSerialFromEvent(event)\n    \n    if (!atomicState.attached_sensors.containsKey(device_serial)){\n        dock_sensor(device_serial, expected_plant_name)\n    }else{\n        def measurement_post_params = [\n                uri: appSettings.https_plantLinkServer,\n                path: \"/api/v1/smartthings/links/${device_serial}/measurements\",\n                headers: [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n                contentType: \"application/json\",\n                body: event.value\n        ]\n        try {\n            httpPost(measurement_post_params) { measurement_post_response ->\n                if (parse_api_response(measurement_post_response, 'creating moisture measurement') &&\n                        measurement_post_response.data.size() >0){\n                    def measurement = measurement_post_response.data[0]\n                    def plant =  measurement.plant\n                    log.debug plant\n                    checkAndUpdatePlantIfNeeded(plant, expected_plant_name)\n                    plantlinksensors.each{ sensor_device ->\n                        if (sensor_device.id == event.deviceId){\n                            sensor_device.setStatusIcon(plant.status)\n                            if (plant.last_measurements && plant.last_measurements[0].moisture){\n                                sensor_device.setPlantFuelLevel(plant.last_measurements[0].moisture * 100 as int)\n                            }\n                            if (plant.last_measurements && plant.last_measurements[0].battery){\n                                sensor_device.setBatteryLevel(plant.last_measurements[0].battery * 100 as int)\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef batteryHandler(event){\n    def expected_plant_name = \"SmartThings - ${event.displayName}\"\n    def device_serial = getDeviceSerialFromEvent(event)\n    \n    if (!atomicState.attached_sensors.containsKey(device_serial)){\n        dock_sensor(device_serial, expected_plant_name)\n    }else{\n        def measurement_post_params = [\n                uri: appSettings.https_plantLinkServer,\n                path: \"/api/v1/smartthings/links/${device_serial}/measurements\",\n                headers: [\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer ${atomicState.authToken}\"],\n                contentType: \"application/json\",\n                body: event.value\n        ]\n        try {\n            httpPost(measurement_post_params) { measurement_post_response ->\n                parse_api_response(measurement_post_response, 'creating battery measurement')\n            }\n        } catch (Exception e) {\n            log.debug \"call failed $e\"\n        }\n    }\n}\n\ndef getDeviceSerialFromEvent(event){\n    def pattern = /.*\"zigbeedeviceid\"\\s*:\\s*\"(\\w+)\".*/\n    def match_result = (event.value =~ pattern)\n    return match_result[0][1]\n}\n\ndef oauthInitUrl(){\n    atomicState.oauthInitState = UUID.randomUUID().toString()\n    def oauthParams = [\n            response_type: \"code\",\n            client_id: appSettings.client_id,\n            state: atomicState.oauthInitState,\n            redirect_uri: buildRedirectUrl()\n    ]\n    return appSettings.https_plantLinkServer + \"/oauth/oauth2/authorize?\" + toQueryString(oauthParams)\n}\n\ndef buildRedirectUrl(){\n    return getServerUrl() + \"/api/token/${atomicState.accessToken}/smartapps/installations/${app.id}/swapToken\"\n}\n\ndef swapToken(){\n    def code = params.code\n    def oauthState = params.state\n    def stcid = appSettings.client_id\n    def postParams = [\n            method: 'POST',\n            uri: \"https://oso-tech.appspot.com\",\n            path: \"/api/v1/oauth-token\",\n            query: [grant_type:'authorization_code', code:params.code, client_id:stcid,\n                    client_secret:appSettings.client_secret, redirect_uri: buildRedirectUrl()],\n    ]\n\n    def jsonMap\n    try {\n        httpPost(postParams) { resp ->\n            jsonMap = resp.data\n        }\n    } catch (Exception e) {\n        log.debug \"call failed $e\"\n    }\n\n    atomicState.refreshToken = jsonMap.refresh_token\n    atomicState.authToken = jsonMap.access_token\n\n    def html = \"\"\"\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n    .container {\n        padding:25px;\n    }\n    .flex1 {\n        width:33%;\n        float:left;\n        text-align: center;\n    }\n    p {\n        font-size: 2em;\n        font-family: Verdana, Geneva, sans-serif;\n        text-align: center;\n        color: #777;\n    }\n</style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"flex1\"><img src=\"https://dashboard.myplantlink.com/images/PLlogo.png\" alt=\"PlantLink\" height=\"75\"/></div>\n        <div class=\"flex1\"><img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected to\"  height=\"25\" style=\"padding-top:25px;\" /></div>\n        <div class=\"flex1\"><img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings\" height=\"75\"/></div>\n        <br clear=\"all\">\n  </div>\n  <div class=\"container\">\n        <p>Your PlantLink Account is now connected to SmartThings!</p>\n        <p style=\"color:green;\">Click <strong>Done</strong> at the top right to finish setup.</p>\n    </div>\n</body>\n</html>\n\"\"\"\n    render contentType: 'text/html', data: html\n}\n\nprivate refreshAuthToken() {\n    def stcid = appSettings.client_id\n    def refreshParams = [\n            method: 'POST',\n            uri: \"https://hardware-dot-oso-tech.appspot.com\",\n            path: \"/api/v1/oauth-token\",\n            query: [grant_type:'refresh_token', code:\"${atomicState.refreshToken}\", client_id:stcid,\n                    client_secret:appSettings.client_secret],\n    ]\n    try{\n        def jsonMap\n        httpPost(refreshParams) { resp ->\n            if(resp.status == 200){\n                log.debug \"OAuth Token refreshed\"\n                jsonMap = resp.data\n                if (resp.data) {\n                    atomicState.refreshToken = resp?.data?.refresh_token\n                    atomicState.authToken = resp?.data?.access_token\n                    if (data?.action && data?.action != \"\") {\n                        log.debug data.action\n                        \"{data.action}\"()\n                        data.action = \"\"\n                    }\n                }\n                data.action = \"\"\n            }else{\n                log.debug \"refresh failed ${resp.status} : ${resp.status.code}\"\n            }\n        }\n    }\n    catch(Exception e){\n        log.debug \"caught exception refreshing auth token: \" + e\n    }\n}\n\ndef parse_api_response(resp, message) {\n    if (resp.status == 200) {\n        return true\n    } else {\n        log.error \"sent ${message} Json & got http status ${resp.status} - ${resp.status.code}\"\n        if (resp.status == 401) {\n            refreshAuthToken()\n            return false\n        } else {\n            debugEvent(\"Authentication error, invalid authentication method, lack of credentials, etc.\", true)\n            return false\n        }\n    }\n}\n\ndef getServerUrl() { return getApiServerUrl() }\n\ndef debugEvent(message, displayEvent) {\n    def results = [\n            name: \"appdebug\",\n            descriptionText: message,\n            displayed: displayEvent\n    ]\n    log.debug \"Generating AppDebug Event: ${results}\"\n    sendEvent (results)\n}\n\ndef toQueryString(Map m){\n    return m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}",
        "docstring": "This SmartApp connects to myplantlink.com and forwards the device data to it so it can calculate easy to read plant status for your specific plant's needs."
    },
    {
        "code": "\\nWatering Time: ${startTimeString()}\\nDays:${daysString()}\\nNotifications:${notifyString()}\"\n            )\n        }\n\n        section(''){\n            href(name: 'weatherPage', title: 'Weather Settings', required: false, page: 'weatherPage',\n                image: 'http://www.plaidsystems.com/smartthings/st_rain_225_r.png',\n                description: \"Weather from: ${zipString()}\\nRain Delay: ${isRainString()}\\nSeasonal Adjust: ${seasonalAdjString()}\"\n            )\n        }\n\n        section(''){\n            href(name: 'zonePage', title: 'Zone summary and setup', required: false, page: 'zonePage',\n                image: 'http://www.plaidsystems.com/smartthings/st_zone16_225.png',\n                description: \"${getZoneSummary()}\"\n            )\n        }\n\n        section(''){\n            href(name: 'delayPage', title: 'Valve delays & Pause controls', required: false, page: 'delayPage',\n                image: 'http://www.plaidsystems.com/smartthings/st_timer.png',\n                description: \"Valve Delay: ${pumpDelayString()} s\\n${waterStoppersString()}\\nSchedule Sync: ${syncString()}\"\n            )\n        }\n        \n        section(''){\n            href(title: 'Spruce Irrigation Knowledge Base', //page: 'customPage',\n                  description: 'Explore our knowledge base for more information on Spruce and Spruce sensors.  Contact form is ' +\n                             'also available here.',\n                required: false, style:'embedded',\n                image: 'http://www.plaidsystems.com/smartthings/st_spruce_leaf_250f.png',\n                url: 'http://support.spruceirrigation.com'\n            )\n        }\n        \n        section(''){\n            href(title: 'Scheduler Version 2.55',\n                  description: \"Updated June 2019\"\n            )\n        }\n    }\n}\n\ndef globalPage() {\n    dynamicPage(name: 'globalPage', title: '') {\n        section('Spruce schedule Settings') {\n                label title: 'Schedule Name:', description: 'Name this schedule', required: false\n                input 'switches', 'capability.switch', title: 'Spruce Irrigation Controller:', description: 'Select a Spruce controller', required: true, multiple: false\n        }\n\n        section('Program Scheduling'){\n            input 'enable', 'bool', title: 'Enable watering:', defaultValue: 'true', metadata: [values: ['true', 'false']]\n            input 'enableManual', 'bool', title: 'Enable this schedule for manual start, only 1 schedule should be enabled for manual start at a time!', defaultValue: 'true', metadata: [values: ['true', 'false']]\n            input 'startTime', 'time', title: 'Watering start time', required: true\n            paragraph(image: 'http://www.plaidsystems.com/smartthings/st_calander.png',\n                      title: 'Selecting watering days',\n                      'Selecting watering days is optional. Spruce will optimize your watering schedule automatically. ' +\n                      'If your area has water restrictions or you prefer set days, select the days to meet your requirements. ')\n            input (name: 'days', type: 'enum', title: 'Water only on these days...', required: false, multiple: true, metadata: [values: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Even', 'Odd']])\n        }\n\n        section('Push Notifications') {\n                input(name: 'notify', type: 'enum', title: 'Select what push notifications to receive.', required: false,\n                    multiple: true, metadata: [values: ['Daily', 'Delays', 'Warnings', 'Weather', 'Moisture', 'Events']])\n                input(name: 'logAll', type: 'bool', title: 'Log all notices to Hello Home?', defaultValue: 'false', options: ['true', 'false'])\n        }\n    }\n}\n\ndef weatherPage() {\n    dynamicPage(name: 'weatherPage', title: 'Weather settings') {\n       section(\"Location to get weather forecast and conditions:\") {\n            input(name: 'zipcode', type: 'text', title: \"Zipcode default location: ${getDefaultLocation()}\", required: false, submitOnChange: true)\n            input 'isRain', 'bool', title: 'Enable Rain check:', metadata: [values: ['true', 'false']]\n            input 'rainDelay', 'decimal', title: 'inches of rain that will delay watering, default: 0.2', required: false\n            input 'isSeason', 'bool', title: 'Enable Seasonal Weather Adjustment:', metadata: [values: ['true', 'false']]\n        }\n    }\n}\n\nprivate String getDefaultLocation() {\n    String DefaultLocation = \"Not set\"\n    if(location?.zipCode) DefaultLocation = location.zipCode\n    if (!location?.zipCode?.isNumber() && location?.latitude && location?.longitude) DefaultLocation = \"${location.latitude.floatValue()},${location.longitude.floatValue()}\"\n    return DefaultLocation\n}\n\nprivate String startTimeString(){\n    if (!startTime) return 'Please set!' else return hhmm(startTime)\n}\n\nprivate String enableString(){\n    if(enable && enableManual) return 'On & Manual Set'\n    else if (enable) return 'On & Manual Off'\n    else if (enableManual) return 'Off & Manual Set'\n    else return 'Off'\n}\n\nprivate String waterStoppersString(){\n    String stoppers = 'Contact Sensor'\n    if (settings.contacts) {\n        if (settings.contacts.size() != 1) stoppers += 's'\n        stoppers += ': '\n        int i = 1\n        settings.contacts.each {\n            if ( i > 1) stoppers += ', '\n            stoppers += it.displayName\n            i++\n        }\n        stoppers = \"${stoppers}\\nPause: When ${settings.contactStop}\\n\"\n    }\n    else {\n        stoppers += ': None\\n'\n    }\n    stoppers += \"Switch\"\n    if (settings.toggles) {\n        if (settings.toggles.size() != 1) stoppers += 'es'\n        stoppers += ': '\n        int i = 1\n        settings.toggles.each {\n            if ( i > 1) stoppers += ', '\n            stoppers += it.displayName\n            i++\n        }\n        stoppers = \"${stoppers}\\nPause: When switched ${settings.toggleStop}\\n\"\n    }\n    else {\n        stoppers += ': None\\n'\n    }\n    int cd = 10\n    if (settings.contactDelay && settings.contactDelay.toInteger() > 10) cd = settings.contactDelay.toInteger()\n    stoppers += \"Restart Delay: ${cd} secs\"\n    return stoppers\n}\n\nprivate String isRainString(){\n    if (settings.isRain && !settings.rainDelay) return '0.2' as String\n    if (settings.isRain) return settings.rainDelay as String else return 'Off'\n}\n\nprivate String seasonalAdjString(){\n    if(settings.isSeason) return 'On' else return 'Off'\n}\n\nprivate String syncString(){\n    if (settings.sync) return \"${settings.sync.displayName}\" else return 'None'\n}\n\nprivate String notifyString(){\n    String notifyStr = ''\n    if(settings.notify) {\n          if (settings.notify.contains('Daily'))         notifyStr += ' Daily'\n          //if (settings.notify.contains('Weekly'))     notifyStr += ' Weekly'\n          if (settings.notify.contains('Delays'))     notifyStr += ' Delays'\n          if (settings.notify.contains('Warnings'))     notifyStr += ' Warnings'\n          if (settings.notify.contains('Weather'))     notifyStr += ' Weather'\n          if (settings.notify.contains('Moisture'))     notifyStr += ' Moisture'\n          if (settings.notify.contains('Events'))     notifyStr += ' Events'\n       }\n       if (notifyStr == '')    notifyStr = ' None'\n       if (settings.logAll) notifyStr += '\\nSending all Notifications to Hello Home log'\n\n       return notifyStr\n}\n\nprivate String daysString(){\n    String daysString = ''\n    if (days){\n        if(days.contains('Even') || days.contains('Odd')) {\n            if (days.contains('Even'))         daysString += ' Even'\n              if (days.contains('Odd'))         daysString += ' Odd'\n        }\n        else {\n            if (days.contains('Monday'))     daysString += ' M'\n            if (days.contains('Tuesday'))     daysString += ' Tu'\n            if (days.contains('Wednesday')) daysString += ' W'\n            if (days.contains('Thursday'))     daysString += ' Th'\n            if (days.contains('Friday'))     daysString += ' F'\n            if (days.contains('Saturday'))     daysString += ' Sa'\n            if (days.contains('Sunday'))     daysString += ' Su'\n        }\n    }\n    if(daysString == '') return ' Any'\n\n    else return daysString\n}\n\nprivate String hhmm(time, fmt = 'h:mm a'){\n    def t = timeToday(time, location.timeZone)\n    def f = new java.text.SimpleDateFormat(fmt)\n    f.setTimeZone(location.timeZone ?: timeZone(time))\n    return f.format(t)\n}\n\nprivate String pumpDelayString(){\n\n    if (!pumpDelay) return '0' else return pumpDelay as String\n    \n}\n\ndef delayPage() {\n    dynamicPage(name: 'delayPage', title: 'Additional Options') {\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_timer.png',\n                      title: 'Pump and Master valve delay',\n                      required: false,\n                      'Setting a delay is optional, default is 0.  If you have a pump that feeds water directly into your valves, ' +\n                      'set this to 0. To fill a tank or build pressure, you may increase the delay.\\n\\nStart->Pump On->delay->Valve ' +\n                      'On->Valve Off->delay->...'\n            input name: 'pumpDelay', type: 'number', title: 'Set a delay in seconds?', defaultValue: '0', required: false\n        }\n\n        section(''){\n            paragraph(image: 'http://www.plaidsystems.com/smartthings/st_pause.png',\n                      title: 'Pause Control Contacts & Switches',\n                      required: false,\n                      'Selecting contacts or control switches is optional. When a selected contact sensor is opened or switch is ' +\n                      'toggled, water immediately stops and will not resume until all of the contact sensors are closed and all of ' +\n                      'the switches are reset.\\n\\nCaution: if all contacts or switches are left in the stop state, the dependent ' +\n                      'schedule(s) will never run.')\n            input(name: 'contacts', title: 'Select water delay contact sensors', type: 'capability.contactSensor', multiple: true,\n                required: false, submitOnChange: true)            \n            if (contacts)\n                input(name: 'contactStop', title: 'Stop watering when sensors are...', type: 'enum', required: (settings.contacts != null),\n                    options: ['open', 'closed'], defaultValue: 'open')\n            input(name: 'toggles', title: 'Select water delay switches', type: 'capability.switch', multiple: true, required: false,\n                submitOnChange: true)\n            if (toggles)\n                input(name: 'toggleStop', title: 'Stop watering when switches are...', type: 'enum',\n                    required: (settings.toggles != null), options: ['on', 'off'], defaultValue: 'off')\n            input(name: 'contactDelay', type: 'number', title: 'Restart watering how many seconds after all contacts and switches ' +\n                    'are reset? (minimum 10s)', defaultValue: '10', required: false)\n        }\n\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_spruce_controller_250.png',\n                           title: 'Controller Sync',\n                          required: false,\n                          'For multiple controllers only.  This schedule will wait for the selected controller to finish before ' +\n                          'starting. Do not set with a single controller!'\n                         input name: 'sync', type: 'capability.switch', title: 'Select Master Controller', description: 'Only use this setting with multiple controllers', required: false, multiple: false\n        }\n    }\n}\n\ndef zonePage() {\n    dynamicPage(name: 'zonePage', title: 'Zone setup', install: false, uninstall: false) {\n        section('') {\n            href(name: 'hrefWithImage', title: 'Zone configuration', page: 'zoneSettingsPage',\n             description: \"${zoneString()}\",\n             required: false,\n             image: 'http://www.plaidsystems.com/smartthings/st_spruce_leaf_250f.png')\n        }\n\n        if (zoneActive('1')){\n        section(''){\n            href(name: 'z1Page', title: \"1: ${getname(\"1\")}\", required: false, page: 'zoneSetPage1',\n                image: \"${getimage(\"1\")}\",\n                description: \"${display(\"1\")}\" )\n            }\n        }\n        if (zoneActive('2')){\n        section(''){\n            href(name: 'z2Page', title: \"2: ${getname(\"2\")}\", required: false, page: 'zoneSetPage2',\n                image: \"${getimage(\"2\")}\",\n                description: \"${display(\"2\")}\" )\n            }\n        }\n        if (zoneActive('3')){\n        section(''){\n            href(name: 'z3Page', title: \"3: ${getname(\"3\")}\", required: false, page: 'zoneSetPage3',\n                image: \"${getimage(\"3\")}\",\n                description: \"${display(\"3\")}\" )\n            }\n        }\n        if (zoneActive('4')){\n        section(''){\n            href(name: 'z4Page', title: \"4: ${getname(\"4\")}\", required: false, page: 'zoneSetPage4',\n                image: \"${getimage(\"4\")}\",\n                description: \"${display(\"4\")}\" )\n            }\n        }\n        if (zoneActive('5')){\n        section(''){\n            href(name: 'z5Page', title: \"5: ${getname(\"5\")}\", required: false, page: 'zoneSetPage5',\n                image: \"${getimage(\"5\")}\",\n                description: \"${display(\"5\")}\" )\n            }\n        }\n        if (zoneActive('6')){\n        section(''){\n            href(name: 'z6Page', title: \"6: ${getname(\"6\")}\", required: false, page: 'zoneSetPage6',\n                image: \"${getimage(\"6\")}\",\n                description: \"${display(\"6\")}\" )\n            }\n        }\n        if (zoneActive('7')){\n        section(''){\n            href(name: 'z7Page', title: \"7: ${getname(\"7\")}\", required: false, page: 'zoneSetPage7',\n                image: \"${getimage(\"7\")}\",\n                description: \"${display(\"7\")}\" )\n            }\n        }\n        if (zoneActive('8')){\n        section(''){\n            href(name: 'z8Page', title: \"8: ${getname(\"8\")}\", required: false, page: 'zoneSetPage8',\n                image: \"${getimage(\"8\")}\",\n                description: \"${display(\"8\")}\" )\n            }\n        }\n        if (zoneActive('9')){\n        section(''){\n            href(name: 'z9Page', title: \"9: ${getname(\"9\")}\", required: false, page: 'zoneSetPage9',\n                image: \"${getimage(\"9\")}\",\n                description: \"${display(\"9\")}\" )\n            }\n        }\n        if (zoneActive('10')){\n        section(''){\n            href(name: 'z10Page', title: \"10: ${getname(\"10\")}\", required: false, page: 'zoneSetPage10',\n                image: \"${getimage(\"10\")}\",\n                description: \"${display(\"10\")}\" )\n            }\n        }\n        if (zoneActive('11')){\n        section(''){\n            href(name: 'z11Page', title: \"11: ${getname(\"11\")}\", required: false, page: 'zoneSetPage11',\n                image: \"${getimage(\"11\")}\",\n                description: \"${display(\"11\")}\" )\n            }\n        }\n        if (zoneActive('12')){\n        section(''){\n            href(name: 'z12Page', title: \"12: ${getname(\"12\")}\", required: false, page: 'zoneSetPage12',\n                image: \"${getimage(\"12\")}\",\n                description: \"${display(\"12\")}\" )\n            }\n        }\n        if (zoneActive('13')){\n        section(''){\n            href(name: 'z13Page', title: \"13: ${getname(\"13\")}\", required: false, page: 'zoneSetPage13',\n                image: \"${getimage(\"13\")}\",\n                description: \"${display(\"13\")}\" )\n            }\n        }\n        if (zoneActive('14')){\n        section(''){\n            href(name: 'z14Page', title: \"14: ${getname(\"14\")}\", required: false, page: 'zoneSetPage14',\n                image: \"${getimage(\"14\")}\",\n                description: \"${display(\"14\")}\" )\n            }\n        }\n        if (zoneActive('15')){\n        section(''){\n            href(name: 'z15Page', title: \"15: ${getname(\"15\")}\", required: false, page: 'zoneSetPage15',\n                image: \"${getimage(\"15\")}\",\n                description: \"${display(\"15\")}\" )\n            }\n        }\n        if (zoneActive('16')){\n        section(''){\n            href(name: 'z16Page', title: \"16: ${getname(\"16\")}\", required: false, page: 'zoneSetPage16',\n                image: \"${getimage(\"16\")}\",\n                description: \"${display(\"16\")}\" )\n            }\n        }\n    }\n}\n\n//code change for ST update file -> change input to zoneNumberEnum\nprivate boolean zoneActive(z){\n    if (!zoneNumberEnum && zoneNumber && zoneNumber >= z.toInteger()) return true\n    else if (!zoneNumberEnum && zoneNumber && zoneNumber != z.toInteger()) return false\n    else if (zoneNumberEnum && zoneNumberEnum.contains(z)) return true\n    return false\n}\n\n\nprivate String zoneString() {\n    String numberString = 'Add zones to setup'\n    if (zoneNumber) numberString = \"Zones enabled: ${zoneNumber}\"\n    if (learn) numberString = \"${numberString}\\nSensor mode: Adaptive\"\n    else numberString = \"${numberString}\\nSensor mode: Delay\"\n    return numberString\n}\n\ndef zoneSettingsPage() {\n    dynamicPage(name: 'zoneSettingsPage', title: 'Zone Configuration') {\n           section(''){\n            //input (name: \"zoneNumber\", type: \"number\", title: \"Enter number of zones to configure?\",description: \"How many valves do you have? 1-16\", required: true)//, defaultValue: 16)\n            input 'zoneNumberEnum', 'enum', title: 'Select zones to configure', multiple: true,    metadata: [values: ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16']]\n            input 'gain', 'number', title: 'Increase or decrease all water times by this %, enter a negative or positive value, Default: 0', required: false, range: '-99..99'\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_sensor_200_r.png',\n                          title: 'Moisture sensor adapt mode',\n                          'Adaptive mode enabled: Watering times will be adjusted based on the assigned moisture sensor.\\n\\nAdaptive mode ' +\n                          'disabled (Delay): Zones with moisture sensors will water on any available days when the low moisture setpoint has ' +\n                          'been reached.'\n             input 'learn', 'bool', title: 'Enable Adaptive Moisture Control (with moisture sensors)', metadata: [values: ['true', 'false']]\n           }\n    }\n}\n\ndef zoneSetPage() {\n    dynamicPage(name: 'zoneSetPage', title: \"Zone ${state.app} Setup\") {\n        section(''){\n            paragraph image: \"http://www.plaidsystems.com/smartthings/st_${state.app}.png\",\n            title: 'Current Settings',\n            \"${display(\"${state.app}\")}\"\n            input \"name${state.app}\", 'text', title: 'Zone name?', required: false, defaultValue: \"Zone ${state.app}\"\n        }\n        \n        section(''){\n             href(name: 'tosprinklerSetPage', title: \"Sprinkler type: ${setString('zone')}\", required: false, page: 'sprinklerSetPage',\n                image: \"${getimage(\"${settings.\"zone${state.app}\"}\")}\",\n                //description: \"Set sprinkler nozzle type or turn zone off\")\n                description: 'Sprinkler type descriptions')\n             input \"zone${state.app}\", 'enum', title: 'Sprinkler Type', multiple: false, required: false, defaultValue: 'Off', submitOnChange: true, metadata: [values: ['Off', 'Spray', 'Rotor', 'Drip', 'Master Valve', 'Pump']]\n         }\n         \n         section(''){\n            href(name: 'toplantSetPage', title: \"Landscape Select: ${setString('plant')}\", required: false, page: 'plantSetPage',\n                image: \"${getimage(\"${settings[\"plant${state.app}\"]}\")}\",\n                //description: \"Set landscape type\")\n                description: 'Landscape type descriptions')\n             input \"plant${state.app}\", 'enum', title: 'Landscape', multiple: false, required: false, submitOnChange: true, metadata: [values: ['Lawn', 'Garden', 'Flowers', 'Shrubs', 'Trees', 'Xeriscape', 'New Plants']]\n            }\n\n        section(''){\n            href(name: 'tooptionSetPage', title: \"Options: ${setString('option')}\", required: false, page: 'optionSetPage',\n                image: \"${getimage(\"${settings[\"option${state.app}\"]}\")}\",\n                //description: \"Set watering options\")\n                description: 'Watering option descriptions')\n            input \"option${state.app}\", 'enum', title: 'Options', multiple: false, required: false, defaultValue: 'Cycle 2x', submitOnChange: true,metadata: [values: ['Slope', 'Sand', 'Clay', 'No Cycle', 'Cycle 2x', 'Cycle 3x']]\n            }\n        \n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_sensor_200_r.png',\n                      title: 'Moisture sensor settings',\n                      'Select a soil moisture sensor to monitor and control watering.  The soil moisture target value is set to a default value but can be adjusted to tune watering'\n            input \"sensor${state.app}\", 'capability.relativeHumidityMeasurement', title: 'Select moisture sensor?', required: false, multiple: false\n            input \"sensorSp${state.app}\", 'number', title: \"Minimum moisture sensor target value, Setpoint: ${getDrySp(state.app)}\", required: false\n        }\n\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_timer.png',\n                      title: 'Optional: Enter total watering time per week',\n                      'This value will replace the calculated time from other settings'\n                input \"minWeek${state.app}\", 'number', title: 'Water time per week.\\nDefault: 0 = autoadjust', description: 'minutes per week', required: false\n                input \"perDay${state.app}\", 'number', title: 'Guideline value for time per day, this divides minutes per week into watering days. Default: 20', defaultValue: '20', required: false\n        }\n    }\n}\n\nprivate String setString(String type) {\n    switch (type) {\n        case 'zone':\n            if (settings.\"zone${state.app}\") return settings.\"zone${state.app}\" else return 'Not Set'\n            break\n        case 'plant':\n            if (settings.\"plant${state.app}\") return settings.\"plant${state.app}\" else return 'Not Set'\n            break\n        case 'option':\n            if (settings.\"option${state.app}\") return settings.\"option${state.app}\" else return 'Not Set'\n            break\n        default:\n            return '????'\n    }\n}\n\ndef plantSetPage() {\n    dynamicPage(name: 'plantSetPage', title: \"${settings[\"name${state.app}\"]} Landscape Select\") {\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/img/st_${state.app}.png',\n                title: \"${settings[\"name${state.app}\"]}\",\n                \"Current settings ${display(\"${state.app}\")}\"\n            //input \"plant${state.app}\", \"enum\", title: \"Landscape\", multiple: false, required: false, submitOnChange: true, metadata: [values: ['Lawn', 'Garden', 'Flowers', 'Shrubs', 'Trees', 'Xeriscape', 'New Plants']]\n        }\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_lawn_200_r.png',\n            title: 'Lawn',\n            'Select Lawn for typical grass applications'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_garden_225_r.png',\n            title: 'Garden',\n            'Select Garden for vegetable gardens'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_flowers_225_r.png',\n            title: 'Flowers',\n            'Select Flowers for beds with smaller seasonal plants'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_shrubs_225_r.png',\n            title: 'Shrubs',\n            'Select Shrubs for beds with larger established plants'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_trees_225_r.png',\n            title: 'Trees',\n            'Select Trees for deep rooted areas without other plants'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_xeriscape_225_r.png',\n            title: 'Xeriscape',\n            'Reduces water for native or drought tolorent plants'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_newplants_225_r.png',\n            title: 'New Plants',\n            'Increases watering time per week and reduces automatic adjustments to help establish new plants. No weekly seasonal adjustment and moisture setpoint set to 40.'\n        }\n    }\n}\n\ndef sprinklerSetPage(){\n    dynamicPage(name: 'sprinklerSetPage', title: \"${settings[\"name${state.app}\"]} Sprinkler Select\") {\n        section(''){\n            paragraph image: \"http://www.plaidsystems.com/img/st_${state.app}.png\",\n            title: \"${settings[\"name${state.app}\"]}\",\n            \"Current settings ${display(\"${state.app}\")}\"\n            //input \"zone${state.app}\", \"enum\", title: \"Sprinkler Type\", multiple: false, required: false, defaultValue: 'Off', metadata: [values: ['Off', 'Spray', 'Rotor', 'Drip', 'Master Valve', 'Pump']]\n            }\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_spray_225_r.png',\n            title: 'Spray',\n            'Spray sprinkler heads spray a fan of water over the lawn. The water is applied evenly and can be turned on for a shorter duration of time.'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_rotor_225_r.png',\n            title: 'Rotor',\n            'Rotor sprinkler heads rotate, spraying a stream over the lawn.  Because they move back and forth across the lawn, they require a longer water period.'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_drip_225_r.png',\n            title: 'Drip',\n            'Drip lines or low flow emitters water slowely to minimize evaporation, because they are low flow, they require longer watering periods.'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_master_225_r.png',\n            title: 'Master',\n            'Master valves will open before watering begins.  Set the delay between master opening and watering in delay settings.'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_pump_225_r.png',\n            title: 'Pump',\n            'Attach a pump relay to this zone and the pump will turn on before watering begins.  Set the delay between pump start and watering in delay settings.'\n        }\n    }\n}\n\ndef optionSetPage(){\n    dynamicPage(name: 'optionSetPage', title: \"${settings[\"name${state.app}\"]} Options\") {\n        section(''){\n            paragraph image: \"http://www.plaidsystems.com/img/st_${state.app}.png\",\n            title: \"${settings[\"name${state.app}\"]}\",\n            \"Current settings ${display(\"${state.app}\")}\"\n            //input \"option${state.app}\", \"enum\", title: \"Options\", multiple: false, required: false, defaultValue: 'Cycle 2x', metadata: [values: ['Slope', 'Sand', 'Clay', 'No Cycle', 'Cycle 2x', 'Cycle 3x']]\n        }\n        section(''){\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_slope_225_r.png',\n            title: 'Slope',\n            'Slope sets the sprinklers to cycle 3x, each with a short duration to minimize runoff'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_sand_225_r.png',\n            title: 'Sand',\n            'Sandy soil drains quickly and requires more frequent but shorter intervals of water'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_clay_225_r.png',\n            title: 'Clay',\n            'Clay sets the sprinklers to cycle 2x, each with a short duration to maximize absorption'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_cycle1x_225_r.png',\n            title: 'No Cycle',\n            'The sprinklers will run for 1 long duration'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_cycle2x_225_r.png',\n            title: 'Cycle 2x',\n            'Cycle 2x will break the water period up into 2 shorter cycles to help minimize runoff and maximize adsorption'\n\n            paragraph image: 'http://www.plaidsystems.com/smartthings/st_cycle3x_225_r.png',\n            title: 'Cycle 3x',\n            'Cycle 3x will break the water period up into 3 shorter cycles to help minimize runoff and maximize adsorption'\n        }\n    }\n}\n\ndef setPage(i){\n    if (i) state.app = i\n    return state.app\n}\n\nprivate String getaZoneSummary(int zone){\n    if (!settings.\"zone${zone}\" || (settings.\"zone${zone}\" == 'Off')) return \"${zone}: Off\"\n\n    String daysString = ''\n    int tpw = initTPW(zone)\n    int dpw = initDPW(zone)\n    int runTime = calcRunTime(tpw, dpw)\n\n    if ( !learn && (settings.\"sensor${zone}\")) {\n        daysString = 'if Moisture is low on: '\n        dpw = daysAvailable()\n    }\n    if (days && (days.contains('Even') || days.contains('Odd'))) {\n        if (dpw == 1) daysString = 'Every 8 days'\n        if (dpw == 2) daysString = 'Every 4 days'\n        if (dpw == 4) daysString = 'Every 2 days'\n        if (days.contains('Even') && days.contains('Odd')) daysString = 'any day'\n    }\n    else {\n        def int[] dpwMap = [0,0,0,0,0,0,0]\n        dpwMap = getDPWDays(dpw)\n        daysString += getRunDays(dpwMap)\n    }\n    return \"${zone}: ${runTime} min, ${daysString}\"\n}\n\nprivate String getZoneSummary(){\n     String summary = ''\n    if (learn) summary = 'Moisture Learning enabled' else summary = 'Moisture Learning disabled'\n\n    int zone = 1\n    createDPWMap()\n    while(zone <= 16) {\n          if (nozzle(zone) == 4) summary = \"${summary}\\n${zone}: ${settings.\"zone${zone}\"}\"\n          else if ( (initDPW(zone) != 0) && zoneActive(zone.toString())) summary = \"${summary}\\n${getaZoneSummary(zone)}\"\n          zone++\n    }\n    if (summary) return summary else return zoneString()    //\"Setup all 16 zones\"\n}\n\nprivate String display(String i){\n    //log.trace \"display(${i})\"\n    String displayString = ''\n    int tpw = initTPW(i.toInteger())\n    int dpw = initDPW(i.toInteger())\n    int runTime = calcRunTime(tpw, dpw)\n    if (settings.\"zone${i}\")     displayString += settings.\"zone${i}\" + ' : '\n    if (settings.\"plant${i}\")     displayString += settings.\"plant${i}\" + ' : '\n    if (settings.\"option${i}\")     displayString += settings.\"option${i}\" + ' : '\n    int j = i.toInteger()\n    if (settings.\"sensor${i}\") {\n        displayString += settings.\"sensor${i}\"\n        displayString += \"=${getDrySp(j)}% : \"\n    }\n    if ((runTime != 0) && (dpw != 0)) displayString = \"${displayString}${runTime} minutes, ${dpw} days per week\"\n    return displayString\n}\n\nprivate String getimage(String image){\n    String imageStr = image\n    if (image.isNumber()) {\n        String zoneStr = settings.\"zone${image}\"\n        if (zoneStr) {\n            if (zoneStr == 'Off')             return 'http://www.plaidsystems.com/smartthings/off2.png'\n            if (zoneStr == 'Master Valve')     return 'http://www.plaidsystems.com/smartthings/master.png'\n            if (zoneStr == 'Pump')             return 'http://www.plaidsystems.com/smartthings/pump.png'\n\n            if (settings.\"plant${image}\") imageStr = settings.\"plant${image}\"        // default assume asking for the plant image\n        }\n    }\n    // OK, lookup the requested image\n    switch (imageStr) {\n        case \"null\":\n        case null:\n            return 'http://www.plaidsystems.com/smartthings/off2.png'\n        case 'Off':\n            return 'http://www.plaidsystems.com/smartthings/off2.png'\n        case 'Lawn':\n            return 'http://www.plaidsystems.com/smartthings/st_lawn_200_r.png'\n        case 'Garden':\n            return 'http://www.plaidsystems.com/smartthings/st_garden_225_r.png'\n        case 'Flowers':\n            return 'http://www.plaidsystems.com/smartthings/st_flowers_225_r.png'\n        case 'Shrubs':\n            return 'http://www.plaidsystems.com/smartthings/st_shrubs_225_r.png'\n        case 'Trees':\n            return 'http://www.plaidsystems.com/smartthings/st_trees_225_r.png'\n        case 'Xeriscape':\n            return 'http://www.plaidsystems.com/smartthings/st_xeriscape_225_r.png'\n        case 'New Plants':\n            return 'http://www.plaidsystems.com/smartthings/st_newplants_225_r.png'\n        case 'Spray':\n            return 'http://www.plaidsystems.com/smartthings/st_spray_225_r.png'\n        case 'Rotor':\n            return 'http://www.plaidsystems.com/smartthings/st_rotor_225_r.png'\n        case 'Drip':\n            return 'http://www.plaidsystems.com/smartthings/st_drip_225_r.png'\n        case 'Master Valve':\n            return \"http://www.plaidsystems.com/smartthings/st_master_225_r.png\"\n        case 'Pump':\n            return 'http://www.plaidsystems.com/smartthings/st_pump_225_r.png'\n        case 'Slope':\n            return 'http://www.plaidsystems.com/smartthings/st_slope_225_r.png'\n        case 'Sand':\n            return 'http://www.plaidsystems.com/smartthings/st_sand_225_r.png'\n        case 'Clay':\n            return 'http://www.plaidsystems.com/smartthings/st_clay_225_r.png'\n        case 'No Cycle':\n            return 'http://www.plaidsystems.com/smartthings/st_cycle1x_225_r.png'\n        case 'Cycle 2x':\n            return 'http://www.plaidsystems.com/smartthings/st_cycle2x_225_r.png'\n        case \"Cycle 3x\":\n            return 'http://www.plaidsystems.com/smartthings/st_cycle3x_225_r.png'\n        default:\n            return 'http://www.plaidsystems.com/smartthings/off2.png'\n    }\n}\n\nprivate String getname(String i) {\n    if (settings.\"name${i}\") return settings.\"name${i}\" else return \"Zone ${i}\"\n}\n\nprivate String zipString() {    \n    if (settings?.zipcode) return settings.zipcode\n    if (location?.zipCode?.isNumber()) return \"${location.zipCode}\"\n    if (location?.latitude && location?.longitude) return \"${location.latitude.floatValue()},${location.longitude.floatValue()}\"\n    return \"not set\"\n}\n\n//app install\ndef installed() {\n    state.dpwMap =                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    state.tpwMap =                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    state.Rain =                 [0,0,0,0,0,0,0]\n    state.daycount =             [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    atomicState.run =             false                // must be atomic - used to recover from crashes\n    state.pauseTime =             null\n    atomicState.startTime =     null\n    atomicState.finishTime =     null        // must be atomic - used to recover from crashes\n\n    log.debug \"Installed with settings: ${settings}\"\n    installSchedule()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    installSchedule()\n}\n\ndef installSchedule(){\n    if (!state.seasonAdj)             state.seasonAdj = 100.0\n    if (!state.weekseasonAdj)         state.weekseasonAdj = 0\n    if (state.daysAvailable != 0)     state.daysAvailable = 0    // force daysAvailable to be initialized by daysAvailable()\n    state.daysAvailable =             daysAvailable()            // every time we save the schedule\n\n    if (atomicState.run) {\n        attemptRecovery()                                     // clean up if we crashed earlier\n    }\n    else {\n        unsubscribe()                                        //added back in to reset manual subscription\n        resetEverything()\n    }\n    subscribe(app, appTouch)                                // enable the \"play\" button for this schedule\n    Random rand = new Random()\n    long randomOffset = 0\n\n    // always collect rainfall\n    int randomSeconds = rand.nextInt(59)\n    if (settings.isRain || settings.isSeason) schedule(\"${randomSeconds} 57 23 1/1 * ? *\", getRainToday)        // capture today's rainfall just before midnight\n\n    if (settings.switches && settings.startTime && settings.enable){\n\n        randomOffset = rand.nextInt(60000) + 20000\n        def checktime = timeToday(settings.startTime, location.timeZone).getTime() + randomOffset\n        //log.debug \"randomOffset ${randomOffset} checktime ${checktime}\"\n        schedule(checktime, preCheck)    //check weather & Days\n        writeSettings()\n        note('schedule', \"${app.label}: Starts at ${startTimeString()}\", 'i')\n    }\n    else {\n        unschedule( preCheck )\n        note('disable', \"${app.label}: Automatic watering disabled or setup is incomplete\", 'a')\n    }\n}\n\n// Called to find and repair after crashes - called by installSchedule() and busy()\nprivate boolean attemptRecovery() {\n    if (!atomicState.run) {\n        return false                                        // only clean up if we think we are still running\n    }\n    else {                                                    // Hmmm...seems we were running before...\n        def csw = settings.switches.currentSwitch\n        def cst = settings.switches.currentStatus\n        switch (csw) {\n            case 'on':                                        // looks like this schedule is running the controller at the moment\n                if (!atomicState.startTime) {                 // cycleLoop cleared the startTime, but cycleOn() didn't set it\n                    log.debug \"${app.label}: crashed in cycleLoop(), cycleOn() never started, cst is ${cst} - resetting\"\n                    resetEverything()                        // reset and try again...it's probably not us running the controller, though\n                    return false\n                }\n                // We have a startTime...\n                if (!atomicState.finishTime) {                // started, but we don't think we're done yet..so it's probably us!\n                    runIn(15, cycleOn)                        // goose the cycle, just in case\n                    note('active', \"${app.label}: schedule is apparently already running\", 'i')\n                    return true\n                }\n\n                // hmmm...switch is on and we think we're finished...probably somebody else is running...let busy figure it out\n                resetEverything()\n                return false\n                break\n\n            case 'off':                                     // switch is off - did we finish?\n                if (atomicState.finishTime)    {                // off and finished, let's just reset things\n                    resetEverything()\n                    return false\n                }\n\n                if (switches.currentStatus != 'pause') {     // off and not paused - probably another schedule, let's clean up\n                    resetEverything()\n                    return false\n                }\n\n                // off and not finished, and paused, we apparently crashed while paused\n                runIn(15, cycleOn)\n                return true\n                break\n\n            case 'programOn':                    // died while manual program running?\n            case 'programWait':                    // looks like died previously before we got started, let's try to clean things up\n                resetEverything()\n                if (atomicState.finishTime) atomicState.finishTime = null\n                if ((cst == 'active') || atomicState.startTime) {    // if we announced we were in preCheck, or made it all the way to cycleOn before it crashed\n                    settings.switches.programOff()                    // only if we think we actually started (cycleOn() started)\n                    // probably kills manual cycles too, but we'll let that go for now\n                }\n                if (atomicState.startTime) atomicState.startTime = null\n                note ('schedule', \"Looks like ${app.label} crashed recently...cleaning up\", c)\n                return false\n                break\n\n            default:\n                log.debug \"attemptRecovery(): atomicState.run == true, and I've nothing left to do\"\n                return true\n        }\n    }\n}\n\n// reset everything to the initial (not running) state\nprivate def resetEverything() {\n    if (atomicState.run) atomicState.run = false        // we're not running the controller any more\n    unsubAllBut()                                        // release manual, switches, sync, contacts & toggles\n\n    // take care not to unschedule preCheck() or getRainToday()\n    unschedule(cycleOn)\n    unschedule(checkRunMap)\n    unschedule(writeCycles)\n    unschedule(subOff)\n\n    if (settings.enableManual) subscribe(settings.switches, 'switch.programOn', manualStart)\n}\n\n// unsubscribe from ALL events EXCEPT app.touch\nprivate def unsubAllBut() {\n    unsubscribe(settings.switches)\n    unsubWaterStoppers()\n    if (settings.sync) unsubscribe(settings.sync)\n\n}\n\n// enable the \"Play\" button in SmartApp list\ndef appTouch(evt) {\n\n    log.debug \"appTouch(): atomicState.run = ${atomicState.run}\"\n\n    runIn(2, preCheck)                        // run it off a schedule, so we can see how long it takes in the app.state\n}\n\n// true if one of the stoppers is in Stop state\nprivate boolean isWaterStopped() {\n    if (settings.contacts && settings.contacts.currentContact.contains(settings.contactStop)) return true\n\n    if (settings.toggles && settings.toggles.currentSwitch.contains(settings.toggleStop)) return true\n\n    return false\n}\n\n// watch for water stoppers\nprivate def subWaterStop() {\n    if (settings.contacts) {\n        unsubscribe(settings.contacts)\n        subscribe(settings.contacts, \"contact.${settings.contactStop}\", waterStop)\n    }\n    if (settings.toggles) {\n        unsubscribe(settings.toggles)\n        subscribe(settings.toggles, \"switch.${settings.toggleStop}\", waterStop)\n    }\n}\n\n// watch for water starters\nprivate def subWaterStart() {\n    if (settings.contacts) {\n        unsubscribe(settings.contacts)\n        def cond = (settings.contactStop == 'open') ? 'closed' : 'open'\n        subscribe(settings.contacts, \"contact.${cond}\", waterStart)\n    }\n    if (settings.toggles) {\n        unsubscribe(settings.toggles)\n        def cond = (settings.toggleStop == 'on') ? 'off' : 'on'\n        subscribe(settings.toggles, \"switch.${cond}\", waterStart)\n    }\n}\n\n// stop watching water stoppers and starters\nprivate def unsubWaterStoppers() {\n    if (settings.contacts)     unsubscribe(settings.contacts)\n    if (settings.toggles)     unsubscribe(settings.toggles)\n}\n\n// which of the stoppers are in stop mode?\nprivate String getWaterStopList() {\n    String deviceList = ''\n    int i = 1\n    if (settings.contacts) {\n        settings.contacts.each {\n            if (it.currentContact == settings.contactStop) {\n                if (i > 1) deviceList += ', '\n                deviceList = \"${deviceList}${it.displayName} is ${settings.contactStop}\"\n                i++\n            }\n        }\n    }\n    if (settings.toggles) {\n        settings.toggles.each {\n            if (it.currentSwitch == settings.toggleStop) {\n                if (i > 1) deviceList += ', '\n                deviceList = \"${deviceList}${it.displayName} is ${settings.toggleStop}\"\n                i++\n            }\n        }\n    }\n    return deviceList\n}\n\n//write initial zone settings to device at install/update\ndef writeSettings(){\n    if (!state.tpwMap)             state.tpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    if (!state.dpwMap)             state.dpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    if (state.setMoisture)         state.setMoisture = null                            // not using any more\n    if (!state.seasonAdj)         state.seasonAdj = 100.0\n    if (!state.weekseasonAdj)     state.weekseasonAdj = 0\n    setSeason()\n}\n\n//get day of week integer\nint getWeekDay(day)\n{\n    def weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    def mapDay = [Monday:1, Tuesday:2, Wednesday:3, Thursday:4, Friday:5, Saturday:6, Sunday:7]\n    if(day && weekdays.contains(day)) {\n        return mapDay.get(day).toInteger()\n    }\n    def today = new Date().format('EEEE', location.timeZone)\n    return mapDay.get(today).toInteger()\n}\n\n// Get string of run days from dpwMap\nprivate String getRunDays(day1,day2,day3,day4,day5,day6,day7)\n{\n    String str = ''\n    if(day1) str += 'M'\n    if(day2) str += 'T'\n    if(day3) str += 'W'\n    if(day4) str += 'Th'\n    if(day5) str += 'F'\n    if(day6) str += 'Sa'\n    if(day7) str += 'Su'\n    if(str == '') str = '0 Days/week'\n    return str\n}\n\n//start manual schedule\ndef manualStart(evt){\n    boolean running = attemptRecovery()        // clean up if prior run crashed\n\t//isWeather()//use for testing\n    if (settings.enableManual && !running && (settings.switches.currentStatus != 'pause')){\n        if (settings.sync && ( (settings.sync.currentSwitch != 'off') || settings.sync.currentStatus == 'pause') ) {\n            note('skipping', \"${app.label}: Manual run aborted, ${settings.sync.displayName} appears to be busy\", 'a')\n            }\n        else {\n            def runNowMap = []\n            runNowMap = cycleLoop(0)\n\n            if (runNowMap) {\n                atomicState.run = true\n                settings.switches.programWait()\n                subscribe(settings.switches, 'switch.off', cycleOff)\n\n                runIn(60, cycleOn)               // start water program\n\n                                                // note that manual DOES abide by waterStoppers (if configured)\n                String newString = ''\n                int tt = state.totalTime\n                if (tt) {\n                    int hours = tt / 60            // DON'T Math.round this one\n                    int mins = tt - (hours * 60)\n                    String hourString = ''\n                    String s = ''\n                    if (hours > 1) s = 's'\n                    if (hours > 0) hourString = \"${hours} hour${s} & \"\n                    s = 's'\n                    if (mins == 1) s = ''\n                    newString = \"run time: ${hourString}${mins} minute${s}:\\n\"\n                }\n\n                note('active', \"${app.label}: Manual run, watering in 1 minute: ${newString}${runNowMap}\", 'd')\n            }\n            else note('skipping', \"${app.label}: Manual run failed, check configuration\", 'a')\n        }\n    }\n    else note('skipping', \"${app.label}: Manual run aborted, ${settings.switches.displayName} appears to be busy\", 'a')\n}\n\n//true if another schedule is running\nboolean busy(){\n    // Check if we are already running, crashed or somebody changed the schedule time while this schedule is running\n    if (atomicState.run){\n        if (!attemptRecovery()) {        // recovery will clean out any prior crashes and correct state of atomicState.run\n            return false                // (atomicState.run = false)\n        }\n        else {\n            // don't change the current status, in case the currently running schedule is in off/paused mode\n            note(settings.switches.currentStatus, \"${app.label}: Already running, skipping additional start\", 'i')\n            return true\n        }\n    }\n    // Not already running...\n\n    // Moved from cycleOn() - don't even start pre-check until the other controller completes its cycle\n    if (settings.sync) {\n        if ((settings.sync.currentSwitch != 'off') || settings.sync.currentStatus == 'pause') {\n            subscribe(settings.sync, 'switch.off', syncOn)\n\n            note('delayed', \"${app.label}: Waiting for ${settings.sync.displayName} to complete before starting\", 'c')\n            return true\n        }\n    }\n\n    // Check that the controller isn't paused while running some other schedule\n    def csw = settings.switches.currentSwitch\n    def cst = settings.switches.currentStatus\n\n    if ((csw == 'off') && (cst != 'pause')) {                // off && !paused: controller is NOT in use\n        log.debug \"switches ${csw}, status ${cst} (1st)\"\n        resetEverything()                                    // get back to the start state\n        return false\n    }\n\n    if (isDay()) {                                            // Yup, we need to run today, so wait for the other schedule to finish\n        log.debug \"switches ${csw}, status ${cst} (3rd)\"\n        resetEverything()\n        subscribe(settings.switches, 'switch.off', busyOff)\n        note('delayed', \"${app.label}: Waiting for currently running schedule to complete before starting\", 'c')\n           return true\n    }\n\n    // Somthing is running, but we don't need to run today anyway - don't need to do busyOff()\n    // (Probably should never get here, because preCheck() should check isDay() before calling busy()\n    log.debug \"Another schedule is running, but ${app.label} is not scheduled for today anyway\"\n    return true\n}\n\ndef busyOff(evt){\n    def cst = settings.switches.currentStatus\n    if ((settings.switches.currentSwitch == 'off') && (cst != 'pause')) { // double check that prior schedule is done\n        unsubscribe(switches)                            // we don't want any more button pushes until preCheck runs\n        Random rand = new Random()                         // just in case there are multiple schedules waiting on the same controller\n        int randomSeconds = rand.nextInt(120) + 15\n        runIn(randomSeconds, preCheck)                    // no message so we don't clog the system\n        note('active', \"${app.label}: ${settings.switches} finished, starting in ${randomSeconds} seconds\", 'i')\n    }\n}\n\n//run check every day\ndef preCheck() {\n\n    if (!isDay()) {\n        log.debug \"preCheck() Skipping: ${app.label} is not scheduled for today\"                    // silent - no note\n        //if (!atomicState.run && enableManual) subscribe(switches, 'switch.programOn', manualStart)    // only if we aren't running already\n        return\n    }\n\n    if (!busy()) {\n        atomicState.run = true                         // set true before doing anything, atomic in case we crash (busy() set it false if !busy)\n        settings.switches.programWait()                // take over the controller so other schedules don't mess with us\n        runIn(45, checkRunMap)                        // schedule checkRunMap() before doing weather check, gives isWeather 45s to complete\n                                                    // because that seems to be a little more than the max that the ST platform allows\n        unsubAllBut()                                // unsubscribe to everything except appTouch()\n        subscribe(settings.switches, 'switch.off', cycleOff)    // and start setting up for today's cycle\n        def start = now()\n        note('active', \"${app.label}: Starting...\", 'd')  //\n        def end = now()\n        log.debug \"preCheck note active ${end - start}ms\"\n\n           if (isWeather()) {                            // set adjustments and check if we shold skip because of rain\n               resetEverything()                        // if so, clean up our subscriptions\n               switches.programOff()                    // and release the controller\n        }\n        else {\n            log.debug 'preCheck(): running checkRunMap in 2 seconds'    //COOL! We finished before timing out, and we're supposed to water today\n            runIn(2, checkRunMap)    // jack the schedule so it runs sooner!\n        }\n    }\n}\n\n//start water program\ndef cycleOn(){\n    if (atomicState.run) {                            // block if manually stopped during precheck which goes to cycleOff\n\n        if (!isWaterStopped()) {                    // make sure ALL the contacts and toggles aren't paused\n            // All clear, let's start running!\n            subscribe(settings.switches, 'switch.off', cycleOff)\n            subWaterStop()                            // subscribe to all the pause contacts and toggles\n            resume()\n\n            // send the notification AFTER we start the controller (in case note() causes us to run over our execution time limit)\n            String newString = \"${app.label}: Starting...\"\n            if (!atomicState.startTime) {\n                atomicState.startTime = now()                // if we haven't already started\n                if (atomicState.startTime) atomicState.finishTime = null        // so recovery in busy() knows we didn't finish\n                if (state.pauseTime) state.pauseTime = null\n                if (state.totalTime) {\n                    String finishTime = new Date(now() + (60000 * state.totalTime).toLong()).format('EE @ h:mm a', location.timeZone)\n                    newString = \"${app.label}: Starting - ETC: ${finishTime}\"\n                }\n            }\n            else if (state.pauseTime) {        // resuming after a pause\n\n                def elapsedTime = Math.round((now() - state.pauseTime) / 60000)    // convert ms to minutes\n                int tt = state.totalTime + elapsedTime + 1\n                state.totalTime = tt        // keep track of the pauses, and the 1 minute delay above\n                String finishTime = new Date(atomicState.startTime + (60000 * tt).toLong()).format('EE @ h:mm a', location.timeZone)\n                state.pauseTime = null\n                newString = \"${app.label}: Resuming - New ETC: ${finishTime}\"\n            }\n            note('active', newString, 'd')\n        }\n        else {\n            // Ready to run, but one of the control contacts is still open, so we wait\n            subWaterStart()                                        // one of them is paused, let's wait until the are all clear!\n            note('pause', \"${app.label}: Watering paused, ${getWaterStopList()}\", 'c')\n        }\n    }\n}\n\n//when switch reports off, watering program is finished\ndef cycleOff(evt){\n\n    if (atomicState.run) {\n        def ft = new Date()\n        atomicState.finishTime = ft                                    // this is important to reset the schedule after failures in busy()\n        String finishTime = ft.format('h:mm a', location.timeZone)\n        note('finished', \"${app.label}: Finished watering at ${finishTime}\", 'd')\n    }\n    else {\n        log.debug \"${settings.switches} turned off\"        // is this a manual off? perhaps we should send a note?\n    }\n    resetEverything()                            // all done here, back to starting state\n}\n\n//run check each day at scheduled time\ndef checkRunMap(){\n\n    //check if isWeather returned true or false before checking\n    if (atomicState.run) {\n\n        //get & set watering times for today\n        def runNowMap = []\n        runNowMap = cycleLoop(1)        // build the map\n\n        if (runNowMap) {\n            runIn(60, cycleOn)                                            // start water\n            subscribe(settings.switches, 'switch.off', cycleOff)        // allow manual off before cycleOn() starts\n            if (atomicState.startTime) atomicState.startTime = null        // these were already cleared in cycleLoop() above\n            if (state.pauseTime) state.pauseTime = null                    // ditto\n            // leave atomicState.finishTime alone so that recovery in busy() knows we never started if cycleOn() doesn't clear it\n\n            String newString = ''\n            int tt = state.totalTime\n            if (tt) {\n                int hours = tt / 60            // DON'T Math.round this one\n                int mins = tt - (hours * 60)\n                String hourString = ''\n                String s = ''\n                if (hours > 1) s = 's'\n                if (hours > 0) hourString = \"${hours} hour${s} & \"\n                s = 's'\n                if (mins == 1) s = ''\n                newString = \"run time: ${hourString}${mins} minute${s}:\\n\"\n            }\n            note('active', \"${app.label}: Watering in 1 minute, ${newString}${runNowMap}\", 'd')\n        }\n        else {\n            unsubscribe(settings.switches)\n            unsubWaterStoppers()\n            switches.programOff()\n            if (enableManual) subscribe(settings.switches, 'switch.programOn', manualStart)\n            note('skipping', \"${app.label}: No watering today\", 'd')\n            if (atomicState.run) atomicState.run = false         // do this last, so that the above note gets sent to the controller\n        }\n    }\n    else {\n        log.debug 'checkRunMap(): atomicState.run = false'      // isWeather cancelled us out before we got started\n    }\n}\n\n//get todays schedule\ndef cycleLoop(int i)\n{\n    boolean isDebug = false\n    if (isDebug) log.debug \"cycleLoop(${i})\"\n\n    int zone = 1\n    int dpw = 0\n    int tpw = 0\n    int cyc = 0\n    int rtime = 0\n    def timeMap = [:]\n    def pumpMap = \"\"\n    def runNowMap = \"\"\n    String soilString = ''\n    int totalCycles = 0\n    int totalTime = 0\n    if (atomicState.startTime) atomicState.startTime = null                    // haven't started yet\n\n    while(zone <= 16)\n    {\n        rtime = 0\n        def setZ = settings.\"zone${zone}\"\n        if ((setZ && (setZ != 'Off')) && (nozzle(zone) != 4) && zoneActive(zone.toString())) {\n\n              // First check if we run this zone today, use either dpwMap or even/odd date\n              dpw = getDPW(zone)\n              int runToday = 0\n              // if manual, or every day allowed, or zone uses a sensor, then we assume we can today\n              //  - preCheck() has already verified that today isDay()\n              if ((i == 0) || /*(state.daysAvailable == 7) ||*/ (settings.\"sensor${zone}\")) {\n                  runToday = 1\n              }\n              else {\n\n                  dpw = getDPW(zone)                                    // figure out if we need to run (if we don't already know we do)\n                  if (settings.days && (settings.days.contains('Even') || settings.days.contains('Odd'))) {\n                    def daynum = new Date().format('dd', location.timeZone)\n                    int dayint = Integer.parseInt(daynum)\n                    if (settings.days.contains('Odd') && (((dayint +1) % Math.round(31 / (dpw * 4))) == 0)) runToday = 1\n                      else if (settings.days.contains('Even') && ((dayint % Math.round(31 / (dpw * 4))) == 0)) runToday = 1\n                  }\n                  else {\n                    int weekDay = getWeekDay()-1\n                    def dpwMap = getDPWDays(dpw)\n                    runToday = dpwMap[weekDay]  //1 or 0\n                    if (isDebug) log.debug \"Zone: ${zone} dpw: ${dpw} weekDay: ${weekDay} dpwMap: ${dpwMap} runToday: ${runToday}\"\n\n                  }\n              }\n\n            // OK, we're supposed to run (or at least adjust the sensors)\n              if (runToday == 1)\n              {\n                def soil\n                if (i == 0) soil = moisture(0)     // manual\n                else soil = moisture(zone)        // moisture check\n                  soilString = \"${soilString}${soil[1]}\"\n\n                // Run this zone if soil moisture needed\n                if ( soil[0] == 1 )\n                {\n                    cyc = cycles(zone)\n                    tpw = getTPW(zone)\n                    dpw = getDPW(zone)                    // moisture() may have changed DPW\n\n                    rtime = calcRunTime(tpw, dpw)\n                    //daily weather adjust if no sensor\n                    if(settings.isSeason && (!settings.learn || !settings.\"sensor${zone}\")) {\n\n\n                        rtime = Math.round(((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)\n                    }\n                    else {\n                        rtime = Math.round((rtime / cyc) + 0.4)    // let moisture handle the seasonAdjust for Adaptive (learn) zones\n                    }\n                    totalCycles += cyc\n                    totalTime += (rtime * cyc)\n                    runNowMap += \"${settings.\"name${zone}\"}: ${cyc} x ${rtime} min\\n\"\n                    if (isDebug) log.debug \"Zone ${zone} Map: ${cyc} x ${rtime} min - totalTime: ${totalTime}\"\n                }\n            }\n        }\n        if (nozzle(zone) == 4) pumpMap += \"${settings.\"name${zone}\"}: ${settings.\"zone${zone}\"} on\\n\"\n        timeMap.\"${zone+1}\" = \"${rtime}\"\n        zone++\n    }\n\n    if (soilString) {\n        String seasonStr = ''\n        String plus = ''\n        float sa = state.seasonAdj\n        if (settings.isSeason && (sa != 100.0) && (sa != 0.0)) {\n            float sadj = sa - 100.0\n            if (sadj > 0.0) plus = '+'                                            //display once in cycleLoop()\n            int iadj = Math.round(sadj)\n            if (iadj != 0) seasonStr = \"Adjusting ${plus}${iadj}% for weather forecast\\n\"\n        }\n        note('moisture', \"${app.label} Sensor status:\\n${seasonStr}${soilString}\" /* + seasonStr + soilString */,'m')\n    }\n\n    if (!runNowMap) {\n        return runNowMap            // nothing to run today\n    }\n\n    //send settings to Spruce Controller\n    switches.settingsMap(timeMap,4002)\n    runIn(30, writeCycles)\n\n    // meanwhile, calculate our total run time\n    int pDelay = 0\n    if (settings.pumpDelay && settings.pumpDelay.isNumber()) pDelay = settings.pumpDelay.toInteger()\n    totalTime += Math.round(((pDelay * (totalCycles-1)) / 60.0))  // add in the pump startup and inter-zone delays\n    state.totalTime = totalTime\n\n    if (state.pauseTime) state.pauseTime = null                    // and we haven't paused yet\n                                                                // but let cycleOn() reset finishTime\n    return (runNowMap + pumpMap)\n}\n\n//send cycle settings\ndef writeCycles(){\n    //log.trace \"writeCycles()\"\n    def cyclesMap = [:]\n    //add pumpdelay @ 1\n    cyclesMap.\"1\" = pumpDelayString()\n    int zone = 1\n    int cycle = 0\n    while(zone <= 17)\n    {\n        if(nozzle(zone) == 4) cycle = 4\n        else cycle = cycles(zone)\n        //offset by 1, due to pumpdelay @ 1\n        cyclesMap.\"${zone+1}\" = \"${cycle}\"\n        zone++\n    }\n    switches.settingsMap(cyclesMap, 4001)\n}\n\ndef resume(){\n    log.debug 'resume()'\n    settings.switches.zon()\n}\n\ndef syncOn(evt){\n    // double check that the switch is actually finished and not just paused\n    if ((settings.sync.currentSwitch == 'off') && (settings.sync.currentStatus != 'pause')) {\n        resetEverything()                                // back to our known state\n        Random rand = new Random()                         // just in case there are multiple schedules waiting on the same controller\n        int randomSeconds = rand.nextInt(120) + 15\n        runIn(randomSeconds, preCheck)                    // no message so we don't clog the system\n        note('schedule', \"${app.label}: ${settings.sync} finished, starting in ${randomSeconds} seconds\", 'c')\n    } // else, it is just pausing...keep waiting for the next \"off\"\n}\n\n// handle start of pause session\ndef waterStop(evt){\n    log.debug \"waterStop: ${evt.displayName}\"\n\n    unschedule(cycleOn)            // in case we got stopped again before cycleOn starts from the restart\n    unsubscribe(settings.switches)\n    subWaterStart()\n\n    if (!state.pauseTime) {            // only need to do this for the first event if multiple contacts\n        state.pauseTime = now()\n\n        String cond = evt.value\n        switch (cond) {\n            case 'open':\n                cond = 'opened'\n                break\n            case 'on':\n                cond = 'switched on'\n                break\n            case 'off':\n                cond = 'switched off'\n                break\n            //case 'closed':\n            //    cond = 'closed'\n            //    break\n            case null:\n                cond = '????'\n                break\n            default:\n                break\n        }\n        note('pause', \"${app.label}: Watering paused - ${evt.displayName} ${cond}\", 'c') // set to Paused\n    }\n    if (settings.switches.currentSwitch != 'off') {\n        runIn(30, subOff)\n        settings.switches.off()                                // stop the water\n    }\n    else\n        subscribe(settings.switches, 'switch.off', cycleOff)\n}\n\n// This is a hack to work around the delay in response from the controller to the above programOff command...\n// We frequently see the off notification coming a long time after the command is issued, so we try to catch that so that\n// we don't prematurely exit the cycle.\ndef subOff() {\n    subscribe(settings.switches, 'switch.off', offPauseCheck)\n}\n\ndef offPauseCheck( evt ) {\n    unsubscribe(settings.switches)\n    subscribe(settings.switches, 'switch.off', cycleOff)\n    if (/*(switches.currentSwitch != 'off') && */ (settings.switches.currentStatus != 'pause')) { // eat the first off while paused\n        cycleOff(evt)\n    }\n}\n\n// handle end of pause session\ndef waterStart(evt){\n    if (!isWaterStopped()){                     // only if ALL of the selected contacts are not open\n        def cDelay = 10\n        if (settings.contactDelay > 10) cDelay = settings.contactDelay\n        runIn(cDelay, cycleOn)\n\n        unsubscribe(settings.switches)\n        subWaterStop()                            // allow stopping again while we wait for cycleOn to start\n\n        log.debug \"waterStart(): enabling device is ${evt.device} ${evt.value}\"\n\n        String cond = evt.value\n        switch (cond) {\n            case 'open':\n                cond = 'opened'\n                break\n            case 'on':\n                cond = 'switched on'\n                break\n            case 'off':\n                cond = 'switched off'\n                break\n            //case 'closed':\n            //    cond = 'closed'\n            //    break\n            case null:\n                cond = '????'\n                break\n            default:\n                break\n        }\n        // let cycleOn() change the status to Active - keep us paused until then\n\n        note('pause', \"${app.label}: ${evt.displayName} ${cond}, watering in ${cDelay} seconds\", 'c')\n    }\n    else {\n        log.debug \"waterStart(): one down - ${evt.displayName}\"\n    }\n}\n\n//Initialize Days per week, based on TPW, perDay and daysAvailable settings\nint initDPW(int zone){\n    //log.debug \"initDPW(${zone})\"\n    if(!state.dpwMap) state.dpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n    int tpw = getTPW(zone)        // was getTPW -does not update times in scheduler without initTPW\n    int dpw = 0\n\n    if(tpw > 0) {\n        float perDay = 20.0\n        if(settings.\"perDay${zone}\") perDay = settings.\"perDay${zone}\".toFloat()\n\n        dpw = Math.round(tpw.toFloat() / perDay)\n        if(dpw <= 1) dpw = 1\n        // 3 days per week not allowed for even or odd day selection\n        if(dpw == 3 && days && (days.contains('Even') || days.contains('Odd')) && !(days.contains('Even') && days.contains('Odd')))\n            if((tpw.toFloat() / perDay) < 3.0) dpw = 2 else dpw = 4\n        int daycheck = daysAvailable()                        // initialize & optimize daysAvailable\n        if (daycheck < dpw) dpw = daycheck\n    }\n    state.dpwMap[zone-1] = dpw\n    return dpw\n}\n\n// Get current days per week value, calls init if not defined\nint getDPW(int zone) {\n    if (state.dpwMap) return state.dpwMap[zone-1] else return initDPW(zone)\n}\n\n//Initialize Time per Week\nint initTPW(int zone) {\n    //log.trace \"initTPW(${zone})\"\n    if (!state.tpwMap) state.tpwMap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n    int n = nozzle(zone)\n    def zn = settings.\"zone${zone}\"\n    if (!zn || (zn == 'Off') || (n == 0) || (n == 4) || (plant(zone) == 0) || !zoneActive(zone.toString())) return 0\n\n    // apply gain adjustment\n    float gainAdjust = 100.0\n    if (settings.gain && settings.gain != 0) gainAdjust += settings.gain\n\n    // apply seasonal adjustment if enabled and not set to new plants\n    float seasonAdjust = 100.0\n    def wsa = state.weekseasonAdj\n    if (wsa && isSeason && (settings.\"plant${zone}\" != 'New Plants')) seasonAdjust = wsa\n\n    int tpw = 0\n    // Use learned, previous tpw if it is available\n    if ( settings.\"sensor${zone}\" ) {\n        seasonAdjust = 100.0             // no weekly seasonAdjust if this zone uses a sensor\n        if(state.tpwMap && settings.learn) tpw = state.tpwMap[zone-1]\n    }\n\n    // set user-specified minimum time with seasonal adjust\n    int minWeek = 0\n    def mw = settings.\"minWeek${zone}\"\n    if (mw) minWeek = mw.toInteger()\n    if (minWeek != 0) {\n        tpw = Math.round(minWeek * (seasonAdjust / 100.0))\n    }\n    else if (!tpw || (tpw == 0)) { // use calculated tpw\n        tpw = Math.round((plant(zone) * nozzle(zone) * (gainAdjust / 100.0) * (seasonAdjust / 100.0)))\n    }\n    state.tpwMap[zone-1] = tpw\n    return tpw\n}\n\n// Get the current time per week, calls init if not defined\nint getTPW(int zone)\n{\n    if (state.tpwMap) return state.tpwMap[zone-1] else return initTPW(zone)\n}\n\n// Calculate daily run time based on tpw and dpw\nint calcRunTime(int tpw, int dpw)\n{\n    int duration = 0\n    if ((tpw > 0) && (dpw > 0)) duration = Math.round(tpw.toFloat() / dpw.toFloat())\n    return duration\n}\n\n// Check the moisture level of a zone returning dry (1) or wet (0) and adjust tpw if overly dry/wet\ndef moisture(int i)\n{\n    boolean isDebug = false\n    if (isDebug) log.debug \"moisture(${i})\"\n\n    def endMsecs = 0\n    // No Sensor on this zone or manual start skips moisture checking altogether\n    if ((i == 0) || !settings.\"sensor${i}\") {\n        return [1,'']\n    }\n\n    // Ensure that the sensor has reported within last 48 hours\n    int spHum = getDrySp(i)\n    int hours = 48\n    def yesterday = new Date(now() - (/* 1000 * 60 * 60 */ 3600000 * hours).toLong())\n    float latestHum = settings.\"sensor${i}\".latestValue('humidity').toFloat()    // state = 29, value = 29.13\n    def lastHumDate = settings.\"sensor${i}\".latestState('humidity').date\n    if (lastHumDate < yesterday) {\n        note('warning', \"${app.label}: Please check sensor ${settings.\"sensor${i}\"}, no humidity reports in the last ${hours} hours\", 'a')\n\n        if (latestHum < spHum)\n            latestHum = spHum - 1.0             // amke sure we water and do seasonal adjustments, but not tpw adjustments\n        else\n            latestHum = spHum + 0.99            // make sure we don't water, do seasonal adjustments, but not tpw adjustments\n    }\n\n    if (!settings.learn)\n    {\n        // in Delay mode, only looks at target moisture level, doesn't try to adjust tpw\n        // (Temporary) seasonal adjustment WILL be applied in cycleLoop(), as if we didn't have a sensor\n        if (latestHum <= spHum.toFloat()) {\n           //dry soil\n               return [1,\"${settings.\"name${i}\"}, Watering: ${settings.\"sensor${i}\"} reads ${latestHum}%, SP is ${spHum}%\\n\"]\n        }\n        else {\n            //wet soil\n               return [0,\"${settings.\"name${i}\"}, Skipping: ${settings.\"sensor${i}\"} reads ${latestHum}%, SP is ${spHum}%\\n\"]\n        }\n    }\n\n    //in Adaptive mode\n    int tpw = getTPW(i)\n    int dpw = getDPW(i)\n    int cpd = cycles(i)\n\n\n\n\n    if (isDebug) log.debug \"moisture(${i}): tpw: ${tpw}, dpw: ${dpw}, cycles: ${cpd} (before adjustment)\"\n\n    float diffHum = 0.0\n    if (latestHum > 0.0) diffHum = (spHum - latestHum) / 100.0\n    else {\n        diffHum = 0.02 // Safety valve in case sensor is reporting 0% humidity (e.g., somebody pulled it out of the ground or flower pot)\n        note('warning', \"${app.label}: Please check sensor ${settings.\"sensor${i}\"}, it is currently reading 0%\", 'a')\n    }\n\n    int daysA = state.daysAvailable\n    int minimum = cpd * dpw                    // minimum of 1 minute per scheduled days per week (note - can be 1*1=1)\n    if (minimum < daysA) minimum = daysA    // but at least 1 minute per available day\n    int tpwAdjust = 0\n\n    if (diffHum > 0.01) {                                 // only adjust tpw if more than 1% of target SP\n          tpwAdjust = Math.round(((tpw * diffHum) + 0.5) * dpw * cpd)    // Compute adjustment as a function of the current tpw\n        float adjFactor = 2.0 / daysA                    // Limit adjustments to 200% per week - spread over available days\n          if (tpwAdjust > (tpw * adjFactor)) tpwAdjust = Math.round((tpw * adjFactor) + 0.5)         // limit fast rise\n        if (tpwAdjust < minimum) tpwAdjust = minimum    // but we need to move at least 1 minute per cycle per day to actually increase the watering time\n    } else if (diffHum < -0.01) {\n        if (diffHum < -0.05) diffHum = -0.05            // try not to over-compensate for a heavy rainstorm...\n        tpwAdjust = Math.round(((tpw * diffHum) - 0.5) * dpw * cpd)\n        float adjFactor = -0.6667 / daysA                // Limit adjustments to 66% per week\n        if (tpwAdjust < (tpw * adjFactor)) tpwAdjust = Math.round((tpw * adjFactor) - 0.5)    // limit slow decay\n        if (tpwAdjust > (-1 * minimum)) tpwAdjust = -1 * minimum // but we need to move at least 1 minute per cycle per day to actually increase the watering time\n    }\n\n    int seasonAdjust = 0\n    if (isSeason) {\n        float sa = state.seasonAdj\n        if ((sa != 100.0) && (sa != 0.0)) {\n            float sadj = sa - 100.0\n            if (sa > 0.0)\n                seasonAdjust = Math.round(((sadj / 100.0) * tpw) + 0.5)\n            else\n                seasonAdjust = Math.round(((sadj / 100.0) * tpw) - 0.5)\n        }\n    }\n     if (isDebug) log.debug \"moisture(${i}): diffHum: ${diffHum}, tpwAdjust: ${tpwAdjust} seasonAdjust: ${seasonAdjust}\"\n\n     // Now, adjust the tpw.\n     // With seasonal adjustments enabled, tpw can go up or down independent of the difference in the sensor vs SP\n    int newTPW = tpw + tpwAdjust + seasonAdjust\n\n    int perDay = 20\n    def perD = settings.\"perDay${i}\"\n    if (perD) perDay = perD.toInteger()\n    if (perDay == 0) perDay = daysA * cpd                // at least 1 minute per cycle per available day\n      if (newTPW < perDay) newTPW = perDay                // make sure we have always have enough for 1 day of minimum water\n\n    int adjusted = 0\n    if ((tpwAdjust + seasonAdjust) > 0) {                            // needs more water\n           int maxTPW = daysA * 120    // arbitrary maximum of 2 hours per available watering day per week\n           if (newTPW > maxTPW) newTPW = maxTPW    // initDPW() below may spread this across more days\n           if (newTPW > (maxTPW * 0.75)) note('warning', \"${app.label}: Please check ${settings[\"sensor${i}\"]}, ${settings.\"name${i}\"} time per week seems high: ${newTPW} mins/week\",'a')\n         if (state.tpwMap[i-1] != newTPW) {    // are we changing the tpw?\n            state.tpwMap[i-1] = newTPW\n            dpw = initDPW(i)                            // need to recalculate days per week since tpw changed - initDPW() stores the value into dpwMap\n            adjusted = newTPW - tpw     // so that the adjustment note is accurate\n         }\n    }\n    else if ((tpwAdjust + seasonAdjust) < 0) {                         // Needs less water\n        // Find the minimum tpw\n        minimum = cpd * daysA                                        // at least 1 minute per cycle per available day\n        int minLimit = 0\n        def minL = settings.\"minWeek${i}\"\n        if (minL) minLimit = minL.toInteger()                        // unless otherwise specified in configuration\n        if (minLimit > 0) {\n            if (newTPW < minLimit) newTPW = minLimit                // use configured minutes per week as the minimum\n        } else if (newTPW < minimum) {\n            newTPW = minimum                                        // else at least 1 minute per cycle per available day\n            note('warning', \"${app.label}: Please check ${settings.\"sensor${i}\"}, ${settings.\"name${i}\"} time per week is very low: ${newTPW} mins/week\",'a')\n        }\n        if (state.tpwMap[i-1] != newTPW) {    // are we changing the tpw?\n            state.tpwMap[i-1] = newTPW        // store the new tpw\n            dpw = initDPW(i)                // may need to reclac days per week - initDPW() now stores the value into state.dpwMap - avoid doing that twice\n            adjusted = newTPW - tpw     // so that the adjustment note is accurate\n        }\n    }\n    // else no adjustments, or adjustments cancelled each other out.\n\n    String moistureSum = ''\n    String adjStr = ''\n    String plus = ''\n    if (adjusted > 0) plus = '+'\n    if (adjusted != 0) adjStr = \", ${plus}${adjusted} min\"\n    if (Math.abs(adjusted) > 1) adjStr = \"${adjStr}s\"\n    if (diffHum >= 0.0) {                 // water only if ground is drier than SP\n        moistureSum = \"> ${settings.\"name${i}\"}, Water: ${settings.\"sensor${i}\"} @ ${latestHum}% (${spHum}%)${adjStr} (${newTPW} min/wk)\\n\"\n        return [1, moistureSum]\n    }\n    else {                             // not watering\n        moistureSum = \"> ${settings.\"name${i}\"}, Skip: ${settings.\"sensor${i}\"} @ ${latestHum}% (${spHum}%)${adjStr} (${newTPW} min/wk)\\n\"\n        return [0, moistureSum]\n    }\n    return [0, moistureSum]\n}\n\n//get moisture SP\nint getDrySp(int i){\n    if (settings.\"sensorSp${i}\") return settings.\"sensorSp${i}\".toInteger() // configured SP\n\n\n    if (settings.\"plant${i}\" == 'New Plants') return 40                        // New Plants get special care\n\n\n    switch (settings.\"option${i}\") {                                        // else, defaults based off of soil type\n        case 'Sand':\n            return 22\n        case 'Clay':\n            return 38\n        default:\n            return 28\n    }\n}\n\n//notifications to device, pushed if requested\ndef note(String statStr, String msg, String msgType) {\n\n    // send to debug first (near-zero cost)\n    log.debug \"${statStr}: ${msg}\"\n\n    // notify user second (small cost)\n    boolean notifyController = true\n    if(settings.notify || settings.logAll) {\n        String spruceMsg = \"Spruce ${msg}\"\n        switch(msgType) {\n            case 'd':\n                  if (settings.notify && settings.notify.contains('Daily')) {        // always log the daily events to the controller\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'c':\n                  if (settings.notify && settings.notify.contains('Delays')) {\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'i':\n                  if (settings.notify && settings.notify.contains('Events')) {\n                      sendIt(spruceMsg)\n                      //notifyController = false                    // no need to notify controller unless we don't notify the user\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'f':\n                  notifyController = false                        // no need to notify the controller, ever\n                if (settings.notify && settings.notify.contains('Weather')) {\n                      sendIt(spruceMsg)\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              case 'a':\n                  notifyController = false                        // no need to notify the controller, ever\n                  if (settings.notify && settings.notify.contains('Warnings')) {\n                      sendIt(spruceMsg)\n                  } else\n                      sendNotificationEvent(spruceMsg)                    // Special case - make sure this goes into the Hello Home log, if not notifying\n                  break\n              case 'm':\n                  if (settings.notify && settings.notify.contains('Moisture')) {\n                      sendIt(spruceMsg)\n                      //notifyController = false                    // no need to notify controller unless we don't notify the user\n                  }\n                  else if (settings.logAll) {\n                      sendNotificationEvent(spruceMsg)\n                  }\n                  break\n              default:\n                  break\n          }\n    }\n    // finally, send to controller DTH, to change the state and to log important stuff in the event log\n    if (notifyController) {        // do we really need to send these to the controller?\n        // only send status updates to the controller if WE are running, or nobody else is\n        if (atomicState.run || ((settings.switches.currentSwitch == 'off') && (settings.switches.currentStatus != 'pause'))) {\n            settings.switches.notify(statStr, msg)\n\n        }\n        else { // we aren't running, so we don't want to change the status of the controller\n            // send the event using the current status of the switch, so we don't change it\n            //log.debug \"note - direct sendEvent()\"\n            settings.switches.notify(settings.switches.currentStatus, msg)\n\n          }\n    }\n}\n\ndef sendIt(String msg) {\n    if (location.contactBookEnabled && settings.recipients) {\n        sendNotificationToContacts(msg, settings.recipients, [event: true])\n    }\n    else {\n        sendPush( msg )\n    }\n}\n\n//days available\nint daysAvailable(){\n\n    // Calculate days available for watering and save in state variable for future use\n    def daysA = state.daysAvailable\n    if (daysA && (daysA > 0)) {                            // state.daysAvailable has already calculated and stored in state.daysAvailable\n        return daysA\n    }\n\n    if (!settings.days)    {                                // settings.days = \"\" --> every day is available\n        state.daysAvailable = 7\n        return 7        // every day is allowed\n    }\n\n    int dayCount = 0                                    // settings.days specified, need to calculate state.davsAvailable (once)\n    if (settings.days.contains('Even') || settings.days.contains('Odd')) {\n        dayCount = 4\n        if(settings.days.contains('Even') && settings.days.contains('Odd')) dayCount = 7\n    }\n    else {\n        if (settings.days.contains('Monday'))         dayCount += 1\n        if (settings.days.contains('Tuesday'))         dayCount += 1\n        if (settings.days.contains('Wednesday'))    dayCount += 1\n        if (settings.days.contains('Thursday'))     dayCount += 1\n        if (settings.days.contains('Friday'))         dayCount += 1\n        if (settings.days.contains('Saturday'))     dayCount += 1\n        if (settings.days.contains('Sunday'))         dayCount += 1\n    }\n\n    state.daysAvailable = dayCount\n    return dayCount\n}\n\n//zone: ['Off', 'Spray', 'rotor', 'Drip', 'Master Valve', 'Pump']\nint nozzle(int i){\n    String getT = settings.\"zone${i}\"\n    if (!getT) return 0\n\n    switch(getT) {\n        case 'Spray':\n            return 1\n        case 'Rotor':\n            return 1.4\n        case 'Drip':\n            return 2.4\n        case 'Master Valve':\n            return 4\n        case 'Pump':\n            return 4\n        default:\n            return 0\n    }\n}\n\n//plant: ['Lawn', 'Garden', 'Flowers', 'Shrubs', 'Trees', 'Xeriscape', 'New Plants']\nint plant(int i){\n    String getP = settings.\"plant${i}\"\n    if(!getP) return 0\n\n    switch(getP) {\n        case 'Lawn':\n            return 60\n        case 'Garden':\n            return 50\n        case 'Flowers':\n            return 40\n        case 'Shrubs':\n            return 30\n        case 'Trees':\n            return 20\n        case 'Xeriscape':\n            return 30\n        case 'New Plants':\n            return 80\n        default:\n            return 0\n    }\n}\n\n//option: ['Slope', 'Sand', 'Clay', 'No Cycle', 'Cycle 2x', 'Cycle 3x']\nint cycles(int i){\n    String getC = settings.\"option${i}\"\n    if(!getC) return 2\n\n    switch(getC) {\n        case 'Slope':\n            return 3\n        case 'Sand':\n            return 1\n        case 'Clay':\n            return 2\n        case 'No Cycle':\n            return 1\n        case 'Cycle 2x':\n            return 2\n        case 'Cycle 3x':\n            return 3\n        default:\n            return 2\n    }\n}\n\n//check if day is allowed\nboolean isDay() {\n\n    if (daysAvailable() == 7) return true                        // every day is allowed\n\n    def daynow = new Date()\n    String today = daynow.format('EEEE', location.timeZone)\n    if (settings.days.contains(today)) return true\n\n    def daynum = daynow.format('dd', location.timeZone)\n    int dayint = Integer.parseInt(daynum)\n    if (settings.days.contains('Even') && (dayint % 2 == 0)) return true\n    if (settings.days.contains('Odd') && (dayint % 2 != 0)) return true\n    return false\n}\n\n//set season adjustment & remove season adjustment\ndef setSeason() {\n    boolean isDebug = false\n    if (isDebug) log.debug 'setSeason()'\n\n    int zone = 1\n    while(zone <= 16) {\n        if ( !settings.learn || !settings.\"sensor${zone}\" || state.tpwMap[zone-1] == 0) {\n\n            int tpw = initTPW(zone)        // now updates state.tpwMap\n            int dpw = initDPW(zone)        // now updates state.dpwMap\n            if (isDebug) {\n                if (!settings.learn && (tpw != 0) && (state.weekseasonAdj != 0)) {\n                    log.debug \"Zone ${zone}: seasonally adjusted by ${state.weekseasonAdj-100}% to ${tpw}\"\n                }\n            }\n        }\n        zone++\n    }\n}\n\n//TWC functions\ndef getCity(){\n\tString wzipcode = zipString()\n    String city\n    try {\n\t\t\tcity = getTwcLocation(wzipcode)?.location?.city ?: wzipcode\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\tcity = \"unknown city\"\n\t\t}\n    \n    return city\n}\n\ndef getConditions(){\n\tString wzipcode = zipString()\n    def conditionsData\n    try {\n\t\t\tconditionsData = getTwcConditions(wzipcode)\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\treturn null\n\t\t}\n    \n    return conditionsData\n}\n\ndef getForecast(){\n\tString wzipcode = zipString()\n    def forecastData\n    try {\n\t\t\tforecastData = getTwcForecast(wzipcode)\n\t\t}\n\tcatch (e) {\n\t\t\tlog.debug \"getTwcLocation exception: $e\"\n\t\t\t// There was a problem obtaining the weather with this zip-code, so fall back to the hub's location and note this for future runs.\n\t\t\treturn null\n\t\t}    \n    \n    return forecastData\n}\n\n//capture today's total rainfall - scheduled for just before midnight each day\ndef getRainToday() {\n    //def wzipcode = zipString()\n    //def conditionsData = getTwcConditions(wzipcode)\n    def conditionsData = getConditions()\n    if (!conditionsData) {\n        note('warning', \"${app.label}: Please check Zipcode/PWS setting, error: null\", 'a')\n    } else {\n        float TRain = 0.0\n        if (conditionsData.precip24Hour.isNumber()) {\n            TRain = conditionsData.precip24Hour.toFloat()\n            if (TRain > 25.0) TRain = 25.0\n            else if (TRain < 0.0) TRain = 0.0\n            log.debug \"getRainToday(): ${conditionsData.precip24Hour} / ${TRain}\"\n        }\n        int day = getWeekDay()                        // what day is it today?\n        if (day == 7) day = 0                        // adjust: state.Rain order is Su,Mo,Tu,We,Th,Fr,Sa\n        state.Rain[day] = TRain as Float            // store today's total rainfall\n    }\n}\n\n//check weather, set seasonal adjustment factors, skip today if rainy\nboolean isWeather(){\n    if (!settings.isRain && !settings.isSeason) return false\n    \n    def city = getCity()\n    def forecastData = getForecast() ?: null\n    def conditionsData = getConditions() ?: null\n    //log.debug forecastData\n    //log.debug conditionsData\n    \n    //if data is null, skip weather adjustments\n    if (!forecastData || !conditionsData) {\n        note('warning', \"${app.label}: Please check Zipcode/PWS setting, error: null\", 'a')\n        return false\n    }\n        \n   \t//check if day or night\n    int not_today = 0\n   \tif (forecastData.daypart[0].daypartName[0] != \"Today\") not_today = 1;\n    \n   \t// OK, we have good data, let's start the analysis\n    float qpfTodayIn = 0.0\n    float qpfTomIn = 0.0\n    float popToday = 50.0\n    float popTom = 50.0\n    float TRain = 0.0\n    float YRain = 0.0\n    float weeklyRain = 0.0\n\n    if (settings.isRain) {\n        log.debug 'isWeather(): isRain'\n\n        // Get forecasted rain for today and tomorrow\n        if (!forecastData) {\n            log.debug 'isWeather(): Unable to get weather forecast.'\n            return false\n        }\n        \n        //log.debug \"${forecastData.daypart[0].qpf}\"\n        //log.debug \"${forecastData.daypart[0].precipChance}\"\n        if (forecastData.daypart[0].qpf[not_today]) qpfTodayIn = forecastData.daypart[0].qpf[not_today].toFloat()\n        if (forecastData.daypart[0].precipChance[not_today]) popToday = forecastData.daypart[0].precipChance[not_today].toFloat()\n        if (forecastData.daypart[0].qpf[2]) qpfTomIn = forecastData.daypart[0].qpf[1].toFloat()\n        if (forecastData.daypart[0].precipChance[2]) popTom = forecastData.daypart[0].precipChance[1].toFloat()\n        if (qpfTodayIn > 25.0) qpfTodayIn = 25.0\n        else if (qpfTodayIn < 0.0) qpfTodayIn = 0.0\n        if (qpfTomIn > 25.0) qpfTomIn = 25.0\n        else if (qpfTomIn < 0.0) qpfTomIn = 0.0\n\n        // Get rainfall so far today\n\n        if (!conditionsData) {\n            log.debug 'isWeather(): Unable to get current weather conditions.'\n            return false\n        }\n        if (conditionsData.precip24Hour.isNumber()) {\n               TRain = conditionsData.precip24Hour.toFloat()\n               if (TRain > 25.0) TRain = 25.0            // Ignore runaway weather\n               else if (TRain < 0.0) TRain = 0.0        // WU can return -999 for estimated locations\n        }\n        if (TRain > (qpfTodayIn * (popToday / 100.0))) {  // Not really what PoP means, but use as an adjustment factor of sorts\n            qpfTodayIn = TRain                        // already have more rain than was forecast for today, so use that instead\n            popToday = 100                            // we KNOW this rain happened\n        }\n\n        // Get yesterday's rainfall\n        int day = getWeekDay()\n        YRain = state.Rain[day - 1]\n\n        log.debug \"TRain ${TRain} qpfTodayIn ${qpfTodayIn} @ ${popToday}%, YRain ${YRain}\"\n\n        int i = 0\n        while (i <= 6){                                // calculate (un)weighted average (only heavy rainstorms matter)\n            int factor = 0\n            if ((day - i) > 0) factor = day - i else factor =  day + 7 - i\n            float getrain = state.Rain[i]\n            if (factor != 0) weeklyRain += (getrain / factor)\n            i++\n        }\n\n        log.debug \"isWeather(): weeklyRain ${weeklyRain}\"\n    }\n\n    log.debug 'isWeather(): build report'\n\t//log.debug \"${forecastData.daypart[0].temperature[not_today]}\"\n    //get highs\n       int highToday = 0\n       int highTom = 0\n       if (forecastData.daypart[0].temperature[not_today]) highToday = forecastData.daypart[0].temperature[not_today].toInteger()\n       if (forecastData.daypart[0].temperature[2]) highTom = forecastData.daypart[0].temperature[2].toInteger()\n\n    String weatherString = \"${app.label}: ${city} weather:\\n TDA: ${highToday}F\"\n    if (settings.isRain) weatherString = \"${weatherString}, ${qpfTodayIn}in rain (${Math.round(popToday)}% PoP)\"\n    weatherString = \"${weatherString}\\n TMW: ${highTom}F\"\n    if (settings.isRain) weatherString = \"${weatherString}, ${qpfTomIn}in rain (${Math.round(popTom)}% PoP)\\n YDA: ${YRain}in rain\"\n\n    if (settings.isSeason)\n    {\n        if (!settings.isRain) {                             // we need to verify we have good data first if we didn't do it above\n\n            if (!forecastData) {\n                log.debug 'Unable to get weather forecast'\n                return false\n            }\n        }\n\n        // is the temp going up or down for the next few days?\n        float heatAdjust = 100.0\n        float avgHigh = highToday.toFloat()\n        if (highToday != 0) {\n            // is the temp going up or down for the next few days?\n            int totalHigh = highToday\n            int j = 2\n            int highs = 1            \n            while (j < 6) { // get forecasted high for next 3 days\n                if (forecastData.daypart[0].temperature[j].isNumber()) {\n                    totalHigh += forecastData.daypart[0].temperature[j].toInteger()\n                    highs++\n                }\n                j+=2\n            }\n            if ( highs > 0 ) avgHigh = (totalHigh / highs)\n            heatAdjust = (avgHigh / highToday).round(2)\n        }\n        log.debug \"highToday ${highToday}, avgHigh ${avgHigh}, heatAdjust ${heatAdjust}\"\n        \n        //get humidity\n        int humToday = 0\n        int avehumidity = 0\n        log.debug \"${forecastData.daypart[0].relativeHumidity[not_today]}\"\n        if (forecastData.daypart[0].relativeHumidity[not_today]) humToday = forecastData.daypart[0].relativeHumidity[not_today]\n        \n        float humAdjust = 100.0\n        float avgHum = humToday.toFloat()\n        \n        if (humToday != 0 && avehumidity != 0) {\n            int j = 2\n            int highs = 1\n            int totalHum = humToday\n            while (j < 6) {                     // get forcasted humitidty for today and the next 3 days                \n                if (forecastData.daypart[0].relativeHumidity[j].isNumber()) {\n                    totalHum += forecastData.daypart[0].relativeHumidity[j]\n                    highs++\n                }\n                j+=2\n            }\n            if (highs > 1) avgHum = totalHum / highs\n            humAdjust = 1.5 - ((0.5 * avgHum) / humToday)    // basically, half of the delta % between today and today+3 days\n        }\n        log.debug \"humToday ${humToday}, avgHum ${avgHum}, humAdjust ${humAdjust}\"\n\n        //daily adjustment - average of heat and humidity factors\n        //hotter over next 3 days, more water\n        //cooler over next 3 days, less water\n        //drier  over next 3 days, more water\n        //wetter over next 3 days, less water\n        //\n        //Note: these should never get to be very large, and work best if allowed to cumulate over time (watering amount will change marginally\n        //        as days get warmer/cooler and drier/wetter)\n           def sa = ((heatAdjust + humAdjust) / 2)// * 100.0\n           state.seasonAdj = sa\n           sa = sa - 100.0\n        String plus = ''\n        if (sa > 0) plus = '+'\n        weatherString = \"${weatherString}\\n Adjusting ${plus}${Math.round(sa)}% for weather forecast\"\n\n        // Apply seasonal adjustment on Monday each week or at install\n        if ((getWeekDay() == 1) || (state.weekseasonAdj == 0)) {\n            //get daylight\n             if (conditionsData.sunriseTimeLocal && conditionsData.sunsetTimeLocal) {\n                 def hours = new java.text.SimpleDateFormat(\"HH\");\n                 def minutes = new java.text.SimpleDateFormat(\"mm\");\n                 String nowAsISO = hours.format(new Date());\n\n\t\t\t\tdef sunriseTime = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss-SSSS\", conditionsData.sunriseTimeLocal)\n                def sunsetTime = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss-SSSS\", conditionsData.sunsetTimeLocal)\n                \n                int getsunRH = hours.format(sunriseTime).toInteger()                \n                int getsunRM = minutes.format(sunriseTime).toInteger()\n                int getsunSH = hours.format(sunsetTime).toInteger()\n                int getsunSM = minutes.format(sunsetTime).toInteger()\n\n                int daylight = ((getsunSH * 60) + getsunSM)-((getsunRH * 60) + getsunRM)\n                if (daylight >= 850) daylight = 850\n                \n                //set seasonal adjustment\n                //seasonal q (fudge) factor\n                float qFact = 75.0\n\n                // (Daylight / 11.66 hours) * ( Average of ((Avg Temp / 70F) + ((1/2 of Average Humidity) / 65.46))) * calibration quotient\n                // Longer days = more water        (day length constant = approx USA day length at fall equinox)\n                // Higher temps = more water\n                // Lower humidity = more water    (humidity constant = USA National Average humidity in July)\n                float wa = ((daylight / 700.0) * (((avgHigh / 70.0) + (1.5-((avgHum * 0.5) / 65.46))) / 2.0) * qFact)\n                state.weekseasonAdj = wa\n\n                //apply seasonal time adjustment\n                plus = ''\n                if (wa != 0) {\n                    if (wa > 100.0) plus = '+'\n                    String waStr = String.format('%.2f', (wa - 100.0))\n                    weatherString = \"${weatherString}\\n Seasonal adjustment of ${waStr}% for the week\"\n                }\n                setSeason()\n            }\n            else {\n                log.debug 'isWeather(): Unable to get sunrise/set info for today.'\n            }\n        }\n    }\n    note('season', weatherString , 'f')\n\n    // if only doing seasonal adjustments, we are done\n    if (!settings.isRain) return false\n\n    float setrainDelay = 0.2\n    if (settings.rainDelay) setrainDelay = settings.rainDelay.toFloat()\n\n    // if we have no sensors, rain causes us to skip watering for the day\n    if (!anySensors()) {\n        if (settings.switches.latestValue('rainsensor') == 'rainsensoron'){\n            note('raintoday', \"${app.label}: skipping, rain sensor is on\", 'd')\n            return true\n           }\n           float popRain = qpfTodayIn * (popToday / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintoday', \"${app.label}: skipping, ${rainStr}in of rain is probable today\", 'd')\n            return true\n        }\n        popRain += qpfTomIn * (popTom / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintom', \"${app.label}: skipping, ${rainStr}in of rain is probable today + tomorrow\", 'd')\n            return true\n        }\n        if (weeklyRain > setrainDelay){\n            String rainStr = String.format('%.2f', weeklyRain)\n            note('rainy', \"${app.label}: skipping, ${rainStr}in weighted average rain over the past week\", 'd')\n            return true\n        }\n    }\n    else { // we have at least one sensor in the schedule\n        // Ignore rain sensor & historical rain - only skip if more than setrainDelay is expected before midnight tomorrow\n        float popRain = (qpfTodayIn * (popToday / 100.0)) - TRain    // ignore rain that has already fallen so far today - sensors should already reflect that\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintoday', \"${app.label}: skipping, at least ${rainStr}in of rain is probable later today\", 'd')\n            return true\n        }\n        popRain += qpfTomIn * (popTom / 100.0)\n        if (popRain > setrainDelay){\n            String rainStr = String.format('%.2f', popRain)\n            note('raintom', \"${app.label}: skipping, at least ${rainStr}in of rain is probable later today + tomorrow\", 'd')\n            return true\n        }\n    }\n    if (isDebug) log.debug \"isWeather() ends\"\n    return false\n}\n\n// true if ANY of this schedule's zones are on and using sensors\nprivate boolean anySensors() {\n    int zone=1\n    while (zone <= 16) {\n        def zoneStr = settings.\"zone${zone}\"\n        if (zoneStr && (zoneStr != 'Off') && settings.\"sensor${zone}\") return true\n        zone++\n    }\n    return false\n}\n\ndef getDPWDays(int dpw){\n    if (dpw && (dpw.isNumber()) && (dpw >= 1) && (dpw <= 7)) {\n        return state.\"DPWDays${dpw}\"\n    } else\n          return [0,0,0,0,0,0,0]\n}\n\n// Create a map of what days each possible DPW value will run on\n// Example:  User sets allowed days to Monday Wed and Fri\n// Map would look like: DPWDays1:[1,0,0,0,0,0,0] (run on Monday)\n//                      DPWDays2:[1,0,0,0,1,0,0] (run on Monday and Friday)\n//                      DPWDays3:[1,0,1,0,1,0,0] (run on Monday Wed and Fri)\n// Everything runs on the first day possible, starting with Monday.\ndef createDPWMap() {\n    state.DPWDays1 = []\n    state.DPWDays2 = []\n    state.DPWDays3 = []\n    state.DPWDays4 = []\n    state.DPWDays5 = []\n    state.DPWDays6 = []\n    state.DPWDays7 = []\n    //def NDAYS = 7\n    // day Distance[NDAYS][NDAYS], easier to just define than calculate everytime\n    def int[][] dayDistance = [[0,1,2,3,3,2,1],[1,0,1,2,3,3,2],[2,1,0,1,2,3,3],[3,2,1,0,1,2,3],[3,3,2,1,0,1,2],[2,3,3,2,1,0,1],[1,2,3,3,2,1,0]]\n    def ndaysAvailable = daysAvailable()\n    int i = 0\n\n    // def int[] daysAvailable = [0,1,2,3,4,5,6]\n    def int[] daysAvailable = [0,0,0,0,0,0,0]\n\n    if(settings.days) {\n          if (settings.days.contains('Even') || settings.days.contains('Odd')) {\n              return\n          }\n          if (settings.days.contains('Monday')) {\n            daysAvailable[i] = 0\n            i++\n          }\n        if (settings.days.contains('Tuesday')) {\n            daysAvailable[i] = 1\n            i++\n          }\n          if (settings.days.contains('Wednesday')) {\n            daysAvailable[i] = 2\n            i++\n          }\n          if (settings.days.contains('Thursday')) {\n            daysAvailable[i] = 3\n            i++\n          }\n          if (settings.days.contains('Friday')) {\n            daysAvailable[i] = 4\n            i++\n          }\n          if (settings.days.contains('Saturday')) {\n            daysAvailable[i] = 5\n            i++\n          }\n          if (settings.days.contains('Sunday')) {\n            daysAvailable[i] = 6\n            i++\n          }\n          if(i != ndaysAvailable) {\n            log.debug 'ERROR: days and daysAvailable do not match in setup - overriding'\n            log.debug \"${i} ${ndaysAvailable}\"\n            ndaysAvailable = i                // override incorrect setup execution\n            state.daysAvailable = i\n          }\n    }\n    else {                    // all days are available if settings.days == \"\"\n        daysAvailable = [0,1,2,3,4,5,6]\n    }\n    //log.debug \"Ndays: ${ndaysAvailable} Available Days: ${daysAvailable}\"\n    def maxday = -1\n    def max = -1\n    def dDays = new int[7]\n    def int[][] runDays = [[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]\n\n    for(def a=0; a < ndaysAvailable; a++) {\n          // Figure out next day using the dayDistance map, getting the farthest away day (max value)\n          if(a > 0 && ndaysAvailable >= 2 && a != ndaysAvailable-1) {\n            if(a == 1) {\n                  for(def c=1; c < ndaysAvailable; c++) {\n                    def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                      if(d > max) {\n                          max = d\n                          maxday = daysAvailable[c]\n                    }\n                  }\n                  //log.debug \"max: ${max}  maxday: ${maxday}\"\n                  dDays[0] = maxday\n            }\n\n            // Find successive maxes for the following days\n            if(a > 1) {\n                  def lmax = max\n                  def lmaxday = maxday\n                  max = -1\n                  for(int c = 1; c < ndaysAvailable; c++) {\n                    def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                    def t = d > max\n                    if (a % 2 == 0)    t = d >= max\n                    if(d < lmax && d >= max) {\n                         if(d == max) {\n                              d = dayDistance[lmaxday][daysAvailable[c]]\n                            if(d > dayDistance[lmaxday][maxday]) {\n                                  max = d\n                                  maxday = daysAvailable[c]\n                            }\n                          }\n                          else {\n                            max = d\n                            maxday = daysAvailable[c]\n                          }\n                    }\n                  }\n                  lmax = 5\n                  while(max == -1) {\n                    lmax = lmax -1\n                    for(int c = 1; c < ndaysAvailable; c++) {\n                          def d = dayDistance[daysAvailable[0]][daysAvailable[c]]\n                          if(d < lmax && d >= max) {\n                            if(d == max) {\n                                    d = dayDistance[lmaxday][daysAvailable[c]]\n                                  if(d > dayDistance[lmaxday][maxday]) {\n                                    max = d\n                                    maxday = daysAvailable[c]\n                                  }\n                            }\n                            else {\n                                  max = d\n                                  maxday = daysAvailable[c]\n                            }\n                          }\n                    }\n                    for (def d=0; d< a-2; d++) {\n                          if(maxday == dDays[d]) max = -1\n                      }\n                  }\n                  //log.debug \"max: ${max} maxday: ${maxday}\"\n                  dDays[a-1] = maxday\n            }\n          }\n\n          // Set the runDays map using the calculated maxdays\n          for(int b=0; b < 7; b++) {\n            // Runs every day available\n            if(a == ndaysAvailable-1) {\n                  runDays[a][b] = 0\n                  for (def c=0; c < ndaysAvailable; c++) {\n                    if(b == daysAvailable[c]) runDays[a][b] = 1\n                  }\n            }\n            else {\n                  // runs weekly, use first available day\n                  if(a == 0) {\n                    if(b == daysAvailable[0])\n                          runDays[a][b] = 1\n                    else\n                          runDays[a][b] = 0\n                  }\n                  else {\n                    // Otherwise, start with first available day\n                    if(b == daysAvailable[0])\n                          runDays[a][b] = 1\n                    else {\n                          runDays[a][b] = 0\n                          for(def c=0; c < a; c++)\n                          if(b == dDays[c])\n                            runDays[a][b] = 1\n                    }\n                  }\n            }\n          }\n    }\n\n      //log.debug \"DPW: ${runDays}\"\n    state.DPWDays1 = runDays[0]\n    state.DPWDays2 = runDays[1]\n    state.DPWDays3 = runDays[2]\n    state.DPWDays4 = runDays[3]\n    state.DPWDays5 = runDays[4]\n    state.DPWDays6 = runDays[5]\n    state.DPWDays7 = runDays[6]\n}\n\n//transition page to populate app state - this is a fix for WP param\ndef zoneSetPage1(){\n    state.app = 1\n    zoneSetPage()\n    }\ndef zoneSetPage2(){\n    state.app = 2\n    zoneSetPage()\n    }\ndef zoneSetPage3(){\n    state.app = 3\n    zoneSetPage()\n    }\ndef zoneSetPage4(){\n    state.app = 4\n    zoneSetPage()\n    }\ndef zoneSetPage5(){\n    state.app = 5\n    zoneSetPage()\n    }\ndef zoneSetPage6(){\n    state.app = 6\n    zoneSetPage()\n    }\ndef zoneSetPage7(){\n    state.app = 7\n    zoneSetPage()\n    }\ndef zoneSetPage8(){\n    state.app = 8\n    zoneSetPage()\n    }\ndef zoneSetPage9(i){\n    state.app = 9\n    zoneSetPage()\n    }\ndef zoneSetPage10(){\n    state.app = 10\n    zoneSetPage()\n    }\ndef zoneSetPage11(){\n    state.app = 11\n    zoneSetPage()\n    }\ndef zoneSetPage12(){\n    state.app = 12\n    zoneSetPage()\n    }\ndef zoneSetPage13(){\n    state.app = 13\n    zoneSetPage()\n    }\ndef zoneSetPage14(){\n    state.app = 14\n    zoneSetPage()\n    }\ndef zoneSetPage15(){\n    state.app = 15\n    zoneSetPage()\n    }\ndef zoneSetPage16(){\n    state.app = 16\n    zoneSetPage()\n    }",
        "docstring": "Setup schedules for Spruce irrigation controller"
    },
    {
        "code": "section(\"Or, turn on when one of these contacts opened\"){\n\t\tinput \"contacts\", \"capability.contactSensor\", multiple: true, title: \"Select Contacts\", required: false\n\t}\n\tsection(\"And off after no more triggers after...\"){\n\t\tinput \"minutes1\", \"number\", title: \"Minutes?\", defaultValue: \"5\"\n\t}\n\tsection(\"Turn on/off light(s)...\"){\n\t\tinput \"switches\", \"capability.switch\", multiple: true, title: \"Select Lights\"\n\t}\n}\n\ndef installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n\n\tlog.debug \"state: \" + state.myState\n}\n\ndef initialize() {\n\tsubscribe(switches, \"switch\", switchChange)\n\tsubscribe(motions, \"motion\", motionHandler)\n\tsubscribe(contacts, \"contact\", contactHandler)\n\n\trunEvery1Minute(\"scheduleCheck\")\n\tstate.myState = \"ready\"\n}\n\ndef switchChange(evt) {\n\tlog.debug \"SwitchChange: $evt.name: $evt.value\"\n\n    if(evt.value == \"on\") {\n        // Slight change of Race condition between motion or contact turning the switch on,\n        // versus user turning the switch on. Since we can't pass event parameters :-(, we rely\n        // on the state and hope the best.\n        if(state.myState == \"activating\") {\n            // OK, probably an event from Activating something, and not the switch itself. Go to Active mode.\n            state.myState = \"active\"\n        } else if(state.myState != \"active\") {\n    \t\tstate.myState = \"already on\"\n        }\n    } else {\n    \t// If active and switch is turned of manually, then stop the schedule and go to ready state\n    \tif(state.myState == \"active\" || state.myState == \"activating\") {\n    \t\tunschedule()\n        }\n  \t\tstate.myState = \"ready\"\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"contactHandler: $evt.name: $evt.value\"\n\n    if (evt.value == \"open\") {\n        if(state.myState == \"ready\") {\n            log.debug \"Turning on lights by contact opening\"\n            switches.on()\n            state.inactiveAt = null\n            state.myState = \"activating\"\n        }\n    } else if (evt.value == \"closed\") {\n        if (!state.inactiveAt && state.myState == \"active\" || state.myState == \"activating\") {\n\t\t\t// When contact closes, we reset the timer if not already set\n            setActiveAndSchedule()\n        }\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"motionHandler: $evt.name: $evt.value\"\n\n    if (evt.value == \"active\") {\n        if(state.myState == \"ready\" || state.myState == \"active\" || state.myState == \"activating\" ) {\n            log.debug \"turning on lights\"\n            switches.on()\n            state.inactiveAt = null\n            state.myState = \"activating\"\n        }\n    } else if (evt.value == \"inactive\") {\n        if (!state.inactiveAt && state.myState == \"active\" || state.myState == \"activating\") {\n\t\t\t// When Motion ends, we reset the timer if not already set\n           setActiveAndSchedule()\n        }\n    }\n    log.debug \"state: \" + state.myState\n}\n\ndef setActiveAndSchedule() {\n    unschedule()\n \tstate.myState = \"active\"\n    state.inactiveAt = now()\n\trunEvery1Minute(\"scheduleCheck\")\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check, ts = ${state.inactiveAt}\"\n    if(state.myState != \"already on\") {\n    \tif(state.inactiveAt != null) {\n\t        def elapsed = now() - state.inactiveAt\n            log.debug \"${elapsed / 1000} sec since motion stopped\"\n\t        def threshold = 1000 * 60 * minutes1\n\t        if (elapsed >= threshold) {\n\t            if (state.myState == \"active\") {\n\t                log.debug \"turning off lights\"\n\t                switches.off()\n\t            }\n\t            state.inactiveAt = null\n\t            state.myState = \"ready\"\n\t        }\n    \t}\n    }\n    log.debug \"state: \" + state.myState\n}",
        "docstring": "Turns on a switch for X minutes, then turns it off. Unless, the switch is already on, in which case it stays on. If the switch is toggled while the timer is running, the timer is canceled."
    },
    {
        "code": "section(\"Turn on switch...\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\n\ndef installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\n\ndef accelerationActiveHandler(evt) {\n\t\tswitch1.on()\n\t}",
        "docstring": "Turn on switch when vibration is sensed"
    },
    {
        "code": "def mainPage()\n{\n\tif (canInstallLabs())\n    {\n       \treturn agentDiscovery()\n    }\n    else\n    {\n        def upgradeNeeded = \"\"\"To use SmartThings Labs, your Hub should be completely up to date.\n\nTo update your Hub, access Location Settings in the Main Menu (tap the gear next to your location name), select your Hub, and choose \"Update Hub\".\"\"\"\n\n        return dynamicPage(name:\"mainPage\", title:\"Upgrade needed!\", nextPage:\"\", install:false, uninstall: true) {\n            section(\"Upgrade\")\n            {\n                paragraph \"$upgradeNeeded\"\n            }\n        }\n    }\n}\n\ndef agentDiscovery(params=[:])\n{\n\tint refreshCount = !state.refreshCount ? 0 : state.refreshCount as int\n    state.refreshCount = refreshCount + 1\n    def refreshInterval = refreshCount == 0 ? 2 : 5\n\t\n    if (!state.subscribe)\n    {\n        subscribe(location, null, locationHandler, [filterEvents:false])\n        state.subscribe = true\n    }\n\t\n    //ssdp request every fifth refresh\n    if ((refreshCount % 5) == 0)\n    {\n        discoverAgents()\n    }\n\t\n    def agentsDiscovered = agentsDiscovered()\n    \n    return dynamicPage(name:\"agentDiscovery\", title:\"Pair with Simple Sync\", nextPage:\"\", refreshInterval: refreshInterval, install:true, uninstall: true) {\n        section(\"Pair with Simple Sync\")\n        {\n            input \"selectedAgent\", \"enum\", required:true, title:\"Select Simple Sync\\n(${agentsDiscovered.size() ?: 0} found)\", multiple:false, options:agentsDiscovered\n        \thref(name:\"manualAgentEntry\",\n            \t title:\"Manually Configure Simple Sync\",\n                 required:false,\n                 page:\"manualAgentEntry\")\n        }\n    }\n}\n\ndef manualAgentEntry()\n{\n\tdynamicPage(name:\"manualAgentEntry\", title:\"Manually Configure Simple Sync\", nextPage:\"verifyManualEntry\", install:false, uninstall:true) {\n    \tsection(\"Manually Configure Simple Sync\")\n        {\n        \tparagraph \"In the event that Simple Sync cannot be automatically discovered by your SmartThings hub, you may enter Simple Sync's IP address here.\"\n            input(name: \"manualIPAddress\", type: \"text\", title: \"IP Address\", required: true)\n        }\n    }\n}\n\ndef verifyManualEntry()\n{\n    def hexIP = convertIPToHexString(manualIPAddress)\n    def hexPort = convertToHexString(47147)\n    def uuid = \"593C03D2-1DA9-4CDB-A335-6C6DC98E56C3\"\n    def hubId = \"\"\n    \n    for (hub in location.hubs)\n    {\n    \tif (hub.localIP != null)\n        {\n        \thubId = hub.id\n            break\n        }\n    }\n    \n    def manualAgent = [deviceType: \"04\",\n    \t\t\t\t\tmac: \"unknown\",\n    \t\t\t\t\tip: hexIP,\n                        port: hexPort,\n                        ssdpPath: \"/upnp/Roomie.xml\",\n                        ssdpUSN: \"uuid:$uuid::urn:roomieremote-com:device:roomie:1\",\n                        hub: hubId,\n                        verified: true,\n                        name: \"Simple Sync $manualIPAddress\"]\n\t\n    state.agents[uuid] = manualAgent\n    \n    addOrUpdateAgent(state.agents[uuid])\n    \n    dynamicPage(name: \"verifyManualEntry\", title: \"Manual Configuration Complete\", nextPage: \"\", install:true, uninstall:true) {\n    \tsection(\"\")\n        {\n        \tparagraph(\"Tap Done to complete the installation process.\")\n        }\n    }\n}\n\ndef discoverAgents()\n{\n    def urn = getURN()\n    \n    sendHubCommand(new physicalgraph.device.HubAction(\"lan discovery $urn\", physicalgraph.device.Protocol.LAN))\n}\n\ndef agentsDiscovered()\n{\n    def gAgents = getAgents()\n    def agents = gAgents.findAll { it?.value?.verified == true }\n    def map = [:]\n    agents.each\n    {\n        map[\"${it.value.uuid}\"] = it.value.name\n    }\n    map\n}\n\ndef getAgents()\n{\n    if (!state.agents)\n    {\n    \tstate.agents = [:]\n    }\n    \n    state.agents\n}\n\ndef installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tinitialize()\n}\n\ndef initialize()\n{\n\tif (state.subscribe)\n\t{\n    \tunsubscribe()\n\t\tstate.subscribe = false\n\t}\n    \n    if (selectedAgent)\n    {\n    \taddOrUpdateAgent(state.agents[selectedAgent])\n    }\n}\n\ndef addOrUpdateAgent(agent)\n{\n\tdef children = getChildDevices()\n\tdef dni = agent.ip + \":\" + agent.port\n    def found = false\n\t\n\tchildren.each\n\t{\n\t\tif ((it.getDeviceDataByName(\"mac\") == agent.mac))\n\t\t{\n        \tfound = true\n            \n            if (it.getDeviceNetworkId() != dni)\n            {\n\t\t\t\tit.setDeviceNetworkId(dni)\n\t\t\t}\n\t\t}\n        else if (it.getDeviceNetworkId() == dni)\n        {\n        \tfound = true\n        }\n\t}\n    \n\tif (!found)\n\t{\n        addChildDevice(\"roomieremote-agent\", \"Simple Sync\", dni, agent.hub, [label: \"Simple Sync\"])\n\t}\n}\n\ndef locationHandler(evt)\n{\n    def description = evt?.description\n    def urn = getURN()\n    def hub = evt?.hubId\n    def parsedEvent = parseEventMessage(description)\n    \n    parsedEvent?.putAt(\"hub\", hub)\n    \n    //SSDP DISCOVERY EVENTS\n\tif (parsedEvent?.ssdpTerm?.contains(urn))\n\t{\n        def agent = parsedEvent\n        def ip = convertHexToIP(agent.ip)\n        def agents = getAgents()\n        \n        agent.verified = true\n        agent.name = \"Simple Sync $ip\"\n        \n        if (!agents[agent.uuid])\n        {\n        \tstate.agents[agent.uuid] = agent\n        }\n    }\n}\n\nprivate def parseEventMessage(String description)\n{\n\tdef event = [:]\n\tdef parts = description.split(',')\n    \n\tparts.each\n    { part ->\n\t\tpart = part.trim()\n\t\tif (part.startsWith('devicetype:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tevent.devicetype = valueString\n\t\t}\n\t\telse if (part.startsWith('mac:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.mac = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('networkAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ip = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('deviceAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.port = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpPath:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpPath = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpUSN:'))\n        {\n\t\t\tpart -= \"ssdpUSN:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpUSN = valueString\n                \n                def uuid = getUUIDFromUSN(valueString)\n                \n                if (uuid)\n                {\n                \tevent.uuid = uuid\n                }\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpTerm:'))\n        {\n\t\t\tpart -= \"ssdpTerm:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpTerm = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('headers'))\n        {\n\t\t\tpart -= \"headers:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.headers = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('body'))\n        {\n\t\t\tpart -= \"body:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.body = valueString\n\t\t\t}\n\t\t}\n\t}\n\n\tevent\n}\n\ndef getURN()\n{\n    return \"urn:roomieremote-com:device:roomie:1\"\n}\n\ndef getUUIDFromUSN(usn)\n{\n\tdef parts = usn.split(\":\")\n\t\n\tfor (int i = 0; i < parts.size(); ++i)\n\t{\n\t\tif (parts[i] == \"uuid\")\n\t\t{\n\t\t\treturn parts[i + 1]\n\t\t}\n\t}\n}\n\ndef String convertHexToIP(hex)\n{\n\t[convertHexToInt(hex[0..1]),convertHexToInt(hex[2..3]),convertHexToInt(hex[4..5]),convertHexToInt(hex[6..7])].join(\".\")\n}\n\ndef Integer convertHexToInt(hex)\n{\n\tInteger.parseInt(hex,16)\n}\n\ndef String convertToHexString(n)\n{\n\tString hex = String.format(\"%X\", n.toInteger())\n}\n\ndef String convertIPToHexString(ipString)\n{\n\tString hex = ipString.tokenize(\".\").collect {\n    \tString.format(\"%02X\", it.toInteger())\n    }.join()\n}\n\ndef Boolean canInstallLabs()\n{\n    return hasAllHubsOver(\"000.011.00603\")\n}\n\ndef Boolean hasAllHubsOver(String desiredFirmware)\n{\n    return realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\ndef List getRealHubFirmwareVersions()\n{\n    return location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate SmartThings with your Simple Control activities via Simple Sync."
    },
    {
        "code": "}\n}\n\ndef agentSelection()\n{\n\tif (agent)\n    {\n\t\tstate.refreshCount = 0\n    }\n    \n\tdynamicPage(name: \"agentSelection\", title: \"Select your Simple Sync\", nextPage: \"control\", install: false, uninstall: true) {\n\t\tsection {\n\t\t\tinput \"agent\", \"capability.mediaController\", title: \"Simple Sync\", required: true, multiple: false\n\t\t}\n\t}\n}\n\ndef control()\n{\n\tdef activities = agent.latestValue('activities')\n    \n    if (!activities || !state.refreshCount)\n    {\n\t    int refreshCount = !state.refreshCount ? 0 : state.refreshCount as int\n\t    state.refreshCount = refreshCount + 1\n\t    def refreshInterval = refreshCount == 0 ? 2 : 4\n\t\t\n\t    // Request activities every 5th attempt\n    \tif((refreshCount % 5) == 0)\n        {\n    \t    agent.getAllActivities()\n\t\t}\n        \n        dynamicPage(name: \"control\", title: \"Updating list of Simple Control activities\", nextPage: \"\", refreshInterval: refreshInterval, install: false, uninstall: true) {\n        \tsection(\"\") {\n            \tparagraph \"Retrieving activities from Simple Sync\"\n            }\n        }\n\t}\n\telse\n    {\n\tdynamicPage(name: \"control\", title: \"Run a Simple Control activity when something happens\", nextPage: \"timeIntervalInput\", install: false, uninstall: true) {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"When...\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Detected\", required: false, multiple: true\n\t\t\t\tifSet \"motionInactive\", \"capability.motionSensor\", title: \"Motion Stops\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tsection(anythingSet ? \"Select additional triggers\" : \"When...\", hideable: anythingSet, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"motionInactive\", \"capability.motionSensor\", title: \"Motion Stops\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection(\"Run this activity\"){\n\t        input \"activity\", \"enum\", title: \"Activity?\", required: true, options: new groovy.json.JsonSlurper().parseText(activities ?: \"[]\").activities?.collect { [\"${it.uuid}\": it.name] }\n\t\t}\n        \n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\"\n\t\t}\n\t}\n    }\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"motionInactive\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"button1\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(motionInactive, \"motion.inactive\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\tstartActivity(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartActivity(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\tstartActivity(evt)\n}\n\nprivate startActivity(evt) {\n\tagent.startActivity(activity)\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}",
        "docstring": "Trigger Simple Control activities when certain actions take place in your home."
    },
    {
        "code": "page(name: \"mainPage\", title: \"Simple Control Setup\", content: \"mainPage\", refreshTimeout: 5)\n\tpage(name:\"agentDiscovery\", title:\"Simple Sync Discovery\", content:\"agentDiscovery\", refreshTimeout:5)\n\tpage(name:\"manualAgentEntry\")\n\tpage(name:\"verifyManualEntry\")\n}\n\nmappings {\n\tpath(\"/devices\") {\n    \taction: [\n        \tGET: \"getDevices\"\n        ]\n\t}\n    path(\"/:deviceType/devices\") {\n    \taction: [\n        \tGET: \"getDevices\",\n            POST: \"handleDevicesWithIDs\"\n        ]\n    }\n    path(\"/device/:deviceType/:id\") {\n    \taction: [\n        \tGET: \"getDevice\",\n            POST: \"updateDevice\"\n        ]\n    }\n\tpath(\"/subscriptions\") {\n\t\taction: [\n\t\t\tGET: \"listSubscriptions\",\n\t\t\tPOST: \"addSubscription\", // {\"deviceId\":\"xxx\", \"attributeName\":\"xxx\",\"callbackUrl\":\"http://...\"}\n            DELETE: \"removeAllSubscriptions\"\n\t\t]\n\t}\n\tpath(\"/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removeSubscription\"\n\t\t]\n\t}\n}\n\nprivate getAllDevices()\n{\n\t//log.debug(\"getAllDevices()\")\n\t([] + switches + locks + thermostats + imageCaptures + relaySwitches + doorControls + colorControls + musicPlayers + speechSynthesizers + switchLevels + indicators + mediaControllers + tones + tvs + alarms + valves + motionSensors + presenceSensors + beacons + pushButtons + smokeDetectors + coDetectors + contactSensors + accelerationSensors + energyMeters + powerMeters + lightSensors + humiditySensors + temperatureSensors + speechRecognizers + stepSensors + touchSensors)?.findAll()?.unique { it.id }\n}\n\ndef getDevices()\n{\n\t//log.debug(\"getDevices, params: ${params}\")\n    allDevices.collect {\n    \t//log.debug(\"device: ${it}\")\n\t\tdeviceItem(it)\n\t}\n}\n\ndef getDevice()\n{\n\t//log.debug(\"getDevice, params: ${params}\")\n    def device = allDevices.find { it.id == params.id }\n    if (!device)\n    {\n    \trender status: 404, data: '{\"msg\": \"Device not found\"}'\n    }\n    else\n    {\n    \tdeviceItem(device)\n    }\n}\n\ndef handleDevicesWithIDs()\n{\n\t//log.debug(\"handleDevicesWithIDs, params: ${params}\")\n\tdef data = request.JSON\n\tdef ids = data?.ids?.findAll()?.unique()\n    //log.debug(\"ids: ${ids}\")\n    def command = data?.command\n\tdef arguments = data?.arguments\n\tdef type = params?.deviceType\n    //log.debug(\"device type: ${type}\")\n    if (command)\n    {\n    \tdef statusCode = 404\n\t    //log.debug(\"command ${command}, arguments ${arguments}\")\n    \tfor (devId in ids)\n        {\n\t\t\tdef device = allDevices.find { it.id == devId }\n            //log.debug(\"device: ${device}\")\n\t\t\t// Check if we have a device that responds to the specified command\n\t\t\tif (validateCommand(device, type, command)) {\n            \tif (arguments) {\n\t\t\t\t\tdevice.\"$command\"(*arguments)\n                }\n                else {\n                \tdevice.\"$command\"()\n                }\n\t\t\t\tstatusCode = 200\n\t\t\t} else {\n            \tstatusCode = 403\n\t\t\t}\n\t\t}\n        def responseData = \"{}\"\n        switch (statusCode)\n        {\n        \tcase 403:\n            \tresponseData = '{\"msg\": \"Access denied. This command is not supported by current capability.\"}'\n                break\n\t\t\tcase 404:\n            \tresponseData = '{\"msg\": \"Device not found\"}'\n                break\n        }\n        render status: statusCode, data: responseData\n    }\n    else\n    {\n\t\tids.collect {\n    \t\tdef currentId = it\n    \t\tdef device = allDevices.find { it.id == currentId }\n        \tif (device)\n        \t{\n        \t\tdeviceItem(device)\n    \t    }\n   \t\t}\n\t}\n}\n\nprivate deviceItem(device) {\n\t[\n\t\tid: device.id,\n\t\tlabel: device.displayName,\n\t\tcurrentState: device.currentStates,\n\t\tcapabilities: device.capabilities?.collect {[\n\t\t\tname: it.name\n\t\t]},\n\t\tattributes: device.supportedAttributes?.collect {[\n\t\t\tname: it.name,\n\t\t\tdataType: it.dataType,\n\t\t\tvalues: it.values\n\t\t]},\n\t\tcommands: device.supportedCommands?.collect {[\n\t\t\tname: it.name,\n\t\t\targuments: it.arguments\n\t\t]},\n\t\ttype: [\n\t\t\tname: device.typeName,\n\t\t\tauthor: device.typeAuthor\n\t\t]\n\t]\n}\n\ndef updateDevice()\n{\n\t//log.debug(\"updateDevice, params: ${params}\")\n\tdef data = request.JSON\n\tdef command = data?.command\n\tdef arguments = data?.arguments\n\tdef type = params?.deviceType\n    //log.debug(\"device type: ${type}\")\n\n\t//log.debug(\"updateDevice, params: ${params}, request: ${data}\")\n\tif (!command) {\n\t\trender status: 400, data: '{\"msg\": \"command is required\"}'\n\t} else {\n\t\tdef statusCode = 404\n\t\tdef device = allDevices.find { it.id == params.id }\n\t\tif (device) {\n\t\t\t// Check if we have a device that responds to the specified command\n\t\t\tif (validateCommand(device, type, command)) {\n\t        \tif (arguments) {\n\t\t\t\t\tdevice.\"$command\"(*arguments)\n\t            }\n\t            else {\n\t            \tdevice.\"$command\"()\n\t            }\n\t\t\t\tstatusCode = 200\n\t\t\t} else {\n\t        \tstatusCode = 403\n\t\t\t}\n\t\t}\n\t\t\n\t    def responseData = \"{}\"\n\t    switch (statusCode)\n\t    {\n\t    \tcase 403:\n\t        \tresponseData = '{\"msg\": \"Access denied. This command is not supported by current capability.\"}'\n\t            break\n\t\t\tcase 404:\n\t        \tresponseData = '{\"msg\": \"Device not found\"}'\n\t            break\n\t    }\n\t    render status: statusCode, data: responseData\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\t//log.debug(\"validateCommand ${command}\")\n    def capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n    //log.debug(\"capabilityCommands: ${capabilityCommands}\")\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n    //log.debug(\"currentDeviceCapability: ${currentDeviceCapability}\")\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n        case \"thermostats\":\n        \treturn \"Thermostat\"\n        case \"doorControls\":\n        \treturn \"Door Control\"\n        case \"colorControls\":\n        \treturn \"Color Control\"\n        case \"musicPlayers\":\n        \treturn \"Music Player\"\n        case \"switchLevels\":\n        \treturn \"Switch Level\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\ndef listSubscriptions()\n{\n\t//log.debug \"listSubscriptions()\"\n\tapp.subscriptions?.findAll { it.deviceId }?.collect {\n\t\tdef deviceInfo = state[it.deviceId]\n\t\tdef response = [\n\t\t\tid: it.id,\n\t\t\tdeviceId: it.deviceId,\n\t\t\tattributeName: it.data,\n\t\t\thandler: it.handler\n\t\t]\n\t\t//if (!selectedAgent) {\n\t\t\tresponse.callbackUrl = deviceInfo?.callbackUrl\n\t\t//}\n\t\tresponse\n\t} ?: []\n}\n\ndef addSubscription() {\n\tdef data = request.JSON\n\tdef attribute = data.attributeName\n\tdef callbackUrl = data.callbackUrl\n\n\t//log.debug \"addSubscription, params: ${params}, request: ${data}\"\n\tif (!attribute) {\n\t\trender status: 400, data: '{\"msg\": \"attributeName is required\"}'\n\t} else {\n\t\tdef device = allDevices.find { it.id == data.deviceId }\n\t\tif (device) {\n\t\t\t//if (!selectedAgent) {\n\t\t\t\t//log.debug \"Adding callbackUrl: $callbackUrl\"\n\t\t\t\tstate[device.id] = [callbackUrl: callbackUrl]\n\t\t\t//}\n\t\t\t//log.debug \"Adding subscription\"\n\t\t\tdef subscription = subscribe(device, attribute, deviceHandler)\n\t\t\tif (!subscription || !subscription.eventSubscription) {\n            \t//log.debug(\"subscriptions: ${app.subscriptions}\")\n                //for (sub in app.subscriptions)\n                //{\n                \t//log.debug(\"subscription.id ${sub.id} subscription.handler ${sub.handler} subscription.deviceId ${sub.deviceId}\")\n                    //log.debug(sub.properties.collect{it}.join('\\n'))\n\t\t\t\t//}\n\t\t\t\tsubscription = app.subscriptions?.find { it.device.id == data.deviceId && it.data == attribute && it.handler == 'deviceHandler' }\n\t\t\t}\n\n\t\t\tdef response = [\n\t\t\t\tid: subscription.id,\n\t\t\t\tdeviceId: subscription.device?.id,\n\t\t\t\tattributeName: subscription.data,\n\t\t\t\thandler: subscription.handler\n\t\t\t]\n\t\t\t//if (!selectedAgent) {\n\t\t\t\tresponse.callbackUrl = callbackUrl\n\t\t\t//}\n\t\t\tresponse\n\t\t} else {\n\t\t\trender status: 400, data: '{\"msg\": \"Device not found\"}'\n\t\t}\n\t}\n}\n\ndef removeSubscription()\n{\n\tdef subscription = app.subscriptions?.find { it.id == params.id }\n\tdef device = subscription?.device\n\n\t//log.debug \"removeSubscription, params: ${params}, subscription: ${subscription}, device: ${device}\"\n\tif (device) {\n\t\t//log.debug \"Removing subscription for device: ${device.id}\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\trender status: 204, data: \"{}\"\n}\n\ndef removeAllSubscriptions()\n{\n\tfor (sub in app.subscriptions)\n    {\n    \t//log.debug(\"Subscription: ${sub}\")\n        //log.debug(sub.properties.collect{it}.join('\\n'))\n        def handler = sub.handler\n        def device = sub.device\n        \n    \tif (device && handler == 'deviceHandler')\n        {\n\t        //log.debug(device.properties.collect{it}.join('\\n'))\n        \t//log.debug(\"Removing subscription for device: ${device}\")\n            state.remove(device.id)\n            unsubscribe(device)\n        }\n    }\n}\n\ndef deviceHandler(evt) {\n\tdef deviceInfo = state[evt.deviceId]\n\t//if (selectedAgent) {\n    //\tsendToRoomie(evt, agentCallbackUrl)\n\t//} else if (deviceInfo) {\n    if (deviceInfo)\n    {\n\t\tif (deviceInfo.callbackUrl) {\n\t\t\tsendToRoomie(evt, deviceInfo.callbackUrl)\n\t\t} else {\n\t\t\tlog.warn \"No callbackUrl set for device: ${evt.deviceId}\"\n\t\t}\n\t} else {\n\t\tlog.warn \"No subscribed device found for device: ${evt.deviceId}\"\n\t}\n}\n\ndef sendToRoomie(evt, String callbackUrl) {\n\tdef callback = new URI(callbackUrl)\n\tdef host = callback.port != -1 ? \"${callback.host}:${callback.port}\" : callback.host\n\tdef path = callback.query ? \"${callback.path}?${callback.query}\".toString() : callback.path\n\tsendHubCommand(new physicalgraph.device.HubAction(\n\t\tmethod: \"POST\",\n\t\tpath: path,\n\t\theaders: [\n\t\t\t\"Host\": host,\n\t\t\t\"Content-Type\": \"application/json\"\n\t\t],\n\t\tbody: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]\n\t))\n}\n\ndef mainPage()\n{\n\tif (canInstallLabs())\n    {\n       \treturn agentDiscovery()\n    }\n    else\n    {\n        def upgradeNeeded = \"\"\"To use SmartThings Labs, your Hub should be completely up to date.\n\nTo update your Hub, access Location Settings in the Main Menu (tap the gear next to your location name), select your Hub, and choose \"Update Hub\".\"\"\"\n\n        return dynamicPage(name:\"mainPage\", title:\"Upgrade needed!\", nextPage:\"\", install:false, uninstall: true) {\n            section(\"Upgrade\")\n            {\n                paragraph \"$upgradeNeeded\"\n            }\n        }\n    }\n}\n\ndef agentDiscovery(params=[:])\n{\n\tint refreshCount = !state.refreshCount ? 0 : state.refreshCount as int\n    state.refreshCount = refreshCount + 1\n    def refreshInterval = refreshCount == 0 ? 2 : 5\n\t\n    if (!state.subscribe)\n    {\n        subscribe(location, null, locationHandler, [filterEvents:false])\n        state.subscribe = true\n    }\n\t\n    //ssdp request every fifth refresh\n    if ((refreshCount % 5) == 0)\n    {\n        discoverAgents()\n    }\n\t\n    def agentsDiscovered = agentsDiscovered()\n    \n    return dynamicPage(name:\"agentDiscovery\", title:\"Pair with Simple Sync\", nextPage:\"\", refreshInterval: refreshInterval, install:true, uninstall: true) {\n        section(\"Pair with Simple Sync\")\n        {\n            input \"selectedAgent\", \"enum\", required:false, title:\"Select Simple Sync\\n(${agentsDiscovered.size() ?: 0} found)\", multiple:false, options:agentsDiscovered\n        \thref(name:\"manualAgentEntry\",\n            \t title:\"Manually Configure Simple Sync\",\n                 required:false,\n                 page:\"manualAgentEntry\")\n        }\n        section(\"Allow Simple Control to Monitor and Control These Things...\")\n        {\n\t\t\tinput \"switches\", \"capability.switch\", title: \"Which Switches?\", multiple: true, required: false\n\t\t\tinput \"locks\", \"capability.lock\", title: \"Which Locks?\", multiple: true, required: false\n\t\t\tinput \"thermostats\", \"capability.thermostat\", title: \"Which Thermostats?\", multiple: true, required: false\n\t\t\tinput \"doorControls\", \"capability.doorControl\", title: \"Which Door Controls?\", multiple: true, required: false\n\t\t\tinput \"colorControls\", \"capability.colorControl\", title: \"Which Color Controllers?\", multiple: true, required: false\n\t\t\tinput \"musicPlayers\", \"capability.musicPlayer\", title: \"Which Music Players?\", multiple: true, required: false\n\t\t\tinput \"switchLevels\", \"capability.switchLevel\", title: \"Which Adjustable Switches?\", multiple: true, required: false\n\t  \t}\n    }\n}\n\ndef manualAgentEntry()\n{\n\tdynamicPage(name:\"manualAgentEntry\", title:\"Manually Configure Simple Sync\", nextPage:\"verifyManualEntry\", install:false, uninstall:true) {\n    \tsection(\"Manually Configure Simple Sync\")\n        {\n        \tparagraph \"In the event that Simple Sync cannot be automatically discovered by your SmartThings hub, you may enter Simple Sync's IP address here.\"\n            input(name: \"manualIPAddress\", type: \"text\", title: \"IP Address\", required: true)\n        }\n    }\n}\n\ndef verifyManualEntry()\n{\n    def hexIP = convertIPToHexString(manualIPAddress)\n    def hexPort = convertToHexString(47147)\n    def uuid = \"593C03D2-1DA9-4CDB-A335-6C6DC98E56C3\"\n    def hubId = \"\"\n    \n    for (hub in location.hubs)\n    {\n    \tif (hub.localIP != null)\n        {\n        \thubId = hub.id\n            break\n        }\n    }\n    \n    def manualAgent = [deviceType: \"04\",\n    \t\t\t\t\tmac: \"unknown\",\n    \t\t\t\t\tip: hexIP,\n                        port: hexPort,\n                        ssdpPath: \"/upnp/Roomie.xml\",\n                        ssdpUSN: \"uuid:$uuid::urn:roomieremote-com:device:roomie:1\",\n                        hub: hubId,\n                        verified: true,\n                        name: \"Simple Sync $manualIPAddress\"]\n\t\n    state.agents[uuid] = manualAgent\n    \n    addOrUpdateAgent(state.agents[uuid])\n    \n    dynamicPage(name: \"verifyManualEntry\", title: \"Manual Configuration Complete\", nextPage: \"\", install:true, uninstall:true) {\n    \tsection(\"\")\n        {\n        \tparagraph(\"Tap Done to complete the installation process.\")\n        }\n    }\n}\n\ndef discoverAgents()\n{\n    def urn = getURN()\n    \n    sendHubCommand(new physicalgraph.device.HubAction(\"lan discovery $urn\", physicalgraph.device.Protocol.LAN))\n}\n\ndef agentsDiscovered()\n{\n    def gAgents = getAgents()\n    def agents = gAgents.findAll { it?.value?.verified == true }\n    def map = [:]\n    agents.each\n    {\n        map[\"${it.value.uuid}\"] = it.value.name\n    }\n    map\n}\n\ndef getAgents()\n{\n    if (!state.agents)\n    {\n    \tstate.agents = [:]\n    }\n    \n    state.agents\n}\n\ndef installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tinitialize()\n}\n\ndef initialize()\n{\n\tif (state.subscribe)\n\t{\n    \tunsubscribe()\n\t\tstate.subscribe = false\n\t}\n    \n    if (selectedAgent)\n    {\n    \taddOrUpdateAgent(state.agents[selectedAgent])\n    }\n}\n\ndef addOrUpdateAgent(agent)\n{\n\tdef children = getChildDevices()\n\tdef dni = agent.ip + \":\" + agent.port\n    def found = false\n\t\n\tchildren.each\n\t{\n\t\tif ((it.getDeviceDataByName(\"mac\") == agent.mac))\n\t\t{\n        \tfound = true\n            \n            if (it.getDeviceNetworkId() != dni)\n            {\n\t\t\t\tit.setDeviceNetworkId(dni)\n\t\t\t}\n\t\t}\n        else if (it.getDeviceNetworkId() == dni)\n        {\n        \tfound = true\n        }\n\t}\n    \n\tif (!found)\n\t{\n        addChildDevice(\"roomieremote-agent\", \"Simple Sync\", dni, agent.hub, [label: \"Simple Sync\"])\n\t}\n}\n\ndef locationHandler(evt)\n{\n    def description = evt?.description\n    def urn = getURN()\n    def hub = evt?.hubId\n    def parsedEvent = parseEventMessage(description)\n    \n    parsedEvent?.putAt(\"hub\", hub)\n    \n    //SSDP DISCOVERY EVENTS\n\tif (parsedEvent?.ssdpTerm?.contains(urn))\n\t{\n        def agent = parsedEvent\n        def ip = convertHexToIP(agent.ip)\n        def agents = getAgents()\n        \n        agent.verified = true\n        agent.name = \"Simple Sync $ip\"\n        \n        if (!agents[agent.uuid])\n        {\n        \tstate.agents[agent.uuid] = agent\n        }\n    }\n}\n\nprivate def parseEventMessage(String description)\n{\n\tdef event = [:]\n\tdef parts = description.split(',')\n    \n\tparts.each\n    { part ->\n\t\tpart = part.trim()\n\t\tif (part.startsWith('devicetype:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tevent.devicetype = valueString\n\t\t}\n\t\telse if (part.startsWith('mac:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.mac = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('networkAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ip = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('deviceAddress:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.port = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpPath:'))\n        {\n\t\t\tdef valueString = part.split(\":\")[1].trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpPath = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpUSN:'))\n        {\n\t\t\tpart -= \"ssdpUSN:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpUSN = valueString\n                \n                def uuid = getUUIDFromUSN(valueString)\n                \n                if (uuid)\n                {\n                \tevent.uuid = uuid\n                }\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('ssdpTerm:'))\n        {\n\t\t\tpart -= \"ssdpTerm:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.ssdpTerm = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('headers'))\n        {\n\t\t\tpart -= \"headers:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.headers = valueString\n\t\t\t}\n\t\t}\n\t\telse if (part.startsWith('body'))\n        {\n\t\t\tpart -= \"body:\"\n\t\t\tdef valueString = part.trim()\n\t\t\tif (valueString)\n            {\n\t\t\t\tevent.body = valueString\n\t\t\t}\n\t\t}\n\t}\n\n\tevent\n}\n\ndef getURN()\n{\n    return \"urn:roomieremote-com:device:roomie:1\"\n}\n\ndef getUUIDFromUSN(usn)\n{\n\tdef parts = usn.split(\":\")\n\t\n\tfor (int i = 0; i < parts.size(); ++i)\n\t{\n\t\tif (parts[i] == \"uuid\")\n\t\t{\n\t\t\treturn parts[i + 1]\n\t\t}\n\t}\n}\n\ndef String convertHexToIP(hex)\n{\n\t[convertHexToInt(hex[0..1]),convertHexToInt(hex[2..3]),convertHexToInt(hex[4..5]),convertHexToInt(hex[6..7])].join(\".\")\n}\n\ndef Integer convertHexToInt(hex)\n{\n\tInteger.parseInt(hex,16)\n}\n\ndef String convertToHexString(n)\n{\n\tString hex = String.format(\"%X\", n.toInteger())\n}\n\ndef String convertIPToHexString(ipString)\n{\n\tString hex = ipString.tokenize(\".\").collect {\n    \tString.format(\"%02X\", it.toInteger())\n    }.join()\n}\n\ndef Boolean canInstallLabs()\n{\n    return hasAllHubsOver(\"000.011.00603\")\n}\n\ndef Boolean hasAllHubsOver(String desiredFirmware)\n{\n    return realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\ndef List getRealHubFirmwareVersions()\n{\n    return location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Integrate SmartThings with your Simple Control activities."
    },
    {
        "code": "section(\"At Havdalah Change Mode To:\")\n    {\n        input \"endMode\", \"mode\", title: \"Mode?\"\n    }\n    section(\"Havdalah Offset (Usually 50 or 72)\") {\n        input \"havdalahOffset\", \"number\", title: \"Minutes After Sundown\", required:true\n    }\n    section(\"Your ZipCode\") {\n        input \"zipcode\", \"text\", title: \"ZipCode\", required:true\n    }\n    section( \"Notifications\" ) {\n        input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n        input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n    }\n    /**/\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    poll();\n    schedule(\"0 0 8 1/1 * ? *\", poll)\n}\n\n//Check hebcal for today's candle lighting or havdalah\ndef poll()\n{\n\n    unschedule(\"endChag\")\n    unschedule(\"setChag\")\n    Hebcal_WebRequest()\n\n}//END def poll()\n\n\n\n/**********************************************\n// HEBCAL FUNCTIONS\n-----------------------------------------------*/\n\n//This function is the web request and response parse\ndef Hebcal_WebRequest(){\n\ndef today = new Date().format(\"yyyy-MM-dd\")\n//def today = \"2014-11-14\"\ndef zip = settings.zip as String\ndef locale = getTwcLocation(zipCode).location\ndef timezone = TimeZone.getTimeZone(locale.ianaTimeZone)\ndef hebcal_date\ndef hebcal_category\ndef hebcal_title\ndef candlelighting\ndef candlelightingLocalTime\ndef havdalah\ndef havdalahLocalTime\ndef pushMessage\ndef testmessage\ndef urlRequest = \"http://www.hebcal.com/hebcal/?v=1&cfg=json&nh=off&nx=off&year=now&month=now&mf=off&c=on&zip=${zipcode}&m=${havdalahOffset}&s=off&D=off&d=off&o=off&ss=off\"\nlog.trace \"${urlRequest}\"\n\ndef hebcal = { response ->\n    hebcal_date = response.data.items.date\n    hebcal_category = response.data.items.category\n    hebcal_title = response.data.items.title\n\n    for (int i = 0; i < hebcal_date.size; i++)\n    {\n        if(hebcal_date[i].split(\"T\")[0]==today)\n        {\n            if(hebcal_category[i]==\"candles\")\n            {\n                candlelightingLocalTime = HebCal_GetTime12(hebcal_title[i])\n                pushMessage = \"Candle Lighting is at ${candlelightingLocalTime}\"\n                candlelightingLocalTime = HebCal_GetTime24(hebcal_date[i])\n                candlelighting = timeToday(candlelightingLocalTime, timezone)\n\n                sendMessage(pushMessage)\n                schedule(candlelighting, setChag)\n                log.debug pushMessage\n            }//END if(hebcal_category==\"candles\")\n\n            else if(hebcal_category[i]==\"havdalah\")\n            {\n                havdalahLocalTime = HebCal_GetTime12(hebcal_title[i])\n                pushMessage = \"Havdalah is at ${havdalahLocalTime}\"\n                havdalahLocalTime = HebCal_GetTime24(hebcal_date[i])\n                havdalah = timeToday(havdalahLocalTime, timezone)\n                testmessage = \"Scheduling for ${havdalah}\"\n                schedule(havdalah, endChag)\n                log.debug pushMessage\n                log.debug testmessage\n            }//END if(hebcal_category==\"havdalah\"){\n        }//END if(hebcal_date[i].split(\"T\")[0]==today)\n\n    }//END for (int i = 0; i < hebcal_date.size; i++)\n }//END def hebcal = { response ->\nhttpGet(urlRequest, hebcal);\n}//END def queryHebcal()\n\n\n//This function gets candle lighting time\ndef HebCal_GetTime12(hebcal_title){\ndef returnTime = hebcal_title.split(\":\")[1] + \":\" + hebcal_title.split(\":\")[2] + \" \"\nreturn returnTime\n}//END def HebCal_GetTime12()\n\n//This function gets candle lighting time\ndef HebCal_GetTime24(hebcal_date){\ndef returnTime = hebcal_date.split(\"T\")[1]\nreturnTime = returnTime.split(\"-\")[0]\nreturn returnTime\n}//END def HebCal_GetTime12()\n\n/*-----------------------------------------------\n END OF HEBCAL FUNCTIONS\n-----------------------------------------------*/\ndef setChag()\n{\n\n    if (location.mode != startMode)\n    {\n        if (location.modes?.find{it.name == startMode})\n        {\n            setLocationMode(startMode)\n            //sendMessage(\"Changed the mode to '${startMode}'\")\n            def dayofweek = new Date().format(\"EEE\")\n            if(dayofweek=='Fri'){\n                sendMessage(\"Shabbat Shalom!\")\n            }\n            else{\n                sendMessage(\"Chag Sameach!\")\n            }\n\n        }//END if (location.modes?.find{it.name == startMode})\n        else\n        {\n            sendMessage(\"Tried to change to undefined mode '${startMode}'\")\n        }//END else\n    }//END if (location.mode != newMode)\n\n    unschedule(\"setChag\")\n}//END def setChag()\n\n\ndef endChag()\n{\n\n    if (location.mode != endMode)\n    {\n        if (location.modes?.find{it.name == endMode})\n        {\n            setLocationMode(endMode)\n            sendMessage(\"Changed the mode to '${endMode}'\")\n        }//END if (location.modes?.find{it.name == endMode})\n        else\n        {\n            sendMessage(\"Tried to change to undefined mode '${endMode}'\")\n        }//END else\n    }//END if (location.mode != endMode)\n\n    //sendMessage(\"Shavuah Tov!\")\n    unschedule(\"endChag\")\n}//END def setChag()\n\ndef sendMessage(msg){\nif ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        //sendPush( msg )\n    }\n\n    if ( phone ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone, msg )\n    }\n}//END def sendMessage(msg)",
        "docstring": "Changes the mode at candle lighting and back after havdalah.  Uses the HebCal.com API to look for days that are shabbat or chag and pull real time candle lighting and havdalah times to change modes automatically"
    },
    {
        "code": "section(\"When the humidity rises above:\") {\n\t\tinput \"humidityHigh\", \"number\", title: \"Percentage ?\"\n\t}\n    section(\"When the humidity drops below:\") {\n\t\tinput \"humidityLow\", \"number\", title: \"Percentage ?\"\n\t}\n    section(\"Control Humidifier:\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n    section( \"Notifications\" ) {\n        input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n        input \"phone1\", \"phone\", title: \"Send a Text Message?\", required: false\n    }\n}\n\ndef installed() {\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(humiditySensor1, \"humidity\", humidityHandler)\n}\n\ndef humidityHandler(evt) {\n\tlog.trace \"humidity: $evt.value\"\n    log.trace \"set high point: $humidityHigh\"\n    log.trace \"set low point: $humidityLow\"\n\n\tdef currentHumidity = Double.parseDouble(evt.value.replace(\"%\", \"\"))\n\tdef humidityHigh1 = humidityHigh \n    def humidityLow1 = humidityLow \n\tdef mySwitch = settings.switch1\n\n\tif (currentHumidity >= humidityHigh1) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting >= $humidityHigh1\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 \n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms1 = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) >= humidityHigh1 } > 1\n\n\t\tif (alreadySentSms1) {\n\t\t\tlog.debug \"Notification already sent within the last $deltaMinutes minutes\"\n\n\t\t} else {\n         \tif (state.lastStatus != \"off\") {\n                log.debug \"Humidity Rose Above $humidityHigh1:  sending SMS and deactivating $mySwitch\"\n                send(\"${humiditySensor1.label} sensed high humidity level of ${evt.value}, turning off ${switch1.label}\")\n                switch1?.off()\n                state.lastStatus = \"off\"\n            }\n\t\t}\n\t}\n    else if (currentHumidity <= humidityLow1) {\n\t\tlog.debug \"Checking how long the humidity sensor has been reporting <= $humidityLow1\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 \n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = humiditySensor1.eventsSince(timeAgo)\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms2 = recentEvents.count { Double.parseDouble(it.value.replace(\"%\", \"\")) <= humidityLow1 } > 1\n\n\t\tif (alreadySentSms2) {\n\t\t\tlog.debug \"Notification already sent within the last $deltaMinutes minutes\"\n\n\t\t} else {\n        \tif (state.lastStatus != \"on\") {\n                log.debug \"Humidity Dropped Below $humidityLow1:  sending SMS and activating $mySwitch\"\n                send(\"${humiditySensor1.label} sensed low humidity level of ${evt.value}, turning on ${switch1.label}\")\n                switch1?.on()\n                state.lastStatus = \"on\"\n            }\n\t\t}\n\t}\n    else {\n    \t//log.debug \"Humidity remained in threshold:  sending SMS to $phone1 and activating $mySwitch\"\n\t\t//send(\"${humiditySensor1.label} sensed humidity level of ${evt.value} is within threshold, keeping on ${switch1.label}\")\n    \t//switch1?.on()\n    }\n}\n\nprivate send(msg) {\n    if ( sendPushMessage != \"No\" ) {\n        log.debug( \"sending push message\" )\n        sendPush( msg )\n    }\n\n    if ( phone1 ) {\n        log.debug( \"sending text message\" )\n        sendSms( phone1, msg )\n    }\n\n    log.debug msg\n}",
        "docstring": "Turn on/off humidifier based on relative humidity from a sensor."
    },
    {
        "code": "section(\"For Whom?\") {\n\t\tinput \"presenceOne\", \"capability.presenceSensor\", title: \"Select Person\", required: true, multiple: true\n\t}\n    section(\"On which Days?\") {\n\t\tinput \"dayOne\", \"enum\", title:\"Select Days\", required: true, multiple:true, metadata: [values: ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']]\n\t}\n\tsection(\"At what time?\") {\n\t\tinput name: \"timeOne\", title: \"Select Time\", type: \"time\", required: true\n\t}\n\tsection(\"For how long?\") {\n\t\tinput name: \"timeTwo\", title: \"Number of minutes\", type: \"number\", required: true\n\t}\n}\n\ndef installed() {\n\tif (timeOne)\n\t{\n\t\tlog.debug \"scheduling 'Smart turn it on' to run at $timeOne\"\n\t\tschedule(timeOne, \"turnOn\")\n\t}\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tif (timeOne)\n\t{\n\t\tlog.debug \"scheduling 'Smart turn it on' to run at $timeOne\"\n\t\tschedule(timeOne, \"turnOn\")\n\t}\n}\n\ndef turnOn(){\nlog.debug \"Start\"\n\tdef dayCheck = dayOne.contains(new Date().format(\"EEE\"))\n    def dayTwo = new Date().format(\"EEE\");\n\tif(dayCheck){\n        def presenceTwo = presenceOne.latestValue(\"presence\").contains(\"present\")\n\t\tif (presenceTwo) {\n        \tswitchOne.on()\n\t\t\tdef delay = timeTwo * 60\n\t\t\trunIn(delay, \"turnOff\")\n\t\t}   \n    }\n}\n\n\n    \ndef turnOff() {\n\tswitchOne.off()\n}",
        "docstring": "Turns on selected device(s) at a set time on selected days of the week only if a selected person is present and turns off selected device(s) after a set time."
    },
    {
        "code": "section(\"Enter User Code Number (This is not the code used to unlock the door)\") {\n    \tinput \"distressCode\", \"number\", defaultValue: \"0\"\n    }\n    section(\"Distress Message Details\") {\n    \tinput \"phone1\", \"phone\", title: \"Phone number to send message to\"\n    \tinput \"distressMsg\", \"text\", title: \"Message to send\"\n    }\n    section(\"User Code Discovery Mode (Enable and unlock the door using desired code. A message will be sent containing the user code used to unlock the door.)\") {\n    \tinput \"discoveryMode\", \"bool\", title: \"Enable\"\n    }\n}\n\ndef installed() {\n    subscribe(lock1, \"lock\", checkCode)\n}\n\ndef updated() {\n\tunsubscribe()\n    subscribe(lock1, \"lock\", checkCode)\n}\n\ndef checkCode(evt) {\n    log.debug \"$evt.value: $evt, $settings\"\n\n    if(evt.value == \"unlocked\" && evt.data) {\n    \tdef lockData = new JsonSlurper().parseText(evt.data)\n        \n        if(discoveryMode) {\n        \tsendPush \"Door unlocked with user code $lockData.usedCode\"\n        }\n        \n        if(lockData.usedCode == distressCode && discoveryMode == false) {\n        \tlog.info \"Distress Message Sent\"\n        \tsendSms(phone1, distressMsg)\n        }\n    }\n}",
        "docstring": "Sends a text to someone when a specific code is entered"
    },
    {
        "code": "section(\"Select the door contact sensor:\") {\n    \tinput \"contact1\", \"capability.contactSensor\", required: true\n    }\n\tsection(\"Automatically lock the door when closed...\") {\n        input \"minutesLater\", \"number\", title: \"Delay (in minutes):\", required: true\n    }\n    section(\"Automatically unlock the door when open...\") {\n        input \"secondsLater\", \"number\", title: \"Delay (in seconds):\", required: true\n    }\n\tsection( \"Push notification?\" ) {\n\t\tinput \"sendPushMessage\", \"enum\", title: \"Send push notification?\", metadata:[values:[\"Yes\", \"No\"]], required: false\n   \t}\n    section( \"Text message?\" ) {\n    \tinput \"sendText\", \"enum\", title: \"Send text message notification?\", metadata:[values:[\"Yes\", \"No\"]], required: false\n       \tinput \"phoneNumber\", \"phone\", title: \"Enter phone number:\", required: false\n   \t}\n}\n\ndef installed()\n{\n    initialize()\n}\n\ndef updated()\n{\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize()\n{\n    log.debug \"Settings: ${settings}\"\n    subscribe(lock1, \"lock\", doorHandler, [filterEvents: false])\n    subscribe(lock1, \"unlock\", doorHandler, [filterEvents: false])  \n    subscribe(contact1, \"contact.open\", doorHandler)\n\tsubscribe(contact1, \"contact.closed\", doorHandler)\n}\n\ndef lockDoor()\n{\n\tif (lock1.latestValue(\"lock\") == \"unlocked\")\n    \t{\n    \tlog.debug \"Locking $lock1...\"\n    \tlock1.lock()\n        log.debug (\"Sending Push Notification...\") \n    \tif (sendPushMessage != \"No\") sendPush(\"$lock1 locked after $contact1 was closed for $minutesLater minute(s)!\")\n    \tlog.debug(\"Sending text message...\")\n\t\tif ((sendText == \"Yes\") && (phoneNumber != \"0\")) sendSms(phoneNumber, \"$lock1 locked after $contact1 was closed for $minutesLater minute(s)!\")\n        }\n\telse if (lock1.latestValue(\"lock\") == \"locked\")\n    \t{\n        log.debug \"$lock1 was already locked...\"\n        }\n}\n\ndef unlockDoor()\n{\n\tif (lock1.latestValue(\"lock\") == \"locked\")\n    \t{\n    \tlog.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        log.debug (\"Sending Push Notification...\") \n    \tif (sendPushMessage != \"No\") sendPush(\"$lock1 unlocked after $contact1 was open for $secondsLater seconds(s)!\")\n    \tlog.debug(\"Sending text message...\")\n\t\tif ((sendText == \"Yes\") && (phoneNumber != \"0\")) sendSms(phoneNumber, \"$lock1 unlocked after $contact1 was open for $secondsLater seconds(s)!\")        \n        }\n\telse if (lock1.latestValue(\"lock\") == \"unlocked\")\n    \t{\n        log.debug \"$lock1 was already unlocked...\"\n        }\n}\n\ndef doorHandler(evt)\n{\n    if ((contact1.latestValue(\"contact\") == \"open\") && (evt.value == \"locked\"))\n    \t{\n        def delay = secondsLater\n        runIn (delay, unlockDoor)\n    \t}\n    else if ((contact1.latestValue(\"contact\") == \"open\") && (evt.value == \"unlocked\"))\n    \t{\n        unschedule (unlockDoor)\n\t\t}\n    else if ((contact1.latestValue(\"contact\") == \"closed\") && (evt.value == \"locked\"))\n    \t{\n        unschedule (lockDoor)\n    \t}   \n    else if ((contact1.latestValue(\"contact\") == \"closed\") && (evt.value == \"unlocked\"))\n    \t{\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        def delay = (minutesLater * 60)\n        runIn (delay, lockDoor)\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"open\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"unlocked\") && (evt.value == \"closed\"))\n    \t{\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n        def delay = (minutesLater * 60)\n        runIn (delay, lockDoor)\n    \t}\n\telse if ((lock1.latestValue(\"lock\") == \"locked\") && (evt.value == \"open\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else if ((lock1.latestValue(\"lock\") == \"locked\") && (evt.value == \"closed\"))\n    \t{\n        unschedule (lockDoor)\n        log.debug \"Unlocking $lock1...\"\n    \tlock1.unlock()\n    \t}\n    else\n    \t{\n        log.debug \"Problem with $lock1, the lock might be jammed!\"\n        unschedule (lockDoor)\n        unschedule (unlockDoor)\n    \t}\n}",
        "docstring": "Automatically locks door X minutes after being closed and keeps door unlocked if door is open."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\", install: true, uninstall: true) {\n\n\t\tsection(\"Where do you want to watch?\") {\n\t\t\tinput name: \"beacons\", type: \"capability.beacon\", title: \"Select your beacon(s)\", \n\t\t\t\tmultiple: true, required: true\n\t\t}\n\n\t\tsection(\"Who do you want to watch for?\") {\n\t\t\tinput name: \"phones\", type: \"device.mobilePresence\", title: \"Select your phone(s)\", \n\t\t\t\tmultiple: true, required: true\n\t\t}\n\n\t\tsection(\"What do you want to do on arrival?\") {\n\t\t\tinput name: \"arrivalPhrase\", type: \"enum\", title: \"Execute a phrase\", \n\t\t\t\toptions: listPhrases(), required: false\n\t\t\tinput \"arrivalOnSwitches\", \"capability.switch\", title: \"Turn on some switches\", \n\t\t\t\tmultiple: true, required: false\n\t\t\tinput \"arrivalOffSwitches\", \"capability.switch\", title: \"Turn off some switches\", \n\t\t\t\tmultiple: true, required: false\n\t\t\tinput \"arrivalLocks\", \"capability.lock\", title: \"Unlock the door\",\n\t\t\t\tmultiple: true, required: false\n\t\t}\n\n\t\tsection(\"What do you want to do on departure?\") {\n\t\t\tinput name: \"departPhrase\", type: \"enum\", title: \"Execute a phrase\", \n\t\t\t\toptions: listPhrases(), required: false\n\t\t\tinput \"departOnSwitches\", \"capability.switch\", title: \"Turn on some switches\", \n\t\t\t\tmultiple: true, required: false\n\t\t\tinput \"departOffSwitches\", \"capability.switch\", title: \"Turn off some switches\", \n\t\t\t\tmultiple: true, required: false\n\t\t\tinput \"departLocks\", \"capability.lock\", title: \"Lock the door\",\n\t\t\t\tmultiple: true, required: false\n\t\t}\n\n\t\tsection(\"Do you want to be notified?\") {\n\t\t\tinput \"pushNotification\", \"bool\", title: \"Send a push notification\"\n\t\t\tinput \"phone\", \"phone\", title: \"Send a text message\", description: \"Tap to enter phone number\", \n\t\t\t\trequired: false\n\t\t}\n\n\t\tsection {\n\t\t\tlabel title: \"Give your automation a name\", description: \"e.g. Goodnight Home, Wake Up\"\n\t\t}\n\n\t\tdef timeLabel = timeIntervalLabel()\n\t\tsection(title: \"More options\", hidden: hideOptionsSection(), hideable: true) {\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", \n\t\t\t\tdescription: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\n\t\t\tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n\t\t}\n\t}\n}\n\n// Lifecycle management\ndef installed() {\n\tlog.debug \"<beacon-control> Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"<beacon-control> Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(beacons, \"presence\", beaconHandler)\n}\n\n// Event handlers\ndef beaconHandler(evt) {\n\tlog.debug \"<beacon-control> beaconHandler: $evt\"\n\n\tif (allOk) {\n\t\tdef data = new groovy.json.JsonSlurper().parseText(evt.data)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> data: $data - phones: \" + phones*.deviceNetworkId\n\n\t\tdef beaconName = getBeaconName(evt)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> beaconName: $beaconName\"\n\n\t\tdef phoneName = getPhoneName(data)\n                // removed logging of device names. can be added back for debugging\n\t\t//log.debug \"<beacon-control> phoneName: $phoneName\"\n\t\tif (phoneName != null) {\n            def action = data.presence == \"1\" ? \"arrived\" : \"left\"\n            def msg = \"$phoneName has $action ${action == 'arrived' ? 'at ' : ''}the $beaconName\"\n\n            if (action == \"arrived\") {\n                msg = arriveActions(msg)\n            }\n            else if (action == \"left\") {\n                msg = departActions(msg)\n            }\n            log.debug \"<beacon-control> msg: $msg\"\n\n            if (pushNotification || phone) {\n                def options = [\n                    method: (pushNotification && phone) ? \"both\" : (pushNotification ? \"push\" : \"sms\"),\n                    phone: phone\n                ]\n                sendNotification(msg, options)\n            }\n        }\n\t}\n}\n\n// Helpers\nprivate arriveActions(msg) {\n\tif (arrivalPhrase || arrivalOnSwitches || arrivalOffSwitches || arrivalLocks) msg += \", so\"\n\t\n\tif (arrivalPhrase) {\n\t\tlog.debug \"<beacon-control> executing: $arrivalPhrase\"\n\t\texecutePhrase(arrivalPhrase)\n\t\tmsg += \" ${prefix('executed')} $arrivalPhrase.\"\n\t}\n\tif (arrivalOnSwitches) {\n\t\tlog.debug \"<beacon-control> turning on: $arrivalOnSwitches\"\n\t\tarrivalOnSwitches.on()\n\t\tmsg += \" ${prefix('turned')} ${list(arrivalOnSwitches)} on.\"\n\t}\n\tif (arrivalOffSwitches) {\n\t\tlog.debug \"<beacon-control> turning off: $arrivalOffSwitches\"\n\t\tarrivalOffSwitches.off()\n\t\tmsg += \" ${prefix('turned')} ${list(arrivalOffSwitches)} off.\"\n\t}\n\tif (arrivalLocks) {\n\t\tlog.debug \"<beacon-control> unlocking: $arrivalLocks\"\n\t\tarrivalLocks.unlock()\n\t\tmsg += \" ${prefix('unlocked')} ${list(arrivalLocks)}.\"\n\t}\n\tmsg\n}\n\nprivate departActions(msg) {\n\tif (departPhrase || departOnSwitches || departOffSwitches || departLocks) msg += \", so\"\n\t\n\tif (departPhrase) {\n\t\tlog.debug \"<beacon-control> executing: $departPhrase\"\n\t\texecutePhrase(departPhrase)\n\t\tmsg += \" ${prefix('executed')} $departPhrase.\"\n\t}\n\tif (departOnSwitches) {\n\t\tlog.debug \"<beacon-control> turning on: $departOnSwitches\"\n\t\tdepartOnSwitches.on()\n\t\tmsg += \" ${prefix('turned')} ${list(departOnSwitches)} on.\"\n\t}\n\tif (departOffSwitches) {\n\t\tlog.debug \"<beacon-control> turning off: $departOffSwitches\"\n\t\tdepartOffSwitches.off()\n\t\tmsg += \" ${prefix('turned')} ${list(departOffSwitches)} off.\"\n\t}\n\tif (departLocks) {\n\t\tlog.debug \"<beacon-control> unlocking: $departLocks\"\n\t\tdepartLocks.lock()\n\t\tmsg += \" ${prefix('locked')} ${list(departLocks)}.\"\n\t}\n\tmsg\n}\n\nprivate prefix(word) {\n\tdef result\n\tdef index = settings.prefixIndex == null ? 0 : settings.prefixIndex + 1\n\tswitch (index) {\n\t\tcase 0:\n\t\t\tresult = \"I $word\"\n\t\t\tbreak\n\t\tcase 1:\n\t\t\tresult = \"I also $word\"\n\t\t\tbreak\n\t\tcase 2:\n\t\t\tresult = \"And I $word\"\n\t\t\tbreak\n\t\tdefault:\n\t\t\tresult = \"And $word\"\n\t\t\tbreak\n\t}\n\n\tsettings.prefixIndex = index\n\tlog.trace \"prefix($word'): $result\"\n\tresult\n}\n\nprivate listPhrases() {\n\tlocation.helloHome.getPhrases().label\n}\n\nprivate executePhrase(phraseName) {\n\tif (phraseName) {\n\t\tlocation.helloHome.execute(phraseName)\n\t\tlog.debug \"<beacon-control> executed phrase: $phraseName\"\n\t}\n}\n\nprivate getBeaconName(evt) {\n\tdef beaconName = beacons.find { b -> b.id == evt.deviceId }\n\treturn beaconName\n}\n\nprivate getPhoneName(data) {    \n\tdef phoneName = phones.find { phone ->\n\t\t// Work around DNI bug in data\n\t\tdef pParts = phone.deviceNetworkId.split('\\\\|')\n\t\tdef dParts = data.dni.split('\\\\|')\n        pParts[0] == dParts[0]\n\t}\n\treturn phoneName\n}\n\nprivate hideOptionsSection() {\n\t(starting || ending || days || modes) ? false : true\n}\n\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"<beacon-control> modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"<beacon-control> daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"<beacon-control> timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\") {\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel() {\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n\nprivate list(List names) {\n\tswitch (names.size()) {\n\t\tcase 0:\n\t\t\treturn null\n\t\tcase 1:\n\t\t\treturn names[0]\n\t\tcase 2:\n\t\t\treturn \"${names[0]} and ${names[1]}\"\n\t\tdefault:\n\t\t\treturn \"${names[0..-2].join(', ')}, and ${names[-1]}\"\n\t}\n}",
        "docstring": "Execute a Hello, Home phrase, turn on or off some lights, and/or lock or unlock your door when you enter or leave a monitored region"
    },
    {
        "code": "}\n\ndef installed()\n{\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef changedLocationMode(evt) {\n\tlog.debug \"changedLocationMode: $evt\"\n\tswitches?.off()\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt\"\n\tswitches?.off()\n}",
        "docstring": "Turn your lights off when the SmartApp is tapped or activated"
    },
    {
        "code": "}\n\ndef installed()\n{\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef changedLocationMode(evt) {\n\tlog.debug \"changedLocationMode: $evt\"\n\tswitches?.on()\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt\"\n\tswitches?.on()\n}",
        "docstring": "Turn your lights on when the SmartApp is tapped or activated."
    },
    {
        "code": "section(\"Change to this mode\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n\tsection(\"False alarm threshold (defaults to 10 min)\") {\n\t\tinput \"falseAlarmThreshold\", \"decimal\", title: \"Number of minutes\", required: false\n\t}\n\tsection( \"Notifications\" ) {\n\t\tinput(\"recipients\", \"contact\", title: \"Send notifications to\", required: false) {\n\t\t\tinput \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n\t\t\tinput \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n\t\t}\n\t}\n\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n        // commented out log statement because presence sensor label could contain user's name\n\t//log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n        // commented out log statement because presence sensor label could contain user's name\n\t//log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tif (evt.value == \"not present\") {\n\t\tif (location.mode != newMode) {\n\t\t\tlog.debug \"checking if everyone is away\"\n\t\t\tif (everyoneIsAway()) {\n\t\t\t\tlog.debug \"starting sequence\"\n\t\t\t\trunIn(findFalseAlarmThreshold() * 60, \"takeAction\", [overwrite: false])\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"mode is the same, not evaluating\"\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"present; doing nothing\"\n\t}\n}\n\ndef takeAction()\n{\n\tif (everyoneIsAway()) {\n\t\tdef threshold = 1000 * 60 * findFalseAlarmThreshold() - 1000\n\t\tdef awayLongEnough = people.findAll { person ->\n\t\t\tdef presenceState = person.currentState(\"presence\")\n\t\t\tif (!presenceState) {\n\t\t\t\t// This device has yet to check in and has no presence state, treat it as not away long enough\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdef elapsed = now() - presenceState.rawDateCreated.time\n\t\t\telapsed >= threshold\n\t\t}\n\t\tlog.debug \"Found ${awayLongEnough.size()} out of ${people.size()} person(s) who were away long enough\"\n\t\tif (awayLongEnough.size() == people.size()) {\n\t\t\t// TODO -- uncomment when app label is available\n\t\t\tdef message = \"SmartThings changed your mode to '${newMode}' because everyone left home\"\n\t\t\tlog.info message\n\t\t\tsend(message)\n\t\t\tsetLocationMode(newMode)\n\t\t} else {\n\t\t\tlog.debug \"not everyone has been away long enough; doing nothing\"\n\t\t}\n\t} else {\n    \tlog.debug \"not everyone is away; doing nothing\"\n    }\n}\n\nprivate everyoneIsAway()\n{\n\tdef result = true\n\tfor (person in people) {\n\t\tif (person.currentPresence == \"present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"everyoneIsAway: $result\"\n\treturn result\n}\n\nprivate send(msg) {\n\tif (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse  {\n\t\tif (sendPushMessage != \"No\") {\n\t\t\tlog.debug(\"sending push message\")\n\t\t\tsendPush(msg)\n\t\t}\n\n\t\tif (phone) {\n\t\t\tlog.debug(\"sending text message\")\n\t\t\tsendSms(phone, msg)\n\t\t}\n\t}\n\tlog.debug msg\n}\n\nprivate findFalseAlarmThreshold() {\n\t(falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold : 10\n}",
        "docstring": "Monitors a set of SmartSense Presence tags or smartphones and triggers a mode change when everyone has left.  Used in conjunction with Big Turn Off or Make It So to turn off lights, appliances, adjust the thermostat, turn on security apps, and more."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"When...\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tsection(anythingSet ? \"Select additional triggers\" : \"When...\", hideable: anythingSet, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection(\"Perform this action\"){\n\t\t\tinput \"actionType\", \"enum\", title: \"Action?\", required: true, defaultValue: \"play\", options: [\n\t\t\t\t\"Turn On & Play\",\n\t\t\t\t\"Turn Off\",\n\t\t\t\t\"Toggle Play/Pause\",\n\t\t\t\t\"Skip to Next Track\",\n\t\t\t\t\"Skip to Beginning/Previous Track\",\n                \"Play Preset 1\",\n                \"Play Preset 2\",\n                \"Play Preset 3\",\n                \"Play Preset 4\",\n                \"Play Preset 5\",\n                \"Play Preset 6\"\n\t\t\t]\n\t\t}\n\t\tsection {\n\t\t\tinput \"bose\", \"capability.musicPlayer\", title: \"Bose® SoundTouch® music player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"volume\", \"number\", title: \"Set the volume volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\"\n\t\t}\n\t}\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\tlog.debug \"takeAction($actionType)\"\n\tdef options = [:]\n\tif (volume) {\n\t\tbose.setLevel(volume as Integer)\n\t\toptions.delay = 1000\n\t}\n\n\tswitch (actionType) {\n\t\tcase \"Turn On & Play\":\n\t\t\toptions ? bose.on(options) : bose.on()\n\t\t\tbreak\n\t\tcase \"Turn Off\":\n\t\t\toptions ? bose.off(options) : bose.off()\n\t\t\tbreak\n\t\tcase \"Toggle Play/Pause\":\n\t\t\tdef currentStatus = bose.currentValue(\"playpause\")\n\t\t\tif (currentStatus == \"play\") {\n\t\t\t\toptions ? bose.pause(options) : bose.pause()\n\t\t\t}\n\t\t\telse if (currentStatus == \"pause\") {\n\t\t\t\toptions ? bose.play(options) : bose.play()\n\t\t\t}\n\t\t\tbreak\n\t\tcase \"Skip to Next Track\":\n\t\t\toptions ? bose.nextTrack(options) : bose.nextTrack()\n\t\t\tbreak\n\t\tcase \"Skip to Beginning/Previous Track\":\n\t\t\toptions ? bose.previousTrack(options) : bose.previousTrack()\n\t\t\tbreak\n        case \"Play Preset 1\":\n\t\t\toptions ? bose.preset1(options) : bose.preset1()\n\t\t\tbreak\n        case \"Play Preset 2\":\n\t\t\toptions ? bose.preset2(options) : bose.preset2()\n\t\t\tbreak \n        case \"Play Preset 3\":\n\t\t\toptions ? bose.preset3(options) : bose.preset3()\n\t\t\tbreak\n        case \"Play Preset 4\":\n\t\t\toptions ? bose.preset4(options) : bose.preset4()\n\t\t\tbreak\n        case \"Play Preset 5\":\n\t\t\toptions ? bose.preset5(options) : bose.preset5()\n\t\t\tbreak\n        case \"Play Preset 6\":\n\t\t\toptions ? bose.preset6(options) : bose.preset6()\n\t\t\tbreak\n\t\tdefault:\n\t\t\tlog.error \"Action type '$actionType' not defined\"\n\t}\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Control your Bose® SoundTouch® when certain actions take place in your home."
    },
    {
        "code": "section(\"And it's dark...\") {\n\t\tinput \"luminance1\", \"capability.illuminanceMeasurement\", title: \"Where?\"\n\t}\n\tsection(\"Turn on a light...\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tdef lightSensorState = luminance1.currentIlluminance\n\tlog.debug \"SENSOR = $lightSensorState\"\n\tif (lightSensorState != null && lightSensorState < 10) {\n\t\tlog.trace \"light.on() ... [luminance: ${lightSensorState}]\"\n\t\tswitch1.on()\n\t}\n}",
        "docstring": "Turn your lights on when a open/close sensor opens and the space is dark."
    },
    {
        "code": "section(\"Turn on a light...\") {\n\t\tinput \"switch1\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef motionActiveHandler(evt) {\n\tswitch1.on()\n}",
        "docstring": "Turn your lights on when motion is detected."
    },
    {
        "code": "page(name: \"timeIntervalInput\", title: \"Only during a certain time\") {\n\t\tsection {\n\t\t\tinput \"starting\", \"time\", title: \"Starting\", required: false\n\t\t\tinput \"ending\", \"time\", title: \"Ending\", required: false\n\t\t}\n\t}\n}\n\ndef selectButton() {\n\tdynamicPage(name: \"selectButton\", title: \"First, select your button device\", nextPage: \"configureButton1\", uninstall: configured()) {\n\t\tsection {\n\t\t\tinput \"buttonDevice\", \"capability.button\", title: \"Button\", multiple: false, required: true\n\t\t}\n\n\t\tsection(title: \"More options\", hidden: hideOptionsSection(), hideable: true) {\n\n\t\t\tdef timeLabel = timeIntervalLabel()\n\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : null\n\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\n\t\t\tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n\t\t}\n\n\t\tsection([title: \" \", mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t}\n\t}\n}\n\ndef createPage(pageNum) {\n\tif ((state.numButton == pageNum) || (pageNum == 8))\n\t\tstate.installCondition = true\n\tdynamicPage(name: \"configureButton$pageNum\", title: \"Set up button $pageNum here\",\n\t\t\tnextPage: \"configureButton${pageNum+1}\", install: state.installCondition, uninstall: configured(), getButtonSections(pageNum))\n}\n\ndef configureButton1() {\n\tstate.numButton = buttonDevice.currentState(\"numberOfButtons\")?.longValue ?: 4\n\tlog.debug \"state variable numButton: ${state.numButton}\"\n\tstate.installCondition = false\n\tcreatePage(1)\n}\ndef configureButton2() {\n\tcreatePage(2)\n}\n\ndef configureButton3() {\n\tcreatePage(3)\n}\n\ndef configureButton4() {\n\tcreatePage(4)\n}\n\ndef configureButton5() {\n\tcreatePage(5)\n}\n\ndef configureButton6() {\n\tcreatePage(6)\n}\n\ndef configureButton7() {\n\tcreatePage(7)\n}\n\ndef configureButton8() {\n\tcreatePage(8)\n}\n\ndef getButtonSections(buttonNumber) {\n\treturn {\n\t\tsection(\"Lights\") {\n\t\t\tinput \"lights_${buttonNumber}_pushed\", \"capability.switch\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"lights_${buttonNumber}_held\", \"capability.switch\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Locks\") {\n\t\t\tinput \"locks_${buttonNumber}_pushed\", \"capability.lock\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"locks_${buttonNumber}_held\", \"capability.lock\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Sonos\") {\n\t\t\tinput \"sonos_${buttonNumber}_pushed\", \"capability.musicPlayer\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"sonos_${buttonNumber}_held\", \"capability.musicPlayer\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Modes\") {\n\t\t\tinput \"mode_${buttonNumber}_pushed\", \"mode\", title: \"Pushed\", required: false\n\t\t\tinput \"mode_${buttonNumber}_held\", \"mode\", title: \"Held\", required: false\n\t\t}\n\t\tdef phrases = location.helloHome?.getPhrases()*.label\n\t\tif (phrases) {\n\t\t\tsection(\"Hello Home Actions\") {\n\t\t\t\tlog.trace phrases\n\t\t\t\tinput \"phrase_${buttonNumber}_pushed\", \"enum\", title: \"Pushed\", required: false, options: phrases\n\t\t\t\tinput \"phrase_${buttonNumber}_held\", \"enum\", title: \"Held\", required: false, options: phrases\n\t\t\t}\n\t\t}\n        section(\"Sirens\") {\n            input \"sirens_${buttonNumber}_pushed\",\"capability.alarm\" ,title: \"Pushed\", multiple: true, required: false\n            input \"sirens_${buttonNumber}_held\", \"capability.alarm\", title: \"Held\", multiple: true, required: false\n        }\n\n\t\tsection(\"Custom Message\") {\n\t\t\tinput \"textMessage_${buttonNumber}\", \"text\", title: \"Message\", required: false\n\t\t}\n\n        section(\"Push Notifications\") {\n            input \"notifications_${buttonNumber}_pushed\",\"bool\" ,title: \"Pushed\", required: false, defaultValue: false\n            input \"notifications_${buttonNumber}_held\", \"bool\", title: \"Held\", required: false, defaultValue: false\n        }\n\n        section(\"Sms Notifications\") {\n            input \"phone_${buttonNumber}_pushed\",\"phone\" ,title: \"Pushed\", required: false\n            input \"phone_${buttonNumber}_held\", \"phone\", title: \"Held\", required: false\n        }\n\t}\n}\n\ndef installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef configured() {\n\treturn buttonDevice || buttonConfigured(1) || buttonConfigured(2) || buttonConfigured(3) || buttonConfigured(4)\n}\n\ndef buttonConfigured(idx) {\n\treturn settings[\"lights_$idx_pushed\"] ||\n\t\tsettings[\"locks_$idx_pushed\"] ||\n\t\tsettings[\"sonos_$idx_pushed\"] ||\n\t\tsettings[\"mode_$idx_pushed\"] ||\n        settings[\"notifications_$idx_pushed\"] ||\n        settings[\"sirens_$idx_pushed\"] ||\n        settings[\"notifications_$idx_pushed\"]   ||\n        settings[\"phone_$idx_pushed\"]\n}\n\ndef buttonEvent(evt){\n\tif(allOk) {\n\t\tdef buttonNumber = evt.data // why doesn't jsonData work? always returning [:]\n\t\tdef value = evt.value\n\t\tlog.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\t\tlog.debug \"button: $buttonNumber, value: $value\"\n\n\t\tdef recentEvents = buttonDevice.eventsSince(new Date(now() - 3000)).findAll{it.value == evt.value && it.data == evt.data}\n\t\tlog.debug \"Found ${recentEvents.size()?:0} events in past 3 seconds\"\n\n\t\tif(recentEvents.size <= 1){\n\t\t\tswitch(buttonNumber) {\n\t\t\t\tcase ~/.*1.*/:\n\t\t\t\t\texecuteHandlers(1, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*2.*/:\n\t\t\t\t\texecuteHandlers(2, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*3.*/:\n\t\t\t\t\texecuteHandlers(3, value)\n\t\t\t\t\tbreak\n\t\t\t\tcase ~/.*4.*/:\n\t\t\t\t\texecuteHandlers(4, value)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Found recent button press events for $buttonNumber with value $value\"\n\t\t}\n\t}\n}\n\ndef executeHandlers(buttonNumber, value) {\n\tlog.debug \"executeHandlers: $buttonNumber - $value\"\n\n\tdef lights = find('lights', buttonNumber, value)\n\tif (lights != null) toggle(lights)\n\n\tdef locks = find('locks', buttonNumber, value)\n\tif (locks != null) toggle(locks)\n\n\tdef sonos = find('sonos', buttonNumber, value)\n\tif (sonos != null) toggle(sonos)\n\n\tdef mode = find('mode', buttonNumber, value)\n\tif (mode != null) changeMode(mode)\n\n\tdef phrase = find('phrase', buttonNumber, value)\n\tif (phrase != null) location.helloHome.execute(phrase)\n\n\tdef textMessage = findMsg('textMessage', buttonNumber)\n\n\tdef notifications = find('notifications', buttonNumber, value)\n\tif (notifications?.toBoolean()) sendPush(textMessage ?: \"Button $buttonNumber was pressed\" )\n\n\tdef phone = find('phone', buttonNumber, value)\n\tif (phone != null) sendSms(phone, textMessage ?:\"Button $buttonNumber was pressed\")\n\n    def sirens = find('sirens', buttonNumber, value)\n    if (sirens != null) toggle(sirens)\n}\n\ndef find(type, buttonNumber, value) {\n\tdef preferenceName = type + \"_\" + buttonNumber + \"_\" + value\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef findMsg(type, buttonNumber) {\n\tdef preferenceName = type + \"_\" + buttonNumber\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef toggle(devices) {\n\tlog.debug \"toggle: $devices = ${devices*.currentValue('switch')}\"\n\n\tif (devices*.currentValue('switch').contains('on')) {\n\t\tdevices.off()\n\t}\n\telse if (devices*.currentValue('switch').contains('off')) {\n\t\tdevices.on()\n\t}\n\telse if (devices*.currentValue('lock').contains('locked')) {\n\t\tdevices.unlock()\n\t}\n\telse if (devices*.currentValue('lock').contains('unlocked')) {\n\t\tdevices.lock()\n\t}\n\telse if (devices*.currentValue('alarm').contains('off')) {\n        devices.siren()\n    }\n\telse {\n\t\tdevices.on()\n\t}\n}\n\ndef changeMode(mode) {\n\tlog.debug \"changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes\"\n\n\tif (location.mode != mode && location.modes?.find { it.name == mode }) {\n\t\tsetLocationMode(mode)\n\t}\n}\n\n// execution filter methods\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location.timeZone).time\n\t\tdef stop = timeToday(ending, location.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate hideOptionsSection() {\n\t(starting || ending || days || modes) ? false : true\n}\n\nprivate timeIntervalLabel() {\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}",
        "docstring": "Control devices with buttons like the Aeon Labs Minimote"
    },
    {
        "code": "section(\"Turn the Camera On at...\"){\n\t\tinput \"startTime\", \"time\", title: \"Start Time\", required:false\n\t}\n\tsection(\"Turn the Camera Off at...\"){\n\t\tinput \"endTime\", \"time\", title: \"End Time\", required:false\n\t}    \n}\n\ndef installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n    /*\n\tdef tz = location.timeZone\n    \n    //if it's after the startTime but before the end time, turn it on\n    if(startTime && timeToday(startTime,tz).time > timeToday(now,tz).time){\n    \n      if(endTime && timeToday(endTime,tz).time < timeToday(now,tz).time){\n        switch1.on()\n      }\n      else{\n        switch1.off()\n      }\n    }\n    else if(endTime && timeToday(endtime,tz).time > timeToday(now,tz).time)\n    {\n      switch1.off()\n    }\n    */\n    \n    if(startTime)\n      runDaily(startTime, turnOnCamera)\n    if(endTime)\n      runDaily(endTime,turnOffCamera)\n}\n\ndef turnOnCamera()\n{\n  log.info \"turned on camera\"\n  switch1.on()\n}\n\ndef turnOffCamera()\n{\n  log.info \"turned off camera\"\n  switch1.off()\n}",
        "docstring": "Turn the power on and off at a specific time."
    },
    {
        "code": "section(\"Turn off camera power...\"){\n\t\tinput \"switches1\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tlog.debug \"Current people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tlog.debug \"Current people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tif (evt.value == \"not present\") {\n\t\t\n        log.debug \"checking if everyone is away\"\n        if (everyoneIsAway()) {\n            log.debug \"starting on Sequence\"\n\n            runIn(60*2, \"turnOn\") //two minute delay after everyone has left\n        }\n\t}\n\telse {\n    \tif (!everyoneIsAway()) {\n          turnOff()\n        }\n\t}\n}\n\ndef turnOff()\n{\n    log.debug \"canceling On requests\"\n    unschedule(\"turnOn\")\n    \n    log.info \"turning off the camera\"\n    switches1.off()\n}\n\ndef turnOn()\n{\n\n\tlog.info \"turned on the camera\"\n    switches1.on()\n\n\tunschedule(\"turnOn\") // Temporary work-around to scheduling bug\n}\n\nprivate everyoneIsAway()\n{\n\tdef result = true\n\tfor (person in people) {\n\t\tif (person.currentPresence == \"present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"everyoneIsAway: $result\"\n\treturn result\n}",
        "docstring": "Turn cameras on when I'm away"
    },
    {
        "code": "input(name: \"message\", type: \"text\", required: false, multiple: false, title: \"With the message:\", description: \"Your ride is here!\")\n\t\tinput(name: \"rider\", type: \"capability.presenceSensor\", required: true, multiple: false, title: \"But only when this person is not with you\", description: \"Who are you picking up?\")\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(driver, \"presence.present\", presence)\n}\n\ndef presence(evt) {\n\n\tif (evt.value == \"present\" && riderIsHome())\n\t{\n//        \tlog.debug \"Rider Is Home; Send A Text\"\n\t\tsendText()\n\t}\n\n}\n\ndef riderIsHome() {\n\n//\tlog.debug \"rider presence: ${rider.currentPresence}\"\n\n\tif (rider.currentPresence != \"present\")\n\t{\n\t\treturn false\n\t}\n\n\tdef riderState = rider.currentState(\"presence\")\n//\tlog.debug \"riderState: ${riderState}\"\n\tif (!riderState)\n\t{\n\t\treturn true\n\t}\n\n\tdef latestState = rider.latestState(\"presence\")\n\n\tdef now = new Date()\n\tdef minusFive = new Date(minutes: now.minutes - 5)\n\n\n\tif (minusFive > latestState.date)\n\t{\n\t\treturn true\n\t}\n\n\treturn false\n}\n\ndef sendText() {\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(message ?: \"Your ride is here!\", recipients)\n\t}\n\telse {\n\t\tsendSms(phoneNumber, message ?: \"Your ride is here!\")\n\t}\n}",
        "docstring": "Send notifications to your carpooling buddies when you arrive to pick them up. If the person you are picking up is home, and has been for 5 minutes or more, they will get a notification when you arrive."
    },
    {
        "code": "section(\"Close the valve...\") {\n\t\tinput \"valve\", \"capability.valve\", title: \"Which?\", required: true, multiple: false\n\t}\n\tsection(\"Send this message (optional, sends standard status message if not specified)\"){\n\t\tinput \"messageText\", \"text\", title: \"Message Text\", required: false\n\t}\n\tsection(\"Via a push notification and/or an SMS message\"){\n\t\tinput \"phone\", \"phone\", title: \"Phone Number (for SMS, optional)\", required: false\n\t\tinput \"pushAndPhone\", \"enum\", title: \"Both Push and SMS?\", required: false, options: [\"Yes\",\"No\"]\n\t}\n\tsection(\"Minimum time between messages (optional)\") {\n\t\tinput \"frequency\", \"decimal\", title: \"Minutes\", required: false\n\t}    \n}\n\ndef installed() {\n \tsubscribe(sensor, \"water\", waterHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n \tsubscribe(sensor, \"water\", waterHandler)\n}\n\ndef waterHandler(evt) {\n\tlog.debug \"Sensor says ${evt.value}\"\n\tif (evt.value == \"wet\") {\n\t\tvalve.close()\n\t}\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}    \n}\n\nprivate sendMessage(evt) {\n\tdef msg = messageText ?: \"We closed the valve because moisture was detected\"\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (!phone || pushAndPhone != \"No\") {\n\t\tlog.debug \"sending push\"\n\t\tsendPush(msg)\n\t}\n\tif (phone) {\n\t\tlog.debug \"sending SMS\"\n\t\tsendSms(phone, msg)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}",
        "docstring": "Close a selected valve if moisture is detected, and get notified by SMS and push notification."
    },
    {
        "code": "section(\"Turn on these outlet(s)\") {\n\t\tinput name: \"outlets\", title: \"Which?\", type: \"capability.switch\", multiple: true\n\t}\n\tsection(\"For this amount of time\") {\n\t\tinput name: \"minutes\", title: \"Minutes?\", type: \"number\", multiple: false\n\t}\n}\n\ndef installed() {\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(motionSensors, \"motion.active\", motionActive)\n\tsubscribe(motionSensors, \"motion.inactive\", motionInactive)\n\tsubscribe(presenceSensors, \"presence.not present\", notPresent)\n}\n\ndef motionActive(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (anyHere()) {\n\t\toutletsOn()\n\t}\n}\n\ndef motionInactive(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (allQuiet()) {\n\t\toutletsOff()\n\t}\n}\n\ndef notPresent(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (!anyHere()) {\n\t\toutletsOff()\n\t}\n}\n\ndef allQuiet() {\n\tdef result = true\n\tfor (it in motionSensors) {\n\t\tif (it.currentMotion == \"active\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}\n\ndef anyHere() {\n\tdef result = true\n\tfor (it in presenceSensors) {\n\t\tif (it.currentPresence == \"not present\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}\n\ndef outletsOn() {\n\toutlets.on()\n\tunschedule(\"scheduledTurnOff\")\n}\n\ndef outletsOff() {\n\tdef delay = minutes * 60\n\trunIn(delay, \"scheduledTurnOff\")\n}\n\ndef scheduledTurnOff() {\n\toutlets.off()\n\tunschedule(\"scheduledTurnOff\") // Temporary work-around to scheduling bug\n}",
        "docstring": "Turns on an outlet when the user is present and off after a period of time"
    },
    {
        "code": "section(\"Turn off a light...\") {\n\t\tinput \"switch1\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(motion1, \"motion.inactive\", motionInactiveHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.inactive\", motionInactiveHandler)\n}\n\ndef motionInactiveHandler(evt) {\n\tswitch1.off()\n}",
        "docstring": "Turn your lights off after a period of no motion being observed."
    },
    {
        "code": "section(\"Turn on or off all of these switches as well\") {\n\t\tinput \"switches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"And turn off but not on all of these switches\") {\n\t\tinput \"offSwitches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"And turn on but not off all of these switches\") {\n\t\tinput \"onSwitches\", \"capability.switch\", multiple: true, required: false\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(master, \"switch\", switchHandler, [filterEvents: false])\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(master, \"switch\", switchHandler, [filterEvents: false])\n}\n\ndef switchHandler(evt) {\n\tlog.info evt.value\n\n\t// use Event rather than DeviceState because we may be changing DeviceState to only store changed values\n\tdef recentStates = master.eventsSince(new Date(now() - 4000), [all:true, max: 10]).findAll{it.name == \"switch\"}\n\tlog.debug \"${recentStates?.size()} STATES FOUND, LAST AT ${recentStates ? recentStates[0].dateCreated : ''}\"\n\n\tif (evt.physical) {\n\t\tif (evt.value == \"on\" && lastTwoStatesWere(\"on\", recentStates, evt)) {\n\t\t\tlog.debug \"detected two taps, turn on other light(s)\"\n\t\t\tonSwitches()*.on()\n\t\t} else if (evt.value == \"off\" && lastTwoStatesWere(\"off\", recentStates, evt)) {\n\t\t\tlog.debug \"detected two taps, turn off other light(s)\"\n\t\t\toffSwitches()*.off()\n\t\t}\n\t}\n\telse {\n\t\tlog.trace \"Skipping digital on/off event\"\n\t}\n}\n\nprivate onSwitches() {\n\t(switches + onSwitches).findAll{it}\n}\n\nprivate offSwitches() {\n\t(switches + offSwitches).findAll{it}\n}\n\nprivate lastTwoStatesWere(value, states, evt) {\n\tdef result = false\n\tif (states) {\n\n\t\tlog.trace \"unfiltered: [${states.collect{it.dateCreated + ':' + it.value}.join(', ')}]\"\n\t\tdef onOff = states.findAll { it.physical || !it.type }\n\t\tlog.trace \"filtered:   [${onOff.collect{it.dateCreated + ':' + it.value}.join(', ')}]\"\n\n\t\t// This test was needed before the change to use Event rather than DeviceState. It should never pass now.\n\t\tif (onOff[0].date.before(evt.date)) {\n\t\t\tlog.warn \"Last state does not reflect current event, evt.date: ${evt.dateCreated}, state.date: ${onOff[0].dateCreated}\"\n\t\t\tresult = evt.value == value && onOff[0].value == value\n\t\t}\n\t\telse {\n\t\t\tresult = onOff.size() > 1 && onOff[0].value == value && onOff[1].value == value\n\t\t}\n\t}\n\tresult\n}",
        "docstring": "Turn on or off any number of switches when an existing switch is tapped twice in a row."
    },
    {
        "code": "section(\"Turn on a pump...\") {\n\t\tinput \"pump\", \"capability.switch\", title: \"Which?\", required: true\n\t}\n}\n\ndef installed() {\n\tsubscribe(sensor, \"water.dry\", waterHandler)\n\tsubscribe(sensor, \"water.wet\", waterHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(sensor, \"water.dry\", waterHandler)\n\tsubscribe(sensor, \"water.wet\", waterHandler)\n}\n\ndef waterHandler(evt) {\n\tlog.debug \"Sensor says ${evt.value}\"\n\tif (evt.value == \"wet\") {\n\t\tpump.on()\n\t} else if (evt.value == \"dry\") {\n\t\tpump.off()\n\t}\n}",
        "docstring": "Turns switch on and off based on moisture sensor input."
    },
    {
        "code": "section(\"If there's no movement (optional, leave blank to not require)...\") {\n\t\tinput \"motion1\", \"capability.motionSensor\", title: \"Where?\", required: false\n\t}\n\tsection(\"or a door or cabinet hasn't been opened (optional, leave blank to not require)...\") {\n\t\tinput \"contact1\", \"capability.contactSensor\", required: false\n\t}\n\tsection(\"between these times...\") {\n\t\tinput \"time0\", \"time\", title: \"From what time?\"\n\t\tinput \"time1\", \"time\", title: \"Until what time?\"\n\t}\n\tsection(\"then alert the following people...\") {\n\t\tinput(\"recipients\", \"contact\", title: \"People to notify\", description: \"Send notifications to\") {\n\t\t\tinput \"phone1\", \"phone\", title: \"Phone number?\", required: false\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tif(noRecentContact() && noRecentMotion()) {\n\t\tdef person = person1 ?: \"your elder\"\n\t\tdef msg = \"Alert! There has been no activity at ${person}'s place ${timePhrase}\"\n\t\tlog.debug msg\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tif (phone1) {\n\t\t\t\tsendSms(phone1, msg)\n\t\t\t} else {\n\t\t\t\tsendPush(msg)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"There has been activity ${timePhrase}, not sending alert\"\n\t}\n}\n\nprivate noRecentMotion()\n{\n\tif(motion1) {\n\t\tdef motionEvents = motion1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} motion events\"\n\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"There have been recent 'active' events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent 'active' events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate noRecentContact()\n{\n\tif(contact1) {\n\t\tdef contactEvents = contact1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${contactEvents?.size() ?: 0} door events\"\n\t\tif (contactEvents.find { it.value == \"open\" }) {\n\t\t\tlog.debug \"There have been recent 'open' events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent 'open' events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Contact sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate getSinceTime() {\n\tif (time0) {\n\t\treturn timeToday(time0, location?.timeZone)\n\t}\n\telse {\n\t\treturn new Date(now() - 21600000)\n\t}\n}\n\nprivate getTimePhrase() {\n\tdef interval = now() - sinceTime.time\n\tif (interval < 3600000) {\n\t\treturn \"in the past ${Math.round(interval/60000)} minutes\"\n\t}\n\telse if (interval < 7200000) {\n\t\treturn \"in the past hour\"\n\t}\n\telse {\n\t\treturn \"in the past ${Math.round(interval/3600000)} hours\"\n\t}\n}",
        "docstring": "Stay connected to your loved ones. Get notified if they are not up and moving around by a specified time and/or if they have not opened a cabinet or door according to a set schedule."
    },
    {
        "code": "section(\"Bathroom motion detector\") {\n\t\tinput \"bathroomMotion\", \"capability.motionSensor\"\n\t}\n    section(\"Active between these times\") {\n    \tinput \"startTime\", \"time\", title: \"Start Time\"\n        input \"stopTime\", \"time\", title: \"Stop Time\"\n    }\n    section(\"Send message when no return within specified time period\") {\n    \tinput \"warnMessage\", \"text\", title: \"Warning Message\"\n        input \"threshold\", \"number\", title: \"Minutes\"\n    }\n    section(\"To these contacts\") {\n\t\tinput(\"recipients\", \"contact\", title: \"Recipients\", description: \"Send notifications to\") {\n\t\t\tinput \"phone1\", \"phone\", required: false\n\t\t\tinput \"phone2\", \"phone\", required: false\n\t\t\tinput \"phone3\", \"phone\", required: false\n\t\t}\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.active = 0\n\tsubscribe(bedroomMotion, \"motion.active\", bedroomActive)\n    subscribe(bathroomMotion, \"motion.active\", bathroomActive)\n}\n\ndef bedroomActive(evt) {\n\tdef start = timeToday(startTime, location?.timeZone)\n    def stop = timeToday(stopTime, location?.timeZone)\n    def now = new Date()\n    log.debug \"bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now\"\n    if (state.status == \"waiting\") {\n    \tlog.debug \"motion detected in bedroom, disarming\"\n    \tunschedule(\"sendMessage\")\n        state.status = null\n    }\n    else {\n        if (start.before(now) && stop.after(now)) {\n            log.debug \"motion in bedroom, look for bathroom motion\"\n            state.status = \"pending\"\n        }\n        else {\n            log.debug \"Not in time window\"\n        }\n    }\n}\n\ndef bathroomActive(evt) {\n\tlog.debug \"bathroomActive, status: $state.status\"\n\tif (state.status == \"pending\") {\n    \tdef delay = threshold.toInteger() * 60\n    \tstate.status = \"waiting\"\n        log.debug \"runIn($delay)\"\n        runIn(delay, sendMessage)\n    }\n}\n\ndef sendMessage() {\n\tlog.debug \"sendMessage\"\n\tdef msg = warnMessage\n    log.info msg\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse {\n\t\tsendPush msg\n\t\tif (phone1) {\n\t\t\tsendSms phone1, msg\n\t\t}\n\t\tif (phone2) {\n\t\t\tsendSms phone2, msg\n\t\t}\n\t\tif (phone3) {\n\t\t\tsendSms phone3, msg\n\t\t}\n\t}\n    state.status = null\n}",
        "docstring": "Monitors motion sensors in bedroom and bathroom during the night and detects if occupant does not return from the bathroom after a specified period of time."
    },
    {
        "code": "}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(meter, \"power\", meterHandler)\n}\n\ndef meterHandler(evt) {\n\n    def meterValue = evt.value as double\n\n    if (!atomicState.lastValue) {\n    \tatomicState.lastValue = meterValue\n    }\n\n    def lastValue = atomicState.lastValue as double\n    atomicState.lastValue = meterValue\n\n    def dUnit = evt.unit ?: \"Watts\"\n\n    def aboveThresholdValue = aboveThreshold as int\n    if (meterValue > aboveThresholdValue) {\n    \tif (lastValue < aboveThresholdValue) { // only send notifications when crossing the threshold\n\t\t    def msg = \"${meter} reported ${evt.value} ${dUnit} which is above your threshold of ${aboveThreshold}.\"\n    \t    sendMessage(msg)\n        } else {\n//        \tlog.debug \"not sending notification for ${evt.description} because the threshold (${aboveThreshold}) has already been crossed\"\n        }\n    }\n\n\n    def belowThresholdValue = belowThreshold as int\n    if (meterValue < belowThresholdValue) {\n    \tif (lastValue > belowThresholdValue) { // only send notifications when crossing the threshold\n\t\t    def msg = \"${meter} reported ${evt.value} ${dUnit} which is below your threshold of ${belowThreshold}.\"\n    \t    sendMessage(msg)\n        } else {\n//        \tlog.debug \"not sending notification for ${evt.description} because the threshold (${belowThreshold}) has already been crossed\"\n        }\n    }\n}\n\ndef sendMessage(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sms) {\n            sendSms(sms, msg)\n        }\n        if (pushNotification) {\n            sendPush(msg)\n        }\n    }\n}",
        "docstring": "Get notified if you're using too much energy"
    },
    {
        "code": "\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(meter, \"power\", meterHandler)\n}\n\ndef meterHandler(evt) {\n    def meterValue = evt.value as double\n    def thresholdValue = threshold as int\n    if (meterValue > thresholdValue) {\n\t    log.debug \"${meter} reported energy consumption above ${threshold}. Turning of switches.\"\n    \tswitches.off()\n    }\n}",
        "docstring": "Turn things off if you're using too much energy"
    },
    {
        "code": "section {\n            href(page: \"flattenedPage\", title: \"All of the above elements on a single page\")\n        }\n    }\n}\n\ndef inputPage() {\n    dynamicPage(name: \"inputPage\", title: \"Links to every 'input' element\") {\n        section {\n            href(page: \"inputBooleanPage\", title: \"to boolean page\")\n            href(page: \"inputIconPage\", title: \"to icon page\")\n            href(page: \"inputImagePage\", title: \"to image page\")\n            href(page: \"inputSelectionPage\", title: \"to selection page\")\n            href(page: \"inputTextPage\", title: \"to text page\")\n            href(page: \"inputTimePage\", title: \"to time page\")\n        }\n        section(\"subsets of selection input\") {\n            href(page: \"inputDevicePage\", title: \"to device selection page\")\n            href(page: \"inputCapabilityPage\", title: \"to capability selection page\")\n            href(page: \"inputRoomPage\", title: \"to room selection page\")\n            href(page: \"inputModePage\", title: \"to mode selection page\")\n            href(page: \"inputHubPage\", title: \"to hub selection page\")\n            href(page: \"inputContactBookPage\", title: \"to contact-book selection page\")\n        }\n    }\n}\n\ndef inputBooleanPage() {\n    dynamicPage(name: \"inputBooleanPage\") {\n        section {\n            paragraph \"The `required` and `multiple` attributes have no effect because the value will always be either `true` or `false`\"\n        }\n        section {\n            input(type: \"boolean\", name: \"booleanWithoutDescription\", title: \"without description\", description: null)\n            input(type: \"boolean\", name: \"booleanWithDescription\", title: \"with description\", description: \"This has a description\")\n        }\n        section(\"defaultValue: 'true'\") {\n            input(type: \"boolean\", name: \"booleanWithDefaultValue\", title: \"\", description: \"\", defaultValue: \"true\")\n        }\n        section(\"with image\") {\n            input(type: \"boolean\", name: \"booleanWithoutDescriptionWithImage\", title: \"without description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", description: null)\n            input(type: \"boolean\", name: \"booleanWithDescriptionWithImage\", title: \"with description\", description: \"This has a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputIconPage() {\n    dynamicPage(name: \"inputIconPage\") {\n        section {\n            paragraph \"`description` is not displayed for icon elements\"\n            paragraph \"`multiple` has no effect because you can only choose a single icon\"\n        }\n        section(\"required: true\") {\n            input(type: \"icon\", name: \"iconRequired\", title: \"without description\", required: true)\n            input(type: \"icon\", name: \"iconRequiredWithDescription\", title: \"with description\", description: \"this is a description\", required: true)\n        }\n        section(\"with image\") {\n            paragraph \"The image specified will be replaced after an icon is selected\"\n            input(type: \"icon\", name: \"iconwithImage\", title: \"without description\", required: false, image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputImagePage() {\n    dynamicPage(name: \"inputImagePage\") {\n        section {\n            paragraph \"This only exists in DeviceTypes. Someone should do something about that. (glares at MikeDave)\"\n            paragraph \"Go to the device preferences of a Mobile Presence device to see it in action\"\n            paragraph \"If you try to set the value of this, it will not behave as it would in Device Preferences\"\n            input(type: \"image\", title: \"This is kind of what it looks like\", required: false)\n        }\n    }\n}\n\n\ndef optionsGroup(List groups, String title) {\n    def group = [values:[], order: groups.size()]\n    group.title = title ?: \"\"\n    groups << group\n    return groups\n}\ndef addValues(List groups, String key, String value) {\n    def lastGroup = groups[-1]\n    lastGroup[\"values\"] << [\n            key: key,\n            value: value,\n            order: lastGroup[\"values\"].size()\n    ]\n    return groups\n}\ndef listToMap(List original) {\n    original.inject([:]) { result, v ->\n        result[v] = v\n        return result\n    }\n}\ndef addGroup(List groups, String title, values) {\n    if (values instanceof List) {\n        values = listToMap(values)\n    }\n\n    values.inject(optionsGroup(groups, title)) { result, k, v ->\n        return addValues(result, k, v)\n    }\n    return groups\n}\ndef addGroup(values) {\n    addGroup([], null, values)\n}\n/* Example usage of options builder\n\n// Creating grouped options\n    def newGroups = []\n    addGroup(newGroups, \"first group\", [\"foo\", \"bar\", \"baz\"])\n    addGroup(newGroups, \"second group\", [zero: \"zero\", one: \"uno\", two: \"dos\", three: \"tres\"])\n\n// simple list\n    addGroup([\"a\", \"b\", \"c\"])\n\n// simple map\n    addGroup([\"a\": \"yes\", \"b\": \"no\", \"c\": \"maybe\"])​​​​\n*/\n\n\ndef inputSelectionPage() {\n\n    def englishOptions = [\"One\", \"Two\", \"Three\"]\n    def spanishOptions = [\"Uno\", \"Dos\", \"Tres\"]\n    def groupedOptions = []\n    addGroup(groupedOptions, \"English\", englishOptions)\n    addGroup(groupedOptions, \"Spanish\", spanishOptions)\n\n    dynamicPage(name: \"inputSelectionPage\") {\n\n        section(\"options variations\") {\n            paragraph \"tap these elements and look at the differences when selecting an option\"\n            input(type: \"enum\", name: \"selectionSimple\", title: \"Simple options\", description: \"no separators in the selectable options\", options: [\"Thing 1\", \"Thing 2\", \"(Complicated) Thing 3\"])\n            input(type: \"enum\", name: \"selectionSimpleGrouped\", title: \"Simple (Grouped) options\", description: \"no separators in the selectable options\", groupedOptions: addGroup(englishOptions + spanishOptions))\n            input(type: \"enum\", name: \"selectionGrouped\", title: \"Grouped options\", description: \"separate groups of options with headers\", groupedOptions: groupedOptions)\n        }\n\n        section(\"list vs map\") {\n            paragraph \"These should be identical in UI, but are different in code and will produce different settings\"\n            input(type: \"enum\", name: \"selectionList\", title: \"Choose a device\", description: \"settings will be something like ['Device1 Label']\", groupedOptions: addGroup([\"Device1 Label\", \"Device2 Label\"]))\n            input(type: \"enum\", name: \"selectionMap\", title: \"Choose a device\", description: \"settings will be something like ['device1-id']\", groupedOptions: addGroup([\"device1-id\": \"Device1 Label\", \"device2-id\": \"Device2 Label\"]))\n        }\n\n        section(\"segmented\") {\n            paragraph \"segmented should only work if there are either 2 or 3 options to choose from\"\n            input(type: \"enum\", name: \"selectionSegmented1\", style: \"segmented\", title: \"1 option\", options: [\"One\"])\n            input(type: \"enum\", name: \"selectionSegmented4\", style: \"segmented\", title: \"4 options\", options: [\"One\", \"Two\", \"Three\", \"Four\"])\n\n            paragraph \"multiple and required will have no effect on segmented selection elements. There will always be exactly 1 option selected\"\n            input(type: \"enum\", name: \"selectionSegmented2\", style: \"segmented\", title: \"2 options\", options: [\"One\", \"Two\"])\n            input(type: \"enum\", name: \"selectionSegmented3\", style: \"segmented\", title: \"3 options\", options: [\"One\", \"Two\", \"Three\"])\n\n            paragraph \"specifying defaultValue still works with segmented selection elements\"\n            input(type: \"enum\", name: \"selectionSegmentedWithDefault\", style: \"segmented\", title: \"defaulted to 'two'\", options: [\"One\", \"Two\", \"Three\"], defaultValue: \"Two\")\n        }\n\n        section(\"required: true\") {\n            input(type: \"enum\", name: \"selectionRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\", groupedOptions: addGroup([\"only option\"]), required: true)\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"enum\", name: \"selectionMultiple\", title: \"This allows multiple selections\", description: \"It should look different when nothing is selected\", groupedOptions: addGroup([\"an option\", \"another option\", \"no way, one more?\"]), multiple: true)\n            input(type: \"enum\", name: \"selectionMultipleDefault1\", title: \"This allows multiple selections with a single default\", description: \"It should look different when nothing is selected\", groupedOptions: addGroup([\"an option\", \"another option\", \"no way, one more?\"]), multiple: true, defaultValue: \"an option\")\n            input(type: \"enum\", name: \"selectionMultipleDefault2\", title: \"This allows multiple selections with multiple defaults\", description: \"It should look different when nothing is selected\", groupedOptions: addGroup([\"an option\", \"another option\", \"no way, one more?\"]), multiple: true, defaultValue: [\"an option\", \"another option\"])\n        }\n\n        section(\"with image\") {\n            input(type: \"enum\", name: \"selectionWithImage\", title: \"This has an image\", description: \"and a description\", groupedOptions: addGroup([\"an option\", \"another option\", \"no way, one more?\"]), image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputTextPage() {\n    dynamicPage(name: \"inputTextPage\", title: \"Every 'text' variation\") {\n        section(\"style and functional differences\") {\n            input(type: \"text\", name: \"textRequired\", title: \"required: true\", description: \"This should look different when nothing has been entered\", required: true)\n            input(type: \"text\", name: \"textWithImage\", title: \"with image\", description: \"This should look different when nothing has been entered\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", required: false)\n        }\n        section(\"text\") {\n            input(type: \"text\", name: \"text\", title: \"This has an alpha-numeric keyboard\", description: \"no special formatting\", required: false)\n        }\n        section(\"password\") {\n            input(type: \"password\", name: \"password\", title: \"This has an alpha-numeric keyboard\", description: \"masks value\", required: false)\n        }\n        section(\"email\") {\n            input(type: \"email\", name: \"email\", title: \"This has an email-specific keyboard\", description: \"no special formatting\", required: false)\n        }\n        section(\"phone\") {\n            input(type: \"phone\", name: \"phone\", title: \"This has a numeric keyboard\", description: \"formatted for phone numbers\", required: false)\n        }\n        section(\"decimal\") {\n            input(type: \"decimal\", name: \"decimal\", title: \"This has an numeric keyboard with decimal point\", description: \"no special formatting\", required: false)\n        }\n        section(\"number\") {\n            input(type: \"number\", name: \"number\", title: \"This has an numeric keyboard without decimal point\", description: \"no special formatting\", required: false)\n        }\n\n        section(\"specified ranges\") {\n            paragraph \"You can limit number and decimal inputs to a specific range.\"\n            input(range: \"50..150\", type: \"decimal\", name: \"decimalRange50..150\", title: \"only values between 50 and 150 will pass validation\", description: \"no special formatting\", required: false)\n            paragraph \"Negative limits will add a negative symbol to the keyboard.\"\n            input(range: \"-50..50\", type: \"number\", name: \"numberRange-50..50\", title: \"only values between -50 and 50 will pass validation\", description: \"no special formatting\", required: false)\n            paragraph \"Specify * to not limit one side or the other.\"\n            input(range: \"*..0\", type: \"decimal\", name: \"decimalRange*..0\", title: \"only negative values will pass validation\", description: \"no special formatting\", required: false)\n            input(range: \"*..*\", type: \"number\", name: \"numberRange*..*\", title: \"only positive values will pass validation\", description: \"no special formatting\", required: false)\n            paragraph \"If you don't specify a range, it defaults to 0..*\"\n        }\n    }\n}\ndef inputTimePage() {\n    dynamicPage(name: \"inputTimePage\") {\n        section {\n            input(type: \"time\", name: \"timeWithDescription\", title: \"a time picker\", description: \"with a description\", required: false)\n            input(type: \"time\", name: \"timeWithoutDescription\", title: \"without a description\", description: null, required: false)\n            input(type: \"time\", name: \"timeRequired\", title: \"required: true\", required: true)\n        }\n    }\n}\n\n/// selection subsets\ndef inputDevicePage() {\n\n    dynamicPage(name: \"inputDevicePage\") {\n\n        section(\"required: true\") {\n            input(type: \"device.switch\", name: \"deviceRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"device.switch\", name: \"deviceMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"device.switch\", name: \"deviceRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputCapabilityPage() {\n\n    dynamicPage(name: \"inputCapabilityPage\") {\n\n        section(\"required: true\") {\n            input(type: \"capability.switch\", name: \"capabilityRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"capability.switch\", name: \"capabilityMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"capability.switch\", name: \"capabilityRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputRoomPage() {\n\n    dynamicPage(name: \"inputRoomPage\") {\n\n        section(\"required: true\") {\n            input(type: \"room\", name: \"roomRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"room\", name: \"roomMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"room\", name: \"roomRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputModePage() {\n\n    dynamicPage(name: \"inputModePage\") {\n\n        section(\"required: true\") {\n            input(type: \"mode\", name: \"modeRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"mode\", name: \"modeMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"mode\", name: \"modeRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputHubPage() {\n\n    dynamicPage(name: \"inputHubPage\") {\n\n        section(\"required: true\") {\n            input(type: \"hub\", name: \"hubRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"hub\", name: \"hubMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"hub\", name: \"hubRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\ndef inputContactBookPage() {\n\n    dynamicPage(name: \"inputContactBookPage\") {\n\n        section(\"required: true\") {\n            input(type: \"contact\", name: \"contactRequired\", title: \"This is required\", description: \"It should look different when nothing is selected\")\n        }\n\n        section(\"multiple: true\") {\n            input(type: \"contact\", name: \"contactMultiple\", title: \"This is required\", description: \"It should look different when nothing is selected\", multiple: true)\n        }\n\n        section(\"with image\") {\n            input(type: \"contact\", name: \"contactRequired\", title: \"This has an image\", description: \"and a description\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\n\ndef appPage() {\n    dynamicPage(name: \"appPage\", title: \"Every 'app' type\") {\n        section {\n            paragraph \"These won't work unless you create a child SmartApp to link to... Sorry.\"\n        }\n        section(\"app\") {\n            app(\n                    name: \"app\",\n                    title: \"required:false, multiple:false\",\n                    required: false,\n                    multiple: false,\n                    namespace: \"Steve\",\n                    appName: \"Child SmartApp\"\n            )\n            app(name: \"appRequired\", title: \"required:true\", required: true, multiple: false, namespace: \"Steve\", appName: \"Child SmartApp\")\n            app(name: \"appComplete\", title: \"state:complete\", required: false, multiple: false, namespace: \"Steve\", appName: \"Child SmartApp\", state: \"complete\")\n            app(name: \"appWithImage\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", required: false, multiple: false, image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", namespace: \"Steve\", appName: \"Child SmartApp\")\n        }\n        section(\"multiple:true\") {\n            app(name: \"appMultiple\", title: \"multiple:true\", required: false, multiple: true, namespace: \"Steve\", appName: \"Child SmartApp\")\n        }\n        section(\"multiple:true with image\") {\n            app(name: \"appMultipleWithImage\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", required: false, multiple: true, image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", namespace: \"Steve\", appName: \"Child SmartApp\")\n        }\n    }\n}\n\ndef labelPage() {\n    dynamicPage(name: \"labelPage\", title: \"Every 'Label' type\") {\n        section(\"label\") {\n            paragraph \"The difference between a label element and a text input element is that the label element will effect the SmartApp directly by setting the label. An input element will place the set value in the SmartApp's settings.\"\n            paragraph \"There are 3 here as an example. Never use more than 1 label element on a page.\"\n            label(name: \"label\", title: \"required:false, multiple:false\", required: false, multiple: false)\n            label(name: \"labelRequired\", title: \"required:true\", required: true, multiple: false)\n            label(name: \"labelWithImage\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", required: false, image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\n\ndef modePage() {\n    dynamicPage(name: \"modePage\", title: \"Every 'mode' type\") { // TODO: finish this\n        section(\"mode\") {\n            paragraph \"The difference between a mode element and a mode input element is that the mode element will effect the SmartApp directly by setting the modes it executes in. A mode input element will place the set value in the SmartApp's settings.\"\n            paragraph \"Another difference is that you can select 'All Modes' when choosing which mode the SmartApp should execute in. This is the same as selecting no modes. When a SmartApp does not have modes specified, it will execute in all modes.\"\n            paragraph \"There are 4 here as an example. Never use more than 1 mode element on a page.\"\n            mode(name: \"mode\", title: \"required:false, multiple:false\", required: false, multiple: false)\n            mode(name: \"modeRequired\", title: \"required:true\", required: true, multiple: false)\n            mode(name: \"modeMultiple\", title: \"multiple:true\", required: false, multiple: true)\n            mode(name: \"modeWithImage\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", required: false, multiple: true, image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n        }\n    }\n}\n\ndef paragraphPage() {\n    dynamicPage(name: \"paragraphPage\", title: \"Every 'paragraph' type\") {\n        section(\"paragraph\") {\n            paragraph \"This is how you should make a paragraph element\"\n            paragraph image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", \"This is a long description, blah, blah, blah.\"\n        }\n    }\n}\n\ndef hrefPage() {\n    dynamicPage(name: \"hrefPage\", title: \"Every 'href' variation\") {\n        section(\"stylistic differences\") {\n            href(page: \"deadEnd\", title: \"state: 'complete'\", description: \"gives the appearance of an input that has been filled out\", state: \"complete\")\n            href(page: \"deadEnd\", title: \"with image\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\")\n            href(page: \"deadEnd\", title: \"with image and description\", description: \"and state: 'complete'\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", state: \"complete\")\n        }\n        section(\"functional differences\") {\n            href(page: \"deadEnd\", title: \"to a page within the app\")\n            href(url: \"http://www.google.com\", title: \"to a url using all defaults\")\n            href(url: \"http://www.google.com\", title: \"external: true\", description: \"takes you outside the app\", external: true)\n        }\n    }\n}\n\ndef buttonsPage() {\n    dynamicPage(name: \"buttonsPage\", title: \"Every 'button' type\") {\n        section(\"Simple Buttons\") {\n            paragraph \"If there are an odd number of buttons, the last button will span the entire view area.\"\n            buttons(name: \"buttons1\", title: \"1 button\", buttons: [\n                    [label: \"foo\", action: \"foo\"]\n            ])\n            buttons(name: \"buttons2\", title: \"2 buttons\", buttons: [\n                    [label: \"foo\", action: \"foo\"],\n                    [label: \"bar\", action: \"bar\"]\n            ])\n            buttons(name: \"buttons3\", title: \"3 buttons\", buttons: [\n                    [label: \"foo\", action: \"foo\"],\n                    [label: \"bar\", action: \"bar\"],\n                    [label: \"baz\", action: \"baz\"]\n            ])\n            buttons(name: \"buttonsWithImage\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", image: \"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", buttons: [\n                    [label: \"foo\", action: \"foo\"],\n                    [label: \"bar\", action: \"bar\"]\n            ])\n        }\n        section(\"Colored Buttons\") {\n            buttons(name: \"buttonsColoredSpecial\", title: \"special strings\", description: \"SmartThings highly recommends using these colors\", buttons: [\n                    [label: \"complete\", action: \"bar\", backgroundColor: \"complete\"],\n                    [label: \"required\", action: \"bar\", backgroundColor: \"required\"]\n            ])\n            buttons(name: \"buttonsColoredHex\", title: \"hex values work\", buttons: [\n                    [label: \"bg: #000dff\", action: \"foo\", backgroundColor: \"#000dff\"],\n                    [label: \"fg: #ffac00\", action: \"foo\", color: \"#ffac00\"],\n                    [label: \"both fg and bg\", action: \"foo\", color: \"#ffac00\", backgroundColor: \"#000dff\"]\n            ])\n            buttons(name: \"buttonsColoredString\", title: \"strings work too\", buttons: [\n                    [label: \"green\", action: \"foo\", backgroundColor: \"green\"],\n                    [label: \"red\", action: \"foo\", backgroundColor: \"red\"],\n                    [label: \"both fg and bg\", action: \"foo\", color: \"red\", backgroundColor: \"green\"]\n            ])\n        }\n    }\n\n}\n\ndef imagePage() {\n    dynamicPage(name: \"imagePage\", title: \"Every 'image' type\") { // TODO: finish thise\n        section(\"image\") {\n            image \"http://f.cl.ly/items/1k1S0A0m3805402o3O12/20130915-191127.jpg\"\n            image(name: \"imageWithMultipleImages\", title: \"This element has an image and a long title.\", description: \"I am setting long title and descriptions to test the offset\", required: false, images: [\"https://s3.amazonaws.com/smartapp-icons/Convenience/Cat-Convenience.png\", \"http://f.cl.ly/items/1k1S0A0m3805402o3O12/20130915-191127.jpg\"])\n        }\n    }\n}\n\ndef videoPage() {\n    dynamicPage(name: \"videoPage\", title: \"Every 'video' type\") { // TODO: finish this\n        section(\"video\") {\n            // TODO: update this when there is a videoElement method\n            element(name: \"videoElement\", element: \"video\", type: \"video\", title: \"this is a video!\", description: \"I am setting long title and descriptions to test the offset\", required: false, image: \"http://f.cl.ly/items/0w0D1p0K2D0d190F3H3N/Image%202015-12-14%20at%207.57.27%20AM.jpg\", video: \"http://f.cl.ly/items/3O2L03471l2K3E3l3K1r/Zombie%20Kid%20Likes%20Turtles.mp4\")\n        }\n    }\n}\n\ndef flattenedPage() {\n    def allSections = []\n    firstPage().sections[0].body.each { hrefElement ->\n        if (hrefElement.name != \"inputPage\") {\n            // inputPage is a bunch of hrefs\n            allSections += \"${hrefElement.page}\"().sections\n        }\n    }\n    // collect the input elements\n    inputPage().sections.each { section ->\n        section.body.each { hrefElement ->\n            allSections += \"${hrefElement.page}\"().sections\n        }\n    }\n    def flattenedPage = dynamicPage(name: \"flattenedPage\", title: \"All elements in one page!\") {}\n    flattenedPage.sections = allSections\n    return flattenedPage\n}\n\ndef foo() {\n    dynamicPage(name: \"deadEnd\") {\n        section {  }\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n\n    initialize()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    // TODO: subscribe to attributes, devices, locations, etc.\n}",
        "docstring": "Every element demonstration app"
    },
    {
        "code": "section(\"Feed my pet at...\") {\n\t\tinput \"time1\", \"time\", title: \"When?\"\n\t}\n}\n\ndef installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledFeeding\"\n\tfeeder?.feed()\n}",
        "docstring": "Setup a schedule for when your pet is fed. Purchase any SmartThings certified pet food feeder and install the Feed My Pet app, and set the time. You and your pet are ready to go. Your life just got smarter."
    },
    {
        "code": "section(\"Send a notification to...\") {\n\t\tinput(\"recipients\", \"contact\", title: \"Recipients\", description: \"Send notifications to\") {\n\t\t\tinput \"phone\", \"phone\", title: \"Phone number?\", required: false\n\t\t}\n\t}\n}\n\ndef installed() {\n\tsubscribe(alarm, \"water.wet\", waterWetHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(alarm, \"water.wet\", waterWetHandler)\n}\n\ndef waterWetHandler(evt) {\n\tdef deltaSeconds = 60\n\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = alarm.eventsSince(timeAgo)\n\tlog.debug \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"wet\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t} else {\n\t\tdef msg = \"${alarm.displayName} is wet!\"\n\t\tlog.debug \"$alarm is wet, texting phone number\"\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tsendPush(msg)\n\t\t\tif (phone) {\n\t\t\t\tsendSms(phone, msg)\n\t\t\t}\n\t\t}\n\t}\n}",
        "docstring": "Get a push notification or text message when water is detected where it doesn't belong."
    },
    {
        "code": "//bridge discovery request every\n\t\tif((refreshCount % 5) == 0) {\n\t\t\tdiscoverCameras()\n\t\t}\n\n\t\treturn dynamicPage(name:\"cameraDiscovery\", title:\"Discovery Started!\", nextPage:\"loginToFoscam\", refreshInterval:refreshInterval, uninstall: true) {\n\t\t\tsection(\"Please wait while we discover your Foscam. Discovery can take five minutes or more, so sit back and relax! Select your device below once discovered.\") {\n\t\t\t\tinput \"selectedFoscam\", \"enum\", required:false, title:\"Select Foscam (${numFound} found)\", multiple:true, options:options\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tdef upgradeNeeded = \"\"\"To use Foscam, your Hub should be completely up to date.\n\n\t\tTo update your Hub, access Location Settings in the Main Menu (tap the gear next to your location name), select your Hub, and choose \"Update Hub\".\"\"\"\n\n\t\treturn dynamicPage(name:\"cameraDiscovery\", title:\"Upgrade needed!\", nextPage:\"\", install:false, uninstall: true) {\n\t\t\tsection(\"Upgrade\") {\n\t\t\t\tparagraph \"$upgradeNeeded\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\ndef loginToFoscam() {\n\tdef showUninstall = username != null && password != null\n\treturn dynamicPage(name: \"loginToFoscam\", title: \"Foscam\", uninstall:showUninstall, install:true,) {\n\t\tsection(\"Log in to Foscam\") {\n\t\t\tinput \"username\", \"text\", title: \"Username\", required: true, autoCorrect:false\n\t\t\tinput \"password\", \"password\", title: \"Password\", required: true, autoCorrect:false\n\t\t}\n\t}\n}\n//END PAGES\n\n/////////////////////////////////////\nprivate discoverCameras()\n{\n\t//add type UDP_CLIENT\n\tdef action = new physicalgraph.device.HubAction(\"0b4D4F5F490000000000000000000000040000000400000000000001\", physicalgraph.device.Protocol.LAN, \"FFFFFFFF:2710\")\n\taction.options = [type:\"LAN_TYPE_UDPCLIENT\"]\n\tsendHubCommand(action)\n}\n\ndef camerasDiscovered() {\n\tdef cameras = getCameras()\n\tdef map = [:]\n\tcameras.each {\n\t\tdef value = it.value.name ?: \"Foscam Camera\"\n\t\tdef key = it.value.ip + \":\" + it.value.port\n\t\tmap[\"${key}\"] = value\n\t}\n\tmap\n}\n\n/////////////////////////////////////\ndef getCameras()\n{\n\tstate.cameras = state.cameras ?: [:]\n}\n\n/////////////////////////////////////\ndef installed() {\n\t//log.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n\n\trunIn(300, \"doDeviceSync\" , [overwrite: false]) //setup ip:port syncing every 5 minutes\n\n\t//wait 5 seconds and get the deviceInfo\n\t//log.info \"calling 'getDeviceInfo()'\"\n\t//runIn(5, getDeviceInfo)\n}\n\n/////////////////////////////////////\ndef updated() {\n\t//log.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\n/////////////////////////////////////\ndef initialize() {\n\t// remove location subscription aftwards\n\tunsubscribe()\n\tstate.subscribe = false\n\n\tif (selectedFoscam)\n\t{\n\t\taddCameras()\n\t}\n}\n\ndef addCameras() {\n\tdef cameras = getCameras()\n\n\tselectedFoscam.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\n\t\tif(!d)\n\t\t{\n\t\t\tdef newFoscam = cameras.find { (it.value.ip + \":\" + it.value.port) == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Foscam\", dni, newFoscam?.value?.hub, [\"label\":newFoscam?.value?.name ?: \"Foscam Camera\", \"data\":[\"mac\": newFoscam?.value?.mac, \"ip\": newFoscam.value.ip, \"port\":newFoscam.value.port], \"preferences\":[\"username\":username, \"password\":password]])\n\n\t\t\tlog.debug \"created ${d.displayName} with id $dni\"\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug \"found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n}\n\ndef getDeviceInfo() {\n\tdef devices = getAllChildDevices()\n\tdevices.each { d ->\n\t\td.getDeviceInfo()\n\t}\n}\n\n/////////////////////////////////////\ndef locationHandler(evt) {\n\t/*\n\tFOSCAM EXAMPLE\n\t4D4F5F4901000000000000000000006200000000000000 (SOF) //46\n\t30303632364534443042344200 (mac) //26\n\t466F7363616D5F44617274684D61756C0000000000 (name) //42\n\t0A01652C (ip) //8\n\tFFFFFE00 (mask) //8\n\t00000000 (gateway ip) //8\n\t00000000 (dns) //8\n\t01005800 (reserve) //8\n\t01040108 (system software version) //8\n\t020B0106 (app software version) //8\n\t0058 (port) //4\n\t01 (dhcp enabled) //2\n\t*/\n\tdef description = evt.description\n\tdef hub = evt?.hubId\n\n\tlog.debug \"GOT LOCATION EVT: $description\"\n\n\tdef parsedEvent = stringToMap(description)\n\n\t//FOSCAM does a UDP response with camera operate protocol:“MO_I” i.e. \"4D4F5F49\"\n\tif (parsedEvent?.type == \"LAN_TYPE_UDPCLIENT\" && parsedEvent?.payload?.startsWith(\"4D4F5F49\"))\n\t{\n\t\tdef unpacked = [:]\n\t\tunpacked.mac = parsedEvent.mac.toString()\n\t\tunpacked.name = hexToString(parsedEvent.payload[72..113]).trim()\n\t\tunpacked.ip = parsedEvent.payload[114..121]\n\t\tunpacked.subnet = parsedEvent.payload[122..129]\n\t\tunpacked.gateway = parsedEvent.payload[130..137]\n\t\tunpacked.dns = parsedEvent.payload[138..145]\n\t\tunpacked.reserve = parsedEvent.payload[146..153]\n\t\tunpacked.sysVersion = parsedEvent.payload[154..161]\n\t\tunpacked.appVersion = parsedEvent.payload[162..169]\n\t\tunpacked.port = parsedEvent.payload[170..173]\n\t\tunpacked.dhcp = parsedEvent.payload[174..175]\n\t\tunpacked.hub = hub\n\n\t\tdef cameras = getCameras()\n\t\tif (!(cameras.\"${parsedEvent.mac.toString()}\"))\n\t\t{\n\t\t\tcameras << [(\"${parsedEvent.mac.toString()}\"):unpacked]\n\t\t}\n\t}\n}\n\n/////////////////////////////////////\nprivate Boolean canInstallLabs()\n{\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware)\n{\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions()\n{\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}\n\nprivate String hexToString(String txtInHex)\n{\n\tbyte [] txtInByte = new byte [txtInHex.length() / 2];\n\tint j = 0;\n\tfor (int i = 0; i < txtInHex.length(); i += 2)\n\t{\n\t\t\ttxtInByte[j++] = Byte.parseByte(txtInHex.substring(i, i + 2), 16);\n\t}\n\treturn new String(txtInByte);\n}",
        "docstring": "Connect and take pictures using your Foscam camera from inside the Smartthings app."
    },
    {
        "code": "section(\"For too long...\") {\n\t\tinput \"maxOpenTime\", \"number\", title: \"Minutes?\"\n\t}\n\tsection(\"Text me at (optional, sends a push notification if not specified)...\") {\n        input(\"recipients\", \"contact\", title: \"Notify\", description: \"Send notifications to\") {\n            input \"phone\", \"phone\", title: \"Phone number?\", required: false\n        }\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(multisensor, \"acceleration\", accelerationHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(multisensor, \"acceleration\", accelerationHandler)\n}\n\ndef accelerationHandler(evt) {\n\tdef latestThreeAxisState = multisensor.threeAxisState // e.g.: 0,0,-1000\n\tif (latestThreeAxisState) {\n\t\tdef isOpen = Math.abs(latestThreeAxisState.xyzValue.z) > 250 // TODO: Test that this value works in most cases...\n\t\tdef isNotScheduled = state.status != \"scheduled\"\n\n\t\tif (!isOpen) {\n\t\t\tclearSmsHistory()\n\t\t\tclearStatus()\n\t\t}\n\n\t\tif (isOpen && isNotScheduled) {\n\t\t\trunIn(maxOpenTime * 60, takeAction, [overwrite: false])\n\t\t\tstate.status = \"scheduled\"\n\t\t}\n\n\t}\n\telse {\n\t\tlog.warn \"COULD NOT FIND LATEST 3-AXIS STATE FOR: ${multisensor}\"\n\t}\n}\n\ndef takeAction(){\n\tif (state.status == \"scheduled\")\n\t{\n\t\tdef deltaMillis = 1000 * 60 * maxOpenTime\n\t\tdef timeAgo = new Date(now() - deltaMillis)\n\t\tdef openTooLong = multisensor.threeAxisState.dateCreated.toSystemDate() < timeAgo\n\n\t\tdef recentTexts = state.smsHistory.find { it.sentDate.toSystemDate() > timeAgo }\n\n\t\tif (!recentTexts) {\n\t\t\tsendTextMessage()\n\t\t}\n\t\trunIn(maxOpenTime * 60, takeAction, [overwrite: false])\n\t} else {\n\t\tlog.trace \"Status is no longer scheduled. Not sending text.\"\n\t}\n}\n\ndef sendTextMessage() {\n\tlog.debug \"$multisensor was open too long, texting phone\"\n\n\tupdateSmsHistory()\n\tdef openMinutes = maxOpenTime * (state.smsHistory?.size() ?: 1)\n\tdef msg = \"Your ${multisensor.label ?: multisensor.name} has been open for more than ${openMinutes} minutes!\"\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (phone) {\n            sendSms(phone, msg)\n        } else {\n            sendPush msg\n        }\n    }\n}\n\ndef updateSmsHistory() {\n\tif (!state.smsHistory) state.smsHistory = []\n\n\tif(state.smsHistory.size() > 9) {\n\t\tlog.debug \"SmsHistory is too big, reducing size\"\n\t\tstate.smsHistory = state.smsHistory[-9..-1]\n\t}\n\tstate.smsHistory << [sentDate: new Date().toSystemFormat()]\n}\n\ndef clearSmsHistory() {\n\tstate.smsHistory = null\n}\n\ndef clearStatus() {\n\tstate.status = null\n}",
        "docstring": "Monitor your garage door and get a text message if it is open too long"
    },
    {
        "code": "}\n\ndef installed() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribeToCommand(switch1, \"on\", onCommand)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(app, appTouchHandler)\n\tsubscribeToCommand(switch1, \"on\", onCommand)\n}\n\ndef appTouch(evt) {\n\tlog.debug \"appTouch: $evt.value, $evt\"\n\tswitch1?.on()\n}\n\ndef onCommand(evt) {\n\tlog.debug \"onCommand: $evt.value, $evt\"\n\tswitch1?.off(delay: 3000)\n}",
        "docstring": "Open your garage door when a switch is turned on."
    },
    {
        "code": "href(name: \"toNumbersPage\", page: \"numbersPage\", title: \"Duration & Direction\", description: numbersPageHrefDescription(), state: \"complete\")\n\t\t\t}\n\t\t}\n\n\t\tif (dimmers) {\n\n\t\t\tsection(\"Gentle Wake Up Has A Controller\") {\n\t\t\t\thref(title: \"Learn how to control Gentle Wake Up\", page: \"controllerExplanationPage\", description: null)\n\t\t\t}\n\n\t\t\tsection(\"Rules For Dimming\") {\n\t\t\t\thref(name: \"toSchedulingPage\", page: \"schedulingPage\", title: \"Automation\", description: schedulingHrefDescription() ?: \"Set rules for when to start\", state: schedulingHrefDescription() ? \"complete\" : \"\")\n\t\t\t\tinput(name: \"manualOverride\", type: \"enum\", options: [\"cancel\": \"Cancel dimming\", \"jumpTo\": \"Jump to the end\"], title: \"When one of the dimmers is manually turned off…\", description: \"dimming will continue\", required: false, multiple: false)\n\t\t\t\thref(name: \"toCompletionPage\", title: \"Completion Actions\", page: \"completionPage\", state: completionHrefDescription() ? \"complete\" : \"\", description: completionHrefDescription() ?: \"Set rules for what to do when dimming completes\")\n\t\t\t}\n\n\t\t\tsection {\n\t\t\t\t// TODO: fancy label\n\t\t\t\tlabel(title: \"Label This SmartApp\", required: false, defaultValue: \"\", description: \"Highly recommended\", submitOnChange: true)\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef unsupportedDevicesPage() {\n\n\tdef unsupportedDimmers = dimmers.findAll { !hasSetLevelCommand(it) }\n\n\tdynamicPage(name: \"unsupportedDevicesPage\") {\n\t\tif (unsupportedDimmers) {\n\t\t\tsection(\"These devices do not support the setLevel command\") {\n\t\t\t\tunsupportedDimmers.each {\n\t\t\t\t\tparagraph deviceLabel(it)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsection {\n\t\t\t\tinput(name: \"dimmers\", type: \"capability.sensor\", title: \"Please remove the above devices from this list.\", submitOnChange: true, multiple: true)\n\t\t\t}\n\t\t\tsection {\n\t\t\t\tparagraph \"If you think there is a mistake here, please contact support.\"\n\t\t\t}\n\t\t} else {\n\t\t\tsection {\n\t\t\t\tparagraph \"You're all set. You can hit the back button, now. Thanks for cleaning up your settings :)\"\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef controllerExplanationPage() {\n\tdynamicPage(name: \"controllerExplanationPage\", title: \"How To Control Gentle Wake Up\") {\n\n\t\tsection(\"With other SmartApps\", hideable: true, hidden: false) {\n\t\t\tparagraph \"When this SmartApp is installed, it will create a controller device which you can use in other SmartApps for even more customizable automation!\"\n\t\t\tparagraph \"The controller acts like a switch so any SmartApp that can control a switch can control Gentle Wake Up, too!\"\n\t\t\tparagraph \"Routines and 'Smart Lighting' are great ways to automate Gentle Wake Up.\"\n\t\t}\n\n\t\tsection(\"More about the controller\", hideable: true, hidden: true) {\n\t\t\tparagraph \"You can find the controller with your other 'Things'. It will look like this.\"\n\t\t\timage \"http://f.cl.ly/items/2O0v0h41301U14042z3i/GentleWakeUpController-tile-stopped.png\"\n\t\t\tparagraph \"You can start and stop Gentle Wake up by tapping the control on the right.\"\n\t\t\timage \"http://f.cl.ly/items/3W323J3M1b3K0k0V3X3a/GentleWakeUpController-tile-running.png\"\n\t\t\tparagraph \"If you look at the device details screen, you will find even more information about Gentle Wake Up and more fine grain controls.\"\n\t\t\timage \"http://f.cl.ly/items/291s3z2I2Q0r2q0x171H/GentleWakeUpController-richTile-stopped.png\"\n\t\t\tparagraph \"The slider allows you to jump to any point in the dimming process. Think of it as a percentage. If Gentle Wake Up is set to dim down as you fall asleep, but your book is just too good to put down; simply drag the slider to the left and Gentle Wake Up will give you more time to finish your chapter and drift off to sleep.\"\n\t\t\timage \"http://f.cl.ly/items/0F0N2G0S3v1q0L0R3J3Y/GentleWakeUpController-richTile-running.png\"\n\t\t\tparagraph \"In the lower left, you will see the amount of time remaining in the dimming cycle. It does not count down evenly. Instead, it will update whenever the slider is updated; typically every 6-18 seconds depending on the duration of your dimming cycle.\"\n\t\t\tparagraph \"Of course, you may also tap the middle to start or stop the dimming cycle at any time.\"\n\t\t}\n\n\t\tsection(\"Starting and stopping the SmartApp itself\", hideable: true, hidden: true) {\n\t\t\tparagraph \"Tap the 'play' button on the SmartApp to start or stop dimming.\"\n\t\t\timage \"http://f.cl.ly/items/0R2u1Z2H30393z2I2V3S/GentleWakeUp-appTouch2.png\"\n\t\t}\n\n\t\tsection(\"Turning off devices while dimming\", hideable: true, hidden: true) {\n\t\t\tparagraph \"It's best to use other Devices and SmartApps for triggering the Controller device. However, that isn't always an option.\"\n\t\t\tparagraph \"If you turn off a switch that is being dimmed, it will either continue to dim, stop dimming, or jump to the end of the dimming cycle depending on your settings.\"\n\t\t\tparagraph \"Unfortunately, some switches take a little time to turn off and may not finish turning off before Gentle Wake Up sets its dim level again. You may need to try a few times to get it to stop.\"\n\t\t\tparagraph \"That's why it's best to use devices that aren't currently dimming. Remember that you can use other SmartApps to toggle the controller. :)\"\n\t\t}\n\t}\n}\n\ndef numbersPage() {\n\tdynamicPage(name:\"numbersPage\", title:\"\") {\n\n\t\tsection {\n\t\t\tparagraph(name: \"pGraph\", title: \"These lights will dim\", fancyDeviceString(dimmers))\n\t\t}\n\n\t\tsection {\n\t\t\tinput(name: \"duration\", type: \"number\", title: \"For this many minutes\", description: \"30\", required: false, defaultValue: 30)\n\t\t}\n\n\t\tsection {\n\t\t\tinput(name: \"startLevel\", type: \"number\", range: \"0..99\", title: \"From this level\", defaultValue: defaultStart(), description: \"Current Level\", required: false, multiple: false)\n\t\t\tinput(name: \"endLevel\", type: \"number\", range: \"0..99\", title: \"To this level\", defaultValue: defaultEnd(), description: \"Between 0 and 99\", required: true, multiple: false)\n\t\t}\n\n\t\tdef colorDimmers = dimmersWithSetColorCommand()\n\t\tif (colorDimmers) {\n\t\t\tsection {\n\t\t\t\tinput(name: \"colorize\", type: \"bool\", title: \"Gradually change the color of ${fancyDeviceString(colorDimmers)}\", description: null, required: false, defaultValue: \"true\")\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef defaultStart() {\n\tif (usesOldSettings() && direction && direction == \"Down\") {\n\t\treturn 99\n\t}\n\treturn 0\n}\n\ndef defaultEnd() {\n\tif (usesOldSettings() && direction && direction == \"Down\") {\n\t\treturn 0\n\t}\n\treturn 99\n}\n\ndef startLevelLabel() {\n\tif (usesOldSettings()) { // using old settings\n\t\tif (direction && direction == \"Down\") { // 99 -> 1\n\t\t\treturn \"99%\"\n\t\t}\n\t\treturn \"0%\"\n\t}\n\treturn hasStartLevel() ? \"${startLevel}%\" : \"Current Level\"\n}\n\ndef endLevelLabel() {\n\tif (usesOldSettings()) {\n\t\tif (direction && direction == \"Down\") { // 99 -> 1\n\t\t\treturn \"0%\"\n\t\t}\n\t\treturn \"99%\"\n\t}\n\treturn \"${endLevel}%\"\n}\n\ndef weekdays() {\n\t[\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n}\n\ndef weekends() {\n\t[\"Saturday\", \"Sunday\"]\n}\n\ndef schedulingPage() {\n\tdynamicPage(name: \"schedulingPage\", title: \"Rules For Automatically Dimming Your Lights\") {\n\n\t\tsection(\"Use Other SmartApps!\") {\n\t\t\thref(title: \"Learn how to control Gentle Wake Up\", page: \"controllerExplanationPage\", description: null)\n\t\t}\n\n\t\tsection(\"Allow Automatic Dimming\") {\n\t\t\tinput(name: \"days\", type: \"enum\", title: \"On These Days\", description: \"Every day\", required: false, multiple: true, options: weekdays() + weekends())\n\t\t}\n\n\t\tsection(\"Start Dimming...\") {\n\t\t\tinput(name: \"startTime\", type: \"time\", title: \"At This Time\", description: null, required: false)\n\t\t\tinput(name: \"modeStart\", title: \"When Entering This Mode\", type: \"mode\", required: false, mutliple: false, submitOnChange: true, description: null)\n\t\t\tif (modeStart) {\n\t\t\t\tinput(name: \"modeStop\", title: \"Stop when leaving '${modeStart}' mode\", type: \"bool\", required: false)\n\t\t\t}\n\t\t}\n\n\t}\n}\n\ndef completionPage() {\n\tdynamicPage(name: \"completionPage\", title: \"Completion Rules\") {\n\n\t\tsection(\"Switches\") {\n\t\t\tinput(name: \"completionSwitches\", type: \"capability.switch\", title: \"Set these switches\", description: null, required: false, multiple: true, submitOnChange: true)\n\t\t\tif (completionSwitches) {\n\t\t\t\tinput(name: \"completionSwitchesState\", type: \"enum\", title: \"To\", description: null, required: false, multiple: false, options: [\"on\", \"off\"], defaultValue: \"on\")\n\t\t\t\tinput(name: \"completionSwitchesLevel\", type: \"number\", title: \"Optionally, Set Dimmer Levels To\", description: null, required: false, multiple: false, range: \"(0..99)\")\n\t\t\t}\n\t\t}\n\n\t\tsection(\"Notifications\") {\n\t\t\tinput(\"recipients\", \"contact\", title: \"Send notifications to\", required: false) {\n\t\t\t\tif (completionPhoneNumber) {\n\t\t\t\t\tinput(name: \"completionPhoneNumber\", type: \"phone\", title: \"Text This Number\", description: \"Phone number\", required: false)\n\t\t\t\t}\n\t\t\t\tinput(name: \"completionPush\", type: \"bool\", title: \"Send A Push Notification\", description: \"Phone number\", required: false)\n\t\t\t}\n\t\t\tinput(name: \"completionMusicPlayer\", type: \"capability.musicPlayer\", title: \"Speak Using This Music Player\", required: false)\n\t\t\tinput(name: \"completionMessage\", type: \"text\", title: \"With This Message\", description: null, required: false)\n\t\t}\n\n\t\tsection(\"Modes and Phrases\") {\n\t\t\tinput(name: \"completionMode\", type: \"mode\", title: \"Change ${location.name} Mode To\", description: null, required: false)\n\t\t\tinput(name: \"completionPhrase\", type: \"enum\", title: \"Execute The Phrase\", description: null, required: false, multiple: false, options: location.helloHome.getPhrases().label)\n\t\t}\n\n\t\tsection(\"Delay\") {\n\t\t\tinput(name: \"completionDelay\", type: \"number\", title: \"Delay This Many Minutes Before Executing These Actions\", description: \"0\", required: false)\n\t\t}\n\t}\n}\n\n// ========================================================\n// Handlers\n// ========================================================\n\ndef installed() {\n\tlog.debug \"Installing 'Gentle Wake Up' with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updating 'Gentle Wake Up' with settings: ${settings}\"\n\tunschedule()\n\n\tdef controller = getController()\n\tif (controller) {\n\t\tcontroller.label = app.label\n\t}\n\n\tinitialize()\n}\n\nprivate initialize() {\n\tstop(\"settingsChange\")\n\n\tif (startTime) {\n\t\tlog.debug \"scheduling dimming routine to run at $startTime\"\n\t\tschedule(startTime, \"scheduledStart\")\n\t}\n\n\t// TODO: make this an option\n\tsubscribe(app, appHandler)\n\n\tsubscribe(location, locationHandler)\n\n\tif (manualOverride) {\n\t\tsubscribe(dimmers, \"switch.off\", stopDimmersHandler)\n\t}\n\n\tif (!getAllChildDevices()) {\n\t\t// create controller device and set name to the label used here\n\t\tdef dni = \"${new Date().getTime()}\"\n\t\tlog.debug \"app.label: ${app.label}\"\n\t\taddChildDevice(\"smartthings\", \"Gentle Wake Up Controller\", dni, null, [\"label\": app.label])\n\t\tstate.controllerDni = dni\n\t}\n}\n\ndef appHandler(evt) {\n\tlog.debug \"appHandler evt: ${evt.value}\"\n\tif (evt.value == \"touch\") {\n\t\tif (atomicState.running) {\n\t\t\tstop(\"appTouch\")\n\t\t} else {\n\t\t\tstart(\"appTouch\")\n\t\t}\n\t}\n}\n\ndef locationHandler(evt) {\n\tlog.debug \"locationHandler evt: ${evt.value}\"\n\n\tif (!modeStart) {\n\t\treturn\n\t}\n\n\tdef isSpecifiedMode = (evt.value == modeStart)\n\tdef modeStopIsTrue = (modeStop && modeStop != \"false\")\n\n\tif (isSpecifiedMode && canStartAutomatically()) {\n\t\tstart(\"modeChange\")\n\t} else if (!isSpecifiedMode && modeStopIsTrue) {\n\t\tstop(\"modeChange\")\n\t}\n\n}\n\ndef stopDimmersHandler(evt) {\n\tlog.trace \"stopDimmersHandler evt: ${evt.value}\"\n\tdef percentComplete = completionPercentage()\n\t// Often times, the first thing we do is turn lights on or off so make sure we don't stop as soon as we start\n\tif (percentComplete > 2 && percentComplete < 98) {\n\t\tif (manualOverride == \"cancel\") {\n\t\t\tlog.debug \"STOPPING in stopDimmersHandler\"\n\t\t\tstop(\"manualOverride\")\n\t\t} else if (manualOverride == \"jumpTo\") {\n\t\t\tdef end = dynamicEndLevel()\n\t\t\tlog.debug \"Jumping to 99% complete in stopDimmersHandler\"\n\t\t\tjumpTo(99)\n\t\t}\n\n\t} else {\n\t\tlog.debug \"not stopping in stopDimmersHandler\"\n\t}\n}\n\n// ========================================================\n// Scheduling\n// ========================================================\n\ndef scheduledStart() {\n\tif (canStartAutomatically()) {\n\t\tstart(\"schedule\")\n\t}\n}\n\npublic def start(source) {\n\tlog.trace \"START\"\n\n\tsendStartEvent(source)\n\n\tsetLevelsInState()\n\n\tatomicState.running = true\n\tatomicState.runCounter = 0\n\n\tatomicState.start = new Date().getTime()\n\n\tschedule(\"0 * * * * ?\", \"healthCheck\")\n\tincrement()\n}\n\npublic def stop(source) {\n\tlog.trace \"STOP\"\n\n\tsendStopEvent(source)\n\n\tatomicState.running = false\n\tatomicState.start = 0\n\tatomicState.runCounter = 0\n\n\tunschedule(\"healthCheck\")\n}\n\nprivate healthCheck() {\n\tlog.trace \"'Gentle Wake Up' healthCheck\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tincrement()\n}\n\n// ========================================================\n// Controller\n// ========================================================\n\ndef sendStartEvent(source) {\n\tlog.trace \"sendStartEvent(${source})\"\n\tdef eventData = [\n\t\t\tname: \"sessionStatus\",\n\t\t\tvalue: \"running\",\n\t\t\tdescriptionText: \"${app.label} has started dimming\",\n\t\t\tdisplayed: true,\n\t\t\tlinkText: app.label,\n\t\t\tisStateChange: true\n\t]\n\tif (source == \"modeChange\") {\n\t\teventData.descriptionText += \" because of a mode change\"\n\t} else if (source == \"schedule\") {\n\t\teventData.descriptionText += \" as scheduled\"\n\t} else if (source == \"appTouch\") {\n\t\teventData.descriptionText += \" because you pressed play on the app\"\n\t} else if (source == \"controller\") {\n\t\teventData.descriptionText += \" because you pressed play on the controller\"\n\t}\n\n\tsendControllerEvent(eventData)\n}\n\ndef sendStopEvent(source) {\n\tlog.trace \"sendStopEvent(${source})\"\n\tdef eventData = [\n\t\t\tname: \"sessionStatus\",\n\t\t\tvalue: \"stopped\",\n\t\t\tdescriptionText: \"${app.label} has stopped dimming\",\n\t\t\tdisplayed: true,\n\t\t\tlinkText: app.label,\n\t\t\tisStateChange: true\n\t]\n\tif (source == \"modeChange\") {\n\t\teventData.descriptionText += \" because of a mode change\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"schedule\") {\n\t\teventData.descriptionText = \"${app.label} has finished dimming\"\n\t} else if (source == \"appTouch\") {\n\t\teventData.descriptionText += \" because you pressed play on the app\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"controller\") {\n\t\teventData.descriptionText += \" because you pressed stop on the controller\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"settingsChange\") {\n\t\teventData.descriptionText += \" because the settings have changed\"\n\t\teventData.value += \"cancelled\"\n\t} else if (source == \"manualOverride\") {\n\t\teventData.descriptionText += \" because the dimmer was manually turned off\"\n\t\teventData.value += \"cancelled\"\n\t}\n\n\t// send 100% completion event\n\tsendTimeRemainingEvent(100)\n\n\t// send a non-displayed 0% completion to reset tiles\n\tsendTimeRemainingEvent(0, false)\n\n\t// send sessionStatus event last so the event feed is ordered properly\n\tsendControllerEvent(eventData)\n}\n\ndef sendTimeRemainingEvent(percentComplete, displayed = true) {\n\tlog.trace \"sendTimeRemainingEvent(${percentComplete})\"\n\n\tdef percentCompleteEventData = [\n\t\t\tname: \"percentComplete\",\n\t\t\tvalue: percentComplete as int,\n\t\t\tdisplayed: displayed,\n\t\t\tisStateChange: true\n\t]\n\tsendControllerEvent(percentCompleteEventData)\n\n\tdef duration = sanitizeInt(duration, 30)\n\tdef timeRemaining = duration - (duration * (percentComplete / 100))\n\tdef timeRemainingEventData = [\n\t\t\tname: \"timeRemaining\",\n\t\t\tvalue: displayableTime(timeRemaining),\n\t\t\tdisplayed: displayed,\n\t\t\tisStateChange: true\n\t]\n\tsendControllerEvent(timeRemainingEventData)\n}\n\ndef sendControllerEvent(eventData) {\n\tdef controller = getController()\n\tif (controller) {\n\t\tcontroller.controllerEvent(eventData)\n\t}\n}\n\ndef getController() {\n\tdef dni = state.controllerDni\n\tif (!dni) {\n\t\tlog.warn \"no controller dni\"\n\t\treturn null\n\t}\n\tdef controller = getChildDevice(dni)\n\tif (!controller) {\n\t\tlog.warn \"no controller\"\n\t\treturn null\n\t}\n\tlog.debug \"controller: ${controller}\"\n\treturn controller\n}\n\n// ========================================================\n// Setting levels\n// ========================================================\n\n\nprivate increment() {\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tif (atomicState.runCounter == null) {\n\t\tatomicState.runCounter = 1\n\t} else {\n\t\tatomicState.runCounter = atomicState.runCounter + 1\n\t}\n\tdef percentComplete = completionPercentage()\n\n\tif (percentComplete > 99) {\n\t\tpercentComplete = 99\n\t}\n\n\tif (atomicState.runCounter > 100) {\n\t\tlog.error \"Force stopping Gentle Wakeup due to too many increments\"\n\t\t// If increment has already been called 100 times, then stop regardless of state\n\t\tpercentComplete = 100\n\t} else {\n\t\tupdateDimmers(percentComplete)\n\t}\n\tif (percentComplete < 99) {\n\n\t\tdef runAgain = stepDuration()\n\t\tlog.debug \"Rescheduling to run again in ${runAgain} seconds\"\n\n\t\trunIn(runAgain, 'increment', [overwrite: true])\n\n\t} else {\n\n\t\tint completionDelay = completionDelaySeconds()\n\t\tif (completionDelay) {\n\t\t\tlog.debug \"Finished with steps. Scheduling completion for ${completionDelay} second(s) from now\"\n\t\t\trunIn(completionDelay, 'completion', [overwrite: true])\n\t\t\tunschedule(\"healthCheck\")\n\t\t\t// don't let the health check start incrementing again while we wait for the delayed execution of completion\n\t\t} else {\n\t\t\tlog.debug \"Finished with steps. Execution completion\"\n\t\t\tcompletion()\n\t\t}\n\n\t}\n}\n\n\ndef updateDimmers(percentComplete) {\n\tdimmers.each { dimmer ->\n\n\t\tdef nextLevel = dynamicLevel(dimmer, percentComplete)\n\n\t\tif (nextLevel == 0) {\n\n\t\t\tdimmer.off()\n\n\t\t} else {\n\n\t\t\tdef shouldChangeColors = (colorize && colorize != \"false\")\n\n\t\t\tif (shouldChangeColors && hasSetColorCommand(dimmer)) {\n\t\t\t\tdef hue = getHue(dimmer, nextLevel)\n\t\t\t\tlog.debug \"Setting ${deviceLabel(dimmer)} level to ${nextLevel} and hue to ${hue}\"\n\t\t\t\tdimmer.setColor([hue: hue, saturation: 100, level: nextLevel])\n\t\t\t} else if (hasSetLevelCommand(dimmer)) {\n\t\t\t\tlog.debug \"Setting ${deviceLabel(dimmer)} level to ${nextLevel}\"\n\t\t\t\tdimmer.setLevel(nextLevel)\n\t\t\t} else {\n\t\t\t\tlog.warn \"${deviceLabel(dimmer)} does not have setColor or setLevel commands.\"\n\t\t\t}\n\n\t\t}\n\t}\n\n\tsendTimeRemainingEvent(percentComplete)\n}\n\nint dynamicLevel(dimmer, percentComplete) {\n\tdef start = atomicState.startLevels[dimmer.id]\n\tdef end = dynamicEndLevel()\n\n\tif (!percentComplete) {\n\t\treturn start\n\t}\n\n\tdef totalDiff = end - start\n\tdef actualPercentage = percentComplete / 100\n\tdef percentOfTotalDiff = totalDiff * actualPercentage\n\n\t(start + percentOfTotalDiff) as int\n}\n\n// ========================================================\n// Completion\n// ========================================================\n\nprivate completion() {\n\tlog.trace \"Starting completion block\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tstop(\"schedule\")\n\n\thandleCompletionSwitches()\n\n\thandleCompletionMessaging()\n\n\thandleCompletionModesAndPhrases()\n}\n\nprivate handleCompletionSwitches() {\n\tcompletionSwitches.each { completionSwitch ->\n\n\t\tdef isDimmer = hasSetLevelCommand(completionSwitch)\n\n\t\tif (completionSwitchesLevel && isDimmer) {\n\t\t\tcompletionSwitch.setLevel(completionSwitchesLevel)\n\t\t} else {\n\t\t\tdef command = completionSwitchesState ?: \"on\"\n\t\t\tcompletionSwitch.\"${command}\"()\n\t\t}\n\t}\n}\n\nprivate handleCompletionMessaging() {\n\tif (completionMessage) {\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(completionMessage, recipients)\n\t\t} else {\n\t\t\tif (completionPhoneNumber) {\n\t\t\t\tsendSms(completionPhoneNumber, completionMessage)\n\t\t\t}\n\t\t\tif (completionPush) {\n\t\t\t\tsendPush(completionMessage)\n\t\t\t}\n\t\t}\n\t\tif (completionMusicPlayer) {\n\t\t\tspeak(completionMessage)\n\t\t}\n\t}\n}\n\nprivate handleCompletionModesAndPhrases() {\n\n\tif (completionMode) {\n\t\tsetLocationMode(completionMode)\n\t}\n\n\tif (completionPhrase) {\n\t\tlocation.helloHome.execute(completionPhrase)\n\t}\n\n}\n\ndef speak(message) {\n\tdef sound = textToSpeech(message)\n\tdef soundDuration = (sound.duration as Integer) + 2\n\tlog.debug \"Playing $sound.uri\"\n\tcompletionMusicPlayer.playTrack(sound.uri)\n\tlog.debug \"Scheduled resume in $soundDuration sec\"\n\trunIn(soundDuration, resumePlaying, [overwrite: true])\n}\n\ndef resumePlaying() {\n\tlog.trace \"resumePlaying()\"\n\tdef sonos = completionMusicPlayer\n\tif (sonos) {\n\t\tdef currentTrack = sonos.currentState(\"trackData\").jsonValue\n\t\tif (currentTrack.status == \"playing\") {\n\t\t\tsonos.playTrack(currentTrack)\n\t\t} else {\n\t\t\tsonos.setTrack(currentTrack)\n\t\t}\n\t}\n}\n\n// ========================================================\n// Helpers\n// ========================================================\n\ndef setLevelsInState() {\n\tdef startLevels = [:]\n\tdimmers.each { dimmer ->\n\t\tif (usesOldSettings()) {\n\t\t\tstartLevels[dimmer.id] = defaultStart()\n\t\t} else if (hasStartLevel()) {\n\t\t\tstartLevels[dimmer.id] = startLevel\n\t\t} else {\n\t\t\tdef dimmerIsOff = dimmer.currentValue(\"switch\") == \"off\"\n\t\t\tstartLevels[dimmer.id] = dimmerIsOff ? 0 : dimmer.currentValue(\"level\")\n\t\t}\n\t}\n\n\tatomicState.startLevels = startLevels\n}\n\ndef canStartAutomatically() {\n\n\tdef today = new Date().format(\"EEEE\")\n\tlog.debug \"today: ${today}, days: ${days}\"\n\n\tif (!days || days.contains(today)) {// if no days, assume every day\n\t\treturn true\n\t}\n\n\tlog.trace \"should not run\"\n\treturn false\n}\n\ndef completionPercentage() {\n\tlog.trace \"checkingTime\"\n\n\tif (!atomicState.running) {\n\t\treturn\n\t}\n\n\tdef now = new Date().getTime()\n\tdef timeElapsed = now - atomicState.start\n\tdef totalRunTime = totalRunTimeMillis() ?: 1\n\tdef percentComplete = timeElapsed / totalRunTime * 100\n\tlog.debug \"percentComplete: ${percentComplete}\"\n\n\treturn percentComplete\n}\n\nint totalRunTimeMillis() {\n\tint minutes = sanitizeInt(duration, 30)\n\tconvertToMillis(minutes)\n}\n\nint convertToMillis(minutes) {\n\tdef seconds = minutes * 60\n\tdef millis = seconds * 1000\n\treturn millis\n}\n\ndef timeRemaining(percentComplete) {\n\tdef normalizedPercentComplete = percentComplete / 100\n\tdef duration = sanitizeInt(duration, 30)\n\tdef timeElapsed = duration * normalizedPercentComplete\n\tdef timeRemaining = duration - timeElapsed\n\treturn timeRemaining\n}\n\nint millisToEnd(percentComplete) {\n\tconvertToMillis(timeRemaining(percentComplete))\n}\n\nString displayableTime(timeRemaining) {\n\tdef timeString = \"${timeRemaining}\"\n\tdef parts = timeString.split(/\\./)\n\tif (!parts.size()) {\n\t\treturn \"0:00\"\n\t}\n\tdef minutes = parts[0]\n\tif (parts.size() == 1) {\n\t\treturn \"${minutes}:00\"\n\t}\n\tdef fraction = \"0.${parts[1]}\" as double\n\tdef seconds = \"${60 * fraction as int}\".padLeft(2, \"0\")\n\treturn \"${minutes}:${seconds}\"\n}\n\ndef jumpTo(percentComplete) {\n\tdef millisToEnd = millisToEnd(percentComplete)\n\tdef endTime = new Date().getTime() + millisToEnd\n\tdef duration = sanitizeInt(duration, 30)\n\tdef durationMillis = convertToMillis(duration)\n\tdef shiftedStart = endTime - durationMillis\n\tatomicState.start = shiftedStart\n\tupdateDimmers(percentComplete)\n\tsendTimeRemainingEvent(percentComplete)\n}\n\n\nint dynamicEndLevel() {\n\tif (usesOldSettings()) {\n\t\tif (direction && direction == \"Down\") {\n\t\t\treturn 0\n\t\t}\n\t\treturn 99\n\t}\n\treturn endLevel as int\n}\n\ndef getHue(dimmer, level) {\n\tdef start = atomicState.startLevels[dimmer.id] as int\n\tdef end = dynamicEndLevel()\n\tif (start > end) {\n\t\treturn getDownHue(level)\n\t} else {\n\t\treturn getUpHue(level)\n\t}\n}\n\ndef getUpHue(level) {\n\tgetBlueHue(level)\n}\n\ndef getDownHue(level) {\n\tgetRedHue(level)\n}\n\nprivate getBlueHue(level) {\n\tif (level < 5) return 72\n\tif (level < 10) return 71\n\tif (level < 15) return 70\n\tif (level < 20) return 69\n\tif (level < 25) return 68\n\tif (level < 30) return 67\n\tif (level < 35) return 66\n\tif (level < 40) return 65\n\tif (level < 45) return 64\n\tif (level < 50) return 63\n\tif (level < 55) return 62\n\tif (level < 60) return 61\n\tif (level < 65) return 60\n\tif (level < 70) return 59\n\tif (level < 75) return 58\n\tif (level < 80) return 57\n\tif (level < 85) return 56\n\tif (level < 90) return 55\n\tif (level < 95) return 54\n\tif (level >= 95) return 53\n}\n\nprivate getRedHue(level) {\n\tif (level < 6) return 1\n\tif (level < 12) return 2\n\tif (level < 18) return 3\n\tif (level < 24) return 4\n\tif (level < 30) return 5\n\tif (level < 36) return 6\n\tif (level < 42) return 7\n\tif (level < 48) return 8\n\tif (level < 54) return 9\n\tif (level < 60) return 10\n\tif (level < 66) return 11\n\tif (level < 72) return 12\n\tif (level < 78) return 13\n\tif (level < 84) return 14\n\tif (level < 90) return 15\n\tif (level < 96) return 16\n\tif (level >= 96) return 17\n}\n\nprivate dimmersContainUnsupportedDevices() {\n\tdef found = dimmers.find { hasSetLevelCommand(it) == false }\n\treturn found != null\n}\n\nprivate hasSetLevelCommand(device) {\n\treturn hasCommand(device, \"setLevel\")\n}\n\nprivate hasSetColorCommand(device) {\n\treturn hasCommand(device, \"setColor\")\n}\n\nprivate hasCommand(device, String command) {\n\treturn (device.supportedCommands.find { it.name == command } != null)\n}\n\nprivate dimmersWithSetColorCommand() {\n\tdef colorDimmers = []\n\tdimmers.each { dimmer ->\n\t\tif (hasSetColorCommand(dimmer)) {\n\t\t\tcolorDimmers << dimmer\n\t\t}\n\t}\n\treturn colorDimmers\n}\n\nprivate int sanitizeInt(i, int defaultValue = 0) {\n\ttry {\n\t\tif (!i) {\n\t\t\treturn defaultValue\n\t\t} else {\n\t\t\treturn i as int\n\t\t}\n\t}\n\tcatch (Exception e) {\n\t\tlog.debug e\n\t\treturn defaultValue\n\t}\n}\n\nprivate completionDelaySeconds() {\n\tint completionDelayMinutes = sanitizeInt(completionDelay)\n\tint completionDelaySeconds = (completionDelayMinutes * 60)\n\treturn completionDelaySeconds ?: 0\n}\n\nprivate stepDuration() {\n\tint minutes = sanitizeInt(duration, 30)\n\tint stepDuration = (minutes * 60) / 100\n\treturn stepDuration ?: 1\n}\n\nprivate debug(message) {\n\tlog.debug \"${message}\\nstate: ${state}\"\n}\n\npublic smartThingsDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" }\n\npublic humanReadableStartDate() {\n\tnew Date().parse(smartThingsDateFormat(), startTime).format(\"h:mm a\", timeZone(startTime))\n}\n\ndef fancyString(listOfStrings) {\n\n\tdef fancify = { list ->\n\t\treturn list.collect {\n\t\t\tdef label = it\n\t\t\tif (list.size() > 1 && it == list[-1]) {\n\t\t\t\tlabel = \"and ${label}\"\n\t\t\t}\n\t\t\tlabel\n\t\t}.join(\", \")\n\t}\n\n\treturn fancify(listOfStrings)\n}\n\ndef fancyDeviceString(devices = []) {\n\tfancyString(devices.collect { deviceLabel(it) })\n}\n\ndef deviceLabel(device) {\n\treturn device.label ?: device.name\n}\n\ndef schedulingHrefDescription() {\n\n\tdef descriptionParts = []\n\tif (days) {\n\t\tif (days == weekdays()) {\n\t\t\tdescriptionParts << \"On weekdays,\"\n\t\t} else if (days == weekends()) {\n\t\t\tdescriptionParts << \"On weekends,\"\n\t\t} else {\n\t\t\tdescriptionParts << \"On ${fancyString(days)},\"\n\t\t}\n\t}\n\n\tdescriptionParts << \"${fancyDeviceString(dimmers)} will start dimming\"\n\n\tif (startTime) {\n\t\tdescriptionParts << \"at ${humanReadableStartDate()}\"\n\t}\n\n\tif (modeStart) {\n\t\tif (startTime) {\n\t\t\tdescriptionParts << \"or\"\n\t\t}\n\t\tdescriptionParts << \"when ${location.name} enters '${modeStart}' mode\"\n\t}\n\n\tif (descriptionParts.size() <= 1) {\n\t\t// dimmers will be in the list no matter what. No rules are set if only dimmers are in the list\n\t\treturn null\n\t}\n\n\treturn descriptionParts.join(\" \")\n}\n\ndef completionHrefDescription() {\n\n\tdef descriptionParts = []\n\tdef example = \"Switch1 will be turned on. Switch2, Switch3, and Switch4 will be dimmed to 50%. The message '<message>' will be spoken, sent as a text, and sent as a push notification. The mode will be changed to '<mode>'. The phrase '<phrase>' will be executed\"\n\n\tif (completionSwitches) {\n\t\tdef switchesList = []\n\t\tdef dimmersList = []\n\n\n\t\tcompletionSwitches.each {\n\t\t\tdef isDimmer = completionSwitchesLevel ? hasSetLevelCommand(it) : false\n\n\t\t\tif (isDimmer) {\n\t\t\t\tdimmersList << deviceLabel(it)\n\t\t\t}\n\n\t\t\tif (!isDimmer) {\n\t\t\t\tswitchesList << deviceLabel(it)\n\t\t\t}\n\t\t}\n\n\n\t\tif (switchesList) {\n\t\t\tdescriptionParts << \"${fancyString(switchesList)} will be turned ${completionSwitchesState ?: 'on'}.\"\n\t\t}\n\n\t\tif (dimmersList) {\n\t\t\tdescriptionParts << \"${fancyString(dimmersList)} will be dimmed to ${completionSwitchesLevel}%.\"\n\t\t}\n\n\t}\n\n\tif (completionMessage && (completionPhoneNumber || completionPush || completionMusicPlayer)) {\n\t\tdef messageParts = []\n\n\t\tif (completionMusicPlayer) {\n\t\t\tmessageParts << \"spoken\"\n\t\t}\n\t\tif (completionPhoneNumber) {\n\t\t\tmessageParts << \"sent as a text\"\n\t\t}\n\t\tif (completionPush) {\n\t\t\tmessageParts << \"sent as a push notification\"\n\t\t}\n\n\t\tdescriptionParts << \"The message '${completionMessage}' will be ${fancyString(messageParts)}.\"\n\t}\n\n\tif (completionMode) {\n\t\tdescriptionParts << \"The mode will be changed to '${completionMode}'.\"\n\t}\n\n\tif (completionPhrase) {\n\t\tdescriptionParts << \"The phrase '${completionPhrase}' will be executed.\"\n\t}\n\n\treturn descriptionParts.join(\" \")\n}\n\ndef numbersPageHrefDescription() {\n\tdef title = \"All dimmers will dim for ${duration ?: '30'} minutes from ${startLevelLabel()} to ${endLevelLabel()}\"\n\tif (colorize) {\n\t\tdef colorDimmers = dimmersWithSetColorCommand()\n\t\tif (colorDimmers == dimmers) {\n\t\t\ttitle += \" and will gradually change color.\"\n\t\t} else {\n\t\t\ttitle += \".\\n${fancyDeviceString(colorDimmers)} will gradually change color.\"\n\t\t}\n\t}\n\treturn title\n}\n\ndef hueSatToHex(h, s) {\n\tdef convertedRGB = hslToRgb(h, s, 0.5)\n\treturn rgbToHex(convertedRGB)\n}\n\ndef hslToRgb(h, s, l) {\n\tdef r, g, b;\n\n\tif (s == 0) {\n\t\tr = g = b = l; // achromatic\n\t} else {\n\t\tdef hue2rgb = { p, q, t ->\n\t\t\tif (t < 0) t += 1;\n\t\t\tif (t > 1) t -= 1;\n\t\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\t\tif (t < 1 / 2) return q;\n\t\t\tif (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n\t\t\treturn p;\n\t\t}\n\n\t\tdef q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\tdef p = 2 * l - q;\n\n\t\tr = hue2rgb(p, q, h + 1 / 3);\n\t\tg = hue2rgb(p, q, h);\n\t\tb = hue2rgb(p, q, h - 1 / 3);\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n}\n\ndef rgbToHex(red, green, blue) {\n\tdef toHex = {\n\t\tint n = it as int;\n\t\tn = Math.max(0, Math.min(n, 255));\n\t\tdef hexOptions = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n\n\t\tdef firstDecimal = ((n - n % 16) / 16) as int\n\t\tdef secondDecimal = (n % 16) as int\n\n\t\treturn \"${hexOptions[firstDecimal]}${hexOptions[secondDecimal]}\"\n\t}\n\n\tdef rgbToHex = { r, g, b ->\n\t\treturn toHex(r) + toHex(g) + toHex(b)\n\t}\n\n\treturn rgbToHex(red, green, blue)\n}\n\ndef usesOldSettings() {\n\t!hasEndLevel()\n}\n\ndef hasStartLevel() {\n\treturn (startLevel != null && startLevel != \"\")\n}\n\ndef hasEndLevel() {\n\treturn (endLevel != null && endLevel != \"\")\n}",
        "docstring": "Dim your lights up slowly, allowing you to wake up more naturally."
    },
    {
        "code": "section(\"For this amount of time\") {\n\t\tinput \"minutes\", \"number\", title: \"Minutes?\"\n\t}\n\tsection(\"After this time of day\") {\n\t\tinput \"timeOfDay\", \"time\", title: \"Time?\"\n\t}\n\tsection(\"And (optionally) these switches are all off\") {\n\t\tinput \"switches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"Change to this mode\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n\tsection( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phoneNumber\", \"phone\", title: \"Send a Text Message?\", required: false\n        }\n\t}\n\n}\n\ndef installed() {\n\tlog.debug \"Current mode = ${location.mode}\"\n\tcreateSubscriptions()\n}\n\ndef updated() {\n\tlog.debug \"Current mode = ${location.mode}\"\n\tunsubscribe()\n\tcreateSubscriptions()\n}\n\ndef createSubscriptions()\n{\n\tsubscribe(motionSensors, \"motion.active\", motionActiveHandler)\n\tsubscribe(motionSensors, \"motion.inactive\", motionInactiveHandler)\n\tsubscribe(switches, \"switch.off\", switchOffHandler)\n\tsubscribe(location, modeChangeHandler)\n\n\tif (state.modeStartTime == null) {\n\t\tstate.modeStartTime = 0\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tstate.modeStartTime = now()\n}\n\ndef switchOffHandler(evt) {\n\tif (correctMode() && correctTime()) {\n\t\tif (allQuiet() && switchesOk()) {\n\t\t\ttakeActions()\n\t\t}\n\t}\n}\n\ndef motionActiveHandler(evt)\n{\n\tlog.debug \"Motion active\"\n}\n\ndef motionInactiveHandler(evt)\n{\n\t// for backward compatibility\n\tif (state.modeStartTime == null) {\n\t\tsubscribe(location, modeChangeHandler)\n\t\tstate.modeStartTime = 0\n\t}\n\n\tif (correctMode() && correctTime()) {\n\t\trunIn(minutes * 60, scheduleCheck, [overwrite: false])\n\t}\n}\n\ndef scheduleCheck()\n{\n\tlog.debug \"scheduleCheck, currentMode = ${location.mode}, newMode = $newMode\"\n\t\n\tif (correctMode() && correctTime()) {\n\t\tif (allQuiet() && switchesOk()) {\n\t\t\ttakeActions()\n\t\t}\n\t}\n}\n\nprivate takeActions() {\n\tdef message = \"Goodnight! SmartThings changed the mode to '$newMode'\"\n\tsend(message)\n\tsetLocationMode(newMode)\n\tlog.debug message\n}\n\nprivate correctMode() {\n\tif (location.mode != newMode) {\n\t\ttrue\n\t} else {\n\t\tlog.debug \"Location is already in the desired mode:  doing nothing\"\n\t\tfalse\n\t}\n}\n\nprivate correctTime() {\n\tdef t0 = now()\n\tdef modeStartTime = new Date(state.modeStartTime)\n\tdef startTime = timeTodayAfter(modeStartTime, timeOfDay, location.timeZone)\n\tif (t0 >= startTime.time) {\n\t\ttrue\n\t} else {\n\t\tlog.debug \"The current time of day (${new Date(t0)}), is not in the correct time window ($startTime):  doing nothing\"\n\t\tfalse\n\t}\n}\n\nprivate switchesOk() {\n\tdef result = true\n\tfor (it in (switches ?: [])) {\n\t\tif (it.currentSwitch == \"on\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"Switches are all off: $result\"\n\tresult\n}\n\nprivate allQuiet() {\n\tdef threshold = 1000 * 60 * minutes - 1000\n\tdef states = motionSensors.collect { it.currentState(\"motion\") ?: [:] }.sort { a, b -> b.dateCreated <=> a.dateCreated }\n\tif (states) {\n\t\tif (states.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"Found active state\"\n\t\t\tfalse\n\t\t} else {\n\t\t\tdef sensor = states.first()\n\t\t    def elapsed = now() - sensor.rawDateCreated.time\n\t\t\tif (elapsed >= threshold) {\n\t\t\t\tlog.debug \"No active states, and enough time has passed\"\n\t\t\t\ttrue\n\t\t\t} else {\n\t\t\t\tlog.debug \"No active states, but not enough time has passed\"\n\t\t\t\tfalse\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"No states to check for activity\"\n\t\ttrue\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}",
        "docstring": "Changes mode when motion ceases after a specific time of night."
    },
    {
        "code": "section(\"Change to this mode\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n\tsection(\"False alarm threshold (defaults to 10 min)\") {\n\t\tinput \"falseAlarmThreshold\", \"decimal\", title: \"Number of minutes\", required: false\n\t}\n\tsection( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phone\", \"phone\", title: \"Send a Text Message?\", required: false\n        }\n\t}\n\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\t// log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\t// log.debug \"Current mode = ${location.mode}, people = ${people.collect{it.label + ': ' + it.currentPresence}}\"\n\tunsubscribe()\n\tsubscribe(people, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tlog.debug \"evt.name: $evt.value\"\n\tdef threshold = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? (falseAlarmThreshold * 60 * 1000) as Long : 10 * 60 * 1000L\n\n\tif (location.mode != newMode) {\n\n\t\tdef t0 = new Date(now() - threshold)\n\t\tif (evt.value == \"present\") {\n\n\t\t\tdef person = getPerson(evt)\n\t\t\tdef recentNotPresent = person.statesSince(\"presence\", t0).find{it.value == \"not present\"}\n\t\t\tif (recentNotPresent) {\n\t\t\t\tlog.debug \"skipping notification of arrival of Person because last departure was only ${now() - recentNotPresent.date.time} msec ago\"\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdef message = \"${person.displayName} arrived at home, changing mode to '${newMode}'\"\n\t\t\t\tsend(message)\n\t\t\t\tsetLocationMode(newMode)\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"mode is the same, not evaluating\"\n\t}\n}\n\nprivate getPerson(evt)\n{\n\tpeople.find{evt.deviceId == it.id}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone) {\n            log.debug(\"sending text message\")\n            sendSms(phone, msg)\n        }\n    }\n}",
        "docstring": "Monitors a set of presence detectors and triggers a mode change when someone arrives at home."
    },
    {
        "code": "section(\"At what time?\"){\n\t\tinput \"time1\", \"time\", title: \"When?\"\n\t}\n\tsection(\"Text me at...\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledCheck\"\n\n\tdef message = message1 ?: \"SmartThings - Habit Helper Reminder!\"\n\n    if (location.contactBookEnabled) {\n        log.debug \"Texting reminder to contacts:${recipients?.size()}\"\n        sendNotificationToContacts(message, recipients)\n    }\n    else {\n        log.debug \"Texting reminder\"\n        sendSms(phone1, message)\n    }\n}",
        "docstring": "Add something you want to be reminded about each day and get a text message to help you form positive habits."
    },
    {
        "code": "section(\"Feed my pet at...\") {\n\t\tinput \"time1\", \"time\", title: \"When?\"\n\t}\n\tsection(\"Text me if I forget...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed()\n{\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated()\n{\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tlog.trace \"scheduledCheck\"\n\n\tdef midnight = (new Date()).clearTime()\n\tdef now = new Date()\n\tdef feederEvents = feeder1.eventsBetween(midnight, now)\n\tlog.trace \"Found ${feederEvents?.size() ?: 0} feeder events since $midnight\"\n\tdef feederOpened = feederEvents.count { it.value && it.value == \"open\" } > 0\n\n\tif (feederOpened) {\n\t\tlog.debug \"Feeder was opened since $midnight, no SMS required\"\n\t} else {\n        if (location.contactBookEnabled) {\n            log.debug \"Feeder was not opened since $midnight, texting contacts:${recipients?.size()}\"\n            sendNotificationToContacts(\"No one has fed the dog\", recipients)\n        }\n        else {\n            log.debug \"Feeder was not opened since $midnight, texting one phone number\"\n            sendSms(phone1, \"No one has fed the dog\")\n        }\n\t}\n}",
        "docstring": "Setup a schedule to be reminded to feed your pet. Purchase any SmartThings certified pet food feeder and install the Feed My Pet app, and set the time. You and your pet are ready to go. Your life just got smarter."
    },
    {
        "code": "section(\"Last Registration Details\") {\n\t\t\tif(hub && registerDate) {\n\t\t\t\t   paragraph \"\"\"Your hub last registered with IP:\n$currentIp\non:\n$registerDate\"\"\"\n\t\t\t} else if (hub && !registerDate) {\n\t\t\t\tparagraph \"Your hub has not (re)registered since you installed this app\"\n\t\t\t} else {\n\t\t\t\tparagraph \"Check back here after installing to see the current IP of your hub\"\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(hub, \"hubInfo\", registrationHandler, [filterEvents: false])\n}\n\ndef registrationHandler(evt) {\n\tdef hubInfo = evt.description.split(',').inject([:]) { map, token ->\n\t\ttoken.split(':').with { map[it[0].trim()] = it[1] }\n\t\tmap\n\t}\n\tstate.localip = hubInfo.localip\n\tstate.lastRegister = new Date()\n\tsendNotificationEvent(\"${hub.name} registered in prod with IP: ${hubInfo.localip}\")\n}",
        "docstring": "Listen for local IP changes when your hub registers."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"Set the lighting mood when...\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tsection(anythingSet ? \"Select additional mood lighting triggers\" : \"Set the lighting mood when...\", hideable: anythingSet, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", description: \"Select mode(s)\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection(\"Control these bulbs...\") {\n\t\t\tinput \"hues\", \"capability.colorControl\", title: \"Which Hue Bulbs?\", required:true, multiple:true\n\t\t}\n\t\tsection(\"Choose light effects...\")\n\t\t\t{\n\t\t\t\tinput \"color\", \"enum\", title: \"Hue Color?\", required: false, multiple:false, options: [\n\t\t\t\t\t[\"Soft White\":\"Soft White - Default\"],\n\t\t\t\t\t[\"White\":\"White - Concentrate\"],\n\t\t\t\t\t[\"Daylight\":\"Daylight - Energize\"],\n\t\t\t\t\t[\"Warm White\":\"Warm White - Relax\"],\n\t\t\t\t\t\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Purple\",\"Pink\"]\n\t\t\t\tinput \"lightLevel\", \"enum\", title: \"Light Level?\", required: false, options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]]\n\t\t\t}\n\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}\n\t}\n}\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt=null) {\n\tlog.trace \"Executing Mood Lighting\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\tlog.trace \"scheduledTimeHandler()\"\n\teventHandler()\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\n\tdef hueColor = 0\n\tdef saturation = 100\n\n\tswitch(color) {\n\t\tcase \"White\":\n\t\t\thueColor = 52\n\t\t\tsaturation = 19\n\t\t\tbreak;\n\t\tcase \"Daylight\":\n\t\t\thueColor = 53\n\t\t\tsaturation = 91\n\t\t\tbreak;\n\t\tcase \"Soft White\":\n\t\t\thueColor = 23\n\t\t\tsaturation = 56\n\t\t\tbreak;\n\t\tcase \"Warm White\":\n\t\t\thueColor = 20\n\t\t\tsaturation = 80 //83\n\t\t\tbreak;\n\t\tcase \"Blue\":\n\t\t\thueColor = 70\n\t\t\tbreak;\n\t\tcase \"Green\":\n\t\t\thueColor = 39\n\t\t\tbreak;\n\t\tcase \"Yellow\":\n\t\t\thueColor = 25\n\t\t\tbreak;\n\t\tcase \"Orange\":\n\t\t\thueColor = 10\n\t\t\tbreak;\n\t\tcase \"Purple\":\n\t\t\thueColor = 75\n\t\t\tbreak;\n\t\tcase \"Pink\":\n\t\t\thueColor = 83\n\t\t\tbreak;\n\t\tcase \"Red\":\n\t\t\thueColor = 100\n\t\t\tbreak;\n\t}\n\n\tstate.previous = [:]\n\n\thues.each {\n\t\tstate.previous[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\")\n\t\t]\n\t}\n\n\tlog.debug \"current values = $state.previous\"\n\n\tdef newValue = [hue: hueColor, saturation: saturation, level: lightLevel as Integer ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result - $lastTime\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Sets the colors and brightness level of your Philips Hue lights to match your mood."
    },
    {
        "code": "}\n\nmappings {\n\n\tpath(\"/:deviceType\") {\n\t\taction: [\n\t\t\tGET: \"list\"\n\t\t]\n\t}\n\tpath(\"/:deviceType/states\") {\n\t\taction: [\n\t\t\tGET: \"listStates\"\n\t\t]\n\t}\n\tpath(\"/:deviceType/subscription\") {\n\t\taction: [\n\t\t\tPOST: \"addSubscription\"\n\t\t]\n\t}\n\tpath(\"/:deviceType/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removeSubscription\"\n\t\t]\n\t}\n\tpath(\"/:deviceType/:id\") {\n\t\taction: [\n\t\t\tGET: \"show\",\n\t\t\tPUT: \"update\"\n\t\t]\n\t}\n\tpath(\"/subscriptions\") {\n\t\taction: [\n\t\t\tGET: \"listSubscriptions\"\n\t\t]\n\t}\n}\n\ndef installed() {\n\t//log.debug settings\n}\n\ndef updated() {\n\tdef currentDeviceIds = settings.collect { k, devices -> devices }.flatten().collect { it.id }.unique()\n\tdef subscriptionDevicesToRemove = app.subscriptions*.device.findAll { device ->\n\t\t!currentDeviceIds.contains(device.id)\n\t}\n\tsubscriptionDevicesToRemove.each { device ->\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\t//log.debug settings\n}\n\ndef list() {\n\t//log.debug \"[PROD] list, params: ${params}\"\n\tdef type = params.deviceType\n\tsettings[type]?.collect{deviceItem(it)} ?: []\n}\n\ndef listStates() {\n\tlog.debug \"[PROD] states, params: ${params}\"\n\tdef type = params.deviceType\n\tdef attributeName = attributeFor(type)\n\tsettings[type]?.collect{deviceState(it, it.currentState(attributeName))} ?: []\n}\n\ndef listSubscriptions() {\n\tstate\n}\n\ndef update() {\n\tdef type = params.deviceType\n\tdef data = request.JSON\n\tdef devices = settings[type]\n\tdef device = settings[type]?.find { it.id == params.id }\n\tdef command = data.command\n\n\t//log.debug \"[PROD] update, params: ${params}, request: ${data}, devices: ${devices*.id}\"\n\t\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t} \n\t\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"alarms\":\n\t\t\treturn \"Alarm\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n\ndef show() {\n\tdef type = params.deviceType\n\tdef devices = settings[type]\n\tdef device = devices.find { it.id == params.id }\n\n\t//log.debug \"[PROD] show, params: ${params}, devices: ${devices*.id}\"\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse {\n\t\tdef attributeName = attributeFor(type)\n\t\tdef s = device.currentState(attributeName)\n\t\tdeviceState(device, s)\n\t}\n}\n\ndef addSubscription() {\n\tlog.debug \"[PROD] addSubscription1\"\n\tdef type = params.deviceType\n\tdef data = request.JSON\n\tdef attribute = attributeFor(type)\n\tdef devices = settings[type]\n\tdef deviceId = data.deviceId\n\tdef callbackUrl = data.callbackUrl\n\tdef device = devices.find { it.id == deviceId }\n\n\t//log.debug \"[PROD] addSubscription, params: ${params}, request: ${data}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Adding switch subscription \" + callbackUrl\n\t\tstate[deviceId] = [callbackUrl: callbackUrl]\n\t\tsubscribe(device, attribute, deviceHandler)\n\t}\n\t//log.info state\n\n}\n\ndef removeSubscription() {\n\tdef type = params.deviceType\n\tdef devices = settings[type]\n\tdef deviceId = params.id\n\tdef device = devices.find { it.id == deviceId }\n\n\t//log.debug \"[PROD] removeSubscription, params: ${params}, request: ${data}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\t//log.info state\n}\n\ndef deviceHandler(evt) {\n\tdef deviceInfo = state[evt.deviceId]\n\tif (deviceInfo) {\n\t\ttry {\n\t\t\thttpPostJson(uri: deviceInfo.callbackUrl, path: '',  body: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]) {\n\t\t\t\tlog.debug \"[PROD IFTTT] Event data successfully posted\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.ResponseParseException e) {\n\t\t\tlog.error(\"Error parsing ifttt payload ${e}\")\n\t\t}\n\t} else {\n\t\tlog.debug \"[PROD] No subscribed device found\"\n\t}\n}\n\nprivate deviceItem(it) {\n\tit ? [id: it.id, label: it.displayName] : null\n}\n\nprivate deviceState(device, s) {\n\tdevice && s ? [id: device.id, label: device.displayName, name: s.name, value: s.value, unixTime: s.date.time] : null\n}\n\nprivate attributeFor(type) {\n\tswitch (type) {\n\t\tcase \"switches\":\n\t\t\tlog.debug \"[PROD] switch type\"\n\t\t\treturn \"switch\"\n\t\tcase \"locks\":\n\t\t\tlog.debug \"[PROD] lock type\"\n\t\t\treturn \"lock\"\n\t\tcase \"alarms\":\n\t\t\tlog.debug \"[PROD] alarm type\"\n\t\t\treturn \"alarm\"\n\t\tcase \"lightSensors\":\n\t\t\tlog.debug \"[PROD] illuminance type\"\n\t\t\treturn \"illuminance\"\n\t\tdefault:\n\t\t\tlog.debug \"[PROD] other sensor type\"\n\t\t\treturn type - \"Sensors\"\n\t}\n}",
        "docstring": "Put the internet to work for you."
    },
    {
        "code": "section(\"Text me at...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\t// Don't send a continuous stream of text messages\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t} else {\n        if (location.contactBookEnabled) {\n            log.debug \"accelerationSensor has moved, texting contacts: ${recipients?.size()}\"\n            sendNotificationToContacts(\"${accelerationSensor.label ?: accelerationSensor.name} moved\", recipients)\n        }\n        else {\n            log.debug \"accelerationSensor has moved, sending text message\"\n            sendSms(phone1, \"${accelerationSensor.label ?: accelerationSensor.name} moved\")\n        }\n\t}\n}",
        "docstring": "Send a text when movement is detected"
    },
    {
        "code": "section(\"When the temperature drops below...\") {\n\t\tinput \"temperature1\", \"number\", title: \"Temperature?\"\n\t}\n    section( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phone1\", \"phone\", title: \"Send a Text Message?\", required: false\n        }\n    }\n\tsection(\"Turn on a heater...\") {\n\t\tinput \"switch1\", \"capability.switch\", required: false\n\t}\n}\n\ndef installed() {\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(evt) {\n\tlog.trace \"temperature: $evt.value, $evt\"\n\n\tdef tooCold = temperature1\n\tdef mySwitch = settings.switch1\n\n\t// TODO: Replace event checks with internal state (the most reliable way to know if an SMS has been sent recently or not).\n\tif (evt.doubleValue <= tooCold) {\n\t\tlog.debug \"Checking how long the temperature sensor has been reporting <= $tooCold\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 // TODO: Ask for \"retry interval\" in prefs?\n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll { it.name == \"temperature\" }\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms = recentEvents.count { it.doubleValue <= tooCold } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaMinutes minutes\"\n\t\t\t// TODO: Send \"Temperature back to normal\" SMS, turn switch off\n\t\t} else {\n\t\t\tlog.debug \"Temperature dropped below $tooCold:  sending SMS and activating $mySwitch\"\n\t\t\tdef tempScale = location.temperatureScale ?: \"F\"\n\t\t\tsend(\"${temperatureSensor1.displayName} is too cold, reporting a temperature of ${evt.value}${evt.unit?:tempScale}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone1) {\n            log.debug(\"sending text message\")\n            sendSms(phone1, msg)\n        }\n    }\n\n    log.debug msg\n}",
        "docstring": "Monitor the temperature and when it drops below your setting get a text and/or turn on a heater or additional appliance."
    },
    {
        "code": "section(\"When the temperature rises above...\") {\n\t\tinput \"temperature1\", \"number\", title: \"Temperature?\"\n\t}\n    section( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phone1\", \"phone\", title: \"Send a Text Message?\", required: false\n        }\n    }\n\tsection(\"Turn on which A/C or fan...\") {\n\t\tinput \"switch1\", \"capability.switch\", required: false\n\t}\n}\n\ndef installed() {\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(temperatureSensor1, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(evt) {\n\tlog.trace \"temperature: $evt.value, $evt\"\n\n\tdef tooHot = temperature1\n\tdef mySwitch = settings.switch1\n\n\t// TODO: Replace event checks with internal state (the most reliable way to know if an SMS has been sent recently or not).\n\tif (evt.doubleValue >= tooHot) {\n\t\tlog.debug \"Checking how long the temperature sensor has been reporting <= $tooHot\"\n\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaMinutes = 10 // TODO: Ask for \"retry interval\" in prefs?\n\t\tdef timeAgo = new Date(now() - (1000 * 60 * deltaMinutes).toLong())\n\t\tdef recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll { it.name == \"temperature\" }\n\t\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\tdef alreadySentSms = recentEvents.count { it.doubleValue >= tooHot } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaMinutes minutes\"\n\t\t\t// TODO: Send \"Temperature back to normal\" SMS, turn switch off\n\t\t} else {\n\t\t\tlog.debug \"Temperature rose above $tooHot:  sending SMS and activating $mySwitch\"\n\t\t\tdef tempScale = location.temperatureScale ?: \"F\"\n\t\t\tsend(\"${temperatureSensor1.displayName} is too hot, reporting a temperature of ${evt.value}${evt.unit?:tempScale}\")\n\t\t\tswitch1?.on()\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phone1) {\n            log.debug(\"sending text message\")\n            sendSms(phone1, msg)\n        }\n    }\n\n    log.debug msg\n}",
        "docstring": "Monitor the temperature and when it rises above your setting get a notification and/or turn on an A/C unit or fan."
    },
    {
        "code": "section(\"Heat setting...\" ) {\n\t\tinput \"heatingSetpoint\", \"decimal\", title: \"Degrees\"\n\t}\n\tsection(\"Air conditioning setting...\") {\n\t\tinput \"coolingSetpoint\", \"decimal\", title: \"Degrees\"\n\t}\n\tsection(\"Optionally choose temperature sensor to use instead of the thermostat's...\") {\n\t\tinput \"sensor\", \"capability.temperatureMeasurement\", title: \"Temp Sensors\", required: false\n\t}\n}\n\ndef installed()\n{\n\tlog.debug \"enter installed, state: $state\"\n\tsubscribeToEvents()\n}\n\ndef updated()\n{\n\tlog.debug \"enter updated, state: $state\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents()\n{\n\tsubscribe(location, changedLocationMode)\n\tif (sensor) {\n\t\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\t\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\t\tsubscribe(thermostat, \"thermostatMode\", temperatureHandler)\n\t}\n\tevaluate()\n}\n\ndef changedLocationMode(evt)\n{\n\tlog.debug \"changedLocationMode mode: $evt.value, heat: $heat, cool: $cool\"\n\tevaluate()\n}\n\ndef temperatureHandler(evt)\n{\n\tevaluate()\n}\n\nprivate evaluate()\n{\n\tif (sensor) {\n\t\tdef threshold = 1.0\n\t\tdef tm = thermostat.currentThermostatMode\n\t\tdef ct = thermostat.currentTemperature\n\t\tdef currentTemp = sensor.currentTemperature\n\t\tlog.trace(\"evaluate:, mode: $tm -- temp: $ct, heat: $thermostat.currentHeatingSetpoint, cool: $thermostat.currentCoolingSetpoint -- \"  +\n\t\t\t\"sensor: $currentTemp, heat: $heatingSetpoint, cool: $coolingSetpoint\")\n\t\tif (tm in [\"cool\",\"auto\"]) {\n\t\t\t// air conditioner\n\t\t\tif (currentTemp - coolingSetpoint >= threshold) {\n\t\t\t\tthermostat.setCoolingSetpoint(ct - 2)\n\t\t\t\tlog.debug \"thermostat.setCoolingSetpoint(${ct - 2}), ON\"\n\t\t\t}\n\t\t\telse if (coolingSetpoint - currentTemp >= threshold && ct - thermostat.currentCoolingSetpoint >= threshold) {\n\t\t\t\tthermostat.setCoolingSetpoint(ct + 2)\n\t\t\t\tlog.debug \"thermostat.setCoolingSetpoint(${ct + 2}), OFF\"\n\t\t\t}\n\t\t}\n\t\tif (tm in [\"heat\",\"emergency heat\",\"auto\"]) {\n\t\t\t// heater\n\t\t\tif (heatingSetpoint - currentTemp >= threshold) {\n\t\t\t\tthermostat.setHeatingSetpoint(ct + 2)\n\t\t\t\tlog.debug \"thermostat.setHeatingSetpoint(${ct + 2}), ON\"\n\t\t\t}\n\t\t\telse if (currentTemp - heatingSetpoint >= threshold && thermostat.currentHeatingSetpoint - ct >= threshold) {\n\t\t\t\tthermostat.setHeatingSetpoint(ct - 2)\n\t\t\t\tlog.debug \"thermostat.setHeatingSetpoint(${ct - 2}), OFF\"\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\t\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\t\tif (thermostat.hasCommand(\"poll\")) {\n\t\t\tthermostat.poll()\n\t\t}\n\t}\n}\n\n// for backward compatibility with existing subscriptions\ndef coolingSetpointHandler(evt) {\n\tlog.debug \"coolingSetpointHandler()\"\n}\ndef heatingSetpointHandler (evt) {\n\tlog.debug \"heatingSetpointHandler ()\"\n}",
        "docstring": "Works the same as Keep Me Cozy, but enables you to pick an alternative temperature sensor in a separate space from the thermostat. Focuses on making you comfortable where you are spending your time rather than where the thermostat is located."
    },
    {
        "code": "section(\"Heat setting...\") {\n\t\tinput \"heatingSetpoint\", \"number\", title: \"Degrees?\"\n\t}\n\tsection(\"Air conditioning setting...\"){\n\t\tinput \"coolingSetpoint\", \"number\", title: \"Degrees?\"\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(thermostat, \"heatingSetpoint\", heatingSetpointHandler)\n\tsubscribe(thermostat, \"coolingSetpoint\", coolingSetpointHandler)\n\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(thermostat, \"heatingSetpoint\", heatingSetpointHandler)\n\tsubscribe(thermostat, \"coolingSetpoint\", coolingSetpointHandler)\n\tsubscribe(thermostat, \"temperature\", temperatureHandler)\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n}\n\ndef heatingSetpointHandler(evt)\n{\n\tlog.debug \"heatingSetpoint: $evt, $settings\"\n}\n\ndef coolingSetpointHandler(evt)\n{\n\tlog.debug \"coolingSetpoint: $evt, $settings\"\n}\n\ndef temperatureHandler(evt)\n{\n\tlog.debug \"currentTemperature: $evt, $settings\"\n}\n\ndef changedLocationMode(evt)\n{\n\tlog.debug \"changedLocationMode: $evt, $settings\"\n\n\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\tthermostat.poll()\n}\n\ndef appTouch(evt)\n{\n\tlog.debug \"appTouch: $evt, $settings\"\n\n\tthermostat.setHeatingSetpoint(heatingSetpoint)\n\tthermostat.setCoolingSetpoint(coolingSetpoint)\n\tthermostat.poll()\n}\n\n// catchall\ndef event(evt)\n{\n\tlog.debug \"value: $evt.value, event: $evt, settings: $settings, handlerName: ${evt.handlerName}\"\n}",
        "docstring": "Changes your thermostat settings automatically in response to a mode change.  Often used with Bon Voyage, Rise and Shine, and other Mode Magic SmartApps to automatically keep you comfortable while you're present and save you energy and money while you are away."
    },
    {
        "code": "section(\"Via this number (optional, sends push notification if not specified)\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone\", \"phone\", title: \"Phone Number\", required: false\n        }\n\t}\n\tsection(\"And by turning on these lights (optional)\") {\n\t\tinput \"switches\", \"capability.switch\", required: false, multiple: true, title: \"Which lights?\"\n\t\tinput \"lightMode\", \"enum\", options: [\"Flash Lights\", \"Turn On Lights\"], required: false, defaultValue: \"Turn On Lights\", title: \"Action?\"\n\t}\n\tsection(\"Time thresholds (in minutes, optional)\"){\n\t\tinput \"cycleTime\", \"decimal\", title: \"Minimum cycle time\", required: false, defaultValue: 10\n\t\tinput \"fillTime\", \"decimal\", title: \"Time to fill tub\", required: false, defaultValue: 5\n\t}\n}\n\ndef installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(sensor1, \"acceleration.active\", accelerationActiveHandler)\n\tsubscribe(sensor1, \"acceleration.inactive\", accelerationInactiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.trace \"vibration\"\n\tif (!state.isRunning) {\n\t\tlog.info \"Arming detector\"\n\t\tstate.isRunning = true\n\t\tstate.startedAt = now()\n\t}\n\tstate.stoppedAt = null\n}\n\ndef accelerationInactiveHandler(evt) {\n\tlog.trace \"no vibration, isRunning: $state.isRunning\"\n\tif (state.isRunning) {\n\t\tlog.debug \"startedAt: ${state.startedAt}, stoppedAt: ${state.stoppedAt}\"\n\t\tif (!state.stoppedAt) {\n\t\t\tstate.stoppedAt = now()\n            def delay = Math.floor(fillTime * 60).toInteger()\n\t\t\trunIn(delay, checkRunning, [overwrite: false])\n\t\t}\n\t}\n}\n\ndef checkRunning() {\n\tlog.trace \"checkRunning()\"\n\tif (state.isRunning) {\n\t\tdef fillTimeMsec = fillTime ? fillTime * 60000 : 300000\n\t\tdef sensorStates = sensor1.statesSince(\"acceleration\", new Date((now() - fillTimeMsec) as Long))\n\n\t\tif (!sensorStates.find{it.value == \"active\"}) {\n\n\t\t\tdef cycleTimeMsec = cycleTime ? cycleTime * 60000 : 600000\n\t\t\tdef duration = now() - state.startedAt\n\t\t\tif (duration - fillTimeMsec > cycleTimeMsec) {\n\t\t\t\tlog.debug \"Sending notification\"\n\n\t\t\t\tdef msg = \"${sensor1.displayName} is finished\"\n\t\t\t\tlog.info msg\n\n                if (location.contactBookEnabled) {\n                    sendNotificationToContacts(msg, recipients)\n                }\n                else {\n\n                    if (phone) {\n                        sendSms phone, msg\n                    } else {\n                        sendPush msg\n                    }\n\n                }\n\n\t\t\t\tif (switches) {\n\t\t\t\t\tif (lightMode?.equals(\"Turn On Lights\")) {\n\t\t\t\t\t\tswitches.on()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflashLights()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.debug \"Not sending notification because machine wasn't running long enough $duration versus $cycleTimeMsec msec\"\n\t\t\t}\n\t\t\tstate.isRunning = false\n\t\t\tlog.info \"Disarming detector\"\n\t\t} else {\n\t\t\tlog.debug \"skipping notification because vibration detected again\"\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"machine no longer running\"\n\t}\n}\n\nprivate flashLights() {\n\tdef doFlash = true\n\tdef onFor = onFor ?: 1000\n\tdef offFor = offFor ?: 1000\n\tdef numFlashes = numFlashes ?: 3\n\n\tlog.debug \"LAST ACTIVATED IS: ${state.lastActivated}\"\n\tif (state.lastActivated) {\n\t\tdef elapsed = now() - state.lastActivated\n\t\tdef sequenceTime = (numFlashes + 1) * (onFor + offFor)\n\t\tdoFlash = elapsed > sequenceTime\n\t\tlog.debug \"DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: ${state.lastActivated}\"\n\t}\n\n\tif (doFlash) {\n\t\tlog.debug \"FLASHING $numFlashes times\"\n\t\tstate.lastActivated = now()\n\t\tlog.debug \"LAST ACTIVATED SET TO: ${state.lastActivated}\"\n\t\tdef initialActionOn = switches.collect{it.currentSwitch != \"on\"}\n\t\tdef delay = 1L\n\t\tnumFlashes.times {\n\t\t\tlog.trace \"Switch on after  $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.on(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.off(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += onFor\n\t\t\tlog.trace \"Switch off after $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.off(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.on(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += offFor\n\t\t}\n\t}\n}",
        "docstring": "Sends a message and (optionally) turns on or blinks a light to indicate that laundry is done."
    },
    {
        "code": "section(\"And notify me if it's open for more than this many minutes (default 10)\") {\n    input \"openThreshold\", \"number\", description: \"Number of minutes\", required: false\n  }\n\n  section(\"Delay between notifications (default 10 minutes\") {\n    input \"frequency\", \"number\", title: \"Number of minutes\", description: \"\", required: false\n  }\n\n  section(\"Via text message at this number (or via push notification if not specified\") {\n    input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n      input \"phone\", \"phone\", title: \"Phone number (optional)\", required: false\n    }\n  }\n}\n\ndef installed() {\n  log.trace \"installed()\"\n  subscribe()\n}\n\ndef updated() {\n  log.trace \"updated()\"\n  unsubscribe()\n  subscribe()\n}\n\ndef subscribe() {\n  subscribe(contact, \"contact.open\", doorOpen)\n  subscribe(contact, \"contact.closed\", doorClosed)\n}\n\ndef doorOpen(evt) {\n  log.trace \"doorOpen($evt.name: $evt.value)\"\n  def delay = (openThreshold != null && openThreshold != \"\") ? openThreshold * 60 : 600\n  runIn(delay, doorOpenTooLong, [overwrite: true])\n}\n\ndef doorClosed(evt) {\n  log.trace \"doorClosed($evt.name: $evt.value)\"\n  unschedule(doorOpenTooLong)\n}\n\ndef doorOpenTooLong() {\n  def contactState = contact.currentState(\"contact\")\n  def freq = (frequency != null && frequency != \"\") ? frequency * 60 : 600\n\n  if (contactState.value == \"open\") {\n    def elapsed = now() - contactState.rawDateCreated.time\n    def threshold = ((openThreshold != null && openThreshold != \"\") ? openThreshold * 60000 : 60000) - 1000\n    if (elapsed >= threshold) {\n      log.debug \"Contact has stayed open long enough since last check ($elapsed ms):  calling sendMessage()\"\n      sendMessage()\n      runIn(freq, doorOpenTooLong, [overwrite: false])\n    } else {\n      log.debug \"Contact has not stayed open long enough since last check ($elapsed ms):  doing nothing\"\n    }\n  } else {\n    log.warn \"doorOpenTooLong() called but contact is closed:  doing nothing\"\n  }\n}\n\nvoid sendMessage() {\n  def minutes = (openThreshold != null && openThreshold != \"\") ? openThreshold : 10\n  def msg = \"${contact.displayName} has been left open for ${minutes} minutes.\"\n  log.info msg\n  if (location.contactBookEnabled) {\n    sendNotificationToContacts(msg, recipients)\n  } else {\n    if (phone) {\n      sendSms phone, msg\n    } else {\n      sendPush msg\n    }\n  }\n}",
        "docstring": "Notifies you when you have left a door or window open longer that a specified amount of time."
    },
    {
        "code": "section(\"Turn on/off a light...\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\ndef installed() {\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(contact1, \"contact\", contactHandler)\n}\n\ndef contactHandler(evt) {\n\tlog.debug \"$evt.value\"\n\tif (evt.value == \"open\") {\n\t\tswitch1.on()\n\t} else if (evt.value == \"closed\") {\n\t\tswitch1.off()\n\t}\n}",
        "docstring": "Turn your lights on when a SmartSense Multi is opened and turn them off when it is closed."
    },
    {
        "code": "preferences {\n\tpage(name: \"Credentials\", title: \"Life360 Authentication\", content: \"authPage\", nextPage: \"listCirclesPage\", install: false)\n    page(name: \"listCirclesPage\", title: \"Select Life360 Circle\", nextPage: \"listPlacesPage\", content: \"listCircles\", install: false)\n    page(name: \"listPlacesPage\", title: \"Select Life360 Place\", nextPage: \"listUsersPage\", content: \"listPlaces\", install: false)\n    page(name: \"listUsersPage\", title: \"Select Life360 Users\", content: \"listUsers\", install: true)\n}\n\n//\tpage(name: \"Credentials\", title: \"Enter Life360 Credentials\", content: \"getCredentialsPage\", nextPage: \"listCirclesPage\", install: false)  \n//    page(name: \"page3\", title: \"Select Life360 Users\", content: \"listUsers\")\n\nmappings {\n\n\tpath(\"/placecallback\") {\n\t\taction: [\n              POST: \"placeEventHandler\",\n              GET: \"placeEventHandler\"\n\t\t]\n\t}\n    \n    path(\"/receiveToken\") {\n\t\taction: [\n            POST: \"receiveToken\",\n            GET: \"receiveToken\"\n\t\t]\n\t}\n}\n\ndef authPage()\n{\n    log.debug \"authPage()\"\n    \n    def description = \"Life360 Credentials Already Entered.\"\n    \n    def uninstallOption = false\n    if (app.installationState == \"COMPLETE\")\n       uninstallOption = true\n\n\tif(!state.life360AccessToken)\n    {\n\t    log.debug \"about to create access token\"\n\t\tcreateAccessToken()\n        description = \"Click to enter Life360 Credentials.\"\n\n\t\tdef redirectUrl = oauthInitUrl()\n    \n\t\treturn dynamicPage(name: \"Credentials\", title: \"Life360\", nextPage:\"listCirclesPage\", uninstall: uninstallOption, install:false) {\n\t\t    section {\n    \t\t\thref url:redirectUrl, style:\"embedded\", required:false, title:\"Life360\", description:description\n\t\t    }\n   \t \t}\n    }\n    else\n    {\n    \tlistCircles()\n    }\n}\n\ndef receiveToken() {\n\n\tstate.life360AccessToken = params.access_token\n    \n    def html = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=640\">\n<title>Withings Connection</title>\n<style type=\"text/css\">\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t.container {\n\t\twidth: 560px;\n\t\tpadding: 40px;\n\t\t/*background: #eee;*/\n\t\ttext-align: center;\n\t}\n\timg {\n\t\tvertical-align: middle;\n\t}\n\timg:nth-child(2) {\n\t\tmargin: 0 30px;\n\t}\n\tp {\n\t\tfont-size: 2.2em;\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\ttext-align: center;\n\t\tcolor: #666666;\n\t\tpadding: 0 40px;\n\t\tmargin-bottom: 0;\n\t}\n/*\n\tp:last-child {\n\t\tmargin-top: 0px;\n\t}\n*/\n\tspan {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t}\n</style>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/life360@2x.png\" alt=\"Life360 icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t<p>Your Life360 Account is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t</div>\n</body>\n</html>\n\"\"\"\n\n\trender contentType: 'text/html', data: html\n\n}\n\ndef oauthInitUrl()\n{\n    log.debug \"oauthInitUrl\"\n    def stcid = getSmartThingsClientId();\n    \n\t// def oauth_url = \"https://api.life360.com/v3/oauth2/authorize?client_id=pREqugabRetre4EstetherufrePumamExucrEHuc&response_type=token&redirect_uri=http%3A%2F%2Fwww.smartthings.com\"\n\n \tstate.oauthInitState = UUID.randomUUID().toString()\n    \n \tdef oauthParams = [\n    \tresponse_type: \"token\", \n        client_id: stcid,  \n        redirect_uri: buildRedirectUrl() \n    ]\n\n\treturn \"https://api.life360.com/v3/oauth2/authorize?\" + toQueryString(oauthParams)\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef getSmartThingsClientId() {\n   return \"pREqugabRetre4EstetherufrePumamExucrEHuc\"\n}\n\ndef getServerUrl() { getApiServerUrl() }\n\ndef buildRedirectUrl()\n{\n    log.debug \"buildRedirectUrl\"\n    // /api/token/:st_token/smartapps/installations/:id/something\n    \n\treturn serverUrl + \"/api/token/${state.accessToken}/smartapps/installations/${app.id}/receiveToken\"\n}\n\n//\n// This method is no longer used - was part of the initial username/password based authentication that has now been replaced\n// by the full OAUTH web flow\n//\n\ndef getCredentialsPage() {\n\n\tdynamicPage(name: \"Credentials\", title: \"Enter Life360 Credentials\", nextPage: \"listCirclesPage\", uninstall: true, install:false)\n    {\n\t\tsection(\"Life 360 Credentials ...\") {\n\t\t\tinput \"username\", \"text\", title: \"Life360 Username?\", multiple: false, required: true\n\t\t\tinput \"password\", \"password\", title: \"Life360 Password?\", multiple: false, required: true, autoCorrect: false\n    \t}\n\n    }\n\n}\n\n//\n// This method is no longer used - was part of the initial username/password based authentication that has now been replaced\n// by the full OAUTH web flow\n//\n\ndef getCredentialsErrorPage(String message) {\n\n\tdynamicPage(name: \"Credentials\", title: \"Enter Life360 Credentials\", nextPage: \"listCirclesPage\", uninstall: true, install:false)\n    {\n\t\tsection(\"Life 360 Credentials ...\") {\n\t\t\tinput \"username\", \"text\", title: \"Life360 Username?\", multiple: false, required: true\n\t\t\tinput \"password\", \"password\", title: \"Life360 Password?\", multiple: false, required: true, autoCorrect: false\n            paragraph \"${message}\"\n    \t}\n\n    }\n\n}\n\ndef testLife360Connection() {\n\n   \tif (state.life360AccessToken)\n   \t\ttrue\n    else\n    \tfalse\n        \n}\n\n//\n// This method is no longer used - was part of the initial username/password based authentication that has now been replaced\n// by the full OAUTH web flow\n//\n\ndef initializeLife360Connection() {\n\n\tdef oauthClientId = appSettings.clientId\n\tdef oauthClientSecret = appSettings.clientSecret\n\n\tinitialize()\n    \n    def username = settings.username\n    def password = settings.password\n    \n    // Base 64 encode the credentials\n\n  \tdef basicCredentials = \"${oauthClientId}:${oauthClientSecret}\"\n    def encodedCredentials = basicCredentials.encodeAsBase64().toString()\n    \n    \n    // call life360, get OAUTH token using password flow, save\n    // curl -X POST -H \"Authorization: Basic cFJFcXVnYWJSZXRyZTRFc3RldGhlcnVmcmVQdW1hbUV4dWNyRUh1YzptM2ZydXBSZXRSZXN3ZXJFQ2hBUHJFOTZxYWtFZHI0Vg==\" \n    //      -F \"grant_type=password\" -F \"username=jeff@hagins.us\" -F \"password=tondeleo\" https://api.life360.com/v3/oauth2/token.json\n    \n\n    def url = \"https://api.life360.com/v3/oauth2/token.json\"\n    \n        \n    def postBody =  \"grant_type=password&\" +\n    \t\t\t\t\"username=${username}&\"+\n                    \"password=${password}\"\n\n    def result = null\n    \n    try {\n       \n \t\thttpPost(uri: url, body: postBody, headers: [\"Authorization\": \"Basic ${encodedCredentials}\" ]) {response -> \n     \t\tresult = response\n\t\t}\n        if (result.data.access_token) {\n       \t\tstate.life360AccessToken = result.data.access_token\n            return true;\n   \t\t}\n\t\tlog.info \"Life360 initializeLife360Connection, response=${result.data}\"\n        return false;\n        \n    }\n    catch (e) {\n       log.error \"Life360 initializeLife360Connection, error: $e\"\n       return false;\n    }\n\n}\n\ndef listCircles (){\n\n\t// understand whether to present the Uninstall option\n    def uninstallOption = false\n    if (app.installationState == \"COMPLETE\")\n       uninstallOption = true\n\n\t// get connected to life360 api\n\n\tif (testLife360Connection()) {\n    \n    \t// now pull back the list of Life360 circles\n    \t// curl -X GET -H \"Authorization: Bearer MmEzODQxYWQtMGZmMy00MDZhLWEwMGQtMTIzYmYxYzFmNGU3\" https://api.life360.com/v3/circles.json\n    \n    \tdef url = \"https://api.life360.com/v3/circles.json\"\n \n    \tdef result = null\n       \n\t\thttpGet(uri: url, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n    \t \tresult = response\n\t\t}\n\n\t\tlog.debug \"Circles=${result.data}\"\n    \n    \tdef circles = result.data.circles\n    \n    \tif (circles.size > 1) {\n    \t    return (\n    \t\t\tdynamicPage(name: \"listCirclesPage\", title: \"Life360 Circles\", nextPage: null, uninstall: uninstallOption, install:false) {\n     \t\t   \t\tsection(\"Select Life360 Circle:\") {\n        \t\t\t\tinput \"circle\", \"enum\", multiple: false, required:true, title:\"Life360 Circle: \", options: circles.collectEntries{[it.id, it.name]}\t\n        \t\t\t}\n    \t\t\t}\n\t        )\n    \t}\n    \telse {\n       \t\tstate.circle = circles[0].id\n       \t\treturn (listPlaces())\n    \t}  \n\t}\n    else {\n    \tgetCredentialsErrorPage(\"Invalid Usernaname or password.\")\n    }\n    \n}\n\ndef listPlaces() {\n\n\t// understand whether to present the Uninstall option\n    def uninstallOption = false\n    if (app.installationState == \"COMPLETE\")\n       uninstallOption = true\n       \n\tif (!state?.circle)\n        state.circle = settings.circle\n\n\t// call life360 and get the list of places in the circle\n    \n \tdef url = \"https://api.life360.com/v3/circles/${state.circle}/places.json\"\n \n    def result = null\n       \n\thttpGet(uri: url, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \tresult = response\n\t}\n\n\tlog.debug \"Places=${result.data}\" \n    \n    def places = result.data.places\n    state.places = places\n    \n    // If there is a place called \"Home\" use it as the default\n    def defaultPlace = places.find{it.name==\"Home\"}\n    def defaultPlaceId\n    if (defaultPlace) {\n    \tdefaultPlaceId = defaultPlace.id\n    \tlog.debug \"Place = $defaultPlace.name, Id=$defaultPlace.id\"\n    }\n       \n    dynamicPage(name: \"listPlacesPage\", title: \"Life360 Places\", nextPage: null, uninstall: uninstallOption, install:false) {\n        section(\"Select Life360 Place to Match Current Location:\") {\n            paragraph \"Please select the ONE Life360 Place that matches your SmartThings location: ${location.name}\"\n        \tinput \"place\", \"enum\", multiple: false, required:true, title:\"Life360 Places: \", options: places.collectEntries{[it.id, it.name]}, defaultValue: defaultPlaceId\n        }\n    }\n    \n}\n\ndef listUsers () {\n\n\t// understand whether to present the Uninstall option\n    def uninstallOption = false\n    if (app.installationState == \"COMPLETE\")\n       uninstallOption = true\n    \n\tif (!state?.circle)\n        state.circle = settings.circle\n\n    // call life360 and get list of users (members)\n\n    def url = \"https://api.life360.com/v3/circles/${state.circle}/members.json\"\n \n    def result = null\n       \n\thttpGet(uri: url, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \tresult = response\n\t}\n\n\tlog.debug \"Members=${result.data}\"\n    \n    // save members list for later\n    \n    def members = result.data.members\n    \n    state.members = members\n    \n    // build preferences page\n        \n    dynamicPage(name: \"listUsersPage\", title: \"Life360 Users\", nextPage: null, uninstall: uninstallOption, install:true) {\n        section(\"Select Life360 Users to Import into SmartThings:\") {\n        \tinput \"users\", \"enum\", multiple: true, required:true, title:\"Life360 Users: \", options: members.collectEntries{[it.id, it.firstName+\" \"+it.lastName]}\t\n        }\n    }\n}\n\ndef installed() {\n\n\tif (!state?.circle)\n        state.circle = settings.circle\n\n\tlog.debug \"In installed() method.\"\n    // log.debug \"Members: ${state.members}\"\n    // log.debug \"Users: ${settings.users}\"\n    \n    settings.users.each {memberId->\n    \n    \t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \tdef member = state.members.find{it.id==memberId}\n        \n        // log.debug \"After Find Attempt.\"\n\n       \t// log.debug \"Member Id = ${member.id}, Name = ${member.firstName} ${member.lastName}, Email Address = ${member.loginEmail}\"\n        \n        // log.debug \"External Id=${app.id}:${member.id}\"\n       \n       \t// create the device\n        if (member) {\n        \n       \t\tdef childDevice = addChildDevice(\"smartthings\", \"Life360 User\", \"${app.id}.${member.id}\",null,[name:member.firstName, completedSetup: true])\n        \n        \t// save the memberId on the device itself so we can find easily later\n        \t// childDevice.setMemberId(member.id)\n        \n        \tif (childDevice)\n        \t{\n        \t\t// log.debug \"Child Device Successfully Created\"\n \t\t\t\tgenerateInitialEvent (member, childDevice)\n\t\t\t\n            \t// build the icon name form the L360 Avatar URL\n                // URL Format: https://www.life360.com/img/user_images/b4698717-1f2e-4b7a-b0d4-98ccfb4e9730/Maddie_Hagins_51d2eea2019c7.jpeg\n                // SmartThings Icon format is: L360.b4698717-1f2e-4b7a-b0d4-98ccfb4e9730.Maddie_Hagins_51d2eea2019c7\n                try {\n                \n                \t// build the icon name from the avatar URL\n                \tlog.debug \"Avatar URL = ${member.avatar}\"\n                \tdef urlPathElements = member.avatar.tokenize(\"/\")\n                    def fileElements = urlPathElements[5].tokenize(\".\")\n                    // def icon = \"st.Lighting.light1\"\n               \t\tdef icon=\"l360.${urlPathElements[4]}.${fileElements[0]}\"\n                    log.debug \"Icon = ${icon}\"\n\n            \t\t// set the icon on the device\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"present\",icon)\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"not present\",icon)\n\t\t\t\t\tchildDevice.save()\n                }\n                catch (e) { // do nothing\n                \tlog.debug \"Error = ${e}\"\n                } \n       \t\t}\n    \t}\n    }\n    \n    createCircleSubscription()\n    \n}\n\ndef createCircleSubscription() {\n\n    // delete any existing webhook subscriptions for this circle\n    //\n    // curl -X DELETE https://webhook.qa.life360.com/v3/circles/:circleId/webhook.json\n    \n    log.debug \"Remove any existing Life360 Webhooks for this Circle.\"\n    \n    def deleteUrl = \"https://api.life360.com/v3/circles/${state.circle}/webhook.json\"\n    \n    try { // ignore any errors - there many not be any existing webhooks\n    \n    \thttpDelete (uri: deleteUrl, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \t\tresult = response}\n\t\t}\n    \n    catch (e) {\n    \n    \tlog.debug (e)\n    }\n    \n    // subscribe to the life360 webhook to get push notifications on place events within this circle\n    \n    // POST /circles/:circle_id/places/webooks\n\t// Params: hook_url\n    \n    log.debug \"Create a new Life360 Webhooks for this Circle.\"\n    \n    createAccessToken() // create our own OAUTH access token to use in webhook url\n    \n    def hookUrl = \"${serverUrl}/api/smartapps/installations/${app.id}/placecallback?access_token=${state.accessToken}\".encodeAsURL()\n    \n    def url = \"https://api.life360.com/v3/circles/${state.circle}/webhook.json\"\n        \n    def postBody =  \"url=${hookUrl}\"\n\n    def result = null\n    \n    try {\n       \n \t    httpPost(uri: url, body: postBody, headers: [\"Authorization\": \"Bearer ${state.life360AccessToken}\" ]) {response -> \n     \t    result = response}\n    \n    } catch (e) {\n        log.debug (e)\n    }\n    \n    // response from this call looks like this:\n    // {\"circleId\":\"41094b6a-32fc-4ef5-a9cd-913f82268836\",\"userId\":\"0d1db550-9163-471b-8829-80b375e0fa51\",\"clientId\":\"11\",\n    //    \"hookUrl\":\"https://testurl.com\"}\n    \n    log.debug \"Response = ${response}\"\n    \n    if (result.data?.hookUrl) {\n\t    log.debug \"Webhook creation successful. Response = ${result.data}\"\n    \n\t}\n}\n\n\ndef updated() {\n\n\tif (!state?.circle)\n        state.circle = settings.circle\n\n\tlog.debug \"In updated() method.\"\n    // log.debug \"Members: ${state.members}\"\n    // log.debug \"Users: ${settings.users}\"\n    \n    // loop through selected users and try to find child device for each\n    \n    settings.users.each {memberId->\n    \n    \tdef externalId = \"${app.id}.${memberId}\"\n\n\t\t// find the appropriate child device based on my app id and the device network id\n\n\t\tdef deviceWrapper = getChildDevice(\"${externalId}\")\n        \n        if (!deviceWrapper) { // device isn't there - so we need to create\n    \n    \t\t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \t\tdef member = state.members.find{it.id==memberId}\n        \n        \t// log.debug \"After Find Attempt.\"\n\n        \t// log.debug \"External Id=${app.id}:${member.id}\"\n       \n       \t\t// create the device\n       \t\tdef childDevice = addChildDevice(\"smartthings\", \"Life360 User\", \"${app.id}.${member.id}\",null,[name:member.firstName, completedSetup: true])\n            // childDevice.setMemberId(member.id)\n        \n        \tif (childDevice)\n        \t{\n        \t\t// log.debug \"Child Device Successfully Created\"\n \t\t\t\tgenerateInitialEvent (member, childDevice)\n                \n                // build the icon name form the L360 Avatar URL\n                // URL Format: https://www.life360.com/img/user_images/b4698717-1f2e-4b7a-b0d4-98ccfb4e9730/Maddie_Hagins_51d2eea2019c7.jpeg\n                // SmartThings Icon format is: L360.b4698717-1f2e-4b7a-b0d4-98ccfb4e9730.Maddie_Hagins_51d2eea2019c7\n                try {\n                \n                \t// build the icon name from the avatar URL\n                \tlog.debug \"Avatar URL = ${member.avatar}\"\n                \tdef urlPathElements = member.avatar.tokenize(\"/\")\n               \t\tdef icon=\"l360.${urlPathElements[4]}.${urlPathElements[5]}\"\n\n            \t\t// set the icon on the device\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"present\",icon)\n\t\t\t\t\tchildDevice.setIcon(\"presence\",\"not present\",icon)\n\t\t\t\t\tchildDevice.save()\n                }\n                catch (e) { // do nothing\n                \tlog.debug \"Error = ${e}\"\n                } \n       \t\t}\n            \n    \t}\n        else {\n        \n          \t// log.debug \"Find by Member Id = ${memberId}\"\n    \n    \t\tdef member = state.members.find{it.id==memberId}\n    \n        \tgenerateInitialEvent (member, deviceWrapper)\n            \n        }\n    }\n\n\t// Now remove any existing devices that represent users that are no longer selected\n    \n    def childDevices = getAllChildDevices()\n    \n    log.debug \"Child Devices = ${childDevices}\"\n    \n    childDevices.each {childDevice->\n    \n    \tlog.debug \"Child = ${childDevice}, DNI=${childDevice.deviceNetworkId}\"\n        \n        // def childMemberId = childDevice.getMemberId()\n        \n        def splitStrings = childDevice.deviceNetworkId.split(\"\\\\.\")\n        \n        log.debug \"Strings = ${splitStrings}\"\n        \n        def childMemberId = splitStrings[1]\n        \n        log.debug \"Child Member Id = ${childMemberId}\"\n        \n        log.debug \"Settings.users = ${settings.users}\"\n        \n        if (!settings.users.find{it==childMemberId}) {\n            deleteChildDevice(childDevice.deviceNetworkId)\n            def member = state.members.find {it.id==memberId}\n            if (member)\n            \tstate.members.remove(member)\n        }\n    \n    }\n}\n\ndef generateInitialEvent (member, childDevice) {\n\n    // lets figure out if the member is currently \"home\" (At the place)\n    \n    try { // we are going to just ignore any errors\n    \n    \tlog.info \"Life360 generateInitialEvent($member, $childDevice)\"\n        \n        def place = state.places.find{it.id==settings.place}\n        \n        if (place) {\n        \n        \tdef memberLatitude = new Float (member.location.latitude)\n            def memberLongitude = new Float (member.location.longitude)\n            def placeLatitude = new Float (place.latitude)\n            def placeLongitude = new Float (place.longitude)\n            def placeRadius = new Float (place.radius)\n        \n        \t// log.debug \"Member Location = ${memberLatitude}/${memberLongitude}\"\n            // log.debug \"Place Location = ${placeLatitude}/${placeLongitude}\"\n            // log.debug \"Place Radius = ${placeRadius}\"\n        \n        \tdef distanceAway = haversine(memberLatitude, memberLongitude, placeLatitude, placeLongitude)*1000 // in meters\n  \n        \t// log.debug \"Distance Away = ${distanceAway}\"\n  \n  \t\t\tboolean isPresent = (distanceAway <= placeRadius)\n\n\t\t\tlog.info \"Life360 generateInitialEvent, member: ($memberLatitude, $memberLongitude), place: ($placeLatitude, $placeLongitude), radius: $placeRadius, dist: $distanceAway, present: $isPresent\"\n                \n        \t// log.debug \"External Id=${app.id}:${member.id}\"\n        \n       \t\t// def childDevice2 = getChildDevice(\"${app.id}.${member.id}\")\n\t\t\n        \t// log.debug \"Child Device = ${childDevice2}\"\n        \n        \tchildDevice?.generatePresenceEvent(isPresent)\n        \n        \t// log.debug \"After generating presence event.\"\n            \n    \t}\n        \n\t}\n    catch (e) {\n    \t// eat it\n    }\n        \n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef haversine(lat1, lon1, lat2, lon2) {\n  def R = 6372.8\n  // In kilometers\n  def dLat = Math.toRadians(lat2 - lat1)\n  def dLon = Math.toRadians(lon2 - lon1)\n  lat1 = Math.toRadians(lat1)\n  lat2 = Math.toRadians(lat2)\n \n  def a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2)\n  def c = 2 * Math.asin(Math.sqrt(a))\n  def d = R * c\n  return(d)\n}\n\n\ndef placeEventHandler() {\n\n\tlog.info \"Life360 placeEventHandler: params=$params, settings.place=$settings.place\"\n\n\t// the POST to this end-point will look like:\n    // POST http://test.com/webhook?circleId=XXXX&placeId=XXXX&userId=XXXX&direction=arrive\n    \n    def circleId = params?.circleId\n    def placeId = params?.placeId\n    def userId = params?.userId\n    def direction = params?.direction\n    def timestamp = params?.timestamp\n    \n    if (placeId == settings.place) {\n\n\t\tdef presenceState = (direction==\"in\")\n    \n\t\tdef externalId = \"${app.id}.${userId}\"\n\n\t\t// find the appropriate child device based on my app id and the device network id\n\n\t\tdef deviceWrapper = getChildDevice(\"${externalId}\")\n\n\t\t// invoke the generatePresenceEvent method on the child device\n\n\t\tif (deviceWrapper) {\n\t\t\tdeviceWrapper.generatePresenceEvent(presenceState)\n    \t\tlog.debug \"Life360 event raised on child device: ${externalId}\"\n\t\t}\n   \t\telse {\n    \t\tlog.warn \"Life360 couldn't find child device associated with inbound Life360 event.\"\n    \t}\n    }\n\n}",
        "docstring": "Life360 Service Manager"
    },
    {
        "code": "section(\"And off when there's been no movement for...\"){\n\t\tinput \"minutes1\", \"number\", title: \"Minutes?\"\n\t}\n\tsection(\"Turn on/off light(s)...\"){\n\t\tinput \"switches\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed() {\n\tsubscribe(motion1, \"motion\", motionHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(motion1, \"motion\", motionHandler)\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"turning on lights\"\n\t\tswitches.on()\n\t} else if (evt.value == \"inactive\") {\n\t\trunIn(minutes1 * 60, scheduleCheck, [overwrite: false])\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"schedule check\"\n\tdef motionState = motion1.currentState(\"motion\")\n    if (motionState.value == \"inactive\") {\n        def elapsed = now() - motionState.rawDateCreated.time\n    \tdef threshold = 1000 * 60 * minutes1 - 1000\n    \tif (elapsed >= threshold) {\n            log.debug \"Motion has stayed inactive long enough since last check ($elapsed ms):  turning lights off\"\n            switches.off()\n    \t} else {\n        \tlog.debug \"Motion has not stayed inactive long enough since last check ($elapsed ms):  doing nothing\"\n        }\n    } else {\n    \tlog.debug \"Motion is active, do nothing and wait for inactive\"\n    }\n}",
        "docstring": "Turn your lights on when motion is detected and then off again once the motion stops for a set period of time."
    },
    {
        "code": "section(\"Turn on a light...\") {\n\t\tinput \"lights\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed() {\n\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler)\n}\n\n// New aeon implementation\ndef illuminanceHandler(evt) {\n\tdef lastStatus = state.lastStatus\n\tif (lastStatus != \"on\" && evt.integerValue < 30) {\n\t\tlights.on()\n\t\tstate.lastStatus = \"on\"\n\t}\n\telse if (lastStatus != \"off\" && evt.integerValue > 50) {\n\t\tlights.off()\n\t\tstate.lastStatus = \"off\"\n\t}\n}",
        "docstring": "Turn your lights on when it gets dark and off when it becomes light again."
    },
    {
        "code": "section (\"Turn off a light...\") {\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(contact1, \"contact.closed\", contactClosedHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.closed\", contactClosedHandler)\n}\n\ndef contactClosedHandler(evt) {\n\tswitch1.off()\n}",
        "docstring": "Turn your lights off when an open/close sensor closes."
    },
    {
        "code": "section(\"Lock the lock...\") {\n\t\tinput \"lock1\",\"capability.lock\", multiple: true\n\t\tinput \"unlock\", \"enum\", title: \"Unlock when presence is detected?\", options: [\"Yes\",\"No\"]\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"spam\", \"enum\", title: \"Send Me Notifications?\", options: [\"Yes\", \"No\"]\n        }\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(presence1, \"presence\", presence)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presence)\n}\n\ndef presence(evt)\n{\n\tif (evt.value == \"present\") {\n\t\tif (unlock == \"Yes\") {\n\t\t\tdef anyLocked = lock1.count{it.currentLock == \"unlocked\"} != lock1.size()\n\t\t\tif (anyLocked) {\n\t\t\t\tsendMessage(\"Doors unlocked at arrival of $evt.linkText\")\n\t\t\t}\n\t\t\tlock1.unlock()\n\t\t}\n\t}\n\telse {\n\t\tdef nobodyHome = presence1.find{it.currentPresence == \"present\"} == null\n\t\tif (nobodyHome) {\n\t\t\tdef anyUnlocked = lock1.count{it.currentLock == \"locked\"} != lock1.size()\n\t\t\tif (anyUnlocked) {\n\t\t\t\tsendMessage(\"Doors locked after everyone departed\")\n\t\t\t}\n\t\t\tlock1.lock()\n\t\t}\n\t}\n}\n\ndef sendMessage(msg) {\n\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (spam == \"Yes\") {\n            sendPush msg\n        }\n    }\n}",
        "docstring": "Locks a deadbolt or lever lock when a SmartSense Presence tag or smartphone leaves a location."
    },
    {
        "code": "preferences(oauthPage: \"deviceAuthorization\") {\n\tpage(name: \"Credentials\", title: \"Connect to your Logitech Harmony device\", content: \"authPage\", install: false, nextPage: \"deviceAuthorization\")\n\tpage(name: \"deviceAuthorization\", title: \"Logitech Harmony device authorization\", install: true) {\n\t\tsection(\"Allow Logitech Harmony to control these things...\") {\n\t\t\tinput \"switches\", \"capability.switch\", title: \"Which Switches?\", multiple: true, required: false\n\t\t\tinput \"motionSensors\", \"capability.motionSensor\", title: \"Which Motion Sensors?\", multiple: true, required: false\n\t\t\tinput \"contactSensors\", \"capability.contactSensor\", title: \"Which Contact Sensors?\", multiple: true, required: false\n\t\t\tinput \"thermostats\", \"capability.thermostat\", title: \"Which Thermostats?\", multiple: true, required: false\n\t\t\tinput \"presenceSensors\", \"capability.presenceSensor\", title: \"Which Presence Sensors?\", multiple: true, required: false\n\t\t\tinput \"temperatureSensors\", \"capability.temperatureMeasurement\", title: \"Which Temperature Sensors?\", multiple: true, required: false\n\t\t\tinput \"accelerationSensors\", \"capability.accelerationSensor\", title: \"Which Vibration Sensors?\", multiple: true, required: false\n\t\t\tinput \"waterSensors\", \"capability.waterSensor\", title: \"Which Water Sensors?\", multiple: true, required: false\n\t\t\tinput \"lightSensors\", \"capability.illuminanceMeasurement\", title: \"Which Light Sensors?\", multiple: true, required: false\n\t\t\tinput \"humiditySensors\", \"capability.relativeHumidityMeasurement\", title: \"Which Relative Humidity Sensors?\", multiple: true, required: false\n\t\t\tinput \"alarms\", \"capability.alarm\", title: \"Which Sirens?\", multiple: true, required: false\n\t\t\tinput \"locks\", \"capability.lock\", title: \"Which Locks?\", multiple: true, required: false\n\t\t}\n\t}\n\tpage(name: \"revokeToken\", title: \"You have succesfully logged out of the account.\", install: false, nextPage: null)\n}\n\nmappings {\n\tpath(\"/devices\") { action: [ GET: \"listDevices\"] }\n\tpath(\"/devices/:id\") { action: [ GET: \"getDevice\", PUT: \"updateDevice\"] }\n\tpath(\"/subscriptions\") { action: [ GET: \"listSubscriptions\", POST: \"addSubscription\"] }\n\tpath(\"/subscriptions/:id\") { action: [ DELETE: \"removeSubscription\"] }\n\tpath(\"/phrases\") { action: [ GET: \"listPhrases\"] }\n\tpath(\"/phrases/:id\") { action: [ PUT: \"executePhrase\"] }\n\tpath(\"/hubs\") { action: [ GET: \"listHubs\" ] }\n\tpath(\"/hubs/:id\") { action: [ GET: \"getHub\" ] }\n\tpath(\"/activityCallback/:dni\") { action: [ POST: \"activityCallback\" ] }\n\tpath(\"/harmony\") { action: [ GET: \"getHarmony\", POST: \"harmony\" ] }\n\tpath(\"/harmony/:mac\") { action: [ DELETE: \"deleteHarmony\" ] }\n\tpath(\"/receivedToken\") { action: [ POST: \"receivedToken\", GET: \"receivedToken\"] }\n\tpath(\"/receiveToken\") { action: [ POST: \"receiveToken\", GET: \"receiveToken\"] }\n\tpath(\"/hookCallback\") { action: [ POST: \"hookEventHandler\", GET: \"hookEventHandler\"] }\n\tpath(\"/oauth/callback\") { action: [ GET: \"callback\" ] }\n\tpath(\"/oauth/initialize\") { action: [ GET: \"init\"] }\n}\n\ndef getServerUrl() { return \"https://graph.api.smartthings.com\" }\ndef getServercallbackUrl() { \"https://graph.api.smartthings.com/oauth/callback\" }\ndef getBuildRedirectUrl() { \"${serverUrl}/oauth/initialize?appId=${app.id}&access_token=${state.accessToken}&apiServerUrl=${apiServerUrl}\" }\n\ndef authPage() {\n\tdef description = null\n\tif (!state.HarmonyAccessToken) {\n\t\tif (!state.accessToken) {\n\t\t\tlog.debug \"Harmony - About to create access token\"\n\t\t\tcreateAccessToken()\n\t\t}\n\t\tdescription = \"Click to enter Harmony Credentials\"\n\t\tdef redirectUrl = buildRedirectUrl\n\t\treturn dynamicPage(name: \"Credentials\", title: \"Harmony\", nextPage: null, uninstall: true, install:false) {\n\t\t\tsection { paragraph title: \"Note:\", \"This device has not been officially tested and certified to “Work with SmartThings”. You can connect it to your SmartThings home but performance may vary and we will not be able to provide support or assistance.\" }\n\t\t\tsection { href url:redirectUrl, style:\"embedded\", required:true, title:\"Harmony\", description:description }\n\t\t}\n\t} else {\n\t\t//device discovery request every 5 //25 seconds\n\t\tint deviceRefreshCount = !state.deviceRefreshCount ? 0 : state.deviceRefreshCount as int\n\t\tstate.deviceRefreshCount = deviceRefreshCount + 1\n\t\tdef refreshInterval = 5\n\n\t\tdef huboptions = state.HarmonyHubs ?: []\n\t\tdef actoptions = state.HarmonyActivities ?: []\n\n\t\tdef numFoundHub = huboptions.size() ?: 0\n\t\tdef numFoundAct = actoptions.size() ?: 0\n\n\t\tif((deviceRefreshCount % 5) == 0) {\n\t\t\tdiscoverDevices()\n\t\t}\n\n\t\treturn dynamicPage(name:\"Credentials\", title:\"Discovery Started!\", nextPage:\"\", refreshInterval:refreshInterval, install:true, uninstall: true) {\n\t\t\tsection(\"Please wait while we discover your Harmony Hubs and Activities. Discovery can take five minutes or more, so sit back and relax! Select your device below once discovered.\") {\n\t\t\t\tinput \"selectedhubs\", \"enum\", required:false, title:\"Select Harmony Hubs (${numFoundHub} found)\", multiple:true, submitOnChange: true, options:huboptions\n\t\t\t}\n\t  \t// Virtual activity flag\n\t  \tif (numFoundHub > 0 && numFoundAct > 0 && true)\n\t\t\tsection(\"You can also add activities as virtual switches for other convenient integrations\") {\n\t\t\t\tinput \"selectedactivities\", \"enum\", required:false, title:\"Select Harmony Activities (${numFoundAct} found)\", multiple:true, submitOnChange: true, options:actoptions\n\t\t\t}\n\t\t\tsection(\"\") {\n\t\t\t\tparagraph \"If you have added another hub to your Logitech Harmony account you need to log out and reconnect to authorize access.\"\n\t\t\t\thref \"revokeToken\", title: \"Log out from account\", description: \"\", state: \"incomplete\"\n\t\t\t}\n\t\tif (state.resethub)\n\t\t\tsection(\"Connection to the hub timed out. Please restart the hub and try again.\") {}\n\t\t}\n\t}\n}\n\ndef revokeToken() {\n\t return dynamicPage(name: \"revokeToken\", title: \"You have succesfully logged out of the account.\") {\n\t \tdeleteToken()\n\t }\n}\n\ndef callback() {\n\tdef redirectUrl = null\n\tif (params.authQueryString) {\n\t\tredirectUrl = URLDecoder.decode(params.authQueryString.replaceAll(\".+&redirect_url=\", \"\"))\n\t\tlog.debug \"Harmony - redirectUrl: ${redirectUrl}\"\n\t} else {\n\t\tlog.warn \"Harmony - No authQueryString\"\n\t}\n\n\tif (state.HarmonyAccessToken) {\n\t\tlog.debug \"Harmony - Access token already exists\"\n\t\tdiscovery()\n\t\tsuccess()\n\t} else {\n\t\tdef code = params.code\n\t\tif (code) {\n\t\t\tif (code.size() > 6) {\n\t\t\t\t// Harmony code\n\t\t\t\tlog.debug \"Harmony - Exchanging code for access token\"\n\t\t\t\treceiveToken(redirectUrl)\n\t\t\t} else {\n\t\t\t\t// Initiate the Harmony OAuth flow.\n\t\t\t\tinit()\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Harmony - This code should be unreachable\"\n\t\t\tsuccess()\n\t\t}\n\t}\n}\n\ndef deleteToken() {\n\tif (state?.HarmonyAccessToken) {\n\t\tstate.HarmonyAccessToken = null;\n\t}\n}\n\ndef init() {\n\tlog.debug \"Harmony - Requesting Code\"\n\tdef oauthParams = [client_id: \"${appSettings.clientId}\", scope: \"remote\", response_type: \"code\", redirect_uri: \"${servercallbackUrl}\" ]\n\tredirect(location: \"https://home.myharmony.com/oauth2/authorize?${toQueryString(oauthParams)}\")\n}\n\ndef receiveToken(redirectUrl = null) {\n\tlog.debug \"Harmony - receiveToken\"\n\tdef oauthParams = [ client_id: \"${appSettings.clientId}\", client_secret: \"${appSettings.clientSecret}\", grant_type: \"authorization_code\", code: params.code ]\n\tdef params = [\n\t  uri: \"https://home.myharmony.com/oauth2/token?${toQueryString(oauthParams)}\",\n\t]\n\ttry {\n\t\thttpPost(params) { response ->\n\t\t\tstate.HarmonyAccessToken = response.data.access_token\n\t\t}\n\t} catch (java.util.concurrent.TimeoutException e) {\n\t\tfail(e)\n\t\tlog.warn \"Harmony - Connection timed out, please try again later.\"\n\t}\n\tdiscovery()\n\tif (state.HarmonyAccessToken) {\n\t\tsuccess()\n\t} else {\n\t\tfail(\"\")\n\t}\n}\n\ndef success() {\n\tdef message = \"\"\"\n\t\t<p>Your Harmony Account is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef fail(msg) {\n\tdef message = \"\"\"\n\t\t<p>The connection could not be established!</p>\n\t\t<p>$msg</p>\n\t\t<p>Click 'Done' to return to the menu.</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef receivedToken() {\n\tdef message = \"\"\"\n\t\t<p>Your Harmony Account is already connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t\"\"\"\n\tconnectionStatus(message)\n}\n\ndef connectionStatus(message, redirectUrl = null) {\n\tdef redirectHtml = \"\"\n\tif (redirectUrl) {\n\t\tredirectHtml = \"\"\"\n\t\t\t<meta http-equiv=\"refresh\" content=\"3; url=${redirectUrl}\" />\n\t\t\"\"\"\n\t}\n\n\tdef html = \"\"\"\n\t\t<!DOCTYPE html>\n\t\t<html>\n\t\t<head>\n\t\t<meta name=\"viewport\" content=\"width=640\">\n\t\t<title>SmartThings Connection</title>\n\t\t<style type=\"text/css\">\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t.container {\n\t\t\t\twidth: 560px;\n\t\t\t\tpadding: 40px;\n\t\t\t\t/*background: #eee;*/\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\timg {\n\t\t\t\tvertical-align: middle;\n\t\t\t}\n\t\t\timg:nth-child(2) {\n\t\t\t\tmargin: 0 30px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 2.2em;\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\ttext-align: center;\n\t\t\t\tcolor: #666666;\n\t\t\t\tpadding: 0 40px;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\t\t/*\n\t\t\tp:last-child {\n\t\t\t\tmargin-top: 0px;\n\t\t\t}\n\t\t*/\n\t\t\tspan {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t}\n\t\t</style>\n\t\t${redirectHtml}\n\t\t</head>\n\t\t<body>\n\t\t\t<div class=\"container\">\n\t\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/harmony@2x.png\" alt=\"Harmony icon\" />\n\t\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t\t\t${message}\n\t\t\t</div>\n\t\t</body>\n\t\t</html>\n\t\"\"\"\n\trender contentType: 'text/html', data: html\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef buildRedirectUrl(page) {\n\treturn \"${serverUrl}/api/token/${state.accessToken}/smartapps/installations/${app.id}/${page}\"\n}\n\ndef installed() {\n\tif (!state.accessToken) {\n\t\tlog.debug \"Harmony - About to create access token\"\n\t\tcreateAccessToken()\n\t} else {\n\t\tinitialize()\n\t}\n}\n\ndef updated() {\n\tif (!state.accessToken) {\n\t\tlog.debug \"Harmony - About to create access token\"\n\t\tcreateAccessToken()\n\t} else {\n\t\tinitialize()\n\t}\n}\n\ndef uninstalled() {\n\tif (state.HarmonyAccessToken) {\n\t\ttry {\n\t\t\tstate.HarmonyAccessToken = \"\"\n\t\t\tlog.debug \"Harmony - Success disconnecting Harmony from SmartThings\"\n\t\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tlog.error \"Harmony - Error disconnecting Harmony from SmartThings: ${e.statusCode}\"\n\t\t}\n\t}\n}\n\ndef initialize() {\n\tstate.aux = 0\n\tif (selectedhubs || selectedactivities) {\n\t\taddDevice()\n\t\trunEvery5Minutes(\"poll\")\n\t\tlog.trace getActivityList()\n\t}\n}\n\ndef getHarmonydevices() {\n\tstate.Harmonydevices ?: []\n}\n\nMap discoverDevices() {\n\tlog.trace \"Harmony - Discovering devices...\"\n\tdiscovery()\n\tif (getHarmonydevices() != []) {\n\t\tdef devices = state.Harmonydevices.hubs\n\t\tlog.trace devices.toString()\n\t\tdef activities = [:]\n\t\tdef hubs = [:]\n\t\tdevices.each {\n\t\t\tif (it.value.response){\n\t\t\t\tdef hubkey = it.key\n\t\t\t\tdef hubname = getHubName(it.key)\n\t\t\t\tdef hubvalue = \"${hubname}\"\n\t\t\t\thubs[\"harmony-${hubkey}\"] = hubvalue\n\t\t\t\tit.value.response.data?.activities?.each {\n\t\t\t\t\tdef value = \"${it.value.name}\"\n\t\t\t\t\tdef key = \"harmony-${hubkey}-${it.key}\"\n\t\t\t\t\tactivities[\"${key}\"] = value\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.trace \"Harmony - Device $it.key is no longer available\"\n\t\t\t}\n\t\t}\n\t\tstate.HarmonyHubs = hubs\n\t\tstate.HarmonyActivities = activities\n\t}\n}\n\n//CHILD DEVICE METHODS\ndef discovery() {\n\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\tdef url = \"https://home.myharmony.com/cloudapi/activity/all?${toQueryString(tokenParam)}\"\n\tdef params = [\n\t\turi: url,\n\t\tcontentType: 'application/json'\n\t]\n\tasynchttp_v1.get('discoveryResponse', params)\n\tlog.trace \"Harmony - Discovery Command Sent\"\n}\n\ndef discoveryResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Connection to the hub timed out. Please restart the hub and try again.\"\n\t\t\tstate.resethub = true\n\t\t}\n\t} else {\n\t\tif (response.status == 200) {\n\t\t\tlog.debug \"Harmony - valid Token\"\n\t\t\tstate.Harmonydevices = response.json\n\t\t\tstate.resethub = false\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Error, response status: $response.status\"\n\t\t}\n\t}\n}\n\ndef addDevice() {\n\tlog.trace \"Harmony - Adding Hubs\"\n\tselectedhubs.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newAction = state.HarmonyHubs.find { it.key == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Logitech Harmony Hub C2C\", dni, null, [label:\"${newAction.value}\"])\n\t\t\tlog.trace \"Harmony - Created ${d.displayName} with id $dni\"\n\t\t\tpoll()\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n\tlog.trace \"Harmony - Adding Activities\"\n\tselectedactivities.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newAction = state.HarmonyActivities.find { it.key == dni }\n\t\t\tif (newAction) {\n\t\t\t\td = addChildDevice(\"smartthings\", \"Harmony Activity\", dni, null, [label:\"${newAction.value} [Harmony Activity]\"])\n\t\t\t\tlog.trace \"Harmony - Created ${d.displayName} with id $dni\"\n\t\t\t\tpoll()\n\t\t\t}\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Found ${d.displayName} with id $dni already exists\"\n\t\t}\n\t}\n}\n\ndef activity(dni,mode) {\n\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\tdef url\n\tif (dni == \"all\") {\n\t\turl = \"https://home.myharmony.com/cloudapi/activity/off?${toQueryString(tokenParam)}\"\n\t} else {\n\t\tdef aux = dni.split('-')\n\t\tdef hubId = aux[1]\n\t\tif (mode == \"hub\" || (aux.size() <= 2) || (aux[2] == \"off\")){\n\t\t\turl = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/off?${toQueryString(tokenParam)}\"\n\t\t} else {\n\t\t  def activityId = aux[2]\n\t\t\turl = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/${activityId}/${mode}?${toQueryString(tokenParam)}\"\n\t\t}\n\t}\n\tdef params = [\n\t\turi: url,\n\t\tcontentType: 'application/json'\n\t]\n\tasynchttp_v1.post('activityResponse', params)\n\tlog.trace \"Harmony - Command Sent\"\n}\n\ndef activityResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tif (response.status == 200) {\n\t\t\tlog.trace \"Harmony - Command sent succesfully\"\n\t\t} else {\n\t\t\tlog.trace \"Harmony - Command failed. Error: $response.status\"\n\t\t}\n\t}\n}\n\ndef poll() {\n\t// GET THE LIST OF ACTIVITIES\n\tif (state.HarmonyAccessToken) {\n\t\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\t\tdef params = [\n\t\t\turi: \"https://home.myharmony.com/cloudapi/state?${toQueryString(tokenParam)}\",\n\t\t\theaders: [\"Accept\": \"application/json\"],\n\t\t\tcontentType: 'application/json'\n\t\t]\n\t\tasynchttp_v1.get('pollResponse', params)\n\t  } else {\n\t\tlog.warn \"Harmony - Access token has expired\"\n\t  }\n}\n\ndef pollResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tdef activities = getChildDevices()\n\t\t// Device-Watch relies on the Logitech Harmony Cloud to get the Device state.\n\t\tactivities.each { activity ->\n\t\t\tactivity.sendEvent(name: \"DeviceWatch-DeviceStatus\", value: \"offline\", displayed: false, isStateChange: true)\n\t\t}\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tdef ResponseValues\n\t\tdef currentActivities = []\n\t\ttry {\n\t\t\t// json response already parsed into JSONElement object\n\t\t\tResponseValues = response.json\n\t\t} catch (e) {\n\t\t\tlog.error \"Harmony - error parsing json from response: $e\"\n\t\t}\n\t\tif (ResponseValues) {\n\t\t\tlog.debug \"Harmony - response body: $response.data\"\n\t\t\tdef activities = getChildDevices()\n\t\t\tResponseValues.hubs.each {\n\t\t\t\t// Device-Watch relies on the Logitech Harmony Cloud to get the Device state.\n\t\t\t\tactivities.each { activity ->\n\t\t\t\t\tif (\"${activity.deviceNetworkId}\".contains(\"harmony-${it.key}\")) {\n\t\t\t\t\t\tactivity.sendEvent(name: \"DeviceWatch-DeviceStatus\", value: \"online\", displayed: false, isStateChange: true)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (it.value.message == \"OK\") {\n\t\t\t\t\tdef hub = getChildDevice(\"harmony-${it.key}\")\n\t\t\t\t\tif (hub) {\n\t\t\t\t\t\tif (it.value.response.data.currentAvActivity == \"-1\") {\n\t\t\t\t\t\t\thub.sendEvent(name: \"currentActivity\", value: \"--\", descriptionText: \"There isn't any activity running\", displayed: false)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdef currentActivity\n\t\t\t\t\t\t\tdef activityDTH = getChildDevice(\"harmony-${it.key}-${it.value.response.data.currentAvActivity}\")\n\t\t\t\t\t\t\tif (activityDTH)\n\t\t\t\t\t\t\t\tcurrentActivity = activityDTH.device.displayName\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrentActivity = getActivityName(it.value.response.data.currentAvActivity,it.key)\n\t\t\t\t\t\t\thub.sendEvent(name: \"currentActivity\", value: currentActivity, descriptionText: \"Current activity is ${currentActivity}\", displayed: false)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tit.value.response.data.currentActivities.each {currentActivity ->\n\t\t\t\t\t\t\tcurrentActivities.add(\"harmony-${it.key}-${currentActivity}\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t  \t} else {\n\t\t\t\t\tlog.trace \"Harmony - error response: $it.value.message\"\n\t\t\t  \t}\n\t\t\t}\n\t\t\tdef activitynotrunning = true\n\t\t\tlog.debug \"Harmony - Current Activities: $currentActivities\"\n\t\t\tactivities.each { activity ->\n\t\t\t\tif (currentActivities.contains(\"$activity.deviceNetworkId\")) {\n\t\t\t\t\tactivity.sendEvent(name: \"switch\", value: \"on\")\n\t\t\t\t} else {\n\t\t\t\t\tactivity.sendEvent(name: \"switch\", value: \"off\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug \"Harmony - did not get json results from response body: $response.data\"\n\t\t}\n\t}\n}\n\ndef getActivityList() {\n\tif (state.HarmonyAccessToken) {\n\t\tdef tokenParam = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/activity/all?${toQueryString(tokenParam)}\"\n\t\tdef params = [\n\t\t\turi: url,\n\t\t\tcontentType: 'application/json'\n\t\t]\n\t\tasynchttp_v1.get('getActivityListResponse', params)\n\t\tlog.trace \"Harmony - Activity List Request Sent\"\n\t}\n}\n\ndef getActivityListResponse(response, data) {\n\tif (response.hasError()) {\n\t\tlog.error \"Harmony - response has error: $response.errorMessage\"\n\t\tif (response.status == 401) { // token is expired\n\t\t\tstate.remove(\"HarmonyAccessToken\")\n\t\t\tlog.warn \"Harmony - Access token has expired\"\n\t\t}\n\t} else {\n\t\tlog.trace \"Harmony - Parsing Activity List Response\"\n\t\tresponse.json.hubs.each {\n\t\t\tdef hub = getChildDevice(\"harmony-${it.key}\")\n\t\t\tif (hub) {\n\t\t\t\tdef hubname = getHubName(\"${it.key}\")\n\t\t\t\tdef activities = []\n\t\t\t\tdef aux = it.value.response.data.activities.size()\n\t\t\t\tif (aux >= 1) {\n\t\t\t\t\tactivities = it.value.response.data.activities.collect {\n\t\t\t\t\t\t[id: it.key, name: it.value['name'], type: it.value['type']]\n\t\t\t\t\t}\n\t\t\t\t\tactivities += [id: \"off\", name: \"Activity OFF\", type: \"0\"]\n\t\t\t\t}\n\t\t\t\thub.sendEvent(name: \"activities\", value: new groovy.json.JsonBuilder(activities).toString(), descriptionText: \"Activities are ${activities.collect { it.name }?.join(', ')}\", displayed: false)\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef getActivityName(activity,hubId) {\n\t// GET ACTIVITY'S NAME\n\tdef actname = activity\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/all?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\tactname = response.data.data.activities[activity].name\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace e\n\t\t}\n\t}\n\treturn actname\n}\n\ndef getActivityId(activity,hubId) {\n\t// GET ACTIVITY'S NAME\n\tdef actid = activity\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/activity/all?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\tresponse.data.data.activities.each {\n\t\t\t\t\tif (it.value.name == activity)\n\t\t\t\t\t\tactid = it.key\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace \"Harmony - getActivityId() response $e\"\n\t\t}\n\t}\n\treturn actid\n}\n\ndef getHubName(hubId) {\n\t// GET HUB'S NAME\n\tdef hubname = hubId\n\tif (state.HarmonyAccessToken) {\n\t\tdef Params = [auth: state.HarmonyAccessToken]\n\t\tdef url = \"https://home.myharmony.com/cloudapi/hub/${hubId}/discover?${toQueryString(Params)}\"\n\t\ttry {\n\t\t\thttpGet(uri: url, headers: [\"Accept\": \"application/json\"]) {response ->\n\t\t\t\thubname = response.data.data.name\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tlog.trace \"Harmony - getHubName() response $e\"\n\t\t}\n\t}\n\treturn hubname\n}\n\ndef sendNotification(msg) {\n\tsendNotification(msg)\n}\n\ndef hookEventHandler() {\n\t// log.debug \"In hookEventHandler method.\"\n\tlog.debug \"Harmony - request = ${request}\"\n\n\tdef json = request.JSON\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\ndef listDevices() {\n\tlog.debug \"Harmony - getDevices(), params: ${params}\"\n\tallDevices.collect {\n\t\tdeviceItem(it)\n\t}\n}\n\ndef getDevice() {\n\tlog.debug \"Harmony - getDevice(), params: ${params}\"\n\tdef device = allDevices.find { it.id == params.id }\n\tif (!device) {\n\t\trender status: 404, data: '{\"msg\": \"Device not found\"}'\n\t} else {\n\t\tdeviceItem(device)\n\t}\n}\n\ndef updateDevice() {\n\tdef data = request.JSON\n\tdef command = data.command\n\tdef arguments = data.arguments\n\tlog.debug \"Harmony - updateDevice(), params: ${params}, request: ${data}\"\n\tif (!command) {\n\t\trender status: 400, data: '{\"msg\": \"command is required\"}'\n\t} else {\n\t\tdef device = allDevices.find { it.id == params.id }\n\tif (device) {\n\t\tif (validateCommand(device, command)) {\n\t\t\tif (arguments) {\n\t\t\t\tdevice.\"$command\"(*arguments)\n\t\t\t} else {\n\t\t\t\tdevice.\"$command\"()\n\t\t\t}\n\t\t\trender status: 204, data: \"{}\"\n\t\t} else {\n\t\t  render status: 403, data: '{\"msg\": \"Access denied. This command is not supported by current capability.\"}'\n\t\t}\n\t} else {\n\t  render status: 404, data: '{\"msg\": \"Device not found\"}'\n\t}\n  }\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(device)\n\tif (currentDeviceCapability != \"\" && capabilityCommands[currentDeviceCapability]) {\n\treturn (command in capabilityCommands[currentDeviceCapability] || (currentDeviceCapability == \"Switch\" && command == \"setLevel\" && device.hasCommand(\"setLevel\"))) ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(device) {\n\tdef capName = \"\"\n\tif (switches.find{it.id == device.id})\n\t\t\tcapName = \"Switch\"\n\t\telse if (alarms.find{it.id == device.id})\n\t\t\tcapName = \"Alarm\"\n\t\telse if (locks.find{it.id == device.id})\n\t\t\tcapName = \"Lock\"\n\tlog.trace \"Device: $device - Capability Name: $capName\"\n\t\treturn capName\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\ndef listSubscriptions() {\n\tlog.debug \"Harmony - listSubscriptions()\"\n\tapp.subscriptions?.findAll { it.device?.device && it.device.id }?.collect {\n\t\tdef deviceInfo = state[it.device.id]\n\t\tdef response = [\n\t\t\tid: it.id,\n\t\t\tdeviceId: it.device.id,\n\t\t\tattributeName: it.data,\n\t\t\thandler: it.handler\n\t\t]\n\t\tif (!state.harmonyHubs) {\n\t\t\tresponse.callbackUrl = deviceInfo?.callbackUrl\n\t\t}\n\t\tresponse\n\t} ?: []\n}\n\ndef addSubscription() {\n\tdef data = request.JSON\n\tdef attribute = data.attributeName\n\tdef callbackUrl = data.callbackUrl\n\n\tlog.debug \"Harmony - addSubscription, params: ${params}, request: ${data}\"\n\tif (!attribute) {\n\t\trender status: 400, data: '{\"msg\": \"attributeName is required\"}'\n\t} else {\n\t\tdef device = allDevices.find { it.id == data.deviceId }\n\t\tif (device) {\n\t\t\tif (!state.harmonyHubs) {\n\t\t\t\tlog.debug \"Harmony - Adding callbackUrl: $callbackUrl\"\n\t\t\t\tstate[device.id] = [callbackUrl: callbackUrl]\n\t\t\t}\n\t\t\tlog.debug \"Harmony - Adding subscription\"\n\t\t\tdef subscription = subscribe(device, attribute, deviceHandler)\n\t\t\tif (!subscription || !subscription.eventSubscription) {\n\t\t\t\tsubscription = app.subscriptions?.find { it.device?.device && it.device.id == data.deviceId && it.data == attribute && it.handler == 'deviceHandler' }\n\t\t\t}\n\n\t\t\tdef response = [\n\t\t\t\tid: subscription.id,\n\t\t\t\tdeviceId: subscription.device.id,\n\t\t\t\tattributeName: subscription.data,\n\t\t\t\thandler: subscription.handler\n\t\t\t]\n\t\t\tif (!state.harmonyHubs) {\n\t\t\t\tresponse.callbackUrl = callbackUrl\n\t\t\t}\n\t\t\tresponse\n\t\t} else {\n\t\t\trender status: 400, data: '{\"msg\": \"Device not found\"}'\n\t\t}\n\t}\n}\n\ndef removeSubscription() {\n\tdef subscription = app.subscriptions?.find { it.id == params.id }\n\tdef device = subscription?.device\n\n\tlog.debug \"removeSubscription, params: ${params}, subscription: ${subscription}, device: ${device}\"\n\tif (device) {\n\t\tlog.debug \"Harmony - Removing subscription for device: ${device.id}\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n\trender status: 204, data: \"{}\"\n}\n\ndef listPhrases() {\n\tlocation.helloHome.getPhrases()?.collect {[\n\t\tid: it.id,\n\t\tlabel: it.label\n\t]}\n}\n\ndef executePhrase() {\n\tlog.debug \"executedPhrase, params: ${params}\"\n\tlocation.helloHome.execute(params.id)\n\trender status: 204, data: \"{}\"\n}\n\ndef deviceHandler(evt) {\n\tdef deviceInfo = state[evt.deviceId]\n\tif (state.harmonyHubs) {\n\t\tstate.harmonyHubs.each { harmonyHub ->\n\t  log.trace \"Harmony - Sending data to $harmonyHub.name\"\n\t\t\tsendToHarmony(evt, harmonyHub.callbackUrl)\n\t\t}\n\t} else if (deviceInfo) {\n\t\tif (deviceInfo.callbackUrl) {\n\t\t\tsendToHarmony(evt, deviceInfo.callbackUrl)\n\t\t} else {\n\t\t\tlog.warn \"Harmony - No callbackUrl set for device: ${evt.deviceId}\"\n\t\t}\n\t} else {\n\t\tlog.warn \"Harmony - No subscribed device found for device: ${evt.deviceId}\"\n\t}\n}\n\ndef sendToHarmony(evt, String callbackUrl) {\n  def callback = new URI(callbackUrl)\n  if (callback.port != -1) {\n  \tdef host = callback.port != -1 ? \"${callback.host}:${callback.port}\" : callback.host\n  \tdef path = callback.query ? \"${callback.path}?${callback.query}\".toString() : callback.path\n  \tsendHubCommand(new physicalgraph.device.HubAction(\n  \t\tmethod: \"POST\",\n  \t\tpath: path,\n  \t\theaders: [\n  \t\t\t\"Host\": host,\n  \t\t\t\"Content-Type\": \"application/json\"\n  \t\t],\n  \t\tbody: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]\n  \t))\n  } else {\n\tdef params = [\n\t  uri: callbackUrl,\n\t  body: [evt: [deviceId: evt.deviceId, name: evt.name, value: evt.value]]\n\t]\n\ttry {\n\t\tlog.debug \"Harmony - Sending data to Harmony Cloud: $params\"\n\t\thttpPostJson(params) { resp ->\n\t\t\tlog.debug \"Harmony - Cloud Response: ${resp.status}\"\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"Harmony - Cloud Something went wrong: $e\"\n\t}\n  }\n}\n\ndef listHubs() {\n\tlocation.hubs?.findAll { it.type.toString() == \"PHYSICAL\" }?.collect { hubItem(it) }\n}\n\ndef getHub() {\n\tdef hub = location.hubs?.findAll { it.type.toString() == \"PHYSICAL\" }?.find { it.id == params.id }\n\tif (!hub) {\n\t\trender status: 404, data: '{\"msg\": \"Hub not found\"}'\n\t} else {\n\t\thubItem(hub)\n\t}\n}\n\ndef activityCallback() {\n\tdef data = request.JSON\n\tdef device = getChildDevice(params.dni)\n\tif (device) {\n\t\tif (data.errorCode == \"200\") {\n\t\t\tdevice.setCurrentActivity(data.currentActivityId)\n\t\t} else {\n\t\t\tlog.warn \"Harmony - Activity callback error: ${data}\"\n\t\t}\n\t} else {\n\t\tlog.warn \"Harmony - Activity callback sent to non-existant dni: ${params.dni}\"\n\t}\n\trender status: 200, data: '{\"msg\": \"Successfully received callbackUrl\"}'\n}\n\ndef getHarmony() {\n\tstate.harmonyHubs ?: []\n}\n\ndef harmony() {\n\tdef data = request.JSON\n\tif (data.mac && data.callbackUrl && data.name) {\n\t\tif (!state.harmonyHubs) { state.harmonyHubs = [] }\n\t\tdef harmonyHub = state.harmonyHubs.find { it.mac == data.mac }\n\t\tif (harmonyHub) {\n\t\t\tharmonyHub.mac = data.mac\n\t\t\tharmonyHub.callbackUrl = data.callbackUrl\n\t\t\tharmonyHub.name = data.name\n\t\t} else {\n\t\t\tstate.harmonyHubs << [mac: data.mac, callbackUrl: data.callbackUrl, name: data.name]\n\t\t}\n\t\trender status: 200, data: '{\"msg\": \"Successfully received Harmony data\"}'\n\t} else {\n\t\tif (!data.mac) {\n\t\t\trender status: 400, data: '{\"msg\": \"mac is required\"}'\n\t\t} else if (!data.callbackUrl) {\n\t\t\trender status: 400, data: '{\"msg\": \"callbackUrl is required\"}'\n\t\t} else if (!data.name) {\n\t\t\trender status: 400, data: '{\"msg\": \"name is required\"}'\n\t\t}\n\t}\n}\n\ndef deleteHarmony() {\n\tlog.debug \"Harmony - Trying to delete Harmony hub with mac: ${params.mac}\"\n\tdef harmonyHub = state.harmonyHubs?.find { it.mac == params.mac }\n\tif (harmonyHub) {\n\t\tlog.debug \"Harmony - Deleting Harmony hub with mac: ${params.mac}\"\n\t\tstate.harmonyHubs.remove(harmonyHub)\n\t} else {\n\t\tlog.debug \"Harmony - Couldn't find Harmony hub with mac: ${params.mac}\"\n\t}\n\trender status: 204, data: \"{}\"\n}\n\ndef getAllDevices() {\n\t([] + switches + motionSensors + contactSensors + thermostats + presenceSensors + temperatureSensors + accelerationSensors + waterSensors + lightSensors + humiditySensors + alarms + locks)?.findAll()?.unique { it.id }\n}\n\ndef deviceItem(device) {\n\t[\n\t\tid: device.id,\n\t\tlabel: device.displayName,\n\t\tcurrentStates: device.currentStates,\n\t\tcapabilities: device.capabilities?.collect {[\n\t\t\tname: it.name\n\t\t]},\n\t\tattributes: device.supportedAttributes?.collect {[\n\t\t\tname: it.name,\n\t\t\tdataType: it.dataType,\n\t\t\tvalues: it.values\n\t\t]},\n\t\tcommands: device.supportedCommands?.collect {[\n\t\t\tname: it.name,\n\t\t\targuments: it.arguments\n\t\t]},\n\t\ttype: [\n\t\t\tname: device.typeName,\n\t\t\tauthor: device.typeAuthor\n\t\t]\n\t]\n}\n\ndef hubItem(hub) {\n\t[\n\t\tid: hub.id,\n\t\tname: hub.name,\n\t\tip: hub.localIP,\n\t\tport: hub.localSrvPortTCP\n\t]\n}",
        "docstring": "Allows you to integrate your Logitech Harmony account with SmartThings."
    },
    {
        "code": "section(\"Notify me...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"pushNotification\", \"bool\", title: \"Push notification\", required: false, defaultValue: \"true\"\n            input \"phone1\", \"phone\", title: \"Phone number\", required: false\n        }\n\t}\n}\n\ndef installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\t// Don't send a continuous stream of notifications\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentNotifications = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentNotifications) {\n\t\tlog.debug \"Notifications already sent within the last $deltaSeconds seconds (phone1: $phone1, pushNotification: $pushNotification)\"\n\t}\n\telse {\n        if (location.contactBookEnabled) {\n            log.debug \"$accelerationSensor has moved, notifying ${recipients?.size()}\"\n            sendNotificationToContacts(\"Mail has arrived!\", recipients)\n        }\n        else {\n        if (phone1 != null && phone1 != \"\") {\n            log.debug \"$accelerationSensor has moved, texting $phone1\"\n            sendSms(phone1, \"Mail has arrived!\")\n        }\n        if (pushNotification) {\n            log.debug \"$accelerationSensor has moved, sending push\"\n            sendPush(\"Mail has arrived!\")\n        }\n    }\n\t}\n}",
        "docstring": "Send a text when mail arrives in your mailbox using a SmartSense Multi on your mailbox door. Note: battery life may be impacted in cold climates."
    },
    {
        "code": "section(\"Thermostats\") {\n\t\tinput \"thermostats\", \"capability.thermostat\", multiple: true, required: false\n\t}\n\tsection(\"Locks\") {\n\t\tinput \"locks\", \"capability.lock\", multiple: true, required: false\n\t}\n}\n\ndef installed() {\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n\tsaveState()\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(location, changedLocationMode)\n\tsubscribe(app, appTouch)\n\tsaveState()\n}\n\ndef appTouch(evt)\n{\n\trestoreState(currentMode)\n}\n\ndef changedLocationMode(evt)\n{\n\trestoreState(evt.value)\n}\n\nprivate restoreState(mode)\n{\n\tlog.info \"restoring state for mode '$mode'\"\n\tdef map = state[mode] ?: [:]\n\tswitches?.each {\n\t\tdef value = map[it.id]\n\t\tif (value?.switch == \"on\") {\n\t\t\tdef level = value.level\n\t\t\tif (level) {\n\t\t\t\tlog.debug \"setting $it.label level to $level\"\n\t\t\t\tit.setLevel(level)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.debug \"turning $it.label on\"\n\t\t\t\tit.on()\n\t\t\t}\n\t\t}\n\t\telse if (value?.switch == \"off\") {\n\t\t\tlog.debug \"turning $it.label off\"\n\t\t\tit.off()\n\t\t}\n\t}\n\n\tthermostats?.each {\n\t\tdef value = map[it.id]\n\t\tif (value?.coolingSetpoint) {\n\t\t\tlog.debug \"coolingSetpoint = $value.coolingSetpoint\"\n\t\t\tit.setCoolingSetpoint(value.coolingSetpoint)\n\t\t}\n\t\tif (value?.heatingSetpoint) {\n\t\t\tlog.debug \"heatingSetpoint = $value.heatingSetpoint\"\n\t\t\tit.setHeatingSetpoint(value.heatingSetpoint)\n\t\t}\n\t}\n\n\tlocks?.each {\n\t\tdef value = map[it.id]\n\t\tif (value) {\n\t\t\tif (value?.locked) {\n\t\t\t\tit.lock()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit.unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nprivate saveState()\n{\n\tdef mode = currentMode\n\tdef map = state[mode] ?: [:]\n\n\tswitches?.each {\n\t\tmap[it.id] = [switch: it.currentSwitch, level: it.currentLevel]\n\t}\n\n\tthermostats?.each {\n\t\tmap[it.id] = [coolingSetpoint: it.currentCoolingSetpoint, heatingSetpoint: it.currentHeatingSetpoint]\n\t}\n\n\tlocks?.each {\n\t\tmap[it.id] = [locked: it.currentLock == \"locked\"]\n\t}\n\n\tstate[mode] = map\n\tlog.debug \"saved state for mode ${mode}: ${state[mode]}\"\n\tlog.debug \"state: $state\"\n}\n\nprivate getCurrentMode()\n{\n\tlocation.mode ?: \"_none_\"\n}",
        "docstring": "Saves the states of a specified set switches and thermostat setpoints and restores them at each mode change. To use 1) Set the mode, 2) Change switches and setpoint to where you want them for that mode, and 3) Install or update the app. Changing to that mode or touching the app will set the devices to the saved state."
    },
    {
        "code": "section(\"Take my medicine at...\"){\n\t\tinput \"time1\", \"time\", title: \"Time 1\"\n\t\tinput \"time2\", \"time\", title: \"Time 2\", required: false\n\t\tinput \"time3\", \"time\", title: \"Time 3\", required: false\n\t\tinput \"time4\", \"time\", title: \"Time 4\", required: false\n\t}\n\tsection(\"I forget send me a notification and/or text message...\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPush\", \"enum\", title: \"Push Notification\", required: false, options: [\"Yes\", \"No\"]\n            input \"phone1\", \"phone\", title: \"Phone Number\", required: false\n        }\n\t}\n\tsection(\"Time window (optional, defaults to plus or minus 15 minutes\") {\n\t\tinput \"timeWindow\", \"decimal\", title: \"Minutes\", required: false\n\t}\n}\n\ndef installed()\n{\n\tinitialize()\n}\n\ndef updated()\n{\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tdef window = timeWindowMsec\n\t[time1, time2, time3, time4].eachWithIndex {time, index ->\n\t\tif (time != null) {\n\t\t\tdef endTime = new Date(timeToday(time, location?.timeZone).time + window)\n\t\t\tlog.debug \"Scheduling check at $endTime\"\n\t\t\t//runDaily(endTime, \"scheduleCheck${index}\")\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tschedule(endTime, scheduleCheck0)\n\t\t\t\t\tbreak\n\t\t\t\tcase 1:\n\t\t\t\t\tschedule(endTime, scheduleCheck1)\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\tschedule(endTime, scheduleCheck2)\n\t\t\t\t\tbreak\n\t\t\t\tcase 3:\n\t\t\t\t\tschedule(endTime, scheduleCheck3)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef scheduleCheck0() { scheduleCheck() }\ndef scheduleCheck1() { scheduleCheck() }\ndef scheduleCheck2() { scheduleCheck() }\ndef scheduleCheck3() { scheduleCheck() }\n\ndef scheduleCheck()\n{\n\tlog.debug \"scheduleCheck\"\n\tdef t0 = new Date(now() - (2 * timeWindowMsec))\n\tdef t1 = new Date()\n\tdef cabinetOpened = cabinet1.eventsBetween(t0, t1).find{it.name == \"contact\" && it.value == \"open\"}\n\tlog.trace \"Looking for events between $t0 and $t1: $cabinetOpened\"\n\n\tif (cabinetOpened) {\n\t\tlog.trace \"Medicine cabinet was opened since $midnight, no notification required\"\n\t} else {\n\t\tlog.trace \"Medicine cabinet was not opened since $midnight, sending notification\"\n\t\tsendMessage()\n\t}\n}\n\nprivate sendMessage() {\n\tdef msg = \"Please remember to take your medicine\"\n\tlog.info msg\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (phone1) {\n            sendSms(phone1, msg)\n        }\n        if (sendPush == \"Yes\") {\n            sendPush(msg)\n        }\n    }\n}\n\ndef getTimeWindowMsec() {\n\t(timeWindow ?: 15) * 60000 as Long\n}",
        "docstring": "Set up a reminder so that if you forget to take your medicine (determined by whether a cabinet or drawer has been opened) by specified time you get a notification or text message."
    },
    {
        "code": "section(\"Using this controller\") {\n\t\tinput \"controller\", \"capability.button\", title: \"Aeon minimote\"\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tstate.colorIndex = -1    \n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe controller, \"button\", buttonHandler\n}\n\ndef buttonHandler(evt) {\n\tswitch(evt.jsonData?.buttonNumber) {\n    \tcase 2:\n        \tif (evt.value == \"held\") {\n            \tbulbs.setLevel(100)\n            }\n            else {\n            \tlevelUp()\n            }\n        \tbreak\n        \n        case 3:\n        \tif (evt.value == \"held\") {\n                def color = [name:\"Soft White\", hue: 23, saturation: 56]\n                bulbs.setColor(hue: color.hue, saturation: color.saturation)            \t\n            }\n            else {\n            \tchangeColor()\n            }\n        \tbreak\n        \n        case 4:\n        \tif (evt.value == \"held\") {\n            \tbulbs.setLevel(10)\n            }\n            else {\n            \tlevelDown()\n            }\n        \tbreak\n        \n        default:\n        \ttoggleState()\n        \tbreak\n    }\n}\n\nprivate toggleState() {\n\tif (currentSwitchState == \"on\") {\n    \tlog.debug \"off\"\n    \tbulbs.off()\n    }\n    else {\n    \tlog.debug \"on\"\n    \tbulbs.on()\n    }\n}\n\nprivate levelUp() {\n\tdef level = Math.min(currentSwitchLevel + 10, 100)\n    log.debug \"level = $level\"\n    bulbs.setLevel(level)\n}\n\nprivate levelDown() {\n\tdef level = Math.max(currentSwitchLevel - 10, 10)\n\tlog.debug \"level = $level\"\n    bulbs.setLevel(level)\n}\n\nprivate changeColor() {\n\n\tfinal colors = [\n        [name:\"Soft White\", hue: 23, saturation: 56],\n        [name:\"Daylight\", hue: 53, saturation: 91],\n        [name:\"White\", hue: 52, saturation: 19],\n        [name:\"Warm White\", hue: 20, saturation: 80],\n        [name:\"Blue\", hue: 70, saturation: 100],\n        [name:\"Green\", hue: 39, saturation: 100],\n        [name:\"Yellow\", hue: 25, saturation: 100],\n        [name:\"Orange\", hue: 10, saturation: 100],\n        [name:\"Purple\", hue: 75, saturation: 100],\n        [name:\"Pink\", hue: 83, saturation: 100],\n        [name:\"Red\", hue: 100, saturation: 100]\n\t]\n    \n    final maxIndex = colors.size() - 1\n    \n    if (state.colorIndex < maxIndex) {\n    \tstate.colorIndex = state.colorIndex + 1\n    }\n    else {\n    \tstate.colorIndex = 0\n    }\n    \n    def color = colors[state.colorIndex]\n    bulbs.setColor(hue: color.hue, saturation: color.saturation)\n}\n\nprivate getCurrentSwitchState() {\n\tdef on = 0\n    def off = 0\n    bulbs.each {\n    \tif (it.currentValue(\"switch\") == \"on\") {\n        \ton++\n        }\n        else {\n        \toff++\n        }\n    }\n    on > off ? \"on\" : \"off\"\n}\n\nprivate getCurrentSwitchLevel() {\n\tdef level = 0\n    bulbs.each {\n    \tlevel = Math.max(it.currentValue(\"level\")?.toInteger() ?: 0, level)\n    }\n    level.toInteger()\n}",
        "docstring": "Control one or more Hue bulbs using an Aeon MiniMote."
    },
    {
        "code": "section(\"To control these lights\") {\n\t\t\tinput \"lights\", \"capability.switch\", multiple: true, required: false, title: \"Lights, switches & dimmers\"\n\t\t}\n\t\tsection([title: \" \", mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}\n\t}\n\tpage(name: \"scenesPage\", title: \"Scenes\", install: true, uninstall: true)\n\tpage(name: \"scenePage\", title: \"Scene\", install: false, uninstall: false, previousPage: \"scenesPage\")\n\tpage(name: \"devicePage\", install: false, uninstall: false, previousPage: \"scenePage\")\n\tpage(name: \"saveStatesPage\", install: false, uninstall: false, previousPage: \"scenePage\")\n}\n\n\ndef scenesPage() {\n\tlog.debug \"scenesPage()\"\n\tdef sceneId = getOrientation()\n\tdynamicPage(name:\"scenesPage\") {\n\t\tsection {\n\t\t\tfor (num in 1..6) {\n\t\t\t\thref \"scenePage\", title: \"${num}. ${sceneName(num)}${sceneId==num ? ' (current)' : ''}\", params: [sceneId:num], description: \"\", state: sceneIsDefined(num) ? \"complete\" : \"incomplete\"\n\t\t\t}\n\t\t}\n\t\tsection {\n\t\t\thref \"scenesPage\", title: \"Refresh\", description: \"\"\n\t\t}\n\t}\n}\n\ndef scenePage(params=[:]) {\n\tlog.debug \"scenePage($params)\"\n\tdef currentSceneId = getOrientation()\n\tdef sceneId = params.sceneId as Integer ?: state.lastDisplayedSceneId\n\tstate.lastDisplayedSceneId = sceneId\n\tdynamicPage(name:\"scenePage\", title: \"${sceneId}. ${sceneName(sceneId)}\") {\n\t\tsection {\n\t\t\tinput \"sceneName${sceneId}\", \"text\", title: \"Scene Name\", required: false\n\t\t}\n\n\t\tsection {\n\t\t\thref \"devicePage\", title: \"Show Device States\", params: [sceneId:sceneId], description: \"\", state: sceneIsDefined(sceneId) ? \"complete\" : \"incomplete\"\n\t\t}\n\n        section {\n            href \"saveStatesPage\", title: \"Record Current Device States\", params: [sceneId:sceneId], description: \"\"\n        }\n\t}\n}\n\ndef devicePage(params) {\n\tlog.debug \"devicePage($params)\"\n\n\tgetDeviceCapabilities()\n\n\tdef sceneId = params.sceneId as Integer ?: state.lastDisplayedSceneId\n\n\tdynamicPage(name:\"devicePage\", title: \"${sceneId}. ${sceneName(sceneId)} Device States\") {\n\t\tsection(\"Lights\") {\n\t\t\tlights.each {light ->\n\t\t\t\tinput \"onoff_${sceneId}_${light.id}\", \"boolean\", title: light.displayName\n\t\t\t}\n\t\t}\n\n\t\tsection(\"Dimmers\") {\n\t\t\tlights.each {light ->\n\t\t\t\tif (state.lightCapabilities[light.id] in [\"level\", \"color\"]) {\n\t\t\t\t\tinput \"level_${sceneId}_${light.id}\", \"enum\", title: light.displayName, options: levels, description: \"\", required: false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsection(\"Colors (hue/saturation)\") {\n\t\t\tlights.each {light ->\n\t\t\t\tif (state.lightCapabilities[light.id] == \"color\") {\n\t\t\t\t\tinput \"color_${sceneId}_${light.id}\", \"text\", title: light.displayName, description: \"\", required: false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef saveStatesPage(params) {\n\tsaveStates(params)\n\tdevicePage(params)\n}\n\n\n/*************************\n * Installation & update *\n *************************/\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe cube, \"threeAxis\", positionHandler\n}\n\n\n/******************\n * Event handlers *\n ******************/\ndef positionHandler(evt) {\n\n\tdef sceneId = getOrientation(evt.xyzValue)\n\tlog.trace \"orientation: $sceneId\"\n\n\tif (sceneId != state.lastActiveSceneId) {\n\t\trestoreStates(sceneId)\n\t}\n\telse {\n\t\tlog.trace \"No status change\"\n\t}\n\tstate.lastActiveSceneId = sceneId\n}\n\n\n/******************\n * Helper methods *\n ******************/\nprivate Boolean sceneIsDefined(sceneId) {\n\tdef tgt = \"onoff_${sceneId}\".toString()\n\tsettings.find{it.key.startsWith(tgt)} != null\n}\n\nprivate updateSetting(name, value) {\n\tapp.updateSetting(name, value)\n\tsettings[name] = value\n}\n\nprivate closestLevel(level) {\n\tlevel ? \"${Math.round(level/5) * 5}%\" : \"0%\"\n}\n\nprivate saveStates(params) {\n\tlog.trace \"saveStates($params)\"\n\tdef sceneId = params.sceneId as Integer\n\tgetDeviceCapabilities()\n\n\tlights.each {light ->\n\t\tdef type = state.lightCapabilities[light.id]\n\n\t\tupdateSetting(\"onoff_${sceneId}_${light.id}\", light.currentValue(\"switch\") == \"on\")\n\n\t\tif (type == \"level\") {\n\t\t\tupdateSetting(\"level_${sceneId}_${light.id}\", closestLevel(light.currentValue('level')))\n\t\t}\n\t\telse if (type == \"color\") {\n\t\t\tupdateSetting(\"level_${sceneId}_${light.id}\", closestLevel(light.currentValue('level')))\n\t\t\tupdateSetting(\"color_${sceneId}_${light.id}\", \"${light.currentValue(\"hue\")}/${light.currentValue(\"saturation\")}\")\n\t\t}\n\t}\n}\n\n\nprivate restoreStates(sceneId) {\n\tlog.trace \"restoreStates($sceneId)\"\n\tgetDeviceCapabilities()\n\n\tlights.each {light ->\n\t\tdef type = state.lightCapabilities[light.id]\n\n\t\tdef isOn = settings.\"onoff_${sceneId}_${light.id}\" == \"true\" ? true : false\n\t\tlog.debug \"${light.displayName} is '$isOn'\"\n\t\tif (isOn) {\n\t\t\tlight.on()\n\t\t}\n\t\telse {\n\t\t\tlight.off()\n\t\t}\n\n\t\tif (type != \"switch\") {\n\t\t\tdef level = switchLevel(sceneId, light)\n\n\t\t\tif (type == \"level\") {\n\t\t\t\tlog.debug \"${light.displayName} level is '$level'\"\n\t\t\t\tif (level != null) {\n\t\t\t\t\tlight.setLevel(level)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == \"color\") {\n\t\t\t\tdef segs = settings.\"color_${sceneId}_${light.id}\"?.split(\"/\")\n\t\t\t\tif (segs?.size() == 2) {\n\t\t\t\t\tdef hue = segs[0].toInteger()\n\t\t\t\t\tdef saturation = segs[1].toInteger()\n\t\t\t\t\tlog.debug \"${light.displayName} color is level: $level, hue: $hue, sat: $saturation\"\n\t\t\t\t\tif (level != null) {\n\t\t\t\t\t\tlight.setColor(level: level, hue: hue, saturation: saturation)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlight.setColor(hue: hue, saturation: saturation)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"${light.displayName} level is '$level'\"\n\t\t\t\t\tif (level != null) {\n\t\t\t\t\t\tlight.setLevel(level)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.error \"Unknown type '$type'\"\n\t\t\t}\n\t\t}\n\n\n\t}\n}\n\nprivate switchLevel(sceneId, light) {\n\tdef percent = settings.\"level_${sceneId}_${light.id}\"\n\tif (percent) {\n\t\tpercent[0..-2].toInteger()\n\t}\n\telse {\n\t\tnull\n\t}\n}\n\nprivate getDeviceCapabilities() {\n\tdef caps = [:]\n\tlights.each {\n\t\tif (it.hasCapability(\"Color Control\")) {\n\t\t\tcaps[it.id] = \"color\"\n\t\t}\n\t\telse if (it.hasCapability(\"Switch Level\")) {\n\t\t\tcaps[it.id] = \"level\"\n\t\t}\n\t\telse {\n\t\t\tcaps[it.id] = \"switch\"\n\t\t}\n\t}\n\tstate.lightCapabilities = caps\n}\n\nprivate getLevels() {\n\tdef levels = []\n\tfor (int i = 0; i <= 100; i += 5) {\n\t\tlevels << \"$i%\"\n\t}\n\tlevels\n}\n\nprivate getOrientation(xyz=null) {\n\tfinal threshold = 250\n\n\tdef value = xyz ?: cube.currentValue(\"threeAxis\")\n\n\tdef x = Math.abs(value.x) > threshold ? (value.x > 0 ? 1 : -1) : 0\n\tdef y = Math.abs(value.y) > threshold ? (value.y > 0 ? 1 : -1) : 0\n\tdef z = Math.abs(value.z) > threshold ? (value.z > 0 ? 1 : -1) : 0\n\n\tdef orientation = 0\n\tif (z > 0) {\n\t\tif (x == 0 && y == 0) {\n\t\t\torientation = 1\n\t\t}\n\t}\n\telse if (z < 0) {\n\t\tif (x == 0 && y == 0) {\n\t\t\torientation = 2\n\t\t}\n\t}\n\telse {\n\t\tif (x > 0) {\n\t\t\tif (y == 0) {\n\t\t\t\torientation = 3\n\t\t\t}\n\t\t}\n\t\telse if (x < 0) {\n\t\t\tif (y == 0) {\n\t\t\t\torientation = 4\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (y > 0) {\n\t\t\t\torientation = 5\n\t\t\t}\n\t\t\telse if (y < 0) {\n\t\t\t\torientation = 6\n\t\t\t}\n\t\t}\n\t}\n\n\torientation\n}\n\nprivate sceneName(num) {\n\tfinal names = [\"UNDEFINED\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\"]\n\tsettings.\"sceneName${num}\" ?: \"Scene ${names[num]}\"\n}",
        "docstring": "Set your lighting by rotating a cube containing a SmartSense Multi"
    },
    {
        "code": "section(\"Select devices to control\") {\n            input \"switch1\", \"capability.switch\", title: \"Light or switch\", required: false, multiple: true\n            input \"lock\", \"capability.lock\", title: \"Lock\", required: false, multiple: true\n            input \"garageDoor\", \"capability.doorControl\", title: \"Garage door controller\", required: false, multiple: true\n        }\n    }\n    \n    page(name: \"pageTwo\", title: \"Master devices\", install: true, uninstall: true)\n}\n\ndef pageTwo() {\n\tdynamicPage(name: \"pageTwo\") {\n    \tsection(\"If set, the state of these devices will be toggled each time the tag is touched, \" + \n                \"e.g. a light that's on will be turned off and one that's off will be turned on, \" +\n                \"other devices of the same type will be set to the same state as their master device. \" +\n                \"If no master is designated then the majority of devices of the same type will be used \" +\n                \"to determine whether to turn on or off the devices.\") {\n            \n            if (switch1 || masterSwitch) {\n                input \"masterSwitch\", \"enum\", title: \"Master switch\", options: switch1.collect{[(it.id): it.displayName]}, required: false\n            }\n            if (lock || masterLock) {\n                input \"masterLock\", \"enum\", title: \"Master lock\", options: lock.collect{[(it.id): it.displayName]}, required: false\n            }\n            if (garageDoor || masterDoor) {\n                input \"masterDoor\", \"enum\", title: \"Master door\", options: garageDoor.collect{[(it.id): it.displayName]}, required: false\n            }            \n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}        \n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe tag, \"nfcTouch\", touchHandler\n    subscribe app, touchHandler\n}\n\nprivate currentStatus(devices, master, attribute) {\n\tlog.trace \"currentStatus($devices, $master, $attribute)\"\n\tdef result = null\n\tif (master) {\n    \tresult = devices.find{it.id == master}?.currentValue(attribute)\n    }\n    else {\n    \tdef map = [:]\n        devices.each {\n        \tdef value = it.currentValue(attribute)\n            map[value] = (map[value] ?: 0) + 1\n            log.trace \"$it.displayName: $value\"\n        }\n        log.trace map\n        result = map.collect{it}.sort{it.value}[-1].key\n    }\n    log.debug \"$attribute = $result\"\n    result\n}\n\ndef touchHandler(evt) {\n\tlog.trace \"touchHandler($evt.descriptionText)\"\n    if (switch1) {\n    \tdef status = currentStatus(switch1, masterSwitch, \"switch\")\n        switch1.each {\n            if (status == \"on\") {\n                it.off()\n            }\n            else {\n                it.on()\n            }\n        }\n    }\n    \n    if (lock) {\n    \tdef status = currentStatus(lock, masterLock, \"lock\")\n        lock.each {\n            if (status == \"locked\") {\n                lock.unlock()\n            }\n            else {\n                lock.lock()\n            }\n        }\n    }\n    \n    if (garageDoor) {\n        def status = currentStatus(garageDoor, masterDoor, \"status\")\n    \tgarageDoor.each {\n        \tif (status == \"open\") {\n            \tit.close()\n            }\n            else {\n            \tit.open()\n            }\n        }\n    }\n}",
        "docstring": "Allows toggling of a switch, lock, or garage door based on an NFC Tag touch event"
    },
    {
        "code": "}\n\ndef installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$contact1 was opened, sending push message to user\"\n\tsendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n}",
        "docstring": "Get a push message sent to your phone when an open/close sensor is opened."
    },
    {
        "code": "section(\"Send this message (optional, sends standard status message if not specified)\"){\n\t\tinput \"messageText\", \"text\", title: \"Message Text\", required: false\n\t}\n\tsection(\"Via a push notification and/or an SMS message\"){\n\t\tinput(\"recipients\", \"contact\", title: \"Send notifications to\") {\n\t\t\tinput \"phone\", \"phone\", title: \"Enter a phone number to get SMS\", required: false\n\t\t\tparagraph \"If outside the US please make sure to enter the proper country code\"\n\t\t\tinput \"pushAndPhone\", \"enum\", title: \"Notify me via Push Notification\", required: false, options: [\"Yes\", \"No\"]\n\t\t}\n\t}\n\tsection(\"Minimum time between messages (optional, defaults to every message)\") {\n\t\tinput \"frequency\", \"decimal\", title: \"Minutes\", required: false\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(button, \"button.pushed\", eventHandler) //tw\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tlog.debug \"Notify got evt ${evt}\"\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}\n}\n\nprivate sendMessage(evt) {\n\tString msg = messageText\n\tMap options = [:]\n\n\tif (!messageText) {\n\t\tmsg = defaultText(evt)\n\t\toptions = [translatable: true, triggerEvent: evt]\n\t}\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients, options)\n\t} else {\n\t\tif (phone) {\n\t\t\toptions.phone = phone\n\t\t\tif (pushAndPhone != 'No') {\n\t\t\t\tlog.debug 'Sending push and SMS'\n\t\t\t\toptions.method = 'both'\n\t\t\t} else {\n\t\t\t\tlog.debug 'Sending SMS'\n\t\t\t\toptions.method = 'phone'\n\t\t\t}\n\t\t} else if (pushAndPhone != 'No') {\n\t\t\tlog.debug 'Sending push'\n\t\t\toptions.method = 'push'\n\t\t} else {\n\t\t\tlog.debug 'Sending nothing'\n\t\t\toptions.method = 'none'\n\t\t}\n\t\tsendNotification(msg, options)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}\n\nprivate defaultText(evt) {\n\tif (evt.name == 'presence') {\n\t\tif (evt.value == 'present') {\n\t\t\tif (includeArticle) {\n\t\t\t\t'{{ triggerEvent.linkText }} has arrived at the {{ location.name }}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t'{{ triggerEvent.linkText }} has arrived at {{ location.name }}'\n\t\t\t}\n\t\t} else {\n\t\t\tif (includeArticle) {\n\t\t\t\t'{{ triggerEvent.linkText }} has left the {{ location.name }}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t'{{ triggerEvent.linkText }} has left {{ location.name }}'\n\t\t\t}\n\t\t}\n\t} else {\n\t\t'{{ triggerEvent.descriptionText }}'\n\t}\n}\n\nprivate getIncludeArticle() {\n\tdef name = location.name.toLowerCase()\n\tdef segs = name.split(\" \")\n\t!([\"work\",\"home\"].contains(name) || (segs.size() > 1 && ([\"the\",\"my\",\"a\",\"an\"].contains(segs[0]) || segs[0].endsWith(\"'s\"))))\n}",
        "docstring": "Receive notifications when anything happens in your home."
    },
    {
        "code": "section(\"Choose one or more, when...\"){\n\t\tinput \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\tinput \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\tinput \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\tinput \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\tinput \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\tinput \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\tinput \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\tinput \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\tinput \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\tinput \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\tinput \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\tinput \"triggerModes\", \"mode\", title: \"System Changes Mode\", description: \"Select mode(s)\", required: false, multiple: true\n\t\tinput \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t}\n\n\tsection(\"Choose light effects...\")\n\t\t{\n\t\t\tinput \"color\", \"enum\", title: \"Hue Color?\", required: false, multiple:false, options: [\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Purple\",\"Pink\"]\n\t\t\tinput \"lightLevel\", \"enum\", title: \"Light Level?\", required: false, options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]]\n\t\t\tinput \"duration\", \"number\", title: \"Duration Seconds?\", required: false\n\t\t\t//input \"turnOn\", \"enum\", title: \"Turn On when Off?\", required: false, options: [\"Yes\",\"No\"]\n\t\t}\n\n\tsection(\"Minimum time between messages (optional, defaults to every message)\") {\n\t\tinput \"frequency\", \"decimal\", title: \"Minutes\", required: false\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n\telse {\n\t\ttakeAction(evt)\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n\n\tdef hueColor = 0\n\tif(color == \"Blue\")\n\t\thueColor = 70//60\n\telse if(color == \"Green\")\n\t\thueColor = 39//30\n\telse if(color == \"Yellow\")\n\t\thueColor = 25//16\n\telse if(color == \"Orange\")\n\t\thueColor = 10\n\telse if(color == \"Purple\")\n\t\thueColor = 75\n\telse if(color == \"Pink\")\n\t\thueColor = 83\n\n\n\tstate.previous = [:]\n\n\thues.each {\n\t\tstate.previous[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\"),\n\t\t\t\"color\": it.currentValue(\"color\")\t\t\t\n\t\t]\n\t}\n\n\tlog.debug \"current values = $state.previous\"\n\n\tdef newValue = [hue: hueColor, saturation: 100, level: (lightLevel as Integer) ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n\tsetTimer()\n}\n\ndef setTimer()\n{\n\tif(!duration) //default to 10 seconds\n\t{\n\t\tlog.debug \"pause 10\"\n\t\tpause(10 * 1000)\n\t\tlog.debug \"reset hue\"\n\t\tresetHue()\n\t}\n\telse if(duration < 10)\n\t{\n\t\tlog.debug \"pause $duration\"\n\t\tpause(duration * 1000)\n\t\tlog.debug \"resetHue\"\n\t\tresetHue()\n\t}\n\telse\n\t{\n\t\tlog.debug \"runIn $duration, resetHue\"\n\t\trunIn(duration,\"resetHue\", [overwrite: false])\n\t}\n}\n\n\ndef resetHue()\n{\n\thues.each {\n\t\tit.setColor(state.previous[it.id])        \n\t}\n}",
        "docstring": "Changes the color and brightness of Philips Hue bulbs when any of a variety of SmartThings is activated.  Supports motion, contact, acceleration, moisture and presence sensors as well as switches."
    },
    {
        "code": "section(\"Turn them all on at...\") {\n\t\tinput name: \"startTime\", title: \"Turn On Time?\", type: \"time\"\n\t}\n\tsection(\"And turn them off at...\") {\n\t\tinput name: \"stopTime\", title: \"Turn Off Time?\", type: \"time\"\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(startTime, \"startTimerCallback\")\n\tschedule(stopTime, \"stopTimerCallback\")\n\n}\n\ndef updated(settings) {\n\tunschedule()\n\tschedule(startTime, \"startTimerCallback\")\n\tschedule(stopTime, \"stopTimerCallback\")\n}\n\ndef startTimerCallback() {\n\tlog.debug \"Turning on switches\"\n\tswitches.on()\n\n}\n\ndef stopTimerCallback() {\n\tlog.debug \"Turning off switches\"\n\tswitches.off()\n}",
        "docstring": "Turn on one or more switches at a specified time and turn them off at a later time."
    },
    {
        "code": "section(\"Take a burst of pictures\") {\n\t\tinput \"camera\", \"capability.imageCapture\"\n\t\tinput \"burstCount\", \"number\", title: \"How many? (default 5)\", defaultValue:5\n\t}\n\tsection(\"Then send this message in a push notification\"){\n\t\tinput \"messageText\", \"text\", title: \"Message Text\"\n\t}\n\tsection(\"And as text message to this number (optional)\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone\", \"phone\", title: \"Phone Number\", required: false\n        }\n\t}\n\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(contact, \"contact.open\", sendMessage)\n\tsubscribe(acceleration, \"acceleration.active\", sendMessage)\n\tsubscribe(motion, \"motion.active\", sendMessage)\n\tsubscribe(mySwitch, \"switch.on\", sendMessage)\n\tsubscribe(arrivalPresence, \"presence.present\", sendMessage)\n\tsubscribe(departurePresence, \"presence.not present\", sendMessage)\n}\n\ndef sendMessage(evt) {\n\tlog.debug \"$evt.name: $evt.value, $messageText\"\n\n    camera.take()\n\t(1..((burstCount ?: 5) - 1)).each {\n\t\tcamera.take(delay: (500 * it))\n\t}\n\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(messageText, recipients)\n    }\n    else {\n        sendPush(messageText)\n        if (phone) {\n            sendSms(phone, messageText)\n        }\n    }\n}",
        "docstring": "Take a burst of photos and send a push notification when..."
    },
    {
        "code": "section(\"Turn it off how many minutes later?\") {\n\t\tinput \"minutesLater\", \"number\", title: \"When?\"\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(theSwitch, \"switch.on\", switchOnHandler, [filterEvents: false])\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe(theSwitch, \"switch.on\", switchOnHandler, [filterEvents: false])\n}\n\ndef switchOnHandler(evt) {\n\tlog.debug \"Switch ${theSwitch} turned: ${evt.value}\"\n\tdef delay = minutesLater * 60\n\tlog.debug \"Turning off in ${minutesLater} minutes (${delay}seconds)\"\n\trunIn(delay, turnOffSwitch)\n}\n\ndef turnOffSwitch() {\n\ttheSwitch.off()\n}",
        "docstring": "Save energy or restrict total time an appliance (like a curling iron or TV) can be in use.  When a switch turns on, automatically turn it back off after a set number of minutes you specify."
    },
    {
        "code": "}\n\ndef installed() {\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt) {\n\tif (evt.value == \"present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has arrived at the ${location}\"\n    \tsendPush(\"${presence.label ?: presence.name} has arrived at the ${location}\")\n\t} else if (evt.value == \"not present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has left the ${location}\"\n    \tsendPush(\"${presence.label ?: presence.name} has left the ${location}\")\n\t}\n}",
        "docstring": "Get a push notification when a SmartSense Presence tag or smartphone arrives at or departs from a location."
    },
    {
        "code": "section(\"Send a text message to...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\n\ndef installed() {\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(presence, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt) {\n\tif (evt.value == \"present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has arrived at the ${location}\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"${presence.label ?: presence.name} has arrived at the ${location}\", recipients)\n        }\n        else {\n            sendSms(phone1, \"${presence.label ?: presence.name} has arrived at the ${location}\")\n        }\n\t} else if (evt.value == \"not present\") {\n\t\t// log.debug \"${presence.label ?: presence.name} has left the ${location}\"\n\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"${presence.label ?: presence.name} has left the ${location}\", recipients)\n        }\n        else {\n            sendSms(phone1, \"${presence.label ?: presence.name} has left the ${location}\")\n        }\n\t}\n}",
        "docstring": "Send me a text message when my presence status changes."
    },
    {
        "code": "}\n\tsection(\"Car(s) using this garage door\") {\n\t\tinput \"cars\", \"capability.presenceSensor\", title: \"Presence sensor\", description: \"Which car(s)?\", multiple: true, required: false\n\t\tinput \"carDoorSensors\", \"capability.accelerationSensor\", title: \"Car door sensor(s)\", description: \"Which car(s)?\", multiple: true, required: false\n\t}\n\tsection(\"Interior door (optional)\") {\n\t\tinput \"interiorDoorSensor\", \"capability.contactSensor\", title: \"Contact sensor?\", required: false\n\t}\n\tsection(\"False alarm threshold (defaults to 10 min)\") {\n\t\tinput \"falseAlarmThreshold\", \"number\", title: \"Number of minutes\", required: false\n\t}\n}\n\ndef installed() {\n\tlog.trace \"installed()\"\n\tsubscribe()\n}\n\ndef updated() {\n\tlog.trace \"updated()\"\n\tunsubscribe()\n\tsubscribe()\n}\n\ndef subscribe() {\n\t// log.debug \"present: ${cars.collect{it.displayName + ': ' + it.currentPresence}}\"\n\tsubscribe(doorSensor, \"contact\", garageDoorContact)\n\n\tsubscribe(cars, \"presence\", carPresence)\n\tsubscribe(carDoorSensors, \"acceleration\", accelerationActive)\n\n\tif (interiorDoorSensor) {\n\t\tsubscribe(interiorDoorSensor, \"contact.closed\", interiorDoorClosed)\n\t}\n}\n\ndef doorOpenCheck()\n{\n\tfinal thresholdMinutes = openThreshold\n\tif (thresholdMinutes) {\n\t\tdef currentState = doorSensor.contactState\n\t\tlog.debug \"doorOpenCheck\"\n\t\tif (currentState?.value == \"open\") {\n\t\t\tlog.debug \"open for ${now() - currentState.date.time}, openDoorNotificationSent: ${state.openDoorNotificationSent}\"\n\t\t\tif (!state.openDoorNotificationSent && now() - currentState.date.time > thresholdMinutes * 60 *1000) {\n\t\t\t\tdef msg = \"${doorSwitch.displayName} has been open for ${thresholdMinutes} minutes\"\n\t\t\t\tlog.info msg\n\n                if (location.contactBookEnabled) {\n                    sendNotificationToContacts(msg, recipients)\n                }\n                else {\n                    sendPush msg\n                    if (phone) {\n                        sendSms phone, msg\n                    }\n                }\n\t\t\t\tstate.openDoorNotificationSent = true\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate.openDoorNotificationSent = false\n\t\t}\n\t}\n}\n\ndef carPresence(evt)\n{\n\tlog.info \"$evt.name: $evt.value\"\n\t// time in which there must be no \"not present\" events in order to open the door\n\tfinal openDoorAwayInterval = falseAlarmThreshold ? falseAlarmThreshold * 60 : 600\n\n\tif (evt.value == \"present\") {\n\t\t// A car comes home\n\n\t\tdef car = getCar(evt)\n\t\tdef t0 = new Date(now() - (openDoorAwayInterval * 1000))\n\t\tdef states = car.statesSince(\"presence\", t0)\n\t\tdef recentNotPresentState = states.find{it.value == \"not present\"}\n\n\t\tif (recentNotPresentState) {\n\t\t\tlog.debug \"Not opening ${doorSwitch.displayName} since car was not present at ${recentNotPresentState.date}, less than ${openDoorAwayInterval} sec ago\"\n\t\t}\n\t\telse {\n\t\t\tif (doorSensor.currentContact == \"closed\") {\n\t\t\t\topenDoor()\n                sendPush \"Opening garage door due to arrival of ${car.displayName}\"\n                state.appOpenedDoor = now()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.debug \"door already open\"\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// A car departs\n\t\tif (doorSensor.currentContact == \"open\") {\n\t\t\tcloseDoor()\n\t\t\tlog.debug \"Closing ${doorSwitch.displayName} after departure\"\n            sendPush(\"Closing ${doorSwitch.displayName} after departure\")\n\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not closing ${doorSwitch.displayName} because its already closed\"\n\t\t}\n\t}\n}\n\ndef garageDoorContact(evt)\n{\n\tlog.info \"garageDoorContact, $evt.name: $evt.value\"\n\tif (evt.value == \"open\") {\n\t\tschedule(\"0 * * * * ?\", \"doorOpenCheck\")\n\t}\n\telse {\n\t\tunschedule(\"doorOpenCheck\")\n\t}\n}\n\n\ndef interiorDoorClosed(evt)\n{\n\tlog.info \"interiorContact, $evt.name: $evt.value\"\n\n\t// time during which closing the interior door will shut the garage door, if the app opened it\n\tfinal threshold = 15 * 60 * 1000\n\tif (state.appOpenedDoor && now() - state.appOpenedDoor < threshold) {\n\t\tstate.appOpenedDoor = 0\n\t\tcloseDoor()\n\t}\n\telse {\n\t\tlog.debug \"app didn't open door\"\n\t}\n}\n\ndef accelerationActive(evt)\n{\n\tlog.info \"$evt.name: $evt.value\"\n\n\tif (doorSensor.currentContact == \"closed\") {\n\t\tlog.debug \"opening door when car door opened\"\n\t\topenDoor()\n\t}\n}\n\nprivate openDoor()\n{\n\tif (doorSensor.currentContact == \"closed\") {\n\t\tlog.debug \"opening door\"\n\t\tdoorSwitch.push()\n\t}\n}\n\nprivate closeDoor()\n{\n\tif (doorSensor.currentContact == \"open\") {\n\t\tlog.debug \"closing door\"\n\t\tdoorSwitch.push()\n\t}\n}\n\nprivate getCar(evt)\n{\n\tcars.find{it.id == evt.deviceId}\n}",
        "docstring": "Monitors arrival and departure of car(s) and 1) opens door when car arrives, 2) closes door after car has departed (for N minutes), 3) opens door when car door motion is detected, 4) closes door when door was opened due to arrival and interior door is closed."
    },
    {
        "code": "section(\"During this time window (default End Time is 4:00 PM)\") {\n\t\tinput \"timeOfDay\", \"time\", title: \"Start Time?\"\n\t\tinput \"endTime\", \"time\", title: \"End Time?\", required: false\n\t}\n\tsection(\"Change to this mode\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n\tsection(\"And (optionally) turn on these appliances\") {\n\t\tinput \"switches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phoneNumber\", \"phone\", title: \"Send a Text Message?\", required: false\n        }\n\t}\n}\n\ndef installed() {\n\tlog.debug \"installed, current mode = ${location.mode}, state.actionTakenOn = ${state.actionTakenOn}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"updated, current mode = ${location.mode}, state.actionTakenOn = ${state.actionTakenOn}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.trace \"timeOfDay: $timeOfDay, endTime: $endTime\"\n\tsubscribe(motionSensors, \"motion.active\", motionActiveHandler)\n\tsubscribe(location, modeChangeHandler)\n\tif (state.modeStartTime == null) {\n\t\tstate.modeStartTime = 0\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tstate.modeStartTime = now()\n}\n\ndef motionActiveHandler(evt)\n{\n\t// for backward compatibility\n\tif (state.modeStartTime == null) {\n\t\tsubscribe(location, modeChangeHandler)\n\t\tstate.modeStartTime = 0\n\t}\n\n\tdef t0 = now()\n\tdef modeStartTime = new Date(state.modeStartTime)\n\tdef timeZone = location.timeZone ?: timeZone(timeOfDay)\n\tdef startTime = timeTodayAfter(modeStartTime, timeOfDay, timeZone)\n\tdef endTime = timeTodayAfter(startTime, endTime ?: \"16:00\", timeZone)\n\tlog.debug \"startTime: $startTime, endTime: $endTime, t0: ${new Date(t0)}, modeStartTime: ${modeStartTime},  actionTakenOn: $state.actionTakenOn, currentMode: $location.mode, newMode: $newMode \"\n\n\tif (t0 >= startTime.time && t0 <= endTime.time && location.mode != newMode) {\n\t\tdef message = \"Good morning! SmartThings changed the mode to '$newMode'\"\n\t\tsend(message)\n\t\tsetLocationMode(newMode)\n\t\tlog.debug message\n\n\t\tdef dateString = new Date().format(\"yyyy-MM-dd\")\n\t\tlog.debug \"last turned on switches on ${state.actionTakenOn}, today is ${dateString}\"\n\t\tif (state.actionTakenOn != dateString) {\n\t\t\tlog.debug \"turning on switches\"\n\t\t\tstate.actionTakenOn = dateString\n\t\t\tswitches?.on()\n\t\t}\n\n\t}\n\telse {\n\t\tlog.debug \"not in time window, or mode is already set, currentMode = ${location.mode}, newMode = $newMode\"\n\t}\n}\n\nprivate send(msg) {\n\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}",
        "docstring": "Changes mode when someone wakes up after a set time in the morning."
    },
    {
        "code": "section(\"Change to this mode\") {\n\t\tinput \"newMode\", \"mode\", title: \"Mode?\"\n\t}\n\tsection( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phoneNumber\", \"phone\", title: \"Send a text message?\", required: false\n        }\n\t}\n}\n\ndef installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tschedule(time, changeMode)\n}\n\ndef changeMode() {\n\tlog.debug \"changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes\"\n\tif (location.mode != newMode) {\n\t\tif (location.modes?.find{it.name == newMode}) {\n\t\t\tsetLocationMode(newMode)\n\t\t\tsend \"${label} has changed the mode to '${newMode}'\"\n\t\t}\n\t\telse {\n\t\t\tsend \"${label} tried to change to undefined mode '${newMode}'\"\n\t\t}\n\t}\n}\n\nprivate send(msg) {\n\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage == \"Yes\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n\tlog.debug msg\n}\n\nprivate getLabel() {\n\tapp.label ?: \"SmartThings\"\n}",
        "docstring": "Changes mode at a specific time of day."
    },
    {
        "code": "section(\"Send this command to HAM Bridge\"){\n\t\tinput \"HAMBcommand\", \"text\", title: \"Command to send\", required: true\n\t}\n\tsection(\"Server address and port number\"){\n\t\tinput \"server\", \"text\", title: \"Server IP\", description: \"Your HAM Bridger Server IP\", required: true\n\t\tinput \"port\", \"number\", title: \"Port\", description: \"Port Number\", required: true\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tsendHttp()\n}\n\ndef sendHttp() {\ndef ip = \"${settings.server}:${settings.port}\"\ndef deviceNetworkId = \"1234\"\nsendHubCommand(new physicalgraph.device.HubAction(\"\"\"GET /?${settings.HAMBcommand} HTTP/1.1\\r\\nHOST: $ip\\r\\n\\r\\n\"\"\", physicalgraph.device.Protocol.LAN, \"${deviceNetworkId}\"))\n}",
        "docstring": "Sends a command to your HAM Bridge server when SmartThings are activated."
    },
    {
        "code": "}\n\n        if (location.channelName != 'samsungtv') {\n            section( \"Set your location\" ) { input \"zipCode\", \"text\", title: \"Zip code\" }\n        }\n\n        if (location.contactBookEnabled || phone1 || phone2 || phone3) {\n            section(\"In addition to push notifications, send text alerts to...\") {\n                input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n                    input \"phone1\", \"phone\", title: \"Phone Number 1\", required: false\n                    input \"phone2\", \"phone\", title: \"Phone Number 2\", required: false\n                    input \"phone3\", \"phone\", title: \"Phone Number 3\", required: false\n                }\n            }\n        }\n\n        section([mobileOnly:true]) {\n            label title: \"Assign a name\", required: false\n            mode title: \"Set for specific mode(s)\"\n        }\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    scheduleJob()\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unschedule()\n    scheduleJob()\n}\n\ndef scheduleJob() {\n    def sec = Math.round(Math.floor(Math.random() * 60))\n    def min = Math.round(Math.floor(Math.random() * 60))\n    def cron = \"$sec $min * * * ?\"\n    schedule(cron, \"checkForSevereWeather\")\n}\n\ndef checkForSevereWeather() {\n    def alerts\n    if(locationIsDefined()) {\n        if(!(zipcodeIsValid())) {\n            log.warn \"Severe Weather Alert: Invalid zipcode entered, defaulting to location's zipcode\"\n        }\n        def zipToLocation = getTwcLocation(\"$zipCode\").location\n        alerts = getTwcAlerts(\"${zipToLocation.latitude},${zipToLocation.longitude}\")\n    } else {\n        log.warn \"Severe Weather Alert: Location is not defined\"\n    }\n\n    if (alerts) {\n        alerts.each {alert ->\n            def msg = alert.headlineText\n            if (alert.effectiveTimeLocal && !msg.contains(\" from \")) {\n                msg += \" from ${parseAlertTime(alert.effectiveTimeLocal).format(\"E hh:mm a\", TimeZone.getTimeZone(alert.effectiveTimeLocalTimeZone))}\"\n            }\n            if (alert.expireTimeLocal && !msg.contains(\" until \")) {\n                msg += \" until ${parseAlertTime(alert.expireTimeLocal).format(\"E hh:mm a\", TimeZone.getTimeZone(alert.expireTimeLocalTimeZone))}\"\n            }\n            send(msg)\n        }\n    } else {\n        log.info \"No current alerts\"\n    }\n}\n\ndef descriptionFilter(String description) {\n    def filterList = [\"special\", \"statement\", \"test\"]\n    def passesFilter = true\n    filterList.each() { word ->\n        if(description.toLowerCase().contains(word)) { passesFilter = false }\n    }\n    passesFilter\n}\n\ndef locationIsDefined() {\n    zipcodeIsValid() || location.zipCode || ( location.latitude && location.longitude )\n}\n\ndef zipcodeIsValid() {\n    zipCode && zipCode.isNumber() && zipCode.size() == 5\n}\n\nprivate send(message) {\n    sendPush message\n    if (settings.phone1) {\n        sendSms phone1, message\n    }\n    if (settings.phone2) {\n        sendSms phone2, message\n    }\n    if (settings.phone3) {\n        sendSms phone3, message\n    }\n}",
        "docstring": "Get a push notification when severe weather is in your area."
    },
    {
        "code": "section(\"Lights\") {\n\t\t\tinput \"lights_1_pushed\", \"capability.switch\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"lights_1_held\", \"capability.switch\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Locks\") {\n\t\t\tinput \"locks_1_pushed\", \"capability.lock\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"locks_1_held\", \"capability.lock\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Sonos\") {\n\t\t\tinput \"sonos_1_pushed\", \"capability.musicPlayer\", title: \"Pushed\", multiple: true, required: false\n\t\t\tinput \"sonos_1_held\", \"capability.musicPlayer\", title: \"Held\", multiple: true, required: false\n\t\t}\n\t\tsection(\"Modes\") {\n\t\t\tinput \"mode_1_pushed\", \"mode\", title: \"Pushed\", required: false\n\t\t\tinput \"mode_1_held\", \"mode\", title: \"Held\", required: false\n\t\t}\n\t\tdef phrases = location.helloHome?.getPhrases()*.label\n\t\tif (phrases) {\n\t\t\tsection(\"Hello Home Actions\") {\n\t\t\t\tlog.trace phrases\n\t\t\t\tinput \"phrase_1_pushed\", \"enum\", title: \"Pushed\", required: false, options: phrases\n\t\t\t\tinput \"phrase_1_held\", \"enum\", title: \"Held\", required: false, options: phrases\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef configured() {\n\treturn buttonDevice || buttonConfigured(1)\n}\n\ndef buttonConfigured(idx) {\n\treturn settings[\"lights_$idx_pushed\"] ||\n\t\tsettings[\"locks_$idx_pushed\"] ||\n\t\tsettings[\"sonos_$idx_pushed\"] ||\n\t\tsettings[\"mode_$idx_pushed\"]\n}\n\ndef buttonEvent(evt){\n\tdef buttonNumber = evt.data // why doesn't jsonData work? always returning [:]\n\tdef value = evt.value\n\tlog.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\tlog.debug \"button: $buttonNumber, value: $value\"\n\n\tdef recentEvents = buttonDevice.eventsSince(new Date(now() - 3000)).findAll{it.value == evt.value}\n\tlog.debug \"Found ${recentEvents.size()?:0} events in past 3 seconds\"\n\n\texecuteHandlers(1, value)\n}\n\ndef executeHandlers(buttonNumber, value) {\n\tlog.debug \"executeHandlers: $buttonNumber - $value\"\n\n\tdef lights = find('lights', buttonNumber, value)\n\tif (lights != null) toggle(lights)\n\n\tdef locks = find('locks', buttonNumber, value)\n\tif (locks != null) toggle(locks)\n\n\tdef sonos = find('sonos', buttonNumber, value)\n\tif (sonos != null) toggle(sonos)\n\n\tdef mode = find('mode', buttonNumber, value)\n\tif (mode != null) changeMode(mode)\n\n\tdef phrase = find('phrase', buttonNumber, value)\n\tif (phrase != null) location.helloHome.execute(phrase)\n}\n\ndef find(type, buttonNumber, value) {\n\tdef preferenceName = type + \"_\" + buttonNumber + \"_\" + value\n\tdef pref = settings[preferenceName]\n\tif(pref != null) {\n\t\tlog.debug \"Found: $pref for $preferenceName\"\n\t}\n\n\treturn pref\n}\n\ndef toggle(devices) {\n\tlog.debug \"toggle: $devices = ${devices*.currentValue('switch')}\"\n\n\tif (devices*.currentValue('switch').contains('on')) {\n\t\tdevices.off()\n\t}\n\telse if (devices*.currentValue('switch').contains('off')) {\n\t\tdevices.on()\n\t}\n\telse if (devices*.currentValue('lock').contains('locked')) {\n\t\tdevices.unlock()\n\t}\n\telse if (devices*.currentValue('lock').contains('unlocked')) {\n\t\tdevices.lock()\n\t}\n\telse {\n\t\tdevices.on()\n\t}\n}\n\ndef changeMode(mode) {\n\tlog.debug \"changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes\"\n\n\tif (location.mode != mode && location.modes?.find { it.name == mode }) {\n\t\tsetLocationMode(mode)\n\t}\n}",
        "docstring": "Use your Aeon Panic Button to setup events when the button is used"
    },
    {
        "code": "def phrases = location.helloHome?.getPhrases()*.label\n\t\tif (phrases) {\n        \tphrases.sort()\n\t\t\tsection(\"Hello Home Actions\") {\n\t\t\t\tlog.trace phrases\n\t\t\t\tinput \"sleepPhrase\", \"enum\", title: \"Enter Sleep Mode (Bedtime) Phrase\", required: false, options: phrases,  submitOnChange:true\n\t\t\t\tinput \"wakePhrase\", \"enum\", title: \"Exit Sleep Mode (Waking Up) Phrase\", required: false, options: phrases,  submitOnChange:true\n\t\t\t}\n\t\t}\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n    \n    log.debug \"Subscribing to sleeping events.\"\n    \n   \tsubscribe (jawbone, \"sleeping\", jawboneHandler)\n    \n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n    \n    log.debug \"Subscribing to sleeping events.\"\n        \n   \tsubscribe (jawbone, \"sleeping\", jawboneHandler)\n    \n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef jawboneHandler(evt) {\n\tlog.debug \"In Jawbone Event Handler, Event Name = ${evt.name}, Value = ${evt.value}\"\n\tif (evt.value == \"sleeping\" && sleepPhrase) {\n    \tlog.debug \"Sleeping\"\n        sendNotificationEvent(\"Sleepy Time performing \\\"${sleepPhrase}\\\" for you as requested.\")\n    \tlocation.helloHome.execute(settings.sleepPhrase)\n    }\n    else if (evt.value == \"not sleeping\" && wakePhrase) {\n    \tlog.debug \"Awake\"\n        sendNotificationEvent(\"Sleepy Time performing \\\"${wakePhrase}\\\" for you as requested.\")\n\t\tlocation.helloHome.execute(settings.wakePhrase)\n    }\n        \n}",
        "docstring": "Use Jawbone sleep mode events to automatically execute Hello, Home phrases. Automatially put the house to bed or wake it up in the morning by pushing the button on your UP."
    },
    {
        "code": "else {\n\t\tdynamicPage(name: \"configuration\") {\n\t\t\tsection(disclaimerText){\n\t\t\t\tinput \"disclaimerResponse\", \"enum\", title: \"Accept terms\", required: true,\n\t\t\t\t\t\toptions: [\"I agree to these terms\", \"I do not agree to these terms\"],\n\t\t\t\t\t\tsubmitOnChange: true\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef configurationPage(){\n\tdynamicPage(name: \"configuration\") {\n\t\tsection(\"Who are you checking on?\") {\n\t\t\tinput \"person1\", \"text\", title: \"Name?\"\n\t\t}\n\t\tsection(\"If there’s no movement (optional, leave blank to not require)...\") {\n\t\t\tinput \"motion1\", \"capability.motionSensor\", title: \"Where?\", required: false\n\t\t}\n\t\tsection(\"or a door or cabinet hasn’t been opened (optional, leave blank to not require)...\") {\n\t\t\tinput \"contact1\", \"capability.contactSensor\", required: false\n\t\t}\n\t\tsection(\"between these times...\") {\n\t\t\tinput \"time0\", \"time\", title: \"From what time?\"\n\t\t\tinput \"time1\", \"time\", title: \"Until what time?\"\n\t\t}\n\t\tsection(\"then alert the following people...\") {\n\t\t\tinput(\"recipients\", \"contact\", title: \"People to notify\", description: \"Send notifications to\") {\n\t\t\t\tinput \"phone1\", \"phone\", title: \"Phone number?\", required: false\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe() //TODO no longer subscribe like we used to - clean this up after all apps updated\n\tunschedule()\n\tschedule(time1, \"scheduleCheck\")\n}\n\ndef scheduleCheck()\n{\n\tif(noRecentContact() && noRecentMotion()) {\n\t\tdef person = person1 ?: \"your elder\"\n\t\tdef msg = \"Alert! There has been no activity at ${person}‘s place ${timePhrase}\"\n\t\tlog.debug msg\n\n\t\tif (location.contactBookEnabled) {\n\t\t\tsendNotificationToContacts(msg, recipients)\n\t\t}\n\t\telse {\n\t\t\tif (phone1) {\n\t\t\t\tsendSms(phone1, msg)\n\t\t\t} else {\n\t\t\t\tsendPush(msg)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.debug \"There has been activity ${timePhrase}, not sending alert\"\n\t}\n}\n\nprivate noRecentMotion()\n{\n\tif(motion1) {\n\t\tdef motionEvents = motion1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} motion events\"\n\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\tlog.debug \"There have been recent ‘active’ events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent ‘active’ events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate noRecentContact()\n{\n\tif(contact1) {\n\t\tdef contactEvents = contact1.eventsSince(sinceTime)\n\t\tlog.trace \"Found ${contactEvents?.size() ?: 0} door events\"\n\t\tif (contactEvents.find { it.value == \"open\" }) {\n\t\t\tlog.debug \"There have been recent ‘open’ events\"\n\t\t\treturn false\n\t\t} else {\n\t\t\tlog.debug \"There have not been any recent ‘open’ events\"\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tlog.debug \"Contact sensor not enabled\"\n\t\treturn true\n\t}\n}\n\nprivate getSinceTime() {\n\tif (time0) {\n\t\treturn timeToday(time0, location?.timeZone)\n\t}\n\telse {\n\t\treturn new Date(now() - 21600000)\n\t}\n}\n\nprivate getTimePhrase() {\n\tdef interval = now() - sinceTime.time\n\tif (interval < 3600000) {\n\t\treturn \"in the past ${Math.round(interval/60000)} minutes\"\n\t}\n\telse if (interval < 7200000) {\n\t\treturn \"in the past hour\"\n\t}\n\telse {\n\t\treturn \"in the past ${Math.round(interval/3600000)} hours\"\n\t}\n}",
        "docstring": "Stay connected to your loved ones. Get notified if they are not up and moving around by a specified time and/or if they have not opened a cabinet or door according to a set schedule."
    },
    {
        "code": "else {\n\t\tdynamicPage(name: \"configuration\") {\n\t\t\tsection(disclaimerText){\n\t\t\t\tinput \"disclaimerResponse\", \"enum\", title: \"Accept terms\", required: true,\n\t\t\t\t\t\toptions: [\"I agree to these terms\", \"I do not agree to these terms\"],\n\t\t\t\t\t\tsubmitOnChange: true\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef configurationPage(){\n\tdynamicPage(name: \"configuration\") {\n\t\tsection(\"Bedroom motion detector(s)\") {\n\t\t\tinput \"bedroomMotion\", \"capability.motionSensor\", multiple: true\n\t\t}\n\t\tsection(\"Bathroom motion detector\") {\n\t\t\tinput \"bathroomMotion\", \"capability.motionSensor\"\n\t\t}\n\t\tsection(\"Active between these times\") {\n\t\t\tinput \"startTime\", \"time\", title: \"Start Time\"\n\t\t\tinput \"stopTime\", \"time\", title: \"Stop Time\"\n\t\t}\n\t\tsection(\"Send message when no return within specified time period\") {\n\t\t\tinput \"warnMessage\", \"text\", title: \"Warning Message\"\n\t\t\tinput \"threshold\", \"number\", title: \"Minutes\"\n\t\t}\n\t\tsection(\"To these contacts\") {\n\t\tinput(\"recipients\", \"contact\", title: \"Recipients\", description: \"Send notifications to\") {\n\t\t\t\tinput \"phone1\", \"phone\", required: false\n\t\t\t\tinput \"phone2\", \"phone\", required: false\n\t\t\t\tinput \"phone3\", \"phone\", required: false\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tstate.active = 0\n\tsubscribe(bedroomMotion, \"motion.active\", bedroomActive)\n\tsubscribe(bathroomMotion, \"motion.active\", bathroomActive)\n}\n\ndef bedroomActive(evt) {\n\tdef start = timeToday(startTime, location?.timeZone)\n\tdef stop = timeToday(stopTime, location?.timeZone)\n\tdef now = new Date()\n\tlog.debug \"bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now\"\n\tif (state.status == \"waiting\") {\n\t\tlog.debug \"motion detected in bedroom, disarming\"\n\t\tunschedule(\"sendMessage\")\n\t\tstate.status = null\n\t}\n\telse {\n\t\tif (start.before(now) && stop.after(now)) {\n\t\t\tlog.debug \"motion in bedroom, look for bathroom motion\"\n\t\t\tstate.status = \"pending\"\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not in time window\"\n\t\t}\n\t}\n}\n\ndef bathroomActive(evt) {\n\tlog.debug \"bathroomActive, status: $state.status\"\n\tif (state.status == \"pending\") {\n\t\tdef delay = threshold.toInteger() * 60\n\t\tstate.status = \"waiting\"\n\t\tlog.debug \"runIn($delay)\"\n\t\trunIn(delay, sendMessage)\n\t}\n}\n\ndef sendMessage() {\n\tlog.debug \"sendMessage\"\n\tdef msg = warnMessage\n\tlog.info msg\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients)\n\t}\n\telse {\n\t\tsendPush msg\n\t\tif (phone1) {\n\t\t\tsendSms phone1, msg\n\t\t}\n\t\tif (phone2) {\n\t\t\tsendSms phone2, msg\n\t\t}\n\t\tif (phone3) {\n\t\t\tsendSms phone3, msg\n\t\t}\n\t}\n\tstate.status = null\n}",
        "docstring": "Monitors motion sensors in bedroom and bathroom during the night and detects if occupant does not return from the bathroom after a specified period of time."
    },
    {
        "code": "section(\"Turning on when it's dark and there's movement...\"){\n\t\tinput \"motionSensor\", \"capability.motionSensor\", title: \"Where?\"\n\t}\n\tsection(\"And then off when it's light or there's been no movement for...\"){\n\t\tinput \"delayMinutes\", \"number\", title: \"Minutes?\"\n\t}\n\tsection(\"Using either on this light sensor (optional) or the local sunrise and sunset\"){\n\t\tinput \"lightSensor\", \"capability.illuminanceMeasurement\", required: false\n\t}\n\tsection (\"Sunrise offset (optional)...\") {\n\t\tinput \"sunriseOffsetValue\", \"text\", title: \"HH:MM\", required: false\n\t\tinput \"sunriseOffsetDir\", \"enum\", title: \"Before or After\", required: false, options: [\"Before\",\"After\"]\n\t}\n\tsection (\"Sunset offset (optional)...\") {\n\t\tinput \"sunsetOffsetValue\", \"text\", title: \"HH:MM\", required: false\n\t\tinput \"sunsetOffsetDir\", \"enum\", title: \"Before or After\", required: false, options: [\"Before\",\"After\"]\n\t}\n\tsection (\"Zip code (optional, defaults to location coordinates when location services are enabled)...\") {\n\t\tinput \"zipCode\", \"text\", title: \"Zip code\", required: false\n\t}\n}\n\ndef installed() {\n\tinitialize()\n}\n\ndef updated() {\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(motionSensor, \"motion\", motionHandler)\n\tif (lightSensor) {\n\t\tsubscribe(lightSensor, \"illuminance\", illuminanceHandler, [filterEvents: false])\n\t}\n\telse {\n\t\tsubscribe(location, \"position\", locationPositionChange)\n\t\tsubscribe(location, \"sunriseTime\", sunriseSunsetTimeHandler)\n\t\tsubscribe(location, \"sunsetTime\", sunriseSunsetTimeHandler)\n\t\tastroCheck()\n\t}\n}\n\ndef locationPositionChange(evt) {\n\tlog.trace \"locationChange()\"\n\tastroCheck()\n}\n\ndef sunriseSunsetTimeHandler(evt) {\n\tstate.lastSunriseSunsetEvent = now()\n\tlog.debug \"SmartNightlight.sunriseSunsetTimeHandler($app.id)\"\n\tastroCheck()\n}\n\ndef motionHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"active\") {\n\t\tif (enabled()) {\n\t\t\tlog.debug \"turning on lights due to motion\"\n\t\t\tlights.on()\n\t\t\tstate.lastStatus = \"on\"\n\t\t}\n\t\tstate.motionStopTime = null\n\t}\n\telse {\n\t\tstate.motionStopTime = now()\n\t\tif(delayMinutes) {\n\t\t\trunIn(delayMinutes*60, turnOffMotionAfterDelay, [overwrite: true])\n\t\t} else {\n\t\t\tturnOffMotionAfterDelay()\n\t\t}\n\t}\n}\n\ndef illuminanceHandler(evt) {\n\tlog.debug \"$evt.name: $evt.value, lastStatus: $state.lastStatus, motionStopTime: $state.motionStopTime\"\n\tdef lastStatus = state.lastStatus\n\tif (lastStatus != \"off\" && evt.integerValue > 50) {\n\t\tlights.off()\n\t\tstate.lastStatus = \"off\"\n\t}\n\telse if (state.motionStopTime) {\n\t\tif (lastStatus != \"off\") {\n\t\t\tdef elapsed = now() - state.motionStopTime\n\t\t\tif (elapsed >= ((delayMinutes ?: 0) * 60000L) - 2000) {\n\t\t\t\tlights.off()\n\t\t\t\tstate.lastStatus = \"off\"\n\t\t\t}\n\t\t}\n\t}\n\telse if (lastStatus != \"on\" && evt.integerValue < 30){\n\t\tlights.on()\n\t\tstate.lastStatus = \"on\"\n\t}\n}\n\ndef turnOffMotionAfterDelay() {\n\tlog.trace \"In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus\"\n\tif (state.motionStopTime && state.lastStatus != \"off\") {\n\t\tdef elapsed = now() - state.motionStopTime\n        log.trace \"elapsed = $elapsed\"\n\t\tif (elapsed >= ((delayMinutes ?: 0) * 60000L) - 2000) {\n        \tlog.debug \"Turning off lights\"\n\t\t\tlights.off()\n\t\t\tstate.lastStatus = \"off\"\n\t\t}\n\t}\n}\n\ndef scheduleCheck() {\n\tlog.debug \"In scheduleCheck - skipping\"\n\t//turnOffMotionAfterDelay()\n}\n\ndef astroCheck() {\n\tdef s = getSunriseAndSunset(zipCode: zipCode, sunriseOffset: sunriseOffset, sunsetOffset: sunsetOffset)\n\tstate.riseTime = s.sunrise.time\n\tstate.setTime = s.sunset.time\n\tlog.debug \"rise: ${new Date(state.riseTime)}($state.riseTime), set: ${new Date(state.setTime)}($state.setTime)\"\n}\n\nprivate enabled() {\n\tdef result\n\tif (lightSensor) {\n\t\tresult = lightSensor.currentIlluminance?.toInteger() < 30\n\t}\n\telse {\n\t\tdef t = now()\n\t\tresult = t < state.riseTime || t > state.setTime\n\t}\n\tresult\n}\n\nprivate getSunriseOffset() {\n\tsunriseOffsetValue ? (sunriseOffsetDir == \"Before\" ? \"-$sunriseOffsetValue\" : sunriseOffsetValue) : null\n}\n\nprivate getSunsetOffset() {\n\tsunsetOffsetValue ? (sunsetOffsetDir == \"Before\" ? \"-$sunsetOffsetValue\" : sunsetOffsetValue) : null\n}",
        "docstring": "Turns on lights when it's dark and motion is detected. Turns lights off when it becomes light or some time after motion ceases."
    },
    {
        "code": "section(\"Sensors detecting residents\") {\n\t\tinput \"residentMotions\", \"capability.motionSensor\", title: \"Motion Sensors\", multiple: true, required: false\n\t}\n\tsection(\"Alarm settings and actions\") {\n\t\tinput \"alarms\", \"capability.alarm\", title: \"Which Alarm(s)\", multiple: true, required: false\n        input \"silent\", \"enum\", options: [\"Yes\",\"No\"], title: \"Silent alarm only (Yes/No)\"\n\t\tinput \"seconds\", \"number\", title: \"Delay in seconds before siren sounds\"\n\t\tinput \"lights\", \"capability.switch\", title: \"Flash these lights (optional)\", multiple: true, required: false\n\t\tinput \"newMode\", \"mode\", title: \"Change to this mode (optional)\", required: false\n\t}\n\tsection(\"Notify others (optional)\") {\n\t\tinput \"textMessage\", \"text\", title: \"Send this message\", multiple: false, required: false\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone\", \"phone\", title: \"To this phone\", multiple: false, required: false\n        }\n\t}\n\tsection(\"Arm system when residents quiet for (default 3 minutes)\") {\n\t\tinput \"residentsQuietThreshold\", \"number\", title: \"Time in minutes\", required: false\n\t}\n}\n\ndef installed() {\n\tlog.debug \"INSTALLED\"\n\tsubscribeToEvents()\n\tstate.alarmActive = null\n}\n\ndef updated() {\n\tlog.debug \"UPDATED\"\n\tunsubscribe()\n\tsubscribeToEvents()\n\tunschedule()\n\tstate.alarmActive = null\n\tstate.residentsAreUp = null\n\tstate.lastIntruderMotion = null\n\talarms?.off()\n}\n\nprivate subscribeToEvents()\n{\n\tsubscribe intrusionMotions, \"motion\", intruderMotion\n\t// subscribe residentMotions, \"motion\", residentMotion\n\tsubscribe intrusionContacts, \"contact\", contact\n\tsubscribe alarms, \"alarm\", alarm\n\tsubscribe(app, appTouch)\n}\n\nprivate residentsHaveBeenQuiet()\n{\n\tdef threshold = ((residentsQuietThreshold != null && residentsQuietThreshold != \"\") ? residentsQuietThreshold : 3) * 60 * 1000\n\tdef result = true\n\tdef t0 = new Date(now() - threshold)\n\tfor (sensor in residentMotions) {\n\t\tdef recentStates = sensor.statesSince(\"motion\", t0)\n\t\tif (recentStates.find{it.value == \"active\"}) {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.debug \"residentsHaveBeenQuiet: $result\"\n\tresult\n}\n\nprivate intruderMotionInactive()\n{\n\tdef result = true\n\tfor (sensor in intrusionMotions) {\n\t\tif (sensor.currentMotion == \"active\") {\n\t\t\tresult = false\n\t\t\tbreak\n\t\t}\n\t}\n\tresult\n}\n\nprivate isResidentMotionSensor(evt)\n{\n\tresidentMotions?.find{it.id == evt.deviceId} != null\n}\n\ndef appTouch(evt)\n{\n\talarms?.off()\n\tstate.alarmActive = false\n}\n\n// Here to handle old subscriptions\ndef motion(evt)\n{\n\tif (isResidentMotionSensor(evt)) {\n\t\tlog.debug \"resident motion, $evt.name: $evt.value\"\n\t\tresidentMotion(evt)\n\t}\n\telse {\n\t\tlog.debug \"intruder motion, $evt.name: $evt.value\"\n\t\tintruderMotion(evt)\n\t}\n}\n\ndef intruderMotion(evt)\n{\n\tif (evt.value == \"active\") {\n\t\tlog.debug \"motion by potential intruder, residentsAreUp: $state.residentsAreUp\"\n\t\tif (!state.residentsAreUp) {\n\t\t\tlog.trace \"checking if residents have been quiet\"\n\t\t\tif (residentsHaveBeenQuiet()) {\n\t\t\t\tlog.trace \"calling startAlarmSequence\"\n\t\t\t\tstartAlarmSequence()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.trace \"calling disarmIntrusionDetection\"\n\t\t\t\tdisarmIntrusionDetection()\n\t\t\t}\n\t\t}\n\t}\n\tstate.lastIntruderMotion = now()\n}\n\ndef residentMotion(evt)\n{\n\t// Don't think we need this any more\n\t//if (evt.value == \"inactive\") {\n\t//\tif (state.residentsAreUp) {\n\t//    \tstartReArmSequence()\n\t//    }\n\t//}\n  unsubscribe(residentMotions)\n}\n\ndef contact(evt)\n{\n\tif (evt.value == \"open\") {\n\t\t// TODO - check for residents being up?\n\t\tif (!state.residentsAreUp) {\n\t\t\tif (residentsHaveBeenQuiet()) {\n\t\t\t\tstartAlarmSequence()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisarmIntrusionDetection()\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef alarm(evt)\n{\n\tlog.debug \"$evt.name: $evt.value\"\n\tif (evt.value == \"off\") {\n\t\talarms?.off()\n\t\tstate.alarmActive = false\n\t}\n}\n\nprivate disarmIntrusionDetection()\n{\n\tlog.debug \"residents are up, disarming intrusion detection\"\n\tstate.residentsAreUp = true\n\tscheduleReArmCheck()\n}\n\nprivate scheduleReArmCheck()\n{\n\tdef cron = \"0 * * * * ?\"\n\tschedule(cron, \"checkForReArm\")\n\tlog.debug \"Starting re-arm check, cron: $cron\"\n}\n\ndef checkForReArm()\n{\n\tdef threshold = ((residentsQuietThreshold != null && residentsQuietThreshold != \"\") ? residentsQuietThreshold : 3) * 60 * 1000\n\tlog.debug \"checkForReArm: threshold is $threshold\"\n\t// check last intruder motion\n\tdef lastIntruderMotion = state.lastIntruderMotion\n\tlog.debug \"checkForReArm: lastIntruderMotion=$lastIntruderMotion\"\n\tif (lastIntruderMotion != null)\n\t{\n\t\tlog.debug \"checkForReArm, time since last intruder motion: ${now() - lastIntruderMotion}\"\n\t\tif (now() - lastIntruderMotion > threshold) {\n\t\t\tlog.debug \"re-arming intrusion detection\"\n\t\t\tstate.residentsAreUp = false\n\t\t\tunschedule()\n\t\t}\n\t}\n\telse {\n\t\tlog.warn \"checkForReArm: lastIntruderMotion was null, unable to check for re-arming intrusion detection\"\n\t}\n}\n\nprivate startAlarmSequence()\n{\n\tif (state.alarmActive) {\n\t\tlog.debug \"alarm already active\"\n\t}\n\telse {\n\t\tstate.alarmActive = true\n\t\tlog.debug \"starting alarm sequence\"\n\n\t\tsendPush(\"Potential intruder detected!\")\n\n\t\tif (newMode) {\n\t\t\tsetLocationMode(newMode)\n\t\t}\n\n\t\tif (silentAlarm()) {\n\t\t\tlog.debug \"Silent alarm only\"\n\t\t\talarms?.strobe()\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(textMessage ?: \"Potential intruder detected\", recipients)\n            }\n            else {\n                if (phone) {\n                    sendSms(phone, textMessage ?: \"Potential intruder detected\")\n                }\n            }\n\t\t}\n\t\telse {\n\t\t\tdef delayTime = seconds\n\t\t\tif (delayTime) {\n\t\t\t\talarms?.strobe()\n\t\t\t\trunIn(delayTime, \"soundSiren\")\n\t\t\t\tlog.debug \"Sounding siren in $delayTime seconds\"\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsoundSiren()\n\t\t\t}\n\t\t}\n\n\t\tif (lights) {\n\t\t\tflashLights(Math.min((seconds/2) as Integer, 10))\n\t\t}\n\t}\n}\n\ndef soundSiren()\n{\n\tif (state.alarmActive) {\n\t\tlog.debug \"Sounding siren\"\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(textMessage ?: \"Potential intruder detected\", recipients)\n        }\n        else {\n            if (phone) {\n                sendSms(phone, textMessage ?: \"Potential intruder detected\")\n            }\n        }\n\t\talarms?.both()\n\t\tif (lights) {\n\t\t\tlog.debug \"continue flashing lights\"\n\t\t\tcontinueFlashing()\n\t\t}\n\t}\n\telse {\n\t\tlog.debug \"alarm activation aborted\"\n\t}\n\tunschedule(\"soundSiren\") // Temporary work-around to scheduling bug\n}\n\ndef continueFlashing()\n{\n\tunschedule()\n\tif (state.alarmActive) {\n\t\tflashLights(10)\n\t\tschedule(util.cronExpression(now() + 10000), \"continueFlashing\")\n\t}\n}\n\nprivate flashLights(numFlashes) {\n\tdef onFor = 1000\n\tdef offFor = 1000\n\n\tlog.debug \"FLASHING $numFlashes times\"\n\tdef delay = 1L\n\tnumFlashes.times {\n\t\tlog.trace \"Switch on after  $delay msec\"\n\t\tlights?.on(delay: delay)\n\t\tdelay += onFor\n\t\tlog.trace \"Switch off after $delay msec\"\n\t\tlights?.off(delay: delay)\n\t\tdelay += offFor\n\t}\n}\n\nprivate silentAlarm()\n{\n\tsilent?.toLowerCase() in [\"yes\",\"true\",\"y\"]\n}",
        "docstring": "Alerts you when there are intruders but not when you just got up for a glass of water in the middle of the night"
    },
    {
        "code": "\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n    scheduledEvent()\n}\n\ndef scheduledEvent() {\n\tlog.info \"SmartWeather Station Controller / scheduledEvent terminated due to deprecation\" // device handles this itself now -- Bob\n/*\n\tlog.trace \"scheduledEvent()\"\n\n\tdef delayTimeSecs = 60 * 60 // reschedule every 60 minutes\n\tdef runAgainWindowMS = 58 * 60 * 1000 // can run at most every 58 minutes\n\tdef timeSinceLastRunMS = state.lastRunTime ? now() - state.lastRunTime : null //how long since it last ran?\n\n\tif(!timeSinceLastRunMS || timeSinceLastRunMS > runAgainWindowMS){\n\t\trunIn(delayTimeSecs, scheduledEvent, [overwrite: false])\n\t\tstate.lastRunTime = now()\n\t\tweatherDevices.refresh()\n\t} else {\n\t\tlog.trace \"Trying to run smartweather-station-controller too soon. Has only been ${timeSinceLastRunMS} ms but needs to be at least ${runAgainWindowMS} ms\"\n\t}\n    */\n}",
        "docstring": "Updates SmartWeather Station Tile devices every hour."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\n\t\tsection {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"Sonos player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"volume\", \"number\", title: \"Set the volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t}\n}\n\ndef chooseTrack() {\n\tdynamicPage(name: \"chooseTrack\") {\n\t\tsection(\"Play a different song for each mode in which you want music\") {\n\t\t\tdef options = songOptions()\n\t\t\tlocation.modes.each {mode ->\n\t\t\t\tinput \"mode_$mode.name\", \"enum\", title: mode.name, options: options, required: false\n\t\t\t}\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsaveSelectedSongs()\n\n\tsubscribe(location, modeChangeHandler)\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler($evt.name: $evt.value)\"\n\tif (allOk) {\n\t\tif (frequency) {\n\t\t\tdef lastTime = state[frequencyKey(evt)]\n\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n}\n\nprivate takeAction(evt) {\n\n\tdef name = \"mode_$evt.value\".toString()\n\tdef selectedSong = state.selectedSongs.\"$name\"\n\n\tif (selectedSong == \"PAUSE\") {\n\t\tsonos.stop()\n\t}\n\telse {\n\t\tlog.info \"Playing '$selectedSong\"\n\n\t\tif (volume != null) {\n\t\t\tsonos.stop()\n\t\t\tpause(500)\n\t\t\tsonos.setLevel(volume)\n\t\t\tpause(500)\n\t\t}\n\n\t\tsonos.playTrack(selectedSong)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Plays a different selected song or station for each mode."
    },
    {
        "code": "section(\"Options\") {\n    \tinput \"volumeOffset\", \"number\", title: \"Adjust Volume by this amount\", required: false, description: \"optional - 5% default\"\n    }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(buttonDevice, \"button\", buttonEvent)\n}\n\ndef buttonEvent(evt){\n\tdef buttonNumber = evt.data\n\tdef value = evt.value\n    log.debug \"buttonEvent: $evt.name = $evt.value ($evt.data)\"\n\tlog.debug \"button: $buttonNumber, value: $value\"\n    \n    def recentEvents = buttonDevice.eventsSince(new Date(now() - 2000)).findAll{it.value == evt.value && it.data == evt.data}\n    log.debug \"Found ${recentEvents.size()?:0} events in past 2 seconds\"\n    \n    if(recentEvents.size <= 1){\n        handleButton(extractButtonNumber(buttonNumber), value)\n    } else {\n    \tlog.debug \"Found recent button press events for $buttonNumber with value $value\"\n    }\n}\n\ndef extractButtonNumber(data) {\n\tdef buttonNumber\n    //TODO must be a better way to do this. Data is like {buttonNumber:1}\n    switch(data) {\n        case ~/.*1.*/:\n            buttonNumber = 1\n            break\n        case ~/.*2.*/:\n            buttonNumber = 2\n            break\n        case ~/.*3.*/:\n            buttonNumber = 3\n            break\n        case ~/.*4.*/:\n            buttonNumber = 4\n            break\n    }\n    return buttonNumber\n}\n\ndef handleButton(buttonNumber, value) {\n\tswitch([number: buttonNumber, value: value]) {\n        case{it.number == 1 && it.value == 'pushed'}:\n            log.debug \"Button 1 pushed - Play/Pause\"\n            togglePlayPause()\n            break\n        case{it.number == 2 && it.value == 'pushed'}:\n            log.debug \"Button 2 pushed - Volume Up\"\n            adjustVolume(true, false)\n            break\n        case{it.number == 3 && it.value == 'pushed'}:\n            log.debug \"Button 3 pushed - Next Track\"\n            sonos.nextTrack()\n            break\n        case{it.number == 4 && it.value == 'pushed'}:\n            log.debug \"Button 4 pushed - Volume Down\"\n\t\t\tadjustVolume(false, false)\n            break\n        case{it.number == 2 && it.value == 'held'}:\n            log.debug \"Button 2 held - Volume Up 2x\"\n            adjustVolume(true, true)\n            break\n        case{it.number == 3 && it.value == 'held'}:\n\t        log.debug \"Button 3 held - Previous Track\"\n            sonos.previousTrack()\n        \tbreak  \n        case{it.number == 4 && it.value == 'held'}:\n            log.debug \"Button 4 held - Volume Down 2x\"\n            adjustVolume(false, true)\n            break\n        default:\n            log.debug \"Unhandled command: $buttonNumber $value\"\n           \n    }\n}\n\ndef togglePlayPause() {\n\tdef currentStatus = sonos.currentValue(\"status\")\n    if (currentStatus == \"playing\") {\n        options ? sonos.pause(options) : sonos.pause()\n    }\n    else {\n        options ? sonos.play(options) : sonos.play()\n    }\n}\n\ndef adjustVolume(boolean up, boolean doubleAmount) {\n\tdef changeAmount = (volumeOffset ?: 5) * (doubleAmount ? 2 : 1)\n    def currentVolume = sonos.currentValue(\"level\")\n    \n    if(up) {\n    \tsonos.setLevel(currentVolume + changeAmount)\n    } else {\n\t    sonos.setLevel(currentVolume - changeAmount)\n    }\n}",
        "docstring": "Control your Sonos system with an Aeon Minimote"
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"When...\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tsection(anythingSet ? \"Select additional triggers\" : \"When...\", hideable: anythingSet, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection(\"Perform this action\"){\n\t\t\tinput \"actionType\", \"enum\", title: \"Action?\", required: true, defaultValue: \"play\", options: [\n\t\t\t\t\"Play\",\n\t\t\t\t\"Stop Playing\",\n\t\t\t\t\"Toggle Play/Pause\",\n\t\t\t\t\"Skip to Next Track\",\n\t\t\t\t\"Play Previous Track\"\n\t\t\t]\n\t\t}\n\t\tsection {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"Speaker music player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"volume\", \"number\", title: \"Set the volume volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\"\n\t\t}\n\t}\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\tlog.debug \"takeAction($actionType)\"\n\tdef options = [:]\n\tif (volume) {\n\t\tsonos.setLevel(volume as Integer)\n\t\toptions.delay = 1000\n\t}\n\n\tswitch (actionType) {\n\t\tcase \"Play\":\n\t\t\toptions ? sonos.on(options) : sonos.on()\n\t\t\tbreak\n\t\tcase \"Stop Playing\":\n\t\t\toptions ? sonos.off(options) : sonos.off()\n\t\t\tbreak\n\t\tcase \"Toggle Play/Pause\":\n\t\t\tdef currentStatus = sonos.currentValue(\"status\")\n\t\t\tif (currentStatus == \"playing\") {\n\t\t\t\toptions ? sonos.pause(options) : sonos.pause()\n\t\t\t}\n\t\t\telse {\n\t\t\t\toptions ? sonos.play(options) : sonos.play()\n\t\t\t}\n\t\t\tbreak\n\t\tcase \"Skip to Next Track\":\n\t\t\toptions ? sonos.nextTrack(options) : sonos.nextTrack()\n\t\t\tbreak\n\t\tcase \"Play Previous Track\":\n\t\t\toptions ? sonos.previousTrack(options) : sonos.previousTrack()\n\t\t\tbreak\n\t\tdefault:\n\t\t\tlog.error \"Action type '$actionType' not defined\"\n\t}\n\n\tif (frequency) {\n\t\tstate.lastActionTimeStamp = now()\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t//evt.deviceId ?: evt.value\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Play or pause your Speaker when certain actions take place in your home."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"Play music when...\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\n\t\tdef hideable = anythingSet || app.installationState == \"COMPLETE\"\n\t\tdef sectionTitle = anythingSet ? \"Select additional triggers\" : \"Play music when...\"\n\n\t\tsection(sectionTitle, hideable: hideable, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"On this Speaker player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"volume\", \"number\", title: \"Set the volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t}\n}\n\ndef chooseTrack() {\n\tdynamicPage(name: \"chooseTrack\") {\n\t\tsection{\n\t\t\tinput \"song\",\"enum\",title:\"Play this track\", required:true, multiple: false, options: songOptions()\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}\n\t}\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"timeOfDay\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tlog.trace \"subscribeToEvents()\"\n\tsaveSelectedSong()\n\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n}\n\ndef eventHandler(evt) {\n\tif (allOk) {\n\t\tif (frequency) {\n\t\t\tdef lastTime = state[frequencyKey(evt)]\n\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttakeAction(evt)\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tlog.info \"Playing '$state.selectedSong\"\n\n\tif (volume != null) {\n\t\tsonos.stop()\n\t\tpause(500)\n\t\tsonos.setLevel(volume)\n\t\tpause(500)\n\t}\n\n\tsonos.playTrack(state.selectedSong)\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\tlog.trace \"oncePerDayOk = $result\"\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize",
        "docstring": "Plays a selected song or station."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"Play message when\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tdef hideable = anythingSet || app.installationState == \"COMPLETE\"\n\t\tdef sectionTitle = anythingSet ? \"Select additional triggers\" : \"Play message when...\"\n\n\t\tsection(sectionTitle, hideable: hideable, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", description: \"Select mode(s)\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection{\n\t\t\tinput \"actionType\", \"enum\", title: \"Action?\", required: true, defaultValue: \"Bell 1\", options: [\n\t\t\t\t\"Custom Message\",\n\t\t\t\t\"Bell 1\",\n\t\t\t\t\"Bell 2\",\n\t\t\t\t\"Dogs Barking\",\n\t\t\t\t\"Fire Alarm\",\n\t\t\t\t\"The mail has arrived\",\n\t\t\t\t\"A door opened\",\n\t\t\t\t\"There is motion\",\n\t\t\t\t\"Smartthings detected a flood\",\n\t\t\t\t\"Smartthings detected smoke\",\n\t\t\t\t\"Someone is arriving\",\n\t\t\t\t\"Piano\",\n\t\t\t\t\"Lightsaber\"]\n\t\t\tinput \"message\",\"text\",title:\"Play this message\", required:false, multiple: false\n\t\t}\n\t\tsection {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"On this Speaker player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"resumePlaying\", \"bool\", title: \"Resume currently playing music after notification\", required: false, defaultValue: true\n\t\t\thref \"chooseTrack\", title: \"Or play this music or radio station\", description: song ? state.selectedSong?.station : \"Tap to set\", state: song ? \"complete\" : \"incomplete\"\n\n\t\t\tinput \"volume\", \"number\", title: \"Temporarily change volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\", required: false\n\t\t}\n\t}\n}\n\ndef chooseTrack() {\n\tdynamicPage(name: \"chooseTrack\") {\n\t\tsection{\n\t\t\tinput \"song\",\"enum\",title:\"Play this track\", required:true, multiple: false, options: songOptions()\n\t\t}\n\t}\n}\n\nprivate songOptions() {\n\n\t// Make sure current selection is in the set\n\n\tdef options = new LinkedHashSet()\n\tif (state.selectedSong?.station) {\n\t\toptions << state.selectedSong.station\n\t}\n\telse if (state.selectedSong?.description) {\n\t\t// TODO - Remove eventually? 'description' for backward compatibility\n\t\toptions << state.selectedSong.description\n\t}\n\n\t// Query for recent tracks\n\tdef states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n\tdef dataMaps = states.collect{it.jsonValue}\n\toptions.addAll(dataMaps.collect{it.station})\n\n\tlog.trace \"${options.size()} songs in list\"\n\toptions.take(20) as List\n}\n\nprivate saveSelectedSong() {\n\ttry {\n\t\tdef thisSong = song\n\t\tlog.info \"Looking for $thisSong\"\n\t\tdef songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n\t\tlog.info \"Searching ${songs.size()} records\"\n\n\t\tdef data = songs.find {s -> s.station == thisSong}\n\t\tlog.info \"Found ${data?.station}\"\n\t\tif (data) {\n\t\t\tstate.selectedSong = data\n\t\t\tlog.debug \"Selected song = $state.selectedSong\"\n\t\t}\n\t\telse if (song == state.selectedSong?.station) {\n\t\t\tlog.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n\t\t}\n\t\telse {\n\t\t\tlog.warn \"Selected song '$song' not found\"\n\t\t}\n\t}\n\tcatch (Throwable t) {\n\t\tlog.error t\n\t}\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"timeOfDay\",\"triggerModes\",\"timeOfDay\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location, modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n\n\tif (song) {\n\t\tsaveSelectedSong()\n\t}\n\n\tloadText()\n}\n\ndef eventHandler(evt) {\n\tlog.trace \"eventHandler($evt?.name: $evt?.value)\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tlog.trace \"takeAction()\"\n\n\tif (song) {\n\t\tsonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)\n\t}\n\telse if (resumePlaying){\n\t\tsonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)\n\t}\n\telse {\n\t\tsonos.playTrackAndRestore(state.sound.uri, state.sound.duration, volume)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n\tlog.trace \"Exiting takeAction()\"\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getTimeLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize\n\nprivate loadText() {\n\tswitch ( actionType) {\n\t\tcase \"Bell 1\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell1.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Bell 2\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell2.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Dogs Barking\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/dogs.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Fire Alarm\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/alarm.mp3\", duration: \"17\"]\n\t\t\tbreak;\n\t\tcase \"The mail has arrived\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/the+mail+has+arrived.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"A door opened\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/a+door+opened.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"There is motion\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/there+is+motion.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Smartthings detected a flood\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+a+flood.mp3\", duration: \"2\"]\n\t\t\tbreak;\n\t\tcase \"Smartthings detected smoke\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/smartthings+detected+smoke.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Someone is arriving\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/someone+is+arriving.mp3\", duration: \"1\"]\n\t\t\tbreak;\n\t\tcase \"Piano\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/piano2.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Lightsaber\":\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/lightsaber.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t\tcase \"Custom Message\":\n\t\t\tif (message) {\n\t\t\t\tstate.sound = textToSpeech(message instanceof List ? message[0] : message) // not sure why this is (sometimes) needed)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate.sound = textToSpeech(\"You selected the custom message option but did not enter a message in the $app.label Smart App\")\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate.sound = [uri: \"http://s3.amazonaws.com/smartapp-media/sonos/bell1.mp3\", duration: \"10\"]\n\t\t\tbreak;\n\t}\n}",
        "docstring": "Play a sound or custom message through your Speaker when the mode changes or other events occur."
    },
    {
        "code": "}\n}\n\ndef mainPage() {\n\tdynamicPage(name: \"mainPage\") {\n\t\tdef anythingSet = anythingSet()\n\t\tif (anythingSet) {\n\t\t\tsection(\"Play weather report when\"){\n\t\t\t\tifSet \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\t\tifSet \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\t\tifSet \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\t\tifSet \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\t\tifSet \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\t\tifSet \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\t\tifSet \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\t\tifSet \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\t\tifSet \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\t\tifSet \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\t\tifSet \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\t\tifSet \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t\t}\n\t\t}\n\t\tdef hideable = anythingSet || app.installationState == \"COMPLETE\"\n\t\tdef sectionTitle = anythingSet ? \"Select additional triggers\" : \"Play weather report when...\"\n\n\t\tsection(sectionTitle, hideable: hideable, hidden: true){\n\t\t\tifUnset \"motion\", \"capability.motionSensor\", title: \"Motion Here\", required: false, multiple: true\n\t\t\tifUnset \"contact\", \"capability.contactSensor\", title: \"Contact Opens\", required: false, multiple: true\n\t\t\tifUnset \"contactClosed\", \"capability.contactSensor\", title: \"Contact Closes\", required: false, multiple: true\n\t\t\tifUnset \"acceleration\", \"capability.accelerationSensor\", title: \"Acceleration Detected\", required: false, multiple: true\n\t\t\tifUnset \"mySwitch\", \"capability.switch\", title: \"Switch Turned On\", required: false, multiple: true\n\t\t\tifUnset \"mySwitchOff\", \"capability.switch\", title: \"Switch Turned Off\", required: false, multiple: true\n\t\t\tifUnset \"arrivalPresence\", \"capability.presenceSensor\", title: \"Arrival Of\", required: false, multiple: true\n\t\t\tifUnset \"departurePresence\", \"capability.presenceSensor\", title: \"Departure Of\", required: false, multiple: true\n\t\t\tifUnset \"smoke\", \"capability.smokeDetector\", title: \"Smoke Detected\", required: false, multiple: true\n\t\t\tifUnset \"water\", \"capability.waterSensor\", title: \"Water Sensor Wet\", required: false, multiple: true\n\t\t\tifUnset \"button1\", \"capability.button\", title: \"Button Press\", required:false, multiple:true //remove from production\n\t\t\tifUnset \"triggerModes\", \"mode\", title: \"System Changes Mode\", required: false, multiple: true\n\t\t\tifUnset \"timeOfDay\", \"time\", title: \"At a Scheduled Time\", required: false\n\t\t}\n\t\tsection {\n\t\t\tinput(\"forecastOptions\", \"enum\", defaultValue: \"0\", title: \"Weather report options\", description: \"Select one or more\", multiple: true,\n\t\t\t\toptions: [\n\t\t\t\t\t[\"0\": \"Current Conditions\"],\n\t\t\t\t\t[\"1\": \"Today's Forecast\"],\n\t\t\t\t\t[\"2\": \"Tonight's Forecast\"],\n\t\t\t\t\t[\"3\": \"Tomorrow's Forecast\"],\n\t\t\t\t]\n\t\t\t)\n\t\t}\n\t\tsection {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"On this Speaker player\", required: true\n\t\t}\n\t\tsection(\"More options\", hideable: true, hidden: true) {\n\t\t\tinput \"resumePlaying\", \"bool\", title: \"Resume currently playing music after weather report finishes\", required: false, defaultValue: true\n\t\t\thref \"chooseTrack\", title: \"Or play this music or radio station\", description: song ? state.selectedSong?.station : \"Tap to set\", state: song ? \"complete\" : \"incomplete\"\n\n\t\t\tinput \"zipCode\", \"text\", title: \"Zip Code\", required: false\n\t\t\tinput \"volume\", \"number\", title: \"Temporarily change volume\", description: \"0-100%\", required: false\n\t\t\tinput \"frequency\", \"decimal\", title: \"Minimum time between actions (defaults to every event)\", description: \"Minutes\", required: false\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: timeLabel ?: \"Tap to set\", state: timeLabel ? \"complete\" : \"incomplete\"\n\t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n\t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\t\t\tif (settings.modes) {\n            \tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n            }\n\t\t\tinput \"oncePerDay\", \"bool\", title: \"Only once per day\", required: false, defaultValue: false\n\t\t}\n\t\tsection([mobileOnly:true]) {\n\t\t\tlabel title: \"Assign a name\", required: false\n\t\t\tmode title: \"Set for specific mode(s)\"\n\t\t}\n\t}\n}\n\ndef chooseTrack() {\n\tdynamicPage(name: \"chooseTrack\") {\n\t\tsection{\n\t\t\tinput \"song\",\"enum\",title:\"Play this track\", required:true, multiple: false, options: songOptions()\n\t\t}\n\t}\n}\n\nprivate anythingSet() {\n\tfor (name in [\"motion\",\"contact\",\"contactClosed\",\"acceleration\",\"mySwitch\",\"mySwitchOff\",\"arrivalPresence\",\"departurePresence\",\"smoke\",\"water\",\"button1\",\"timeOfDay\",\"triggerModes\"]) {\n\t\tif (settings[name]) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nprivate ifUnset(Map options, String name, String capability) {\n\tif (!settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\nprivate ifSet(Map options, String name, String capability) {\n\tif (settings[name]) {\n\t\tinput(options, name, capability)\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tunschedule()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(app, appTouchHandler)\n\tsubscribe(contact, \"contact.open\", eventHandler)\n\tsubscribe(contactClosed, \"contact.closed\", eventHandler)\n\tsubscribe(acceleration, \"acceleration.active\", eventHandler)\n\tsubscribe(motion, \"motion.active\", eventHandler)\n\tsubscribe(mySwitch, \"switch.on\", eventHandler)\n\tsubscribe(mySwitchOff, \"switch.off\", eventHandler)\n\tsubscribe(arrivalPresence, \"presence.present\", eventHandler)\n\tsubscribe(departurePresence, \"presence.not present\", eventHandler)\n\tsubscribe(smoke, \"smoke.detected\", eventHandler)\n\tsubscribe(smoke, \"smoke.tested\", eventHandler)\n\tsubscribe(smoke, \"carbonMonoxide.detected\", eventHandler)\n\tsubscribe(water, \"water.wet\", eventHandler)\n\tsubscribe(button1, \"button.pushed\", eventHandler)\n\n\tif (triggerModes) {\n\t\tsubscribe(location,modeChangeHandler)\n\t}\n\n\tif (timeOfDay) {\n\t\tschedule(timeOfDay, scheduledTimeHandler)\n\t}\n\n\tif (song) {\n\t\tsaveSelectedSong()\n\t}\n}\n\ndef eventHandler(evt) {\n\tlog.trace \"eventHandler($evt?.name: $evt?.value)\"\n\tif (allOk) {\n\t\tlog.trace \"allOk\"\n\t\tdef lastTime = state[frequencyKey(evt)]\n\t\tif (oncePerDayOk(lastTime)) {\n\t\t\tif (frequency) {\n\t\t\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\t\t\ttakeAction(evt)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.debug \"Not taking action because $frequency minutes have not elapsed since last action\"\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttakeAction(evt)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.debug \"Not taking action because it was already taken today\"\n\t\t}\n\t}\n}\n\ndef modeChangeHandler(evt) {\n\tlog.trace \"modeChangeHandler $evt.name: $evt.value ($triggerModes)\"\n\tif (evt.value in triggerModes) {\n\t\teventHandler(evt)\n\t}\n}\n\ndef scheduledTimeHandler() {\n\teventHandler(null)\n}\n\ndef appTouchHandler(evt) {\n\ttakeAction(evt)\n}\n\nprivate takeAction(evt) {\n\n\tloadText()\n\n\tif (song) {\n\t\tsonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)\n\t}\n\telse if (resumePlaying){\n\t\tsonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)\n\t}\n\telse if (volume) {\n\t\tsonos.playTrackAtVolume(state.sound.uri, volume)\n\t}\n\telse {\n\t\tsonos.playTrack(state.sound.uri)\n\t}\n\n\tif (frequency || oncePerDay) {\n\t\tstate[frequencyKey(evt)] = now()\n\t}\n}\n\nprivate songOptions() {\n\n\t// Make sure current selection is in the set\n\n\tdef options = new LinkedHashSet()\n\tif (state.selectedSong?.station) {\n\t\toptions << state.selectedSong.station\n\t}\n\telse if (state.selectedSong?.description) {\n\t\t// TODO - Remove eventually? 'description' for backward compatibility\n\t\toptions << state.selectedSong.description\n\t}\n\n\t// Query for recent tracks\n\tdef states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n\tdef dataMaps = states.collect{it.jsonValue}\n\toptions.addAll(dataMaps.collect{it.station})\n\n\tlog.trace \"${options.size()} songs in list\"\n\toptions.take(20) as List\n}\n\nprivate saveSelectedSong() {\n\ttry {\n\t\tdef thisSong = song\n\t\tlog.info \"Looking for $thisSong\"\n\t\tdef songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n\t\tlog.info \"Searching ${songs.size()} records\"\n\n\t\tdef data = songs.find {s -> s.station == thisSong}\n\t\tlog.info \"Found ${data?.station}\"\n\t\tif (data) {\n\t\t\tstate.selectedSong = data\n\t\t\tlog.debug \"Selected song = $state.selectedSong\"\n\t\t}\n\t\telse if (song == state.selectedSong?.station) {\n\t\t\tlog.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n\t\t}\n\t\telse {\n\t\t\tlog.warn \"Selected song '$song' not found\"\n\t\t}\n\t}\n\tcatch (Throwable t) {\n\t\tlog.error t\n\t}\n}\n\nprivate frequencyKey(evt) {\n\t\"lastActionTimeStamp\"\n}\n\nprivate dayString(Date date) {\n\tdef df = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n\tif (location.timeZone) {\n\t\tdf.setTimeZone(location.timeZone)\n\t}\n\telse {\n\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t}\n\tdf.format(date)\n}\n\nprivate oncePerDayOk(Long lastTime) {\n\tdef result = true\n\tif (oncePerDay) {\n\t\tresult = lastTime ? dayString(new Date()) != dayString(new Date(lastTime)) : true\n\t\tlog.trace \"oncePerDayOk = $result\"\n\t}\n\tresult\n}\n\n// TODO - centralize somehow\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting, location?.timeZone).time\n\t\tdef stop = timeToday(ending, location?.timeZone).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getTimeLabel()\n{\n\t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n}\n// TODO - End Centralize\n\nprivate loadText() {\n\tif (location.timeZone || zipCode) {\n\t\tdef weather = getWeatherFeature(\"forecast\", zipCode)\n\t\tdef current = getWeatherFeature(\"conditions\", zipCode)\n\t\tdef isMetric = location.temperatureScale == \"C\"\n\t\tdef delim = \"\"\n\t\tdef sb = new StringBuilder()\n\t\tlist(forecastOptions).sort().each {opt ->\n\t\t\tif (opt == \"0\") {\n\t\t\t\tif (isMetric) {\n                \tsb << \"The current temperature is ${Math.round(current.current_observation.temp_c)} degrees.\"\n                }\n                else {\n                \tsb << \"The current temperature is ${Math.round(current.current_observation.temp_f)} degrees.\"\n                }\n\t\t\t\tdelim = \" \"\n\t\t\t}\n\t\t\telse if (opt == \"1\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Today's forecast is \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[0].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[0].fcttext\n                }\n\t\t\t}\n\t\t\telse if (opt == \"2\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Tonight will be \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[1].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[1].fcttext\n                }\n\t\t\t}\n\t\t\telse if (opt == \"3\") {\n\t\t\t\tsb << delim\n\t\t\t\tsb << \"Tomorrow will be \"\n\t\t\t\tif (isMetric) {\n                \tsb << weather.forecast.txt_forecast.forecastday[2].fcttext_metric \n                }\n                else {\n                \tsb << weather.forecast.txt_forecast.forecastday[2].fcttext\n                }\n\t\t\t}\n\t\t}\n\n\t\tdef msg = sb.toString()\n        msg = msg.replaceAll(/([0-9]+)C/,'$1 degrees') // TODO - remove after next release\n\t\tlog.debug \"msg = ${msg}\"\n\t\tstate.sound = textToSpeech(msg, true)\n\t}\n\telse {\n\t\tstate.sound = textToSpeech(\"Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.\")\n\t}\n}\n\nprivate list(String s) {\n\t[s]\n}\nprivate list(l) {\n\tl\n}",
        "docstring": "Play a weather report through your Speaker when the mode changes or other events occur"
    },
    {
        "code": "}\n}\n\ndef setupNotifications() {\n    \n    dynamicPage(name: \"setupNotifications\", title: \"Configure Your Goal Notifications.\", install: true, uninstall: true) {\t\n    \n\t\tsection(\"Select your Jawbone UP\") {\n\t\t\tinput \"jawbone\", \"device.jawboneUser\", title: \"Jawbone UP\", required: true, multiple: false\n\t\t}\n           \n     \tsection(\"Notify Me When\"){\n\t\t\tinput \"thresholdType\", \"enum\", title: \"Select When to Notify\", required: false, defaultValue: \"Goal Reached\", options: [[\"Goal\":\"Goal Reached\"],[\"Threshold\":\"Specific Number of Steps\"]], submitOnChange:true\n            if (settings.thresholdType) {\n                if (settings.thresholdType == \"Threshold\") {\n                \tinput \"threshold\", \"number\", title: \"Enter Step Threshold\", description: \"Number\", required: true\n                }\n            }\n\t\t}\n        \n\t\tsection(\"Via a push notification and/or an SMS message\"){\n            input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n                input \"phone\", \"phone\", title: \"Phone Number (for SMS, optional)\", required: false\n                input \"notificationType\", \"enum\", title: \"Select Notification\", required: false, defaultValue: \"None\", options: [\"None\", \"Push\", \"SMS\", \"Both\"]\n            }\n\t\t}\n        \n        section(\"Flash the Lights\") {\n        \tinput \"lights\", \"capability.switch\", title: \"Which Lights?\", required: false, multiple: true\n        \tinput \"flashCount\", \"number\", title: \"How Many Times?\", defaultValue: 5, required: false           \n        }\n        \n        section(\"Change the Color of the Lights\") {\n        \tinput \"hues\", \"capability.colorControl\", title: \"Which Hue Bulbs?\", required:false, multiple:true\n            input \"color\", \"enum\", title: \"Hue Color?\", required: false, multiple:false, options: [\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Purple\",\"Pink\"]\n\t\t\tinput \"lightLevel\", \"enum\", title: \"Light Level?\", required: false, options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]]\n\t\t\tinput \"duration\", \"number\", title: \"Duration in Seconds?\", defaultValue: 30, required: false\n        }\n        \n        section(\"Play a song on the Sonos\") {\n\t\t\tinput \"sonos\", \"capability.musicPlayer\", title: \"On this Sonos player\", required: false, submitOnChange:true\n            if (settings.sonos) {\n\t\t\t\tinput \"song\",\"enum\",title:\"Play this track or radio station\", required:true, multiple: false, options: songOptions()  \n\t\t\t\tinput \"resumePlaying\", \"bool\", title: \"Resume currently playing music after notification\", required: false, defaultValue: true                \n                input \"volume\", \"number\", title: \"Temporarily change volume\", description: \"0-100%\", required: false\n                input \"songDuration\", \"number\", title: \"Play for this many seconds\", defaultValue: 60, description: \"0-100%\", required: true\n            }\n\n\t\t}\n    }\n}\n\ndef chooseTrack() {\n\tdynamicPage(name: \"chooseTrack\") {\n\t\tsection{\n\t\t\tinput \"song\",\"enum\",title:\"Play this track\", required:true, multiple: false, options: songOptions()\n\t\t}\n\t}\n}\n\nprivate songOptions() {\n\n\t// Make sure current selection is in the set\n\n\tdef options = new LinkedHashSet()\n\tif (state.selectedSong?.station) {\n\t\toptions << state.selectedSong.station\n\t}\n\telse if (state.selectedSong?.description) {\n\t\t// TODO - Remove eventually? 'description' for backward compatibility\n\t\toptions << state.selectedSong.description\n\t}\n\n\t// Query for recent tracks\n\tdef states = sonos.statesSince(\"trackData\", new Date(0), [max:30])\n\tdef dataMaps = states.collect{it.jsonValue}\n\toptions.addAll(dataMaps.collect{it.station})\n\n\tlog.trace \"${options.size()} songs in list\"\n\toptions.take(20) as List\n}\n\nprivate saveSelectedSong() {\n\ttry {\n\t\tdef thisSong = song\n\t\tlog.info \"Looking for $thisSong\"\n\t\tdef songs = sonos.statesSince(\"trackData\", new Date(0), [max:30]).collect{it.jsonValue}\n\t\tlog.info \"Searching ${songs.size()} records\"\n\n\t\tdef data = songs.find {s -> s.station == thisSong}\n\t\tlog.info \"Found ${data?.station}\"\n\t\tif (data) {\n\t\t\tstate.selectedSong = data\n\t\t\tlog.debug \"Selected song = $state.selectedSong\"\n\t\t}\n\t\telse if (song == state.selectedSong?.station) {\n\t\t\tlog.debug \"Selected existing entry '$song', which is no longer in the last 20 list\"\n\t\t}\n\t\telse {\n\t\t\tlog.warn \"Selected song '$song' not found\"\n\t\t}\n\t}\n\tcatch (Throwable t) {\n\t\tlog.error t\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\n\tlog.trace \"Entering initialize()\"\n    \n\tstate.lastSteps = 0\n    state.steps = jawbone.currentValue(\"steps\").toInteger()\n    state.goal = jawbone.currentValue(\"goal\").toInteger()\n    \n\tsubscribe (jawbone,\"goal\",goalHandler)\n    subscribe (jawbone,\"steps\",stepHandler)\n    \n    if (song) {\n\t\tsaveSelectedSong()\n\t}\n    \n\tlog.trace \"Exiting initialize()\"    \n}\n\ndef goalHandler(evt) {\n\n\tlog.trace \"Entering goalHandler()\"\n\n\tdef goal = evt.value.toInteger()\n    \n    state.goal = goal\n    \n    log.trace \"Exiting goalHandler()\"\n}\n\ndef stepHandler(evt) {\n\n\tlog.trace \"Entering stepHandler()\"\n    \n    log.debug \"Event Value ${evt.value}\"\n    log.debug \"state.steps = ${state.steps}\"\n    log.debug \"state.goal = ${state.goal}\"\n\n\tdef steps = evt.value.toInteger()\n    \n    state.lastSteps = state.steps\n    state.steps = steps\n    \n    def stepGoal\n    if (settings.thresholdType == \"Goal\")\n    \tstepGoal = state.goal\n    else\n    \tstepGoal = settings.threshold\n    \n    if ((state.lastSteps < stepGoal) && (state.steps >= stepGoal)) { // only trigger when crossing through the goal threshold\n    \n    // goal achieved for the day! Yay! Lets tell someone!\n    \n    \tif (settings.notificationType != \"None\") { // Push or SMS Notification requested\n\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(stepMessage, recipients)\n            }\n            else {\n\n                def options = [\n                    method: settings.notificationType.toLowerCase(),\n                    phone: settings.phone\n                ]\n\n                sendNotification(stepMessage, options)\n            }\n        }\n        \n        if (settings.sonos) { // play a song on the Sonos as requested\n        \n        \t// runIn(1, sonosNotification, [overwrite: false])\n            sonosNotification()\n            \n        }  \n        \n        if (settings.hues) { // change the color of hue bulbs ras equested\n        \n        \t// runIn(1, hueNotification, [overwrite: false])\n            hueNotification()\n        \n        }        \n        \n        if (settings.lights) { // flash the lights as requested\n        \n\t\t\t// runIn(1, lightsNotification, [overwrite: false])\n        \tlightsNotification()\n        \n        }\n    \n    }\n    \n\tlog.trace \"Exiting stepHandler()\"    \n\n}\n\n\ndef lightsNotification() {\n\n\t// save the current state of the lights \n    \n    log.trace \"Save current state of lights\"\n    \n\tstate.previousLights = [:]\n\n\tlights.each {\n\t\tstate.previousLights[it.id] = it.currentValue(\"switch\")\n\t}\n    \n    // Flash the light on and off 5 times for now - this could be configurable \n            \n    log.trace \"Now flash the lights\"\n    \n    for (i in 1..flashCount) {\n           \n    \tlights.on()\n        pause(500)\n        lights.off()\n               \n    }\n    \n    // restore the original state\n    \n    log.trace \"Now restore the original state of lights\"    \n    \n \tlights.each {\n\t\tit.\"${state.previousLights[it.id]}\"()\n\t}   \n\n\n}\n\ndef hueNotification() {\n\n\tlog.trace \"Entering hueNotification()\"\n\n\tdef hueColor = 0\n\tif(color == \"Blue\")\n\t\thueColor = 70//60\n\telse if(color == \"Green\")\n\t\thueColor = 39//30\n\telse if(color == \"Yellow\")\n\t\thueColor = 25//16\n\telse if(color == \"Orange\")\n\t\thueColor = 10\n\telse if(color == \"Purple\")\n\t\thueColor = 75\n\telse if(color == \"Pink\")\n\t\thueColor = 83\n\n\n\tstate.previousHue = [:]\n\n\thues.each {\n\t\tstate.previousHue[it.id] = [\n\t\t\t\"switch\": it.currentValue(\"switch\"),\n\t\t\t\"level\" : it.currentValue(\"level\"),\n\t\t\t\"hue\": it.currentValue(\"hue\"),\n\t\t\t\"saturation\": it.currentValue(\"saturation\")\n\t\t]\n\t}\n\n\tlog.debug \"current values = ${state.previousHue}\"\n\n\tdef newValue = [hue: hueColor, saturation: 100, level: (lightLevel as Integer) ?: 100]\n\tlog.debug \"new value = $newValue\"\n\n\thues*.setColor(newValue)\n\tsetTimer()\n    \n\tlog.trace \"Exiting hueNotification()\"\n    \n}\n\ndef setTimer()\n{\n\tlog.debug \"runIn ${duration}, resetHue\"\n\trunIn(duration, resetHue, [overwrite: false])\n}\n\n\ndef resetHue()\n{\n    log.trace \"Entering resetHue()\"\n\tsettings.hues.each {\n\t\tit.setColor(state.previousHue[it.id])\n\t}\n    log.trace \"Exiting resetHue()\"    \n}\n\ndef sonosNotification() {\n\n\tlog.trace \"sonosNotification()\"\n    \n    if (settings.song) {\n    \n   \t\tif (settings.resumePlaying) {\n     \t\tif (settings.volume)\n\t\t\t\tsonos.playTrackAndResume(state.selectedSong, settings.songDuration, settings.volume)\n            else\n            \tsonos.playTrackAndResume(state.selectedSong, settings.songDuration)\n        } else {\n        \tif (settings.volume)\n \t\t\t\tsonos.playTrackAtVolume(state.selectedSong, settings.volume)\n            else\n                sonos.playTrack(state.selectedSong)\n        }\n        \n\t\tsonos.on() // make sure it is playing\n        \n\t}\n\n\tlog.trace \"Exiting sonosNotification()\"\n}",
        "docstring": "Use a step tracker device to track daily step goals and trigger various device actions when your goals are met!"
    },
    {
        "code": "section (\"At sunset...\") {\n        input \"sunsetMode\", \"mode\", title: \"Change mode to?\", required: false\n        input \"sunsetOn\", \"capability.switch\", title: \"Turn on?\", required: false, multiple: true\n        input \"sunsetOff\", \"capability.switch\", title: \"Turn off?\", required: false, multiple: true\n    }\n    section (\"Sunrise offset (optional)...\") {\n        input \"sunriseOffsetValue\", \"text\", title: \"HH:MM\", required: false\n        input \"sunriseOffsetDir\", \"enum\", title: \"Before or After\", required: false, options: [\"Before\",\"After\"]\n    }\n    section (\"Sunset offset (optional)...\") {\n        input \"sunsetOffsetValue\", \"text\", title: \"HH:MM\", required: false\n        input \"sunsetOffsetDir\", \"enum\", title: \"Before or After\", required: false, options: [\"Before\",\"After\"]\n    }\n    section (\"Zip code (optional, defaults to location coordinates)...\") {\n        input \"zipCode\", \"text\", required: false\n    }\n    section( \"Notifications\" ) {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", options: [\"Yes\", \"No\"], required: false\n            input \"phoneNumber\", \"phone\", title: \"Send a text message?\", required: false\n        }\n    }\n\n}\n\ndef installed() {\n    initialize()\n}\n\ndef updated() {\n    unsubscribe()\n    unschedule()\n    initialize()\n}\n\ndef initialize() {\n    subscribe(location, \"position\", locationPositionChange)\n    subscribe(location, \"sunriseTime\", sunriseTimeHandler)\n    subscribe(location, \"sunsetTime\", sunsetTimeHandler)\n\n    //Run today too\n    scheduleWithOffset(location.currentValue(\"sunsetTime\"), sunsetOffsetValue, sunsetOffsetDir, \"sunsetHandler\")\n    scheduleWithOffset(location.currentValue(\"sunriseTime\"), sunriseOffsetValue, sunriseOffsetDir, \"sunriseHandler\")\n}\n\ndef locationPositionChange(evt) {\n    log.trace \"locationChange()\"\n    updated()\n}\n\ndef sunsetTimeHandler(evt) {\n    log.trace \"sunsetTimeHandler()\"\n    scheduleWithOffset(evt.value, sunsetOffsetValue, sunsetOffsetDir, \"sunsetHandler\")\n}\n\ndef sunriseTimeHandler(evt) {\n    log.trace \"sunriseTimeHandler()\"\n    scheduleWithOffset(evt.value, sunriseOffsetValue, sunriseOffsetDir, \"sunriseHandler\")\n}\n\ndef scheduleWithOffset(nextSunriseSunsetTime, offset, offsetDir, handlerName) {\n    def nextSunriseSunsetTimeDate = Date.parse(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", nextSunriseSunsetTime)\n    def offsetTime = new Date(nextSunriseSunsetTimeDate.time + getOffset(offset, offsetDir))\n\n    log.debug \"scheduling Sunrise/Sunset for $offsetTime\"\n    runOnce(offsetTime, handlerName, [overwrite: false])\n}\n\ndef sunriseHandler() {\n    log.info \"Executing sunrise handler\"\n    if (sunriseOn) {\n        sunriseOn.on()\n    }\n    if (sunriseOff) {\n        sunriseOff.off()\n    }\n    changeMode(sunriseMode)\n}\n\ndef sunsetHandler() {\n    log.info \"Executing sunset handler\"\n    if (sunsetOn) {\n        sunsetOn.on()\n    }\n    if (sunsetOff) {\n        sunsetOff.off()\n    }\n    changeMode(sunsetMode)\n}\n\ndef changeMode(newMode) {\n    if (newMode && location.mode != newMode) {\n        if (location.modes?.find{it.name == newMode}) {\n            setLocationMode(newMode)\n            send \"${label} has changed the mode to '${newMode}'\"\n        }\n        else {\n            send \"${label} tried to change to undefined mode '${newMode}'\"\n        }\n    }\n}\n\nprivate send(msg) {\n    if (location.contactBookEnabled) {\n        log.debug(\"sending notifications to: ${recipients?.size()}\")\n        sendNotificationToContacts(msg, recipients)\n    }\n    else {\n        if (sendPushMessage != \"No\") {\n            log.debug(\"sending push message\")\n            sendPush(msg)\n        }\n\n        if (phoneNumber) {\n            log.debug(\"sending text message\")\n            sendSms(phoneNumber, msg)\n        }\n    }\n\n    log.debug msg\n}\n\nprivate getLabel() {\n    app.label ?: \"SmartThings\"\n}\n\nprivate getOffset(String offsetValue, String offsetDir) {\n    def timeOffsetMillis = calculateTimeOffsetMillis(offsetValue)\n    if (offsetDir == \"Before\") {\n        return -timeOffsetMillis\n    }\n    return timeOffsetMillis\n}\n\nprivate calculateTimeOffsetMillis(String offset) {\n    def result = 0\n    if (!offset) {\n        return result\n    }\n\n    def before = offset.startsWith('-')\n    if (before || offset.startsWith('+')) {\n        offset = offset[1..-1]\n    }\n\n    if (offset.isNumber()) {\n        result = Math.round((offset as Double) * 60000L)\n    } else if (offset.contains(\":\")) {\n        def segs = offset.split(\":\")\n        result = (segs[0].toLong() * 3600000L) + (segs[1].toLong() * 60000L)\n    }\n\n    if (before) {\n        result = -result\n    }\n\n    result\n}",
        "docstring": "Changes mode and controls lights based on local sunrise and sunset times."
    },
    {
        "code": "section(\"To use Tesla, SmartThings encrypts and securely stores your Tesla credentials.\") {}\n\t}\n}\n\ndef selectCars() {\n\tdef loginResult = forceLogin()\n\n\tif(loginResult.success)\n\t{\n\t\tdef options = carsDiscovered() ?: []\n\n\t\treturn dynamicPage(name: \"selectCars\", title: \"Tesla\", install:true, uninstall:true) {\n\t\t\tsection(\"Select which Tesla to connect\"){\n\t\t\t\tinput(name: \"selectedCars\", type: \"enum\", required:false, multiple:true, options:options)\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tlog.error \"login result false\"\n        return dynamicPage(name: \"selectCars\", title: \"Tesla\", install:false, uninstall:true, nextPage:\"\") {\n\t\t\tsection(\"\") {\n\t\t\t\tparagraph \"Please check your username and password\"\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ndef installed() {\n\tlog.debug \"Installed\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef uninstalled() {\n\tremoveChildDevices(getChildDevices())\n}\n\ndef initialize() {\n\n\tif (selectCars) {\n\t\taddDevice()\n\t}\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !selectedCars }\n\tlog.info delete\n    //removeChildDevices(delete)\n}\n\n//CHILD DEVICE METHODS\ndef addDevice() {\n    def devices = getcarList()\n    log.trace \"Adding childs $devices - $selectedCars\"\n\tselectedCars.each { dni ->\n\t\tdef d = getChildDevice(dni)\n\t\tif(!d) {\n\t\t\tdef newCar = devices.find { (it.dni) == dni }\n\t\t\td = addChildDevice(\"smartthings\", \"Tesla\", dni, null, [name:\"Tesla\", label:\"Tesla\"])\n\t\t\tlog.trace \"created ${d.name} with id $dni\"\n\t\t} else {\n\t\t\tlog.trace \"found ${d.name} with id $key already exists\"\n\t\t}\n\t}\n}\n\nprivate removeChildDevices(delete)\n{\n\tlog.debug \"deleting ${delete.size()} Teslas\"\n\tdelete.each {\n\t\tstate.suppressDelete[it.deviceNetworkId] = true\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t\tstate.suppressDelete.remove(it.deviceNetworkId)\n\t}\n}\n\ndef getcarList() {\n\tdef devices = []\n\n\tdef carListParams = [\n\t\turi: \"https://portal.vn.teslamotors.com/\",\n        path: \"/vehicles\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n    \n\thttpGet(carListParams) { resp ->\n\t\tlog.debug \"Getting car list\"\n\t\tif(resp.status == 200) {\n            def vehicleId = resp.data.id.value[0].toString()\n            def vehicleVIN = resp.data.vin[0]\n            def dni = vehicleVIN + \":\" + vehicleId\n \t\t\tdef name = \"Tesla [${vehicleId}]\"\n            // CHECK HERE IF MOBILE IS ENABLE\n            // path: \"/vehicles/${vehicleId}/mobile_enabled\",\n            // if (enable)\n            devices += [\"name\" : \"${name}\", \"dni\" : \"${dni}\"]\n            // else return [errorMessage:\"Mobile communication isn't enable on all of your vehicles.\"]\n\t\t} else if(resp.status == 302) {\n        \t// Token expired or incorrect\n\t\t\tsingleUrl = resp.headers.Location.value\n\t\t} else {\n\t\t\t// ERROR\n\t\t\tlog.error \"car list: unknown response\"\n\t\t}        \n\t}\n    return devices\n}\n\nMap carsDiscovered() {\n\tdef devices =  getcarList()\n    log.trace \"Map $devices\"    \n\tdef map = [:]\n\tif (devices instanceof java.util.Map) {\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.dni\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t} else { //backwards compatable\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.dni\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t}\n\tmap\n}\n\ndef removeChildFromSettings(child) {\n\tdef device = child.device\n\tdef dni = device.deviceNetworkId\n\tlog.debug \"removing child device $device with dni ${dni}\"\n\tif(!state?.suppressDelete?.get(dni))\n\t{\n\t\tdef newSettings = settings.cars?.findAll { it != dni } ?: []\n\t\tapp.updateSetting(\"cars\", newSettings)\n\t}\n}\n\nprivate forceLogin() {\n\tupdateCookie(null)\n\tlogin()\n}\n\n\nprivate login() {\n\tif(getCookieValueIsValid()) {\n\t\treturn [success:true]\n\t}\n\treturn doLogin()\n}\n\nprivate doLogin() {\n\tdef loginParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n        path: \"/login\",\n\t\tcontentType: \"application/x-www-form-urlencoded\",\n\t\tbody: \"user_session%5Bemail%5D=${username}&user_session%5Bpassword%5D=${password}\"\n\t]\n\n\tdef result = [success:false]\n\t\n    try {\n    \thttpPost(loginParams) { resp ->\n            if (resp.status == 302) {\n                log.debug \"login 302 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n                def cookie = resp?.headers?.'Set-Cookie'?.split(\";\")?.getAt(0)\n                if (cookie) {\n                    log.debug \"login setting cookie to $cookie\"\n                    updateCookie(cookie)                \n                    result.success = true\n                } else {\n                    // ERROR: any more information we can give?\n                    result.reason = \"Bad login\"\n                }\n            } else {\n                // ERROR: any more information we can give?\n                result.reason = \"Bad login\"\n            }\n    \t}        \n\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\t\tresult.reason = \"Bad login\"\n\t}\n\treturn result\n}\n\nprivate command(String dni, String command, String value = '') {\n\tdef id = getVehicleId(dni)\n    def commandPath\n\tswitch (command) {\n\t\tcase \"flash\":\n    \t\tcommandPath = \"/vehicles/${id}/command/flash_lights\"\n            break;\n\t\tcase \"honk\":\n    \t\tcommandPath = \"/vehicles/${id}/command/honk_horn\"  \n            break;\n\t\tcase \"doorlock\":\n    \t\tcommandPath = \"/vehicles/${id}/command/door_lock\"  \n            break;            \n\t\tcase \"doorunlock\":\n    \t\tcommandPath = \"/vehicles/${id}/command/door_unlock\"  \n            break;  \n\t\tcase \"climaon\":\n    \t\tcommandPath = \"/vehicles/${id}/command/auto_conditioning_start\"  \n            break;            \n\t\tcase \"climaoff\":\n    \t\tcommandPath = \"/vehicles/${id}/command/auto_conditioning_stop\"  \n            break;             \n\t\tcase \"roof\":\n    \t\tcommandPath = \"/vehicles/${id}/command/sun_roof_control?state=${value}\" \n            break;    \n\t\tcase \"temp\":\n    \t\tcommandPath = \"/vehicles/${id}/command/set_temps?driver_temp=${value}&passenger_temp=${value}\"\n            break;              \n\t\tdefault:\n\t\t\tbreak; \n    }   \n    \n\tdef commandParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: commandPath,\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef loginRequired = false\n\n\thttpGet(commandParams) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            sendNotification(data.toString())\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\tif(loginRequired) { throw new Exception(\"Login Required\") }\n}\n\nprivate honk(String dni) {\n\tdef id = getVehicleId(dni)\n\tdef honkParams = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/honk_horn\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef loginRequired = false\n\n\thttpGet(honkParams) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired) {\n\t\tthrow new Exception(\"Login Required\")\n\t}\n}\n\nprivate poll(String dni) {\n\tdef id = getVehicleId(dni)\n\tdef pollParams1 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/climate_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\tdef childDevice = getChildDevice(dni)\n    \n\tdef loginRequired = false\n\n\thttpGet(pollParams1) { resp ->\n\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            childDevice?.sendEvent(name: 'temperature', value: cToF(data.inside_temp).toString())\n            if (data.is_auto_conditioning_on)            \n            \tchildDevice?.sendEvent(name: 'clima', value: 'on')\n            else\n                childDevice?.sendEvent(name: 'clima', value: 'off')\n            childDevice?.sendEvent(name: 'thermostatSetpoint', value: cToF(data.driver_temp_setting).toString())            \n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tdef pollParams2 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/vehicle_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\thttpGet(pollParams2) { resp ->\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            if (data.sun_roof_percent_open == 0)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'close')\n\t\t\telse if (data.sun_roof_percent_open > 0 && data.sun_roof_percent_open < 70)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'vent')\n\t\t\telse if (data.sun_roof_percent_open >= 70 && data.sun_roof_percent_open <= 80)                \n            \tchildDevice?.sendEvent(name: 'roof', value: 'comfort')\n            else if (data.sun_roof_percent_open > 80 && data.sun_roof_percent_open <= 100)\n            \tchildDevice?.sendEvent(name: 'roof', value: 'open')           \n            if (data.locked)            \n            \tchildDevice?.sendEvent(name: 'door', value: 'lock')\n            else\n                childDevice?.sendEvent(name: 'door', value: 'unlock')\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tdef pollParams3 = [\n\t\turi: \"https://portal.vn.teslamotors.com\",\n\t\tpath: \"/vehicles/${id}/command/charge_state\",\n\t\theaders: [Cookie: getCookieValue(), 'User-Agent': validUserAgent()]\n\t]\n\n\thttpGet(pollParams3) { resp ->\n\t\tif(resp.status == 403) {\n\t\t\tloginRequired = true\n\t\t} else if (resp.status == 200) {\n\t\t\tdef data = resp.data\n            childDevice?.sendEvent(name: 'connected', value: data.charging_state.toString())\n            childDevice?.sendEvent(name: 'miles', value: data.battery_range.toString())\n            childDevice?.sendEvent(name: 'battery', value: data.battery_level.toString())\n\t\t} else {\n\t\t\tlog.error \"unknown response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired) {\n\t\tthrow new Exception(\"Login Required\")\n\t}\n}\n\nprivate getVehicleId(String dni) {\n    return dni.split(\":\").last()\n}\n\nprivate Boolean getCookieValueIsValid()\n{\n\t// TODO: make a call with the cookie to verify that it works\n\treturn getCookieValue()\n}\n\nprivate updateCookie(String cookie) {\n\tstate.cookie = cookie\n}\n\nprivate getCookieValue() {\n\tstate.cookie\n}\n\ndef cToF(temp) {\n    return temp * 1.8 + 32\n}\n\nprivate validUserAgent() {\n\t\"curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8x zlib/1.2.5\"\n}",
        "docstring": "Integrate your Tesla car with SmartThings."
    },
    {
        "code": "section(\"Text me at...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n  log.debug \"$contact1 was opened, sending text\"\n    if (location.contactBookEnabled) {\n        sendNotificationToContacts(\"Your ${contact1.label ?: contact1.name} was opened\", recipients)\n    }\n    else {\n        sendSms(phone1, \"Your ${contact1.label ?: contact1.name} was opened\")\n    }\n}",
        "docstring": "Get a text message sent to your phone when an open/close sensor is opened."
    },
    {
        "code": "section(\"While I'm out...\") {\n\t\tinput \"presence1\", \"capability.presenceSensor\", title: \"Who?\"\n\t}\n\tsection(\"Text me at...\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed() {\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(motion1, \"motion.active\", motionActiveHandler)\n}\n\ndef motionActiveHandler(evt) {\n\tlog.trace \"$evt.value: $evt, $settings\"\n\n\tif (presence1.latestValue(\"presence\") == \"not present\") {\n\t\t// Don't send a continuous stream of text messages\n\t\tdef deltaSeconds = 10\n\t\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\t\tdef recentEvents = motion1.eventsSince(timeAgo)\n\t\tlog.debug \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\t\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\t\tif (alreadySentSms) {\n\t\t\tlog.debug \"SMS already sent within the last $deltaSeconds seconds\"\n\t\t} else {\n            if (location.contactBookEnabled) {\n                log.debug \"$motion1 has moved while you were out, sending notifications to: ${recipients?.size()}\"\n                sendNotificationToContacts(\"${motion1.label} ${motion1.name} moved while you were out\", recipients)\n            }\n            else {\n                log.debug \"$motion1 has moved while you were out, sending text\"\n                sendSms(phone1, \"${motion1.label} ${motion1.name} moved while you were out\")\n            }\n\t\t}\n\t} else {\n\t\tlog.debug \"Motion detected, but presence sensor indicates you are present\"\n\t}\n}",
        "docstring": "Send a text message when there is motion while you are away."
    },
    {
        "code": "section(\"Turn on or off all of these switches as well\") {\n\t\tinput \"switches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"And turn off but not on all of these switches\") {\n\t\tinput \"offSwitches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"And turn on but not off all of these switches\") {\n\t\tinput \"onSwitches\", \"capability.switch\", multiple: true, required: false\n\t}\n\tsection(\"And Dim these switches\") {\n\t\tinput \"dimSwitches\", \"capability.switchLevel\", multiple: true, required: false\n\t}    \n}\n\ndef installed()\n{   \n\tsubscribe(master, \"switch.on\", onHandler)\n\tsubscribe(master, \"switch.off\", offHandler)\n\tsubscribe(master, \"level\", dimHandler)   \n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(master, \"switch.on\", onHandler)\n\tsubscribe(master, \"switch.off\", offHandler)\n\tsubscribe(master, \"level\", dimHandler)   \n}\n\ndef logHandler(evt) {\n\tlog.debug evt.value\n}\n\ndef onHandler(evt) {\n\tlog.debug evt.value\n\tlog.debug onSwitches()\n\tonSwitches()?.on()\n}\n\ndef offHandler(evt) {\n\tlog.debug evt.value\n\tlog.debug offSwitches()\n\toffSwitches()?.off()\n}\n\ndef dimHandler(evt) {\n\tlog.debug \"Dim level: $evt.value\"\n\tdimSwitches?.setLevel(evt.value)\n}\n\nprivate onSwitches() {\n\tif(switches && onSwitches) { switches + onSwitches }\n\telse if(switches) { switches }\n\telse { onSwitches }\n}\n\nprivate offSwitches() {\n\tif(switches && offSwitches) { switches + offSwitches }\n\telse if(switches) { switches }\n\telse { offSwitches }\n}",
        "docstring": "Turns on, off and dim a collection of lights based on the state of a specific switch."
    },
    {
        "code": "section(\"Then flash...\"){\n\t\tinput \"switches\", \"capability.switch\", title: \"These lights\", multiple: true\n\t\tinput \"numFlashes\", \"number\", title: \"This number of times (default 3)\", required: false\n\t}\n\tsection(\"Time settings in milliseconds (optional)...\"){\n\t\tinput \"onFor\", \"number\", title: \"On for (default 1000)\", required: false\n\t\tinput \"offFor\", \"number\", title: \"Off for (default 1000)\", required: false\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tsubscribe()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tsubscribe()\n}\n\ndef subscribe() {\n\tif (contact) {\n\t\tsubscribe(contact, \"contact.open\", contactOpenHandler)\n\t}\n\tif (acceleration) {\n\t\tsubscribe(acceleration, \"acceleration.active\", accelerationActiveHandler)\n\t}\n\tif (motion) {\n\t\tsubscribe(motion, \"motion.active\", motionActiveHandler)\n\t}\n\tif (mySwitch) {\n\t\tsubscribe(mySwitch, \"switch.on\", switchOnHandler)\n\t}\n\tif (myPresence) {\n\t\tsubscribe(myPresence, \"presence\", presenceHandler)\n\t}\n}\n\ndef motionActiveHandler(evt) {\n\tlog.debug \"motion $evt.value\"\n\tflashLights()\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"contact $evt.value\"\n\tflashLights()\n}\n\ndef accelerationActiveHandler(evt) {\n\tlog.debug \"acceleration $evt.value\"\n\tflashLights()\n}\n\ndef switchOnHandler(evt) {\n\tlog.debug \"switch $evt.value\"\n\tflashLights()\n}\n\ndef presenceHandler(evt) {\n\tlog.debug \"presence $evt.value\"\n\tif (evt.value == \"present\") {\n\t\tflashLights()\n\t} else if (evt.value == \"not present\") {\n\t\tflashLights()\n\t}\n}\n\nprivate flashLights() {\n\tdef doFlash = true\n\tdef onFor = onFor ?: 1000\n\tdef offFor = offFor ?: 1000\n\tdef numFlashes = numFlashes ?: 3\n\n\tlog.debug \"LAST ACTIVATED IS: ${state.lastActivated}\"\n\tif (state.lastActivated) {\n\t\tdef elapsed = now() - state.lastActivated\n\t\tdef sequenceTime = (numFlashes + 1) * (onFor + offFor)\n\t\tdoFlash = elapsed > sequenceTime\n\t\tlog.debug \"DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: ${state.lastActivated}\"\n\t}\n\n\tif (doFlash) {\n\t\tlog.debug \"FLASHING $numFlashes times\"\n\t\tstate.lastActivated = now()\n\t\tlog.debug \"LAST ACTIVATED SET TO: ${state.lastActivated}\"\n\t\tdef initialActionOn = switches.collect{it.currentSwitch != \"on\"}\n\t\tdef delay = 0L\n\t\tnumFlashes.times {\n\t\t\tlog.trace \"Switch on after  $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.on(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.off(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += onFor\n\t\t\tlog.trace \"Switch off after $delay msec\"\n\t\t\tswitches.eachWithIndex {s, i ->\n\t\t\t\tif (initialActionOn[i]) {\n\t\t\t\t\ts.off(delay: delay)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts.on(delay:delay)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelay += offFor\n\t\t}\n\t}\n}",
        "docstring": "Flashes a set of lights in response to motion, an open/close event, or a switch."
    },
    {
        "code": "section(\"Text me at...\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone1\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\ndef installed() {\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef updated() {\n\tunsubscribe()\n\tsubscribe(accelerationSensor, \"acceleration.active\", accelerationActiveHandler)\n}\n\ndef accelerationActiveHandler(evt) {\n\t// Don't send a continuous stream of text messages\n\tdef deltaSeconds = 5\n\tdef timeAgo = new Date(now() - (1000 * deltaSeconds))\n\tdef recentEvents = accelerationSensor.eventsSince(timeAgo)\n\tlog.trace \"Found ${recentEvents?.size() ?: 0} events in the last $deltaSeconds seconds\"\n\tdef alreadySentSms = recentEvents.count { it.value && it.value == \"active\" } > 1\n\n\tif (alreadySentSms) {\n\t\tlog.debug \"SMS already sent to phone within the last $deltaSeconds seconds\"\n\t} else {\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(\"Gun case has moved!\", recipients)\n        }\n        else {\n            log.debug \"$accelerationSensor has moved, texting phone\"\n            sendSms(phone1, \"Gun case has moved!\")\n        }\n\t}\n}",
        "docstring": "Send a text when your gun case moves"
    },
    {
        "code": "section(\"Turn off these thermostats\"){\n\t\tinput \"thermostatDevices\", \"capability.thermostat\", title: \"Thermostats\", required: true, multiple: true\n\t}\n\tsection(\"Send this message (optional, sends standard status message if not specified)\"){\n\t\tinput \"messageText\", \"text\", title: \"Message Text\", required: false\n\t}\n\n\tif (location.contactBookEnabled || phone) {\n\t\tsection(\"Via a push notification and/or an SMS message\"){\n\t\t\tinput(\"recipients\", \"contact\", title: \"Send notifications to\") {\n\t\t\t\tinput \"phone\", \"phone\", title: \"Enter a phone number to get SMS\", required: false\n\t\t\t\tparagraph \"If outside the US please make sure to enter the proper country code\"\n\t\t\t\tinput \"pushAndPhone\", \"enum\", title: \"Notify me via Push Notification\", required: false, options: [\"Yes\", \"No\"]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsection(\"Via a push notification\"){\n\t\t\tinput \"pushAndPhone\", \"enum\", title: \"Notify me via Push Notification\", required: false, options: [\"Yes\", \"No\"]\n\t\t}\n\t}\n\tsection(\"Minimum time between messages (optional, defaults to every message)\") {\n\t\tinput \"frequency\", \"decimal\", title: \"Minutes\", required: false\n\t}\n  }\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribeToEvents()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribeToEvents()\n}\n\ndef subscribeToEvents() {\n\tsubscribe(smokeDevices, \"smoke.detected\", eventHandler)\n\tsubscribe(smokeDevices, \"smoke.tested\", eventHandler)\n\tsubscribe(smokeDevices, \"carbonMonoxide.detected\", eventHandler)\n \tsubscribe(carbonMonoxideDevices, \"carbonMonoxide.detected\", eventHandler)\n}\n\ndef eventHandler(evt) {\n\tlog.debug \"Notify got evt ${evt}\"\n\t// Turn off thermostat\n\tthermostatDevices*.setThermostatMode(\"off\")\n\tif (frequency) {\n\t\tdef lastTime = state[evt.deviceId]\n\t\tif (lastTime == null || now() - lastTime >= frequency * 60000) {\n\t\t\tsendMessage(evt)\n\t\t}\n\t}\n\telse {\n\t\tsendMessage(evt)\n\t}\n}\n\nprivate sendMessage(evt) {\n\tString msg = messageText\n\tMap options = [:]\n\n\tif (!messageText) {\n\t\tmsg = '{{ triggerEvent.descriptionText }}'\n\t\toptions = [translatable: true, triggerEvent: evt]\n\t}\n\tlog.debug \"$evt.name:$evt.value, pushAndPhone:$pushAndPhone, '$msg'\"\n\n\tif (location.contactBookEnabled) {\n\t\tsendNotificationToContacts(msg, recipients, options)\n\t} else {\n\t\tif (phone) {\n\t\t\toptions.phone = phone\n\t\t\tif (pushAndPhone != 'No') {\n\t\t\t\tlog.debug 'Sending push and SMS'\n\t\t\t\toptions.method = 'both'\n\t\t\t} else {\n\t\t\t\tlog.debug 'Sending SMS'\n\t\t\t\toptions.method = 'phone'\n\t\t\t}\n\t\t} else if (pushAndPhone != 'No') {\n\t\t\tlog.debug 'Sending push'\n\t\t\toptions.method = 'push'\n\t\t} else {\n\t\t\tlog.debug 'Sending nothing'\n\t\t\toptions.method = 'none'\n\t\t}\n\t\tsendNotification(msg, options)\n\t}\n\tif (frequency) {\n\t\tstate[evt.deviceId] = now()\n\t}\n}",
        "docstring": "Receive notifications when anything happens in your home."
    },
    {
        "code": "section(title: \"Multi Attribute Tile Types\") {\n            input(type: \"bool\", name: \"genericDeviceTile\", title: \"generic\", description: \"A device that showcases the various use of generic multi-attribute-tiles.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"lightingDeviceTile\", title: \"lighting\", description: \"A device that showcases the various use of lighting multi-attribute-tiles.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"thermostatDeviceTile\", title: \"thermostat\", description: \"A device that showcases the various use of thermostat multi-attribute-tiles.\", defaultValue: \"true\")\n            input(type: \"bool\", name: \"mediaPlayerDeviceTile\", title: \"media player\", description: \"A device that showcases the various use of mediaPlayer multi-attribute-tiles.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"videoPlayerDeviceTile\", title: \"video player\", description: \"A device that showcases the various use of videoPlayer multi-attribute-tiles.\", defaultValue: \"false\")\n        }\n        section(title: \"Device Tile Types\") {\n            input(type: \"bool\", name: \"standardDeviceTile\", title: \"standard device tiles\", description: \"A device that showcases the various use of standard device tiles.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"valueDeviceTile\", title: \"value device tiles\", description: \"A device that showcases the various use of value device tiles.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"presenceDeviceTile\", title: \"presence device tiles\", description: \"A device that showcases the various use of color control device tile.\", defaultValue: \"false\")\n        }\n        section(title: \"Other Tile Types\") {\n            input(type: \"bool\", name: \"carouselDeviceTile\", title: \"image carousel\", description: \"A device that showcases the various use of carousel device tile.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"sliderDeviceTile\", title: \"slider\", description: \"A device that showcases the various use of slider device tile.\", defaultValue: \"false\")\n            input(type: \"bool\", name: \"colorWheelDeviceTile\", title: \"color wheel\", description: \"A device that showcases the various use of color wheel device tile.\", defaultValue: \"false\")\n        }\n    }\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef uninstalled() {\n    getChildDevices().each {\n        deleteChildDevice(it.deviceNetworkId)\n    }\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initializeDevices()\n}\n\ndef initializeDevices() {\n    settings.each { key, value ->\n        log.debug \"$key : $value\"\n        def existingDevice = getChildDevices().find { it.name == key }\n        log.debug \"$existingDevice\"\n        if (existingDevice && !value) {\n            deleteChildDevice(existingDevice.deviceNetworkId)\n        } else if (!existingDevice && value) {\n            String dni = UUID.randomUUID()\n            log.debug \"$dni\"\n            addChildDevice(app.namespace, key, dni, null, [\n                label: labelMap()[key] ?: key,\n                completedSetup: true\n            ])\n        }\n    }\n}\n\n// Map the name of the Device to a proper Label\ndef labelMap() {\n    [\n        genericDeviceTile: \"Tile Multiattribute Generic\",\n        lightingDeviceTile: \"Tile Multiattribute Lighting\",\n        thermostatDeviceTile: \"Tile Multiattribute Thermostat\",\n        mediaPlayerDeviceTile: \"Tile Multiattribute Media Player\",\n        videoPlayerDeviceTile: \"Tile Multiattribute Video Player\",\n        standardDeviceTile: \"Tile Device Standard\",\n        valueDeviceTile: \"Tile Device Value\",\n        presenceDeviceTile: \"Tile Device Presence\",\n        carouselDeviceTile: \"Tile Device Carousel\",\n        sliderDeviceTile: \"Tile Device Slider\",\n        colorWheelDeviceTile: \"Tile Device Color Wheel\"\n    ]\n}",
        "docstring": "A controller SmartApp to install virtual devices into your location in order to simulate various native Device Tiles."
    },
    {
        "code": "section(\"Turn on a switch for 5 minutes...\"){\n\t\tinput \"switch1\", \"capability.switch\"\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated(settings) {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tswitch1.on()\n\tdef fiveMinuteDelay = 60 * 5\n\trunIn(fiveMinuteDelay, turnOffSwitch)\n}\n\ndef turnOffSwitch() {\n\tswitch1.off()\n}",
        "docstring": "When a SmartSense Multi is opened, a switch will be turned on, and then turned off after 5 minutes."
    },
    {
        "code": "section(\"Turn on/off a light...\"){\n\t\tinput \"switch1\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt)\n{\n\tlog.debug \"presenceHandler $evt.name: $evt.value\"\n\tdef current = presence1.currentValue(\"presence\")\n\tlog.debug current\n\tdef presenceValue = presence1.find{it.currentPresence == \"present\"}\n\tlog.debug presenceValue\n\tif(presenceValue){\n\t\tswitch1.on()\n\t\tlog.debug \"Someone's home!\"\n\t}\n\telse{\n\t\tswitch1.off()\n\t\tlog.debug \"Everyone's away.\"\n\t}\n}",
        "docstring": "Turn something on when you arrive and back off when you leave."
    },
    {
        "code": "section(\"Turn on a light...\"){\n\t\tinput \"switches\", \"capability.switch\", multiple: true\n\t}\n}\n\n\ndef installed()\n{\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contact1, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"$evt.value: $evt, $settings\"\n\tlog.trace \"Turning on switches: $switches\"\n\tswitches.on()\n}",
        "docstring": "Turn something on when an open/close sensor opens."
    },
    {
        "code": "section(\"Turn on/off a light...\"){\n\t\tinput \"switch1\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence\", presenceHandler)\n}\n\ndef presenceHandler(evt)\n{\n\tdef now = new Date()\n\tdef sunTime = getSunriseAndSunset();\n    \n\tlog.debug \"nowTime: $now\"\n\tlog.debug \"riseTime: $sunTime.sunrise\"\n\tlog.debug \"setTime: $sunTime.sunset\"\n\tlog.debug \"presenceHandler $evt.name: $evt.value\"\n    \n\tdef current = presence1.currentValue(\"presence\")\n\tlog.debug current\n\tdef presenceValue = presence1.find{it.currentPresence == \"present\"}\n\tlog.debug presenceValue\n\tif(presenceValue && (now > sunTime.sunset)) {\n\t\tswitch1.on()\n\t\tlog.debug \"Welcome home at night!\"\n\t}\n    else if(presenceValue && (now < sunTime.sunset)) {\n    \tlog.debug \"Welcome home at daytime!\"\n    }\n\telse {\n\t\tswitch1.off()\n\t\tlog.debug \"Everyone's away.\"\n\t}\n}",
        "docstring": "Turn something on only if you arrive after sunset and back off anytime you leave."
    },
    {
        "code": "}\n\nmappings {\n\tpath(\"/list\") {\n\t\taction: [\n\t\t\tGET: \"listAll\"\n\t\t]\n\t}\n\n\tpath(\"/events/:id\") {\n\t\taction: [\n\t\t\tGET: \"showEvents\"\n\t\t]\n\t}\n\n\tpath(\"/switches\") {\n\t\taction: [\n\t\t\tGET: \"listSwitches\",\n\t\t\tPUT: \"updateSwitches\",\n\t\t\tPOST: \"updateSwitches\"\n\t\t]\n\t}\n\tpath(\"/switches/:id\") {\n\t\taction: [\n\t\t\tGET: \"showSwitch\",\n\t\t\tPUT: \"updateSwitch\",\n\t\t\tPOST: \"updateSwitch\"\n\t\t]\n\t}\n\tpath(\"/switches/subscriptions\") {\n\t\tlog.debug \"switches added\"\n\t\taction: [\n\t\t\tPOST: \"addSwitchSubscription\"\n\t\t]\n\t}\n\tpath(\"/switches/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removeSwitchSubscription\",\n\t\t\tGET: \"removeSwitchSubscription\"\n\t\t]\n\t}\n\n\tpath(\"/motionSensors\") {\n\t\taction: [\n\t\t\tGET: \"listMotions\",\n\t\t\tPUT: \"updateMotions\",\n\t\t\tPOST: \"updateMotions\"\n\n\t\t]\n\t}\n\tpath(\"/motionSensors/:id\") {\n\t\taction: [\n\t\t\tGET: \"showMotion\",\n\t\t\tPUT: \"updateMotion\",\n\t\t\tPOST: \"updateMotion\"\n\t\t]\n\t}\n\tpath(\"/motionSensors/subscriptions\") {\n\t\tlog.debug \"motionSensors added\"\n\t\taction: [\n\t\t\tPOST: \"addMotionSubscription\"\n\t\t]\n\t}\n\tpath(\"/motionSensors/subscriptions/:id\") {\n\t\tlog.debug \"motionSensors Deleted\"\n\t\taction: [\n\t\t\tDELETE: \"removeMotionSubscription\",\n\t\t\tGET: \"removeMotionSubscription\"\n\t\t]\n\t}\n\n\tpath(\"/locks\") {\n\t\taction: [\n\t\t\tGET: \"listLocks\",\n\t\t\tPUT: \"updateLocks\",\n\t\t\tPOST: \"updateLocks\"\n\t\t]\n\t}\n\tpath(\"/locks/:id\") {\n\t\taction: [\n\t\t\tGET: \"showLock\",\n\t\t\tPUT: \"updateLock\",\n\t\t\tPOST: \"updateLock\"\n\t\t]\n\t}\n\tpath(\"/locks/subscriptions\") {\n\t\taction: [\n\t\t\tPOST: \"addLockSubscription\"\n\t\t]\n\t}\n\tpath(\"/locks/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removeLockSubscription\",\n\t\t\tGET: \"removeLockSubscription\"\n\t\t]\n\t}\n\n\tpath(\"/contactSensors\") {\n\t\taction: [\n\t\t\tGET: \"listContactSensors\",\n\t\t\tPUT: \"updateContactSensor\",\n\t\t\tPOST: \"updateContactSensor\"\n\t\t]\n\t}\n\tpath(\"/contactSensors/:id\") {\n\t\taction: [\n\t\t\tGET: \"showContactSensor\",\n\t\t\tPUT: \"updateContactSensor\",\n\t\t\tPOST: \"updateContactSensor\"\n\t\t]\n\t}\n\tpath(\"/contactSensors/subscriptions\") {\n\t\tlog.debug \"contactSensors/subscriptions\"\n\t\taction: [\n\t\t\tPOST: \"addContactSubscription\"\n\t\t]\n\t}\n\tpath(\"/contactSensors/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removeContactSensorSubscription\",\n\t\t\tGET: \"removeContactSensorSubscription\"\n\t\t]\n\t}\n\n\tpath(\"/presenceSensors\") {\n\t\taction: [\n\t\t\tGET: \"listPresenceSensors\",\n\t\t\tPUT: \"updatePresenceSensor\",\n\t\t\tPOST: \"updatePresenceSensor\"\n\t\t]\n\t}\n\tpath(\"/presenceSensors/:id\") {\n\t\taction: [\n\t\t\tGET: \"showPresenceSensor\",\n\t\t\tPUT: \"updatePresenceSensor\",\n\t\t\tPOST: \"updatePresenceSensor\"\n\t\t]\n\t}\n\tpath(\"/presenceSensors/subscriptions\") {\n\t\tlog.debug \"PresenceSensors/subscriptions\"\n\t\taction: [\n\t\t\tPOST: \"addPresenceSubscription\"\n\t\t]\n\t}\n\tpath(\"/presenceSensors/subscriptions/:id\") {\n\t\taction: [\n\t\t\tDELETE: \"removePresenceSensorSubscription\",\n\t\t\tGET: \"removePresenceSensorSubscription\"\n\t\t]\n\t}\n\n\tpath(\"/state\") {\n\t\taction: [\n\t\t\tGET: \"currentState\"\n\t\t]\n\t}\n\n\tpath(\"/phrases\") {\n\t\taction: [\n\t\t\tGET: \"listPhrases\"\n\t\t]\n\t}\n\tpath(\"/phrases/:phraseName\") {\n\t\taction: [\n\t\t\tGET: \"executePhrase\",\n\t\t\tPOST: \"executePhrase\",\n\t\t]\n\t}\n\n}\n\ndef installed() {\n//\tsubscribe(motions, \"motion.active\", motionOpenHandler)\n\n//\tsubscribe(contactSensors, \"contact.open\", contactOpenHandler)\n//\tlog.trace \"contactSensors Installed\"\n\n}\n\ndef updated() {\n\n//\tunsubscribe()\n//    subscribe(motions, \"motion.active\", motionOpenHandler)\n//\tsubscribe(contactSensors, \"contact.open\", contactOpenHandler)\n\n//log.trace \"contactSensors Updated\"\n\n}\n\ndef listAll() {\n\tlistSwitches() + listMotions() + listLocks() + listContactSensors() + listPresenceSensors() + listPhrasesWithType()\n}\n\ndef listContactSensors() {\n\tcontactSensors.collect { device(it, \"contactSensor\") }\n}\n\n\nvoid updateContactSensors() {\n\tupdateAll(contactSensors)\n}\n\ndef showContactSensor() {\n\tshow(contactSensors, \"contact\")\n}\n\nvoid updateContactSensor() {\n\tupdate(contactSensors)\n}\n\ndef addContactSubscription() {\n\tlog.debug \"addContactSensorSubscription,  params: ${params}\"\n\taddSubscription(contactSensors, \"contact\")\n}\n\ndef removeContactSensorSubscription() {\n\tremoveSubscription(contactSensors)\n}\n\n\ndef listPresenceSensors() {\n\tpresenceSensors.collect { device(it, \"presenceSensor\") }\n}\n\n\nvoid updatePresenceSensors() {\n\tupdateAll(presenceSensors)\n}\n\ndef showPresenceSensor() {\n\tshow(presenceSensors, \"presence\")\n}\n\nvoid updatePresenceSensor() {\n\tupdate(presenceSensors)\n}\n\ndef addPresenceSubscription() {\n\tlog.debug \"addPresenceSensorSubscription,  params: ${params}\"\n\taddSubscription(presenceSensors, \"presence\")\n}\n\ndef removePresenceSensorSubscription() {\n\tremoveSubscription(presenceSensors)\n}\n\n\ndef listSwitches() {\n\tswitches.collect { device(it, \"switch\") }\n}\n\nvoid updateSwitches() {\n\tupdateAll(switches)\n}\n\ndef showSwitch() {\n\tshow(switches, \"switch\")\n}\n\nvoid updateSwitch() {\n\tupdate(switches)\n}\n\ndef addSwitchSubscription() {\n\tlog.debug \"addSwitchSubscription,  params: ${params}\"\n\taddSubscription(switches, \"switch\")\n}\n\ndef removeSwitchSubscription() {\n\tremoveSubscription(switches)\n}\n\ndef listMotions() {\n\tmotions.collect { device(it, \"motionSensor\") }\n}\n\nvoid updateMotions() {\n\tupdateAll(motions)\n}\n\ndef showMotion() {\n\tshow(motions, \"motion\")\n}\n\nvoid updateMotion() {\n\tupdate(motions)\n}\n\ndef addMotionSubscription() {\n\n\taddSubscription(motions, \"motion\")\n}\n\ndef removeMotionSubscription() {\n\tremoveSubscription(motions)\n}\n\ndef listLocks() {\n\tlocks.collect { device(it, \"lock\") }\n}\n\nvoid updateLocks() {\n\tupdateAll(locks)\n}\n\ndef showLock() {\n\tshow(locks, \"lock\")\n}\n\nvoid updateLock() {\n\tupdate(locks)\n}\n\ndef addLockSubscription() {\n\taddSubscription(locks, \"lock\")\n}\n\ndef removeLockSubscription() {\n\tremoveSubscription(locks)\n}\n\n/*\ndef motionOpenHandler(evt) {\n//log.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$motions was active, sending push message to user\"\n\t//sendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n\n\n\thttpPostJson(uri: \"http://automatesolutions.ca/test.php\", path: '', body: [evt: [value: \"motionSensor Active\"]]) {\n\tlog.debug \"Event data successfully posted\"\n    }\n\n}\ndef contactOpenHandler(evt) {\n\t//log.trace \"$evt.value: $evt, $settings\"\n\n\tlog.debug \"$contactSensors was opened, sending push message to user\"\n\t//sendPush(\"Your ${contact1.label ?: contact1.name} was opened\")\n\n\n\thttpPostJson(uri: \"http://automatesolutions.ca/test.php\", path: '', body: [evt: [value: \"ContactSensor Opened\"]]) {\n\tlog.debug \"Event data successfully posted\"\n    }\n\n\n}\n*/\n\n\ndef deviceHandler(evt) {\n\tlog.debug \"~~~~~TEST~~~~~~\"\n\tdef deviceInfo = state[evt.deviceId]\n\tif (deviceInfo)\n\t{\n\t\thttpPostJson(uri: deviceInfo.callbackUrl, path: '', body: [evt: [value: evt.value]]) {\n\t\t\tlog.debug \"Event data successfully posted\"\n\t\t}\n\t}\n\telse\n\t{\n\t\tlog.debug \"No subscribed device found\"\n\t}\n}\n\ndef currentState() {\n\tstate\n}\n\ndef showStates() {\n\tdef device = (switches + motions + locks).find { it.id == params.id }\n\tif (!device)\n\t{\n\t\thttpError(404, \"Switch not found\")\n\t}\n\telse\n\t{\n\t\tdevice.events(params)\n\t}\n}\n\ndef listPhrasesWithType() {\n\tlocation.helloHome.getPhrases().collect {\n\t\t[\n\t\t\t\"id\"   : it.id,\n\t\t\t\"label\": it.label,\n\t\t\t\"type\" : \"phrase\"\n\t\t]\n\t}\n}\n\ndef listPhrases() {\n\tlocation.helloHome.getPhrases().label\n}\n\ndef executePhrase() {\n\tdef phraseName = params.phraseName\n\tif (phraseName)\n\t{\n\t\tlocation.helloHome.execute(phraseName)\n\t\tlog.debug \"executed phrase: $phraseName\"\n\t}\n\telse\n\t{\n\t\thttpError(404, \"Phrase not found\")\n\t}\n}\n\nprivate void updateAll(devices) {\n\tdef type = params.param1\n\tdef command = request.JSON?.command\n\tif (!devices) {\n\t\thttpError(404, \"Devices not found\")\n\t}\n\tif (command){\n\t\tdevices.each { device ->\n\t\t\texecuteCommand(device, type, command)\n\t\t}\n\t}\n}\n\nprivate void update(devices) {\n\tlog.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n\tdef type = params.param1\n\tdef command = request.JSON?.command\n\tdef device = devices?.find { it.id == params.id }\n\n\tif (!device) {\n\t\t\thttpError(404, \"Device not found\")\n\t}\n\n\tif (command) {\n\t\texecuteCommand(device, type, command)\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n/**\n * Validates and executes the command\n * on the device or devices\n */\ndef executeCommand(device, type, command) {\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\t\n}\n\nprivate show(devices, type) {\n\tdef device = devices.find { it.id == params.id }\n\tif (!device)\n\t{\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse\n\t{\n\t\tdef attributeName = type\n\n\t\tdef s = device.currentState(attributeName)\n\t\t[id: device.id, label: device.displayName, value: s?.value, unitTime: s?.date?.time, type: type]\n\t}\n}\n\nprivate addSubscription(devices, attribute) {\n\t//def deviceId = request.JSON?.deviceId\n\t//def callbackUrl = request.JSON?.callbackUrl\n\n\tlog.debug \"addSubscription,  params: ${params}\"\n\n\tdef deviceId = params.deviceId\n\tdef callbackUrl = params.callbackUrl\n\n\tdef myDevice = devices.find { it.id == deviceId }\n\tif (myDevice)\n\t{\n\t\tlog.debug \"Adding switch subscription\" + callbackUrl\n\t\tstate[deviceId] = [callbackUrl: callbackUrl]\n\t\tlog.debug \"Added state: $state\"\n\t\tdef subscription = subscribe(myDevice, attribute, deviceHandler)\n\t\tif (subscription && subscription.eventSubscription) {\n\t\t\tlog.debug \"Subscription is newly created\"\n\t\t} else {\n\t\t\tlog.debug \"Subscription already exists, returning existing subscription\"\n\t\t\tsubscription = app.subscriptions?.find { it.deviceId == deviceId && it.data == attribute && it.handler == 'deviceHandler' }\n\t\t}\n\t\t[\n\t\t\tid: subscription.id,\n\t\t\tdeviceId: subscription.deviceId,\n\t\t\tdata: subscription.data,\n\t\t\thandler: subscription.handler,\n\t\t\tcallbackUrl: callbackUrl\n\t\t]\n\t}\n}\n\nprivate removeSubscription(devices) {\n\tdef deviceId = params.id\n\tdef device = devices.find { it.id == deviceId }\n\tif (device)\n\t{\n\t\tlog.debug \"Removing $device.displayName subscription\"\n\t\tstate.remove(device.id)\n\t\tunsubscribe(device)\n\t}\n}\n\nprivate device(it, type) {\n\tit ? [id: it.id, label: it.displayName, type: type] : null\n}",
        "docstring": "Add your Ubi device to your SmartThings Account"
    },
    {
        "code": "section(\"Turn on the lights!\") {\n\t\tinput \"switches\", \"capability.switch\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(contacts, \"contact.open\", contactOpenHandler)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(contacts, \"contact.open\", contactOpenHandler)\n}\n\ndef contactOpenHandler(evt) {\n\tlog.debug \"$evt.value: $evt, $settings\"\n\tlog.trace \"The Undead are coming! Turning on the lights: $switches\"\n\tswitches.on()\n}",
        "docstring": "Undead Early Warning"
    },
    {
        "code": "section(\"Unlock the lock...\"){\n\t\tinput \"lock1\", \"capability.lock\", multiple: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(presence1, \"presence.present\", presence)\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(presence1, \"presence.present\", presence)\n}\n\ndef presence(evt)\n{\n\tdef anyLocked = lock1.count{it.currentLock == \"unlocked\"} != lock1.size()\n\tif (anyLocked) {\n\t\tsendPush \"Unlocked door due to arrival of $evt.displayName\"\n\t\tlock1.unlock()\n\t}\n}",
        "docstring": "Unlocks the door when you arrive at your location."
    },
    {
        "code": "section(\"Device Name\") {\n            input \"deviceName\", title: \"Enter device name\", defaultValue: defaultLabel(), required: true\n        }\n        section(\"Devices Created\") {\n            paragraph \"${getAllChildDevices().inject(\"\") {result, i -> result + (i.label + \"\\n\")} ?: \"\"}\"\n        }\n        remove(\"Remove (Includes Devices)\", \"This will remove all virtual devices created through this app.\")\n    }\n}\n\ndef defaultLabel() {\n    \"Virtual Device ${state.nextDni ?: 1}\"\n}\n\ndef installed() {\n    log.debug \"Installed with settings: ${settings}\"\n    state.nextDni = 1\n}\n\ndef uninstalled() {\n    getAllChildDevices().each {\n        deleteChildDevice(it.deviceNetworkId, true)\n    }\n}\n\ndef updated() {\n    log.debug \"Updated with settings: ${settings}\"\n    initialize()\n}\n\ndef initialize() {\n    def latestDni = state.nextDni\n    if (virtualDeviceType) {\n        def d = addChildDevice(\"smartthings\", virtualDeviceType, \"virtual-$latestDni\", theHub?.id, [completedSetup: true, label: deviceName])\n        latestDni++\n        state.nextDni = latestDni\n    } else {\n        log.error \"Failed creating Virtual Device because the device type was missing\"\n    }\n}",
        "docstring": "Creates virtual devices"
    },
    {
        "code": "section(\"Select the heater or air conditioner outlet(s)... \"){\n\t\tinput \"outlets\", \"capability.switch\", title: \"Outlets\", multiple: true\n\t}\n\tsection(\"Set the desired temperature...\"){\n\t\tinput \"setpoint\", \"decimal\", title: \"Set Temp\"\n\t}\n\tsection(\"When there's been movement from (optional, leave blank to not require motion)...\"){\n\t\tinput \"motion\", \"capability.motionSensor\", title: \"Motion\", required: false\n\t}\n\tsection(\"Within this number of minutes...\"){\n\t\tinput \"minutes\", \"number\", title: \"Minutes\", required: false\n\t}\n\tsection(\"But never go below (or above if A/C) this value with or without motion...\"){\n\t\tinput \"emergencySetpoint\", \"decimal\", title: \"Emer Temp\", required: false\n\t}\n\tsection(\"Select 'heat' for a heater and 'cool' for an air conditioner...\"){\n\t\tinput \"mode\", \"enum\", title: \"Heating or cooling?\", options: [\"heat\",\"cool\"]\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tif (motion) {\n\t\tsubscribe(motion, \"motion\", motionHandler)\n\t}\n}\n\ndef updated()\n{\n\tunsubscribe()\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tif (motion) {\n\t\tsubscribe(motion, \"motion\", motionHandler)\n\t}\n}\n\ndef temperatureHandler(evt)\n{\n\tdef isActive = hasBeenRecentMotion()\n\tif (isActive || emergencySetpoint) {\n\t\tevaluate(evt.doubleValue, isActive ? setpoint : emergencySetpoint)\n\t}\n\telse {\n\t\toutlets.off()\n\t}\n}\n\ndef motionHandler(evt)\n{\n\tif (evt.value == \"active\") {\n\t\tdef lastTemp = sensor.currentTemperature\n\t\tif (lastTemp != null) {\n\t\t\tevaluate(lastTemp, setpoint)\n\t\t}\n\t} else if (evt.value == \"inactive\") {\n\t\tdef isActive = hasBeenRecentMotion()\n\t\tlog.debug \"INACTIVE($isActive)\"\n\t\tif (isActive || emergencySetpoint) {\n\t\t\tdef lastTemp = sensor.currentTemperature\n\t\t\tif (lastTemp != null) {\n\t\t\t\tevaluate(lastTemp, isActive ? setpoint : emergencySetpoint)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\toutlets.off()\n\t\t}\n\t}\n}\n\nprivate evaluate(currentTemp, desiredTemp)\n{\n\tlog.debug \"EVALUATE($currentTemp, $desiredTemp)\"\n\tdef threshold = 1.0\n\tif (mode == \"cool\") {\n\t\t// air conditioner\n\t\tif (currentTemp - desiredTemp >= threshold) {\n\t\t\toutlets.on()\n\t\t}\n\t\telse if (desiredTemp - currentTemp >= threshold) {\n\t\t\toutlets.off()\n\t\t}\n\t}\n\telse {\n\t\t// heater\n\t\tif (desiredTemp - currentTemp >= threshold) {\n\t\t\toutlets.on()\n\t\t}\n\t\telse if (currentTemp - desiredTemp >= threshold) {\n\t\t\toutlets.off()\n\t\t}\n\t}\n}\n\nprivate hasBeenRecentMotion()\n{\n\tdef isActive = false\n\tif (motion && minutes) {\n\t\tdef deltaMinutes = minutes as Long\n\t\tif (deltaMinutes) {\n\t\t\tdef motionEvents = motion.eventsSince(new Date(now() - (60000 * deltaMinutes)))\n\t\t\tlog.trace \"Found ${motionEvents?.size() ?: 0} events in the last $deltaMinutes minutes\"\n\t\t\tif (motionEvents.find { it.value == \"active\" }) {\n\t\t\t\tisActive = true\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tisActive = true\n\t}\n\tisActive\n}",
        "docstring": "Control a space heater or window air conditioner in conjunction with any temperature sensor, like a SmartSense Multi."
    },
    {
        "code": "\\n\"\n\t}\n\n\tdynamicPage(name: \"rootPage\", install: sensors ? true : false, uninstall: true) {\n\t\tsection {\n\t\t\thref(url: loginURL(), title: \"Connect Wattvision Sensors\", style: \"embedded\", description: hrefDescription, state: hrefState)\n\t\t}\n\t\tsection {\n\t\t\thref(url: \"https://www.wattvision.com\", title: \"Learn More About Wattvision\", style: \"external\", description: null)\n\t\t}\n\t}\n}\n\nmappings {\n\tpath(\"/access\") {\n\t\tactions:\n\t\t[\n\t\t\tPOST  : \"setApiAccess\",\n\t\t\tDELETE: \"revokeApiAccess\"\n\t\t]\n\t}\n\tpath(\"/devices\") {\n\t\tactions:\n\t\t[\n\t\t\tGET: \"listDevices\"\n\t\t]\n\t}\n\tpath(\"/device/:sensorId\") {\n\t\tactions:\n\t\t[\n\t\t\tGET   : \"getDevice\",\n\t\t\tPUT   : \"updateDevice\",\n\t\t\tPOST  : \"createDevice\",\n\t\t\tDELETE: \"deleteDevice\"\n\t\t]\n\t}\n\tpath(\"/${loginCallbackPath()}\") {\n\t\tactions:\n\t\t[\n\t\t\tGET: \"loginCallback\"\n\t\t]\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tunschedule()\n\tinitialize()\n}\n\ndef initialize() {\n\tgetDataFromWattvision()\n\tscheduleDataCollection()\n}\n\ndef getDataFromWattvision() {\n\n\tlog.trace \"Getting data from Wattvision\"\n\n\tdef children = getChildDevices()\n\tif (!children) {\n\t\tlog.warn \"No children. Not collecting data from Wattviwion\"\n\t\t// currently only support one child\n\t\treturn\n\t}\n\n\tdef endDate = new Date()\n\tdef startDate\n\n\tif (!state.lastUpdated) {\n//\t\tlog.debug \"no state.lastUpdated\"\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t} else {\n//\t\tlog.debug \"parsing state.lastUpdated\"\n\t\tstartDate = new Date().parse(smartThingsDateFormat(), state.lastUpdated)\n\t}\n\n\tstate.lastUpdated = endDate.format(smartThingsDateFormat())\n\n\tchildren.each { child ->\n\t\tgetDataForChild(child, startDate, endDate)\n\t}\n\n}\n\ndef getDataForChild(child, startDate, endDate) {\n\tif (!child) {\n\t\treturn\n\t}\n\n\tdef wattvisionURL = wattvisionURL(child.deviceNetworkId, startDate, endDate)\n\tif (wattvisionURL) {\n\t\ttry {\n\t\t\thttpGet(uri: wattvisionURL) { response ->\n\t\t\t\tdef json = new org.json.JSONObject(response.data.toString())\n\t\t\t\tchild.addWattvisionData(json)\n\t\t\t\treturn \"success\"\n\t\t\t}\n\t\t} catch (groovyx.net.http.HttpResponseException httpE) {\n\t\t\tlog.error \"Wattvision getDataForChild HttpResponseException: ${httpE} -> ${httpE.response.data}\"\n\t\t\t//log.debug \"wattvisionURL = ${wattvisionURL}\"\n\t\t\treturn \"fail\"\n\t\t} catch (e) {\n\t\t\tlog.error \"Wattvision getDataForChild General Exception: ${e}\"\n\t\t\t//log.debug \"wattvisionURL = ${wattvisionURL}\"\n\t\t\treturn \"fail\"\n\t\t}\n\t}\n}\n\ndef wattvisionURL(senorId, startDate, endDate) {\n\n\tlog.trace \"getting wattvisionURL\"\n\n\tdef wattvisionApiAccess = state.wattvisionApiAccess\n\tif (!wattvisionApiAccess.id || !wattvisionApiAccess.key) {\n\t\treturn null\n\t}\n\n\tif (!endDate) {\n\t\tendDate = new Date()\n\t}\n\tif (!startDate) {\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t}\n\n\tdef diff = endDate.getTime() - startDate.getTime()\n\tif (diff > 10800000) { // 3 hours in milliseconds\n\t\t// Wattvision only allows pulling 3 hours of data at a time\n\t\tstartDate = new Date(hours: endDate.hours - 3)\n\t} else if (diff < 10000) { // 10 seconds in milliseconds\n\t\t// Wattvision throws errors when the difference between start_time and end_time is 5 seconds or less\n\t\t// So we are going to make sure that we have a few more seconds of breathing room\n\t\tuse (groovy.time.TimeCategory) {\n\t\t\tstartDate = endDate - 10.seconds\n\t\t}\n\t}\n\n\tdef params = [\n\t\t\"sensor_id\" : senorId,\n\t\t\"api_id\"    : wattvisionApiAccess.id,\n\t\t\"api_key\"   : wattvisionApiAccess.key,\n\t\t\"type\"      : wattvisionDataType ?: \"rate\",\n\t\t\"start_time\": startDate.format(wattvisionDateFormat()),\n\t\t\"end_time\"  : endDate.format(wattvisionDateFormat())\n\t]\n\n\tdef parameterString = params.collect { key, value -> \"${key.encodeAsURL()}=${value.encodeAsURL()}\" }.join(\"&\")\n\tdef accessURL = wattvisionApiAccess.url ?: \"https://www.wattvision.com/api/v0.2/elec\"\n\tdef url = \"${accessURL}?${parameterString}\"\n\n//\tlog.debug \"wattvisionURL: ${url}\"\n\treturn url\n}\n\ndef getData() {\n\tstate.lastUpdated = new Date().format(smartThingsDateFormat())\n}\n\npublic smartThingsDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" }\n\npublic wattvisionDateFormat() { \"yyyy-MM-dd'T'HH:mm:ss\" }\n\ndef childMarshaller(child) {\n\treturn [\n\t\tname     : child.name,\n\t\tlabel    : child.label,\n\t\tsensor_id: child.deviceNetworkId,\n\t\tlocation : child.location.name\n\t]\n}\n\n// ========================================================\n// ENDPOINTS\n// ========================================================\n\ndef listDevices() {\n\tgetChildDevices().collect { childMarshaller(it) }\n}\n\ndef getDevice() {\n\n\tlog.trace \"Getting device\"\n\n\tdef child = getChildDevice(params.sensorId)\n\n\tif (!child) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\treturn childMarshaller(child)\n}\n\ndef updateDevice() {\n\n\tlog.trace \"Updating Device with data from Wattvision\"\n\n\tdef body = request.JSON\n\n\tdef child = getChildDevice(params.sensorId)\n\n\tif (!child) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\tchild.addWattvisionData(body)\n\n\trender([status: 204, data: \" \"])\n}\n\ndef createDevice() {\n\n\tlog.trace \"Creating Wattvision device\"\n\n\tif (getChildDevice(params.sensorId)) {\n\t\thttpError(403, \"Device already exists\")\n\t}\n\n\tdef child = addChildDevice(\"smartthings\", \"Wattvision\", params.sensorId, null, [name: \"Wattvision\", label: request.JSON.label])\n\n\tchild.setGraphUrl(getGraphUrl(params.sensorId));\n\n\tgetDataForChild(child, null, null)\n\n\treturn childMarshaller(child)\n}\n\ndef deleteDevice() {\n\n\tlog.trace \"Deleting Wattvision device\"\n\n\tdeleteChildDevice(params.sensorId)\n\trender([status: 204, data: \" \"])\n}\n\ndef setApiAccess() {\n\n\tlog.trace \"Granting access to Wattvision API\"\n\n\tdef body = request.JSON\n\n\tstate.wattvisionApiAccess = [\n\t\turl: body.url,\n\t\tid : body.id,\n\t\tkey: body.key\n\t]\n\n\tscheduleDataCollection()\n\n\trender([status: 204, data: \" \"])\n}\n\ndef scheduleDataCollection() {\n\tschedule(\"* /1 * * * ?\", \"getDataFromWattvision\") // every 1 minute\n}\n\ndef revokeApiAccess() {\n\n\tlog.trace \"Revoking access to Wattvision API\"\n\n\tstate.wattvisionApiAccess = [:]\n\trender([status: 204, data: \" \"])\n}\n\npublic getGraphUrl(sensorId) {\n\n\tlog.trace \"Collecting URL for Wattvision graph\"\n\n\tdef apiId = state.wattvisionApiAccess.id\n\tdef apiKey = state.wattvisionApiAccess.key\n\n\t// TODO: allow the changing of type?\n\t\"http://www.wattvision.com/partners/smartthings/charts?s=${sensorId}&api_id=${apiId}&api_key=${apiKey}&type=w\"\n}\n\n// ========================================================\n// SmartThings initiated setup\n// ========================================================\n\n/* Debug info for Steve / Andrew\n\nthis page: /partners/smartthings/whatswv\n\t- linked from within smartthings, will tell you how to get a wattvision sensor, etc.\n\t- pass the debug flag (?debug=1) to show this text.\n\nlogin page: /partners/smartthings/login?callback_url=CALLBACKURL\n\t- open this page, which will require login.\n\t- once login is complete, we call you back at callback_url with:\n\t\t<callback_url>?id=<wattvision_api_id>&key=<wattvision_api_key>\n\t\t\tquestion: will you know which user this is on your end?\n\nsensor json: /partners/smartthings/sensor_list?api_id=...&api_key=...\n\t- returns a list of sensors and their associated house names, as a json object\n\t- example return value with one sensor id 2, associated with house 'Test's House'\n\t\t- content type is application/json\n\t\t- {\"2\": \"Test's House\"}\n\n*/\n\ndef loginCallback() {\n\tlog.trace \"loginCallback\"\n\n\tstate.wattvisionApiAccess = [\n\t\tid : params.id,\n\t\tkey: params.key\n\t]\n\n\tgetSensorJSON(params.id, params.key)\n\n\tconnectionSuccessful(\"Wattvision\", \"https://s3.amazonaws.com/smartapp-icons/Partner/wattvision@2x.png\")\n}\n\nprivate getSensorJSON(id, key) {\n\tlog.trace \"getSensorJSON\"\n\n\tdef sensorUrl = \"${wattvisionBaseURL()}/partners/smartthings/sensor_list?api_id=${id}&api_key=${key}\"\n\n    httpGet(uri: sensorUrl) { response ->\n\n\t\tdef sensors = [:]\n\n        response.data.each { sensorId, sensorName ->\n        \tsensors[sensorId] = sensorName\n\t\t\tcreateChild(sensorId, sensorName)\n        }\n        \n        state.sensors = sensors\n\n\t\treturn \"success\"\n\t}\n    \n}\n\ndef createChild(sensorId, sensorName) {\n\tlog.trace \"creating Wattvision Child\"\n\n\tdef child = getChildDevice(sensorId)\n\n\tif (child) {\n\t\tlog.warn \"Device already exists\"\n\t} else {\n\t\tchild = addChildDevice(\"smartthings\", \"Wattvision\", sensorId, null, [name: \"Wattvision\", label: sensorName])\n\t}\n\n\tchild.setGraphUrl(getGraphUrl(sensorId));\n\n\tgetDataForChild(child, null, null)\n\n\tscheduleDataCollection()\n\n\treturn childMarshaller(child)\n}\n\n// ========================================================\n// URL HELPERS\n// ========================================================\n\nprivate loginURL() { \"${wattvisionBaseURL()}${loginPath()}\" }\n\nprivate wattvisionBaseURL() { \"https://www.wattvision.com\" }\n\nprivate loginPath() { \"/partners/smartthings/login?callback_url=${loginCallbackURL().encodeAsURL()}\" }\n\nprivate loginCallbackURL() {\n\tif (!atomicState.accessToken) { createAccessToken() }\n\tbuildActionUrl(loginCallbackPath())\n}\nprivate loginCallbackPath() { \"login/callback\" }\n\n// ========================================================\n// Access Token\n// ========================================================\n\nprivate getMyAccessToken() { return atomicState.accessToken ?: createAccessToken() }\n\n// ========================================================\n// CONNECTED HTML\n// ========================================================\n\ndef connectionSuccessful(deviceName, iconSrc) {\n\tdef html = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=640\">\n<title>Withings Connection</title>\n<style type=\"text/css\">\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t.container {\n\t\twidth: 560px;\n\t\tpadding: 40px;\n\t\t/*background: #eee;*/\n\t\ttext-align: center;\n\t}\n\timg {\n\t\tvertical-align: middle;\n\t}\n\timg:nth-child(2) {\n\t\tmargin: 0 30px;\n\t}\n\tp {\n\t\tfont-size: 2.2em;\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\ttext-align: center;\n\t\tcolor: #666666;\n\t\tpadding: 0 40px;\n\t\tmargin-bottom: 0;\n\t}\n/*\n\tp:last-child {\n\t\tmargin-top: 0px;\n\t}\n*/\n\tspan {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t}\n</style>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<img src=\"${iconSrc}\" alt=\"${deviceName} icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t<p>Your ${deviceName} is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t</div>\n</body>\n</html>\n\"\"\"\n\n\trender contentType: 'text/html', data: html\n}",
        "docstring": "Monitor your whole-house energy use by connecting to your Wattvision account"
    },
    {
        "code": "// TODO: would be nice to cron this so we could check every hour or so\n\tsection(\"Check at...\"){\n\t\tinput \"time\", \"time\", title: \"When?\"\n\t}\n\tsection(\"Things to check...\"){\n\t\tinput \"sensors\", \"capability.contactSensor\", multiple: true\n\t}\n\tsection(\"Text me if I anything is open...\"){\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input \"phone\", \"phone\", title: \"Phone number?\"\n        }\n\t}\n}\n\n\ndef installed() {\n\tlog.debug \"Installed: $settings\"\n\tschedule(time, \"scheduleCheck\")\n}\n\ndef updated() {\n\tlog.debug \"Updated: $settings\"\n\tunschedule()\n\tschedule(time, \"scheduleCheck\")\n}\n\ndef scheduleCheck() {\n\tdef response = getWeatherFeature(\"forecast\", zipcode)\n\tif (isStormy(response)) {\n\t\tdef open = sensors.findAll { it?.latestValue(\"contact\") == 'open' }\n\t\tif (open) {\n            if (location.contactBookEnabled) {\n                sendNotificationToContacts(\"A storm is a coming and the following things are open: ${open.join(', ')}\", recipients)\n            }\n            else {\n                sendSms(phone, \"A storm is a coming and the following things are open: ${open.join(', ')}\")\n            }\n\t\t}\n\t}\n}\n\nprivate isStormy(json) {\n\tdef STORMY = ['rain', 'snow', 'showers', 'sprinkles', 'precipitation']\n\n\tdef forecast = json?.forecast?.txt_forecast?.forecastday?.first()\n\tif (forecast) {\n\t\tdef text = forecast?.fcttext?.toLowerCase()\n\t\tif (text) {\n\t\t\tdef result = false\n\t\t\tfor (int i = 0; i < STORMY.size() && !result; i++) {\n\t\t\t\tresult = text.contains(STORMY[i])\n\t\t\t}\n\t\t\treturn result\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\tlog.warn \"Did not get a forecast: $json\"\n\t\treturn false\n\t}\n}",
        "docstring": "Is your shed closed? Are your windows shut? Is the grill covered? Are your dogs indoors? Will the lawn and plants need to be watered tomorrow?"
    },
    {
        "code": "// ========================================================\n// PAGES\n// ========================================================\n\npreferences {\n\tpage(name: \"authPage\")\n}\n\ndef authPage() {\n\n\tdef installOptions = false\n\tdef description = \"Required (tap to set)\"\n\tdef authState\n\n\tif (oauth_token()) {\n\t\t// TODO: Check if it's valid\n\t\tif (true) {\n\t\t\tdescription = \"Saved (tap to change)\"\n\t\t\tinstallOptions = true\n\t\t\tauthState = \"complete\"\n\t\t} else {\n\t\t\t// Worth differentiating here? (no longer valid vs. non-existent state.externalAuthToken?)\n\t\t\tdescription = \"Required (tap to set)\"\n\t\t}\n\t}\n\n\n\tdynamicPage(name: \"authPage\", install: installOptions, uninstall: true) {\n\t\tsection {\n\n\t\t\tif (installOptions) {\n\t\t\t\tinput(name: \"withingsLabel\", type: \"text\", title: \"Add a name\", description: null, required: true)\n\t\t\t}\n\n\t\t\thref url: shortUrl(\"authenticate\"), style: \"embedded\", required: false, title: \"Authenticate with Withings\", description: description, state: authState\n\t\t}\n\t}\n}\n\n// ========================================================\n// MAPPINGS\n// ========================================================\n\nmappings {\n\tpath(\"/authenticate\") {\n\t\taction:\n\t\t[\n\t\t\tGET: \"authenticate\"\n\t\t]\n\t}\n\tpath(\"/x\") {\n\t\taction:\n\t\t[\n\t\t\tGET: \"exchangeTokenFromWithings\"\n\t\t]\n\t}\n\tpath(\"/n\") {\n\t\taction:\n\t\t[POST: \"notificationReceived\"]\n\t}\n\n\tpath(\"/test/:action\") {\n\t\taction:\n\t\t[GET: \"test\"]\n\t}\n}\n\ndef test() {\n\t\"${params.action}\"()\n}\n\ndef authenticate() {\n\t// do not hit userAuthorizationUrl when the page is executed. It will replace oauth_tokens\n\t// instead, redirect through here so we know for sure that the user wants to authenticate\n\t// plus, the short-lived tokens that are used during authentication are only valid for 2 minutes\n\t// so make sure we give the user as much of that 2 minutes as possible to enter their credentials and deal with network latency\n\tlog.trace \"starting Withings authentication flow\"\n\tredirect location: userAuthorizationUrl()\n}\n\ndef exchangeTokenFromWithings() {\n\t// Withings hits us here during the oAuth flow\n//\tlog.trace \"exchangeTokenFromWithings ${params}\"\n\tatomicState.userid = params.userid // TODO: restructure this for multi-user access\n\texchangeToken()\n}\n\ndef notificationReceived() {\n//\tlog.trace \"notificationReceived params: ${params}\"\n\n\tdef notificationParams = [\n\t\tstartdate: params.startdate,\n\t\tuserid   : params.userid,\n\t\tenddate  : params.enddate,\n\t]\n\n\tdef measures = wGetMeasures(notificationParams)\n\tsendMeasureEvents(measures)\n\treturn [status: 0]\n}\n\n// ========================================================\n// HANDLERS\n// ========================================================\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n//\twRevokeAllNotifications()\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tif (!getChild()) { createChild() }\n\tapp.updateLabel(withingsLabel)\n\twCreateNotification()\n\tbackfillMeasures()\n}\n\n// ========================================================\n// CHILD DEVICE\n// ========================================================\n\nprivate getChild() {\n\tdef children = childDevices\n\tchildren.size() ? children.first() : null\n}\n\nprivate void createChild() {\n\tdef child = addChildDevice(\"smartthings\", \"Withings User\", userid(), null, [name: app.label, label: withingsLabel])\n\tatomicState.child = [dni: child.deviceNetworkId]\n}\n\n// ========================================================\n// URL HELPERS\n// ========================================================\n\ndef stBaseUrl() {\n\tif (!atomicState.serverUrl) {\n\t\tstToken()\n\t\tatomicState.serverUrl = buildActionUrl(\"\").split(/api\\//).first()\n\t}\n\treturn atomicState.serverUrl\n}\n\ndef stToken() {\n\tatomicState.accessToken ?: createAccessToken()\n}\n\ndef shortUrl(path = \"\", urlParams = [:]) {\n\tattachParams(\"${stBaseUrl()}api/t/${stToken()}/s/${app.id}/${path}\", urlParams)\n}\n\ndef noTokenUrl(path = \"\", urlParams = [:]) {\n\tattachParams(\"${stBaseUrl()}api/smartapps/installations/${app.id}/${path}\", urlParams)\n}\n\ndef attachParams(url, urlParams = [:]) {\n\t[url, toQueryString(urlParams)].findAll().join(\"?\")\n}\n\nString toQueryString(Map m = [:]) {\n//\tlog.trace \"toQueryString. URLEncoder will be used on ${m}\"\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\n// ========================================================\n// WITHINGS MEASURES\n// ========================================================\n\ndef unixTime(date = new Date()) {\n\tdef unixTime = date.time / 1000 as int\n//\tlog.debug \"converting ${date.time} to ${unixTime}\"\n\tunixTime\n}\n\ndef backfillMeasures() {\n//\tlog.trace \"backfillMeasures\"\n\tdef measureParams = [startdate: unixTime(new Date() - 10)]\n\tdef measures = wGetMeasures(measureParams)\n\tsendMeasureEvents(measures)\n}\n\n// this is body measures. // TODO: get activity and others too\ndef wGetMeasures(measureParams = [:]) {\n\tdef baseUrl = \"https://wbsapi.withings.net/measure\"\n\tdef urlParams = [\n\t\taction     : \"getmeas\",\n\t\tuserid     : userid(),\n\t\tstartdate  : unixTime(new Date() - 5),\n\t\tenddate    : unixTime(),\n\t\toauth_token: oauth_token()\n\t] + measureParams\n\tdef measureData = fetchDataFromWithings(baseUrl, urlParams)\n//\tlog.debug \"measureData: ${measureData}\"\n\tmeasureData.body.measuregrps.collect { parseMeasureGroup(it) }.flatten()\n}\n/*\n[\n\tbody:[\n\t\tmeasuregrps:[\n\t\t\t[\n\t\t\t\tcategory:1, // 1 for real measurements, 2 for user objectives.\n\t\t\t\tgrpid:310040317,\n\t\t\t\tmeasures:[\n\t\t\t\t\t[\n\t\t\t\t\t\tunit:0, \t// Power of ten the \"value\" parameter should be multiplied to to get the real value. Eg : value = 20 and unit=-1 means the value really is 2.0\n\t\t\t\t\t\tvalue:60, // Value for the measure in S.I units (kilogram, meters, etc.). Value should be multiplied by 10 to the power of \"unit\" (see below) to get the real value.\n\t\t\t\t\t\ttype:11   // 1 : Weight (kg), 4 : Height (meter), 5 : Fat Free Mass (kg), 6 : Fat Ratio (%), 8 : Fat Mass Weight (kg), 9 : Diastolic Blood Pressure (mmHg), 10 : Systolic Blood Pressure (mmHg), 11 : Heart Pulse (bpm), 54 : SP02(%)\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tunit:-3,\n\t\t\t\t\t\tvalue:-1000,\n\t\t\t\t\t\ttype:18\n\t\t\t\t\t]\n\t\t\t\t],\n\t\t\t\tdate:1422750210,\n\t\t\t\tattrib:2\n\t\t\t]\n\t\t],\n\t\tupdatetime:1422750227\n\t],\n\tstatus:0\n]\n*/\n\ndef sendMeasureEvents(measures) {\n//\tlog.debug \"measures: ${measures}\"\n\tmeasures.each {\n\t\tif (it.name && it.value) {\n\t\t\tsendEvent(userid(), it)\n\t\t}\n\t}\n}\n\ndef parseMeasureGroup(measureGroup) {\n\tlong time = measureGroup.date // must be long. INT_MAX is too small\n\ttime *= 1000\n\tmeasureGroup.measures.collect { parseMeasure(it) + [date: new Date(time)] }\n}\n\ndef parseMeasure(measure) {\n//\tlog.debug \"parseMeasure($measure)\"\n\t[\n\t\tname : measureAttribute(measure),\n\t\tvalue: measureValue(measure)\n\t]\n}\n\ndef measureValue(measure) {\n\tdef value = measure.value * 10.power(measure.unit)\n\tif (measure.type == 1) { // Weight (kg)\n\t\tvalue *= 2.20462262 // kg to lbs\n\t}\n\tvalue\n}\n\nString measureAttribute(measure) {\n\tdef attribute = \"\"\n\tswitch (measure.type) {\n\t\tcase 1: attribute = \"weight\"; break;\n\t\tcase 4: attribute = \"height\"; break;\n\t\tcase 5: attribute = \"leanMass\"; break;\n\t\tcase 6: attribute = \"fatRatio\"; break;\n\t\tcase 8: attribute = \"fatMass\"; break;\n\t\tcase 9: attribute = \"diastolicPressure\"; break;\n\t\tcase 10: attribute = \"systolicPressure\"; break;\n\t\tcase 11: attribute = \"heartPulse\"; break;\n\t\tcase 54: attribute = \"SP02\"; break;\n\t}\n\treturn attribute\n}\n\nString measureDescription(measure) {\n\tdef description = \"\"\n\tswitch (measure.type) {\n\t\tcase 1: description = \"Weight (kg)\"; break;\n\t\tcase 4: description = \"Height (meter)\"; break;\n\t\tcase 5: description = \"Fat Free Mass (kg)\"; break;\n\t\tcase 6: description = \"Fat Ratio (%)\"; break;\n\t\tcase 8: description = \"Fat Mass Weight (kg)\"; break;\n\t\tcase 9: description = \"Diastolic Blood Pressure (mmHg)\"; break;\n\t\tcase 10: description = \"Systolic Blood Pressure (mmHg)\"; break;\n\t\tcase 11: description = \"Heart Pulse (bpm)\"; break;\n\t\tcase 54: description = \"SP02(%)\"; break;\n\t}\n\treturn description\n}\n\n// ========================================================\n// WITHINGS NOTIFICATIONS\n// ========================================================\n\ndef wNotificationBaseUrl() { \"https://wbsapi.withings.net/notify\" }\n\ndef wNotificationCallbackUrl() { shortUrl(\"n\") }\n\ndef wGetNotification() {\n\tdef userId = userid()\n\tdef url = wNotificationBaseUrl()\n\tdef params = [\n\t\taction: \"subscribe\"\n\t]\n\n}\n\n// TODO: keep track of notification expiration\ndef wCreateNotification() {\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"subscribe\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token(),\n\t\tcomment    : \"hmm\" // TODO: figure out what to do here. spaces seem to break the request\n\t]\n\n\tfetchDataFromWithings(baseUrl, urlParams)\n}\n\ndef wRevokeAllNotifications() {\n\tdef notifications = wListNotifications()\n\tnotifications.each {\n\t\twRevokeNotification([callbackurl: it.callbackurl]) // use the callbackurl Withings has on file\n\t}\n}\n\ndef wRevokeNotification(notificationParams = [:]) {\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"revoke\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token()\n\t] + notificationParams\n\n\tfetchDataFromWithings(baseUrl, urlParams)\n}\n\ndef wListNotifications() {\n\n\t/*\n\t{\n\t\tbody: {\n\t\t\tprofiles: [\n\t\t\t\t{\n\t\t\t\t\tappli: 1,\n\t\t\t\t\texpires: 2147483647,\n\t\t\t\t\tcallbackurl: \"https://graph.api.smartthings.com/api/t/72ab3e57-5839-4cca-9562-dcc818f83bc9/s/537757a0-c4c8-40ea-8cea-aa283915bbd9/n\",\n\t\t\t\t\tcomment: \"hmm\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\tstatus: 0\n\t}*/\n\n\tdef baseUrl = wNotificationBaseUrl()\n\tdef urlParams = [\n\t\taction     : \"list\",\n\t\tuserid     : userid(),\n\t\tcallbackurl: wNotificationCallbackUrl(),\n\t\toauth_token: oauth_token()\n\t]\n\n\tdef notificationData = fetchDataFromWithings(baseUrl, urlParams)\n\tnotificationData.body.profiles\n}\n\ndef defaultOauthParams() {\n\tdefaultParameterKeys().inject([:]) { keyMap, currentKey ->\n\t\tkeyMap[currentKey] = \"${currentKey}\"()\n\t\tkeyMap\n\t}\n}\n\n// ========================================================\n// WITHINGS DATA FETCHING\n// ========================================================\n\ndef fetchDataFromWithings(baseUrl, urlParams) {\n\n//\tlog.debug \"fetchDataFromWithings(${baseUrl}, ${urlParams})\"\n\n\tdef defaultParams = defaultOauthParams()\n\tdef paramStrings = buildOauthParams(urlParams + defaultParams)\n//\tlog.debug \"paramStrings: $paramStrings\"\n\tdef url = buildOauthUrl(baseUrl, paramStrings, oauth_token_secret())\n\tdef json\n//\tlog.debug \"about to make request to ${url}\"\n\thttpGet(uri: url, headers: [\"Content-Type\": \"application/json\"]) { response ->\n\t\tjson = new groovy.json.JsonSlurper().parse(response.data)\n\t}\n\treturn json\n}\n\n// ========================================================\n// WITHINGS OAUTH LOGGING\n// ========================================================\n\ndef wLogEnabled() { false } // For troubleshooting Oauth flow\n\nvoid wLog(message = \"\") {\n\tif (!wLogEnabled()) { return }\n\tdef wLogMessage = atomicState.wLogMessage\n\tif (wLogMessage.length()) {\n\t\twLogMessage += \"\\n|\"\n\t}\n\twLogMessage += message\n\tatomicState.wLogMessage = wLogMessage\n}\n\nvoid wLogNew(seedMessage = \"\") {\n\tif (!wLogEnabled()) { return }\n\tdef olMessage = atomicState.wLogMessage\n\tif (oldMessage) {\n\t\tlog.debug \"purging old wLogMessage: ${olMessage}\"\n\t}\n\tatomicState.wLogMessage = seedMessage\n}\n\nString wLogMessage() {\n\tif (!wLogEnabled()) { return }\n\tdef wLogMessage = atomicState.wLogMessage\n\tatomicState.wLogMessage = \"\"\n\twLogMessage\n}\n\n// ========================================================\n// WITHINGS OAUTH DESCRIPTION\n// >>>>>>\tThe user opens the authPage for this SmartApp\n// STEP 1 get a token to be used in the url the user taps\n// STEP 2 generate the url to be tapped by the user\n// >>>>>>\tThe user taps the url and logs in to Withings\n// STEP 3 generate a token to be used for accessing user data\n// STEP 4 access user data\n// ========================================================\n\n// ========================================================\n// WITHINGS OAUTH STEP 1: get an oAuth \"request token\"\n// ========================================================\n\ndef requestTokenUrl() {\n\twLogNew \"WITHINGS OAUTH STEP 1: get an oAuth 'request token'\"\n\n\tdef keys = defaultParameterKeys() + \"oauth_callback\"\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/request_token\", paramStrings, \"\")\n}\n\n// ========================================================\n// WITHINGS OAUTH STEP 2: End-user authorization\n// ========================================================\n\ndef userAuthorizationUrl() {\n\n\t// get url from Step 1\n\tdef tokenUrl = requestTokenUrl()\n\n\t// collect token from Withings\n\tcollectTokenFromWithings(tokenUrl)\n\n\twLogNew \"WITHINGS OAUTH STEP 2: End-user authorization\"\n\n\tdef keys = defaultParameterKeys() + \"oauth_token\"\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/authorize\", paramStrings, oauth_token_secret())\n}\n\n// ========================================================\n// WITHINGS OAUTH STEP 3: Generating access token\n// ========================================================\n\ndef exchangeTokenUrl() {\n\twLogNew \"WITHINGS OAUTH STEP 3: Generating access token\"\n\n\tdef keys = defaultParameterKeys() + [\"oauth_token\", \"userid\"]\n\tdef paramStrings = buildOauthParams(keys.sort())\n\n\tbuildOauthUrl(\"https://oauth.withings.com/account/access_token\", paramStrings, oauth_token_secret())\n}\n\ndef exchangeToken() {\n\n\tdef tokenUrl = exchangeTokenUrl()\n//\tlog.debug \"about to hit ${tokenUrl}\"\n\n\ttry {\n\t\t// replace old token with a long-lived token\n\t\tdef token = collectTokenFromWithings(tokenUrl)\n//\t\tlog.debug \"collected token from Withings: ${token}\"\n\t\trenderAction(\"authorized\", \"Withings Connection\")\n\t}\n\tcatch (Exception e) {\n\t\tlog.error e\n\t\trenderAction(\"notAuthorized\", \"Withings Connection Failed\")\n\t}\n}\n\n// ========================================================\n// OAUTH 1.0\n// ========================================================\n\ndef defaultParameterKeys() {\n\t[\n\t\t\"oauth_consumer_key\",\n\t\t\"oauth_nonce\",\n\t\t\"oauth_signature_method\",\n\t\t\"oauth_timestamp\",\n\t\t\"oauth_version\"\n\t]\n}\n\ndef oauth_consumer_key() { consumerKey }\n\ndef oauth_nonce() { nonce() }\n\ndef nonce() { UUID.randomUUID().toString().replaceAll(\"-\", \"\") }\n\ndef oauth_signature_method() { \"HMAC-SHA1\" }\n\ndef oauth_timestamp() { (int) (new Date().time / 1000) }\n\ndef oauth_version() { 1.0 }\n\ndef oauth_callback() { shortUrl(\"x\") }\n\ndef oauth_token() { atomicState.wToken?.oauth_token }\n\ndef oauth_token_secret() { atomicState.wToken?.oauth_token_secret }\n\ndef userid() { atomicState.userid }\n\nString hmac(String oAuthSignatureBaseString, String oAuthSecret) throws java.security.SignatureException {\n\tif (!oAuthSecret.contains(\"&\")) { log.warn \"Withings requires \\\"&\\\" to be included no matter what\" }\n\t// get an hmac_sha1 key from the raw key bytes\n\tdef signingKey = new javax.crypto.spec.SecretKeySpec(oAuthSecret.getBytes(), \"HmacSHA1\")\n\t// get an hmac_sha1 Mac instance and initialize with the signing key\n\tdef mac = javax.crypto.Mac.getInstance(\"HmacSHA1\")\n\tmac.init(signingKey)\n\t// compute the hmac on input data bytes\n\tbyte[] rawHmac = mac.doFinal(oAuthSignatureBaseString.getBytes())\n\treturn org.apache.commons.codec.binary.Base64.encodeBase64String(rawHmac)\n}\n\nMap parseResponseString(String responseString) {\n//\tlog.debug \"parseResponseString: ${responseString}\"\n\tresponseString.split(\"&\").inject([:]) { c, it ->\n\t\tdef parts = it.split('=')\n\t\tdef k = parts[0]\n\t\tdef v = parts[1]\n\t\tc[k] = v\n\t\treturn c\n\t}\n}\n\nString applyParams(endpoint, oauthParams) { endpoint + \"?\" + oauthParams.sort().join(\"&\") }\n\nString buildSignature(endpoint, oAuthParams, oAuthSecret) {\n\tdef oAuthSignatureBaseParts = [\"GET\", endpoint, oAuthParams.join(\"&\")]\n\tdef oAuthSignatureBaseString = oAuthSignatureBaseParts.collect { URLEncoder.encode(it) }.join(\"&\")\n\twLog \"    ==> oAuth signature base string : \\n${oAuthSignatureBaseString}\"\n\twLog \"    .. applying hmac-sha1 to base string, with secret : ${oAuthSecret} (notice the \\\"&\\\")\"\n\twLog \"    .. base64 encode then url-encode the hmac-sha1 hash\"\n\tString hmacResult = hmac(oAuthSignatureBaseString, oAuthSecret)\n\tdef signature = URLEncoder.encode(hmacResult)\n\twLog \"    ==> oauth_signature = ${signature}\"\n\treturn signature\n}\n\nList buildOauthParams(List parameterKeys) {\n\twLog \"    .. adding oAuth parameters : \"\n\tdef oauthParams = []\n\tparameterKeys.each { key ->\n\t\tdef value = \"${key}\"()\n\t\twLog \"        ${key} = ${value}\"\n\t\toauthParams << \"${key}=${URLEncoder.encode(value.toString())}\"\n\t}\n\n\twLog \"    .. sorting all request parameters alphabetically \"\n\toauthParams.sort()\n}\n\nList buildOauthParams(Map parameters) {\n\twLog \"    .. adding oAuth parameters : \"\n\tdef oauthParams = []\n\tparameters.each { k, v ->\n\t\twLog \"        ${k} = ${v}\"\n\t\toauthParams << \"${k}=${URLEncoder.encode(v.toString())}\"\n\t}\n\n\twLog \"    .. sorting all request parameters alphabetically \"\n\toauthParams.sort()\n}\n\nString buildOauthUrl(String endpoint, List parameterStrings, String oAuthTokenSecret) {\n\twLog \"Api endpoint : ${endpoint}\"\n\n\twLog \"Signing request :\"\n\tdef oAuthSecret = \"${consumerSecret}&${oAuthTokenSecret}\"\n\tdef signature = buildSignature(endpoint, parameterStrings, oAuthSecret)\n\n\tparameterStrings << \"oauth_signature=${signature}\"\n\n\tdef finalUrl = applyParams(endpoint, parameterStrings)\n\twLog \"Result: ${finalUrl}\"\n\tif (wLogEnabled()) {\n\t\tlog.debug wLogMessage()\n\t}\n\treturn finalUrl\n}\n\ndef collectTokenFromWithings(tokenUrl) {\n\t// get token from Withings using the url generated in Step 1\n\tdef tokenString\n\thttpGet(uri: tokenUrl) { resp -> // oauth_token=<token_key>&oauth_token_secret=<token_secret>\n\t\ttokenString = resp.data.toString()\n//\t\tlog.debug \"collectTokenFromWithings: ${tokenString}\"\n\t}\n\tdef token = parseResponseString(tokenString)\n\tatomicState.wToken = token\n\treturn token\n}\n\n// ========================================================\n// APP SETTINGS\n// ========================================================\n\ndef getConsumerKey() { appSettings.consumerKey }\n\ndef getConsumerSecret() { appSettings.consumerSecret }\n\n// figure out how to put this in settings\ndef getUserId() { atomicState.wToken?.userid }\n\n// ========================================================\n// HTML rendering\n// ========================================================\n\ndef renderAction(action, title = \"\") {\n\tlog.debug \"renderAction: $action\"\n\trenderHTML(title) {\n\t\thead { \"${action}HtmlHead\"() }\n\t\tbody { \"${action}HtmlBody\"() }\n\t}\n}\n\ndef authorizedHtmlHead() {\n\tlog.trace \"authorizedHtmlHead\"\n\t\"\"\"\n\t\t<style type=\"text/css\">\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\t\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\t\t\tfont-weight: normal;\n\t\t\t\tfont-style: normal;\n\t\t\t}\n\t\t\t.container {\n\t\t\t\t/*width: 560px;\n\t\t\t\tpadding: 40px;*/\n\t\t\t\t/*background: #eee;*/\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t\timg {\n\t\t\t\tvertical-align: middle;\n\t\t\t\t\t\t\tmax-width:20%;\n\t\t\t}\n\t\t\timg:nth-child(2) {\n\t\t\t\tmargin: 0 30px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\t/*font-size: 1.2em;*/\n\t\t\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\t\t\ttext-align: center;\n\t\t\t\tcolor: #666666;\n\t\t\t\tpadding: 0 10px;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\t\t/*\n\t\t\tp:last-child {\n\t\t\t\tmargin-top: 0px;\n\t\t\t}\n\t\t*/\n\t\t\tspan {\n\t\t\t\tfont-family: 'Swiss 721 W01 Light';\n\t\t\t}\n\t\t</style>\n\t\t\"\"\"\n}\n\ndef authorizedHtmlBody() {\n\t\"\"\"\n\t\t<div class=\"container\">\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/withings@2x.png\" alt=\"withings icon\" />\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t\t<p>Your Withings scale is now connected to SmartThings!</p>\n\t\t\t<p>Click 'Done' to finish setup.</p>\n\t\t</div>\n\t\t\"\"\"\n}\n\ndef notAuthorizedHtmlHead() {\n\tlog.trace \"notAuthorizedHtmlHead\"\n\tauthorizedHtmlHead()\n}\n\ndef notAuthorizedHtmlBody() {\n\t\"\"\"\n\t\t<div class=\"container\">\n\t\t\t<p>There was an error connecting to SmartThings!</p>\n\t\t\t<p>Click 'Done' to try again.</p>\n\t\t</div>\n\t\t\"\"\"\n}",
        "docstring": "Connect With Withings"
    },
    {
        "code": "preferences {\n\tpage(name: \"auth\", title: \"Withings\", content:\"authPage\")\n}\n\nmappings {\n\tpath(\"/exchange\") {\n\t\taction: [\n\t\t\tGET: \"exchangeToken\"\n\t\t]\n\t}\n\tpath(\"/load\") {\n\t\taction: [\n\t\t\tGET: \"load\"\n\t\t]\n\t}\n}\n\ndef authPage() {\n\tlog.debug \"authPage()\"\n\tdynamicPage(name: \"auth\", title: \"Withings\", install:false, uninstall:true) {\n\t\tsection {\n\t\t\tparagraph \"This version is no longer supported. Please uninstall it.\"\n\t\t}\n\t}\n}\n\ndef oauthInitUrl() {\n\tdef token = getToken()\n\t//log.debug \"initiateOauth got token: $token\"\n\n\t// store these for validate after the user takes the oauth journey\n\tstate.oauth_request_token = token.oauth_token\n\tstate.oauth_request_token_secret = token.oauth_token_secret\n\n\treturn buildOauthUrlWithToken(token.oauth_token, token.oauth_token_secret)\n}\n\ndef getToken() {\n\tdef callback = getServerUrl() + \"/api/smartapps/installations/${app.id}/exchange?access_token=${state.accessToken}\"\n\tdef params = [\n\t\toauth_callback:URLEncoder.encode(callback),\n\t]\n\tdef requestTokenBaseUrl = \"https://oauth.withings.com/account/request_token\"\n\tdef url = buildSignedUrl(requestTokenBaseUrl, params)\n\t//log.debug \"getToken - url: $url\"\n\n\treturn getJsonFromUrl(url)\n}\n\ndef buildOauthUrlWithToken(String token, String tokenSecret) {\n\tdef callback = getServerUrl() + \"/api/smartapps/installations/${app.id}/exchange?access_token=${state.accessToken}\"\n\tdef params = [\n\t\toauth_callback:URLEncoder.encode(callback),\n\t\toauth_token:token\n\t]\n\tdef authorizeBaseUrl = \"https://oauth.withings.com/account/authorize\"\n\n\treturn buildSignedUrl(authorizeBaseUrl, params, tokenSecret)\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n// vvv vvv\t\tOAuth 1.0\t   vvv vvv //\n/////////////////////////////////////////\n/////////////////////////////////////////\nString buildSignedUrl(String baseUrl, Map urlParams, String tokenSecret=\"\") {\n\tdef params = [\n\t\toauth_consumer_key: smartThingsConsumerKey,\n\t\toauth_nonce: nonce(),\n\t\toauth_signature_method: \"HMAC-SHA1\",\n\t\toauth_timestamp: timestampInSeconds(),\n\t\toauth_version: 1.0\n\t] + urlParams\n\tdef signatureBaseString = [\"GET\", baseUrl, toQueryString(params)].collect { URLEncoder.encode(it) }.join(\"&\")\n\n\tparams.oauth_signature = hmac(signatureBaseString, getSmartThingsConsumerSecret(), tokenSecret)\n\n\t// query string is different from what is used in generating the signature above b/c it includes \"oauth_signature\"\n\tdef url = [baseUrl, toQueryString(params)].join('?')\n\treturn url\n}\n\nString nonce() {\n\treturn UUID.randomUUID().toString().replaceAll(\"-\", \"\")\n}\n\nInteger timestampInSeconds() {\n\treturn (int)(new Date().time/1000)\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\nString hmac(String dataString, String consumerSecret, String tokenSecret=\"\") throws java.security.SignatureException {\n\tString result\n\n\tdef key = [consumerSecret, tokenSecret].join('&')\n\t\n\t// get an hmac_sha1 key from the raw key bytes\n\tdef signingKey = new javax.crypto.spec.SecretKeySpec(key.getBytes(), \"HmacSHA1\")\n\t\n\t// get an hmac_sha1 Mac instance and initialize with the signing key\n\tdef mac = javax.crypto.Mac.getInstance(\"HmacSHA1\")\n\tmac.init(signingKey)\n\n\t// compute the hmac on input data bytes\n\tbyte[] rawHmac = mac.doFinal(dataString.getBytes())\n\n\tresult = org.apache.commons.codec.binary.Base64.encodeBase64String(rawHmac)\n\n\treturn result\n}\n/////////////////////////////////////////\n/////////////////////////////////////////\n// ^^^ ^^^\t\tOAuth 1.0\t   ^^^ ^^^ //\n/////////////////////////////////////////\n/////////////////////////////////////////\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n// vvv vvv\t\t rest\t\t   vvv vvv //\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nprotected rest(Map params) {\n\tnew physicalgraph.device.RestAction(params)\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n// ^^^ ^^^\t\t rest\t\t   ^^^ ^^^ //\n/////////////////////////////////////////\n/////////////////////////////////////////\n\ndef exchangeToken() {\n\t//\t oauth_token=abcd\n\t//\t &userid=123\n\n\tdef newToken = params.oauth_token\n\tdef userid = params.userid\n\tdef tokenSecret = state.oauth_request_token_secret\n\n\tdef params = [\n\t\toauth_token: newToken,\n\t\tuserid: userid\n\t]\n\n\tdef requestTokenBaseUrl = \"https://oauth.withings.com/account/access_token\"\n\tdef url = buildSignedUrl(requestTokenBaseUrl, params, tokenSecret)\n\t//log.debug \"signed url: $url with secret $tokenSecret\"\n\n\tdef token = getJsonFromUrl(url)\n\n\tstate.userid = userid\n\tstate.oauth_token = token.oauth_token\n\tstate.oauth_token_secret = token.oauth_token_secret\n\n\tlog.debug \"swapped token\"\n\n\tdef location = getServerUrl() + \"/api/smartapps/installations/${app.id}/load?access_token=${state.accessToken}\"\n\tredirect(location:location)\n}\n\ndef load() {\n\tdef json = get(getMeasurement(new Date() - 30))\n\t// removed logging of actual json payload.  Can be put back for debugging\n\tlog.debug \"swapped, then received json\"\n\tparse(data:json)\n\n\tdef html = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=640\">\n<title>Withings Connection</title>\n<style type=\"text/css\">\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t@font-face {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n\t\tsrc: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n\t\t\t url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t}\n\t.container {\n\t\twidth: 560px;\n\t\tpadding: 40px;\n\t\t/*background: #eee;*/\n\t\ttext-align: center;\n\t}\n\timg {\n\t\tvertical-align: middle;\n\t}\n\timg:nth-child(2) {\n\t\tmargin: 0 30px;\n\t}\n\tp {\n\t\tfont-size: 2.2em;\n\t\tfont-family: 'Swiss 721 W01 Thin';\n\t\ttext-align: center;\n\t\tcolor: #666666;\n\t\tpadding: 0 40px;\n\t\tmargin-bottom: 0;\n\t}\n/*\n\tp:last-child {\n\t\tmargin-top: 0px;\n\t}\n*/\n\tspan {\n\t\tfont-family: 'Swiss 721 W01 Light';\n\t}\n</style>\n</head>\n<body>\n\t<div class=\"container\">\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/withings@2x.png\" alt=\"withings icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n\t\t<img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n\t\t<p>Your Withings scale is now connected to SmartThings!</p>\n\t\t<p>Click 'Done' to finish setup.</p>\n\t</div>\n</body>\n</html>\n\"\"\"\n\n\trender contentType: 'text/html', data: html\n}\n\nMap getJsonFromUrl(String url) {\n\treturn [:] // stop making requests to Withings API. This entire SmartApp will be replaced with a fix\n\n\tdef jsonString\n\thttpGet(uri: url) { resp ->\n\t\tjsonString = resp.data.toString()\n\t}\n\n\treturn getJsonFromText(jsonString)\n}\n\nMap getJsonFromText(String jsonString) {\n\tdef jsonMap = jsonString.split(\"&\").inject([:]) { c, it ->\n\t\tdef parts = it.split('=')\n\t\tdef k = parts[0]\n\t\tdef v = parts[1]\n\t\tc[k] = v\n\t\treturn c\n\t}\n\n\treturn jsonMap\n}\n\ndef getMeasurement(Date since=null) {\n\treturn null // stop making requests to Withings API. This entire SmartApp will be replaced with a fix\n\n\t// TODO: add startdate and enddate ... esp. when in response to notify\n\tdef params = [\n\t\taction:\"getmeas\",\n\t\toauth_consumer_key:getSmartThingsConsumerKey(),\n\t\toauth_nonce:nonce(),\n\t\toauth_signature_method:\"HMAC-SHA1\",\n\t\toauth_timestamp:timestampInSeconds(),\n\t\toauth_token:state.oauth_token,\n\t\toauth_version:1.0,\n\t\tuserid: state.userid\n\t]\n\n\tif(since)\n\t{\n\t\tparams.startdate = dateToSeconds(since)\n\t}\n\n\tdef requestTokenBaseUrl = \"http://wbsapi.withings.net/measure\"\n\tdef signatureBaseString = [\"GET\", requestTokenBaseUrl, toQueryString(params)].collect { URLEncoder.encode(it) }.join(\"&\")\n\n\tparams.oauth_signature = hmac(signatureBaseString, getSmartThingsConsumerSecret(), state.oauth_token_secret)\n\n\treturn rest(\n\t\tmethod: 'GET',\n\t\tendpoint: \"http://wbsapi.withings.net\",\n\t\tpath: \"/measure\",\n\t\tquery: params,\n\t\tsynchronous: true\n\t)\n\n}\n\nString get(measurementRestAction) {\n\treturn \"\" // stop making requests to Withings API. This entire SmartApp will be replaced with a fix\n\n\tdef httpGetParams = [\n\t\turi: measurementRestAction.endpoint,\n\t\tpath: measurementRestAction.path,\n\t\tquery: measurementRestAction.query\n\t]\n\n\tString json\n\thttpGet(httpGetParams) {resp ->\n\t\tjson = resp.data.text.toString()\n\t}\n\n\treturn json\n}\n\ndef parse(Map response) {\n\tdef json = new org.codehaus.groovy.grails.web.json.JSONObject(response.data)\n\tparseJson(json)\n}\n\ndef parseJson(json) {\n\tlog.debug \"parseJson: $json\"\n\n\tdef lastDataPointMillis = (state.lastDataPointMillis ?: 0).toLong()\n\tdef i = 0\n\n\tif(json.status == 0)\n\t{\n\t\tlog.debug \"parseJson measure group size: ${json.body.measuregrps.size()}\"\n\n\t\tstate.errorCount = 0\n\n\t\tdef childDni = getWithingsDevice(json.body.measuregrps).deviceNetworkId\n\n\t\tdef latestMillis = lastDataPointMillis\n\t\tjson.body.measuregrps.sort { it.date }.each { group ->\n\n\t\t\tdef measurementDateSeconds = group.date\n\t\t\tdef dataPointMillis = measurementDateSeconds * 1000L\n\n\t\t\tif(dataPointMillis > lastDataPointMillis)\n\t\t\t{\n\t\t\t\tgroup.measures.each { measure ->\n\t\t\t\t\ti++\n\t\t\t\t\tsaveMeasurement(childDni, measure, measurementDateSeconds)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(dataPointMillis > latestMillis)\n\t\t\t{\n\t\t\t\tlatestMillis = dataPointMillis\n\t\t\t}\n\n\t\t}\n\n\t\tif(latestMillis > lastDataPointMillis)\n\t\t{\n\t\t\tstate.lastDataPointMillis = latestMillis\n\t\t}\n\n\t\tdef weightData = state.findAll { it.key.startsWith(\"measure.\") }\n\n\t\t// remove old data\n\t\tdef old = \"measure.\" + (new Date() - 30).format('yyyy-MM-dd')\n\t\tstate.findAll { it.key.startsWith(\"measure.\") && it.key < old }.collect { it.key }.each { state.remove(it) }\n\t}\n\telse\n\t{\n\t\tdef errorCount = (state.errorCount ?: 0).toInteger()\n\t\tstate.errorCount = errorCount + 1\n\n\t\t// TODO: If we poll, consider waiting for a couple failures before showing an error\n\t\t//\t\t\tBut if we are only notified, then we need to raise the error right away\n\t\tmeasurementError(json.status)\n\t}\n\n\tlog.debug \"Done adding $i measurements\"\n\treturn\n}\n\ndef measurementError(status) {\n\tlog.error \"received api response status ${status}\"\n\tsendEvent(state.childDni, [name: \"connection\", value:\"Connection error: ${status}\", isStateChange:true, displayed:true])\n}\n\ndef saveMeasurement(childDni, measure, measurementDateSeconds) {\n\tdef dateString = secondsToDate(measurementDateSeconds).format('yyyy-MM-dd')\n\n\tdef measurement = withingsEvent(measure)\n\tsendEvent(state.childDni, measurement + [date:dateString], [dateCreated:secondsToDate(measurementDateSeconds)])\n\n\tlog.debug \"sm: ${measure.type} (${measure.type == 1})\"\n\n\tif(measure.type == 6)\n\t{\n\t\tsendEvent(state.childDni, [name: \"leanRatio\", value:(100-measurement.value), date:dateString, isStateChange:true, display:true], [dateCreated:secondsToDate(measurementDateSeconds)])\n\t}\n\telse if(measure.type == 1)\n\t{\n\t\tstate[\"measure.\" + dateString] = measurement.value\n\t}\n}\n\ndef eventValue(measure, roundDigits=1) {\n\tdef value = measure.value * 10.power(measure.unit)\n\n\tif(roundDigits != null)\n\t{\n\t\tdef significantDigits = 10.power(roundDigits)\n\t\tvalue = (value * significantDigits).toInteger() / significantDigits\n\t}\n\n\treturn value\n}\n\ndef withingsEvent(measure) {\n\tdef withingsTypes = [\n\t\t(1):\"weight\",\n\t\t(4):\"height\",\n\t\t(5):\"leanMass\",\n\t\t(6):\"fatRatio\",\n\t\t(8):\"fatMass\",\n\t\t(11):\"pulse\"\n\t]\n\n\tdef value = eventValue(measure, (measure.type == 4 ? null : 1))\n\n\tif(measure.type == 1) {\n\t\tvalue *= 2.20462\n\t} else if(measure.type == 4) {\n\t\tvalue *= 39.3701\n\t}\n\n\tlog.debug \"m:${measure.type}, v:${value}\"\n\n\treturn [\n\t\tname: withingsTypes[measure.type],\n\t\tvalue: value\n\t]\n}\n\nInteger dateToSeconds(Date d) {\n\treturn d.time / 1000\n}\n\nDate secondsToDate(Number seconds) {\n\treturn new Date(seconds * 1000L)\n}\n\ndef getWithingsDevice(measuregrps=null) {\n\t// unfortunately, Withings doesn't seem to give us enough information to know which device(s) they have,\n\t// ... so we have to guess and create a single device\n\n\tif(state.childDni)\n\t{\n\t\treturn getChildDevice(state.childDni)\n\t}\n\telse\n\t{\n\t\tdef children = getChildDevices()\n\t\tif(children.size() > 0)\n\t\t{\n\t\t\treturn children[0]\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no child yet, create one\n\t\t\tdef dni = [app.id, UUID.randomUUID().toString()].join('.')\n\t\t\tstate.childDni = dni\n\n\t\t\tdef childDeviceType = getBodyAnalyzerChildName()\n\n\t\t\tif(measuregrps)\n\t\t\t{\n\t\t\t\tdef hasNoHeartRate = measuregrps.find { grp -> grp.measures.find { it.type == 11 } } == null\n\t\t\t\tif(hasNoHeartRate)\n\t\t\t\t{\n\t\t\t\t\tchildDeviceType = getScaleChildName()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdef child = addChildDevice(getChildNamespace(), childDeviceType, dni, null, [label:\"Withings\"])\n\t\t\tstate.childId = child.id\n\t\t\treturn child\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// TODO: subscribe to attributes, devices, locations, etc.\n}\n\ndef poll() {\n\tif(shouldPoll())\n\t{\n\t\treturn getMeasurement()\n\t}\n\n\treturn null\n}\n\ndef shouldPoll() {\n\tdef lastPollString = state.lastPollMillisString\n\tdef lastPoll = lastPollString?.isNumber() ? lastPollString.toLong() : 0\n\tdef ONE_HOUR = 60 * 60 * 1000\n\n\tdef time = new Date().time\n\n\tif(time > (lastPoll + ONE_HOUR))\n\t{\n\t\tlog.debug \"Executing poll b/c (now > last + 1hr): ${time} > ${lastPoll + ONE_HOUR} (last: ${lastPollString})\"\n\t\tstate.lastPollMillisString = time\n\n\t\treturn true\n\t}\n\n\tlog.debug \"skipping poll b/c !(now > last + 1hr): ${time} > ${lastPoll + ONE_HOUR} (last: ${lastPollString})\"\n\treturn false\n}\n\ndef refresh() {\n\tlog.debug \"Executing 'refresh'\"\n\treturn getMeasurement()\n}\n\ndef getChildNamespace() { \"smartthings\" }\ndef getScaleChildName() { \"Wireless Scale\" }\ndef getBodyAnalyzerChildName() { \"Smart Body Analyzer\" }\n\ndef getServerUrl() { appSettings.serverUrl }\ndef getSmartThingsConsumerKey() { appSettings.clientId }\ndef getSmartThingsConsumerSecret() { appSettings.clientSecret }",
        "docstring": "Connect your Withings scale to SmartThings."
    },
    {
        "code": "preferences {\n\tpage(name: \"auth\", title: \"Sign in\", content: \"authPage\", uninstall:true)\n\tpage(name: \"page2\", title: \"Yoics Devices\", install:true, content: \"listAvailableCameras\")\n}\n\n\nmappings {\n\tpath(\"/foauth\") {\n\t\taction: [\n\t\t\tGET: \"foauth\"\n\t\t]\n\t}\n\tpath(\"/authorize\") {\n\t\taction: [\n\t\t\tPOST: \"authorize\"\n\t\t]\n\t}\n\n}\n\ndef authPage()\n{\n\tlog.debug \"authPage()\"\n\n\tif(!state.accessToken)\n\t{\n\t\tlog.debug \"about to create access token\"\n\t\tcreateAccessToken()\n\t}\n\n\n\tdef description = \"Required\"\n\n\tif(getAuthHashValueIsValid())\n\t{\n\t\t// TODO: Check if it's valid\n\t\tif(true)\n\t\t{\n\t\t\tdescription = \"Already saved\"\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdescription = \"Required\"\n\t\t}\n\t}\n\n\tdef redirectUrl = buildUrl(\"\", \"foauth\")\n\n\treturn dynamicPage(name: \"auth\", title: \"Yoics\", nextPage:\"page2\") {\n\t\tsection(\"Yoics Login\"){\n\t\t\thref url:redirectUrl, style:\"embedded\", required:false, title:\"Yoics\", description:description\n\t\t}\n\t}\n\n}\n\ndef buildUrl(String key, String endpoint=\"increment\", Boolean absolute=true)\n{\n\tif(key) {\n\t\tkey = \"/${key}\"\n\t}\n\n\tdef url = \"/api/smartapps/installations/${app.id}/${endpoint}${key}?access_token=${state.accessToken}\"\n\n\tif (q) {\n\t\turl += \"q=${q}\"\n\t}\n\n\tif(absolute)\n\t{\n\t\turl = serverUrl + url\n\t}\n\n\treturn url\n}\n\n//Deprecated\ndef getServerName() {\n\treturn getServerUrl()\n}\n\ndef getServerUrl() {\n  return appSettings.serverUrl\n}\n\ndef listAvailableCameras() {\n\n\t//def loginResult = forceLogin()\n\n\t//if(loginResult.success)\n\t//{\n\t\tstate.cameraNames = [:]\n\n\t\tdef cameras = getDeviceList().inject([:]) { c, it ->\n\t\t\tdef dni = [app.id, it.uuid].join('.')\n\t\t\tdef cameraName = it.title ?: \"Yoics\"\n\n\t\t\tstate.cameraNames[dni] = cameraName\n\t\t\tc[dni] = cameraName\n\n\t\t\treturn c\n\t\t}\n\n\t\treturn dynamicPage(name: \"page2\", title: \"Yoics Devices\", install:true) {\n\t\t\tsection(\"Select which Yoics Devices to connect\"){\n\t\t\t\tinput(name: \"cameras\", title:\"\", type: \"enum\", required:false, multiple:true, metadata:[values:cameras])\n\t\t\t}\n\t\t\tsection(\"Turn on which Lights when taking pictures\")\n\t\t\t{\n\t\t\t\tinput \"switches\", \"capability.switch\", multiple: true, required:false\n\t\t\t}\n\t\t}\n\t//}\n\t/*else\n\t{\n\t\tlog.error \"login result false\"\n\t\treturn [errorMessage:\"There was an error logging in to Dropcam\"]\n\t}*/\n\n}\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef uninstalled() {\n\tremoveChildDevices(getChildDevices())\n}\n\ndef initialize() {\n\n\tif(!state.suppressDelete)\n\t{\n\t\tstate.suppressDelete = [:]\n\t}\n\n\tlog.debug \"settings: $settings\"\n\n\tdef devices = cameras.collect { dni ->\n\n\t\tdef name = state.cameraNames[dni] ?: \"Yoics Device\"\n\n\t\tdef d = getChildDevice(dni)\n\n\t\tif(!d)\n\t\t{\n\t\t\td = addChildDevice(\"smartthings\", \"Yoics Camera\", dni, null, [name:\"YoicsCamera\", label:name])\n\n\t\t\t/* WE'LL GET PROXY ON TAKE REQUEST\n\t\t\tdef setupProxyResult = setupProxy(dni)\n\t\t\tif(setupProxyResult.success)\n\t\t\t{\n\t\t\t\tlog.debug \"Setting up the proxy worked...taking image capture now?\"\n\n\t\t\t}\n\t\t\t*/\n\n\t\t\t//Let's not take photos on add\n\t\t\t//d.take()\n\n\t\t\tlog.debug \"created ${d.displayName} with id $dni\"\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.debug \"found ${d.displayName} with id $dni already exists\"\n\t\t}\n\n\t\treturn d\n\t}\n\n\tlog.debug \"created ${devices.size()} dropcams\"\n\n\t/* //Original Code seems to delete the dropcam that is being added */\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !cameras?.contains(it.deviceNetworkId) }\n\tremoveChildDevices(delete)\n}\n\nprivate removeChildDevices(delete)\n{\n\tlog.debug \"deleting ${delete.size()} dropcams\"\n\tdelete.each {\n\t\tstate.suppressDelete[it.deviceNetworkId] = true\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t\tstate.suppressDelete.remove(it.deviceNetworkId)\n\t}\n}\nprivate List getDeviceList()\n{\n\n\t//https://apilb.yoics.net/web/api/getdevices.ashx?token=&filter=all&whose=me&state=%20all&type=xml\n\n\tdef deviceListParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/getdevices.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), filter: \"all\", whose: \"me\", state: \"all\", type:\"json\" ]\n\t]\n\n\tlog.debug \"cam list via: $deviceListParams\"\n\n\tdef multipleHtml\n\tdef singleUrl\n\tdef something\n\tdef more\n\n\tdef devices = []\n\n\thttpGet(deviceListParams) { resp ->\n\n\t\tlog.debug \"getting device list...\"\n\n\t\tsomething = resp.status\n\t\tmore = \"headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\n\t\tif(resp.status == 200)\n\t\t{\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\t//log.debug \"get devices list response: ${jsonString}\"\n\t\t\t//log.debug \"get device list response: ${body}\"\n\n\t\t\tbody.NewDataSet.Table.each { d ->\n\t\t\t\t//log.debug \"Addding ${d.devicealias} with address: ${d.deviceaddress}\"\n\t\t\t\tdevices << [title: d.devicealias, uuid: d.deviceaddress]\t//uuid should be another name\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR\n\t\t\tlog.error \"camera list: unknown response\"\n\t\t}\n\n\t}\n\n\t log.debug \"list: after getting cameras: \" + [devices:devices, url:singleUrl, html:multipleHtml?.size(), something:something, more:more]\n\n\t// ERROR?\n\treturn devices\n}\n\ndef removeChildFromSettings(child)\n{\n\tdef device = child.device\n\n\tdef dni = device.deviceNetworkId\n\tlog.debug \"removing child device $device with dni ${dni}\"\n\n\tif(!state?.suppressDelete?.get(dni))\n\t{\n\t\tdef newSettings = settings.cameras?.findAll { it != dni } ?: []\n\t\tapp.updateSetting(\"cameras\", newSettings)\n\t}\n}\n\nprivate forceLogin() {\n\tupdateAuthHash(null)\n\tlogin()\n}\n\n\nprivate login() {\n\n\tif(getAuthHashValueIsValid())\n\t{\n\t\treturn [success:true]\n\t}\n\treturn doLogin()\n}\n\n/*private setupProxy(dni) {\n\t//https://apilb.yoics.net/web/api/connect.ashx?token=&deviceaddress=00:00:48:02:2A:A2:08:0E&type=xml\n\n\tdef address = dni?.split(/\\./)?.last()\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/connect.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), deviceaddress:address, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tdef proxy = body?.NewDataSet?.Table[0]?.proxy\n\t\t\tdef requested = body?.NewDataSet?.Table[0]?.requested\n\t\t\tdef expirationsec = body?.NewDataSet?.Table[0]?.expirationsec\n\t\t\tdef url = body?.NewDataSet?.Table[0]?.url\n\n\t\t\tdef proxyMap = [proxy:proxy, requested: requested, expirationsec:expirationsec, url: url]\n\n\t\t\tif (proxy) {\n\t\t\t\t//log.debug \"setting ${dni} proxy to ${proxyMap}\"\n\t\t\t\t//updateDeviceProxy(address, proxyMap)\n\t\t\t\tresult.success = true\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}*/\n\n\n\nprivate doLogin(user = \"\", pwd = \"\") { //change this name\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/login.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [key: \"SmartThingsApplication\", usr: username, pwd: password, apilevel: 12, type:\"json\" ]\n\t]\n\n\tif (user) {\n\t\tloginParams.query = [key: \"SmartThingsApplication\", usr: user, pwd: pwd, apilevel: 12, type:\"json\" ]\n\t}\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tlog.debug \"login response: ${jsonString}\"\n\t\t\tlog.debug \"login response: ${body}\"\n\n\t\t\tdef authhash = body?.NewDataSet?.Table[0]?.authhash //.token\n\n\t\t\t//this may return as well??\n\t\t\tdef token = body?.NewDataSet?.Table[0]?.token ?: null\n\n\t\t\tif (authhash) {\n\t\t\t\tlog.debug \"login setting authhash to ${authhash}\"\n\t\t\t\tupdateAuthHash(authhash)\n\t\t\t\tif (token) {\n\t\t\t\t\tlog.debug \"login setting login token to ${token}\"\n\t\t\t\t\tupdateLoginToken(token)\n\t\t\t\t\tresult.success = true\n\t\t\t\t} else {\n\t\t\t\t\tresult.success = doLoginToken()\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}\n\nprivate doLoginToken() {\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/login.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [key: \"SmartThingsApplication\", usr: getUserName(), auth: getAuthHashValue(), apilevel: 12, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200)\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tdef token = body?.NewDataSet?.Table[0]?.token\n\n\t\t\tif (token) {\n\t\t\t\tlog.debug \"login setting login to $token\"\n\t\t\t\tupdateLoginToken(token)\n\t\t\t\tresult.success = true\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = \"Bad login\"\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n}\n\ndef takePicture(String dni, Integer imgWidth=null)\n{\n\n\t//turn on any of the selected lights that are off\n\tdef offLights = switches.findAll{(it.currentValue(\"switch\") == \"off\")}\n\tlog.debug offLights\n\toffLights.collect{it.on()}\n\n\tlog.debug \"parent.takePicture(${dni}, ${imgWidth})\"\n\n\tdef uuid = dni?.split(/\\./)?.last()\n\n\tlog.debug \"taking picture for $uuid (${dni})\"\n\n\tdef imageBytes\n\tdef loginRequired = false\n\n\ttry\n\t{\n\t\timageBytes = doTakePicture(uuid, imgWidth)\n\t}\n\tcatch(Exception e)\n\t{\n\t\tlog.error \"Exception $e trying to take a picture, attempting to login again\"\n\t\tloginRequired = true\n\t}\n\n\tif(loginRequired)\n\t{\n\t\tdef loginResult = doLoginToken()\n\t\tif(loginResult.success)\n\t\t{\n\t\t\t// try once more\n\t\t\timageBytes = doTakePicture(uuid, imgWidth)\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error \"tried to login to dropcam after failing to take a picture and failed\"\n\t\t}\n\t}\n\n\t//turn previously off lights to their original state\n\toffLights.collect{it.off()}\n\treturn imageBytes\n}\n\nprivate doTakePicture(String uuid, Integer imgWidth)\n{\n\timgWidth = imgWidth ?: 1280\n\tdef loginRequired = false\n\n\tdef proxyParams = getDeviceProxy(uuid)\n\tif(!proxyParams.success)\n\t{\n\t\tthrow new Exception(\"Login Required\")\n\t}\n\n\tdef takeParams = [\n\t\turi: \"${proxyParams.uri}\",\n\t\tpath: \"${proxyParams.path}\",\n\t\theaders: ['User-Agent': validUserAgent()]\n\t]\n\n\tdef imageBytes\n\n\thttpGet(takeParams) { resp ->\n\n\t\tif(resp.status == 403)\n\t\t{\n\t\t\tloginRequired = true\n\t\t}\n\t\telse if (resp.status == 200 && resp.headers.'Content-Type'.contains(\"image/jpeg\"))\n\t\t{\n\t\t\timageBytes = resp.data\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error \"unknown takePicture() response: ${resp.status} - ${resp.headers.'Content-Type'}\"\n\t\t}\n\t}\n\n\tif(loginRequired)\n\t{\n\t\tthrow new Exception(\"Login Required\")\n\t}\n\n\treturn imageBytes\n}\n\n/////////////////////////\nprivate Boolean getLoginTokenValueIsValid()\n{\n\treturn getLoginTokenValue()\n}\n\nprivate updateLoginToken(String token) {\n\tstate.loginToken = token\n}\n\nprivate getLoginTokenValue() {\n\tstate.loginToken\n}\n\nprivate Boolean getAuthHashValueIsValid()\n{\n\treturn getAuthHashValue()\n}\n\nprivate updateAuthHash(String hash) {\n\tstate.authHash = hash\n}\n\nprivate getAuthHashValue() {\n\tstate.authHash\n}\n\nprivate updateUserName(String username) {\n\tstate.username = username\n}\n\nprivate getUserName() {\n\tstate.username\n}\n\n/*private getDeviceProxy(dni){\n\t//check if it exists or is not longer valid and create a new proxy here\n\tlog.debug \"returning proxy ${state.proxy[dni].proxy}\"\n\tdef proxy = [uri:state.proxy[dni].proxy, path:state.proxy[dni].url]\n\tlog.debug \"returning proxy ${proxy}\"\n\tproxy\n}*/\n\nprivate updateDeviceProxy(dni, map){\n\tif (!state.proxy) { state.proxy = [:] }\n\tstate.proxy[dni] = map\n}\n\nprivate getDeviceProxy(dni) {\n\tdef address = dni?.split(/\\./)?.last()\n\n\tdef loginParams = [\n\t\turi: \"https://apilb.yoics.net\",\n\t\tpath: \"/web/api/connect.ashx\",\n\t\theaders: ['User-Agent': validUserAgent()],\n\t\trequestContentType: \"application/json\",\n\t\tquery: [token: getLoginTokenValue(), deviceaddress:address, type:\"json\" ]\n\t]\n\n\tdef result = [success:false]\n\n\thttpGet(loginParams) { resp ->\n\t\tif (resp.status == 200) //&& resp.headers.'Content-Type'.contains(\"application/json\")\n\t\t{\n\t\t\tlog.debug \"login 200 json headers: \" + resp.headers.collect { \"${it.name}:${it.value}\" }\n\t\t\tdef jsonString = resp.data.str\n\t\t\tdef body = new groovy.json.JsonSlurper().parseText(jsonString)\n\n\t\t\tif (body?.NewDataSet?.Table[0]?.error)\n\t\t\t{\n\t\t\t\tlog.error \"Attempt to get Yoics Proxy failed\"\n\t\t\t\t// ERROR: any more information we can give?\n\t\t\t\tresult.reason = body?.NewDataSet?.Table[0]?.message\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.uri = body?.NewDataSet?.Table[0]?.proxy\n\t\t\t\tresult.path = body?.NewDataSet?.Table[0]?.url\n\t\t\t\tresult.requested = body?.NewDataSet?.Table[0]?.requested\n\t\t\t\tresult.expirationsec = body?.NewDataSet?.Table[0]?.expirationsec\n\t\t\t\tresult.success = true\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ERROR: any more information we can give?\n\t\t\tresult.reason = \"Bad login\"\n\t\t}\n\n\n\t}\n\n\treturn result\n\n}\n\nprivate validUserAgent() {\n\t\"curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8x zlib/1.2.5\"\n}\n\ndef foauth() {\n\tdef html = \"\"\"<html>\n<head>\n\t<title>$inputQuery results</title>\n\t<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<link rel=\"shortcut icon\" href=\"/static/sT2cZkBCCKJduBLfQ6NfUjZg1AiMhFK9ESNxUjjlvsk.ico\" type=\"image/x-icon\">\n\t<link rel=\"apple-touch-icon\" href=\"/static/7UIUNICQhrzmPRYK3T7j5BhAsvUIbKE8OARNI702Dw9.png\">\n\t<link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/static/HkpqhLsUc5flOzvxrpaoyybhcCP1iRd0ogxhWFJ9vKo.png\">\n\n\t<script src=\"/static/1vXORVkZK58St3QjdbzerXZDi9MfZQ8Q3wCyumiNiep.js\" type=\"text/javascript\" ></script>\n\t<link href=\"/static/ZLo6WmGLBQwvykZ4sFgJS1W8IKyGj3TKdKZXyHcBB9l.css\" type=\"text/css\" rel=\"stylesheet\" media=\"screen, projection\" />\n\t<link rel=\"stylesheet\" href=\"/static/sd6ug4HGJyhdTwTONDZK6Yw8VsYbyDa4qUPgLokOkTn.css\" type=\"text/css\">\n\n</head>\n<body>\n\n\t<h1>\n\t\tYoics Login\n\t</h1>\n\n<form name=\"login\" action=\"${buildUrl(\"\", \"authorize\")}\" method=\"post\">\nUser:\n<br>\n<input type=\"text\" name=\"user\" style=\"height: 50px;\">\n<br>\n<br>\nPassword:\n<br>\n<input type=\"password\" name=\"password\" style=\"height: 50px;\">\n\n<input type=\"submit\" value=\"Submit\">\n</form>\n\n\n</body>\n</html>\"\"\"\n\n\trender status: 200, contentType: 'text/html', data: html\n}\n\ndef authorize() {\n\n\tdef loginResult = doLogin(params.user, params.password)\n\n\tdef result\n\tif (loginResult.success) {\n    \tresult = \"Successful\"\n\n        //save username\n\t\tupdateUserName(params.user)\n    } else {\n    \tresult = \"Failed\"\n    }\n\n\tdef html = \"\"\"<html>\n<head>\n\t<title>$inputQuery results</title>\n\t<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<link rel=\"shortcut icon\" href=\"/static/sT2cZkBCCKJduBLfQ6NfUjZg1AiMhFK9ESNxUjjlvsk.ico\" type=\"image/x-icon\">\n<link rel=\"apple-touch-icon\" href=\"/static/7UIUNICQhrzmPRYK3T7j5BhAsvUIbKE8OARNI702Dw9.png\">\n<link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/static/HkpqhLsUc5flOzvxrpaoyybhcCP1iRd0ogxhWFJ9vKo.png\">\n\n\n\n<script src=\"/static/1vXORVkZK58St3QjdbzerXZDi9MfZQ8Q3wCyumiNiep.js\" type=\"text/javascript\" ></script>\n<link href=\"/static/ZLo6WmGLBQwvykZ4sFgJS1W8IKyGj3TKdKZXyHcBB9l.css\" type=\"text/css\" rel=\"stylesheet\" media=\"screen, projection\" />\n<link rel=\"stylesheet\" href=\"/static/sd6ug4HGJyhdTwTONDZK6Yw8VsYbyDa4qUPgLokOkTn.css\" type=\"text/css\">\n<script>\nfunction buildCmd(){\n\n}\n</script>\n</head>\n<body>\n\n\t<h1>\n\t\tYoics Login ${result}!\n\t</h1>\n\n</body>\n</html>\"\"\"\n\n\trender status: 200, contentType: 'text/html', data: html\n}",
        "docstring": "Connect and Control your Yoics Enabled Devices"
    },
    {
        "code": "}\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n    def startHour = startHour1\n    def stopHour = stopHour1\n    def startTime = minutes\n    if (minutes == \"1\") {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tstartTime = \"0 0,30 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tstartTime = \"0 0,20,40 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tstartTime = \"0 0,15,30,45 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tstartTime = \"0 0,12,24,36,48 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tstartTime = \"0 0,10,20,30,40,50 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tstartTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tstartTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tstartTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t}\n\tlog.debug \"${startTime}\"   \n    /*\n    def stopTime = \"0 $minutes $stopHour * * ?\"   */\n\tschedule(startTime, openValve)\n/*\tschedule(\"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\", openValve) */\n/*\tschedule(stopTime, closeValve)  */\n   \tsubscribe(valves1, \"switch.on\", valveOnHandler, [filterEvents: false])\n\n}\n\ndef updated(settings) {\n\tunschedule()\n\tunsubscribe()\n\tlog.debug \"Installed with settings: ${settings}\"\n    def startHour = startHour1\n    def stopHour = stopHour1\n    def startTime = minutes\n    if (minutes == \"1\") {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tstartTime = \"0 0,30 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tstartTime = \"0 0,20,40 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tstartTime = \"0 0,15,30,45 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tstartTime = \"0 0,12,24,36,48 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tstartTime = \"0 0,10,20,30,40,50 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tstartTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tstartTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tstartTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t} else {\n\t\tstartTime = \"0 0 \" + startHour + \"-\" + stopHour + \" * * ?\"\n\t}\n\tlog.debug \"${startTime}\"   \n    /*\n    def stopTime = \"0 $minutes $stopHour * * ?\"   */\n\tschedule(startTime, openValve)\n/*\tschedule(stopTime, closeValve)  */\n   \tsubscribe(valves1, \"switch.on\", valveOnHandler, [filterEvents: false])\n/*\tschedule(\"0 0,5,10,15,20,25,30,35,40,45,50,55 \" + startHour + \"-\" + stopHour + \" * * ?\", openValve)  */\n\n}\n\ndef openValve() {\n\tlog.debug \"Turning on Sprinklers ${valves1}\"\n\tvalves1.on()\n\n}\n\ndef closeValve() {\n\tlog.debug \"Turning off Sprinklers ${valves1}\"\n\tvalves1.off()\n}\n\ndef valveOnHandler(evt) {\n\tlog.debug \"Valve ${valves1} turned: ${evt.value}\"\n\tdef delay = duration\n\tlog.debug \"Turning off in ${duration/60} minutes (${delay}seconds)\"\n\trunIn(delay, closeValve)\n}\n\ndef setStartTime() {\n    if (minutes == \"1\") {\n\t\tdef startTime = \"0 0 $startHour * * ?\"\n\t} else if (minutes == \"2\") {\n\t\tdef startTime = \"0 0,30 $startHour * * ?\"\n\t} else if (minutes == \"3\") {\n\t\tdef startTime = \"0 0,20,40 $startHour * * ?\"\n\t} else if (minutes == \"4\") {\n\t\tdef startTime = \"0 0,15,30,45 $startHour * * ?\"\n\t} else if (minutes == \"5\") {\n\t\tdef startTime = \"0 0,12,24,36,48 $startHour * * ?\"\n\t} else if (minutes == \"6\") {\n\t\tdef startTime = \"0 0,10,20,30,40,50 $startHour * * ?\"\n\t} else if (minutes == \"12\") {\n\t\tdef startTime = \"0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?\"\n\t} else if (minutes == \"20\") {\n\t\tdef startTime = \"0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?\"\n\t} else if (minutes == \"30\") {\n\t\tdef startTime = \"0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?\"\n\t} else {\n\t\tdef startTime = \"0 0 $startHour * * ?\"\n\t}\n}",
        "docstring": "Control Sprayers for a period of time a number of times per hour"
    },
    {
        "code": "path(\"/armaway/:pincode\") {\n        action: [ GET: \"apiArmAway\" ]\n    }\n\n    path(\"/armstay\") {\n        action: [ GET: \"apiArmStay\" ]\n    }\n\n    path(\"/armstay/:pincode\") {\n        action: [ GET: \"apiArmStay\" ]\n    }\n\n    path(\"/disarm\") {\n        action: [ GET: \"apiDisarm\" ]\n    }\n\n    path(\"/disarm/:pincode\") {\n        action: [ GET: \"apiDisarm\" ]\n    }\n\n    path(\"/panic\") {\n        action: [ GET: \"apiPanic\" ]\n    }\n\n    path(\"/status\") {\n        action: [ GET: \"apiStatus\" ]\n    }\n}\n\n// Show setup page\ndef pageSetup() {\n    LOG(\"pageSetup()\")\n\n    if (state.version != getVersion()) {\n        return setupInit() ? pageAbout() : pageUninstall()\n    }\n\n    if (getNumZones() == 0) {\n        return pageSelectZones()\n    }\n\n    def alarmStatus = \"Alarm is ${getAlarmStatus()}\"\n\n    def pageProperties = [\n        name:       \"pageSetup\",\n        //title:      \"Status\",\n        nextPage:   null,\n        install:    true,\n        uninstall:  state.installed\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Status\") {\n            if (state.zones.size() > 0) {\n                href \"pageStatus\", title:alarmStatus, description:\"Tap for more information\"\n            } else {\n                paragraph alarmStatus\n            }\n            if (state.history.size() > 0) {\n                href \"pageHistory\", title:\"Event History\", description:\"Tap to view\"\n            }\n        }\n        section(\"Setup Menu\") {\n            href \"pageSelectZones\", title:\"Add/Remove Zones\", description:\"Tap to open\"\n            href \"pageConfigureZones\", title:\"Configure Zones\", description:\"Tap to open\"\n            href \"pageArmingOptions\", title:\"Arming/Disarming Options\", description:\"Tap to open\"\n            href \"pageAlarmOptions\", title:\"Alarm Options\", description:\"Tap to open\"\n            href \"pageNotifications\", title:\"Notification Options\", description:\"Tap to open\"\n            href \"pageRemoteOptions\", title:\"Remote Control Options\", description:\"Tap to open\"\n            href \"pageRestApiOptions\", title:\"REST API Options\", description:\"Tap to open\"\n            href \"pageAbout\", title:\"About Smart Alarm\", description:\"Tap to open\"\n        }\n        section([title:\"Options\", mobileOnly:true]) {\n            label title:\"Assign a name\", required:false\n        }\n    }\n}\n\n// Show \"About\" page\ndef pageAbout() {\n    LOG(\"pageAbout()\")\n\n    def textAbout =\n        \"Version ${getVersion()}\\n${textCopyright()}\\n\\n\" +\n        \"You can contribute to the development of this app by making \" +\n        \"donation to geko@statusbits.com via PayPal.\"\n\n    def hrefInfo = [\n        url:        \"http://statusbits.github.io/smartalarm/\",\n        style:      \"embedded\",\n        title:      \"Tap here for more information...\",\n        description:\"http://statusbits.github.io/smartalarm/\",\n        required:   false\n    ]\n\n    def pageProperties = [\n        name:       \"pageAbout\",\n        //title:      \"About\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"About\") {\n            paragraph textAbout\n            href hrefInfo\n        }\n        section(\"License\") {\n            paragraph textLicense()\n        }\n    }\n}\n\n// Show \"Uninstall\" page\ndef pageUninstall() {\n    LOG(\"pageUninstall()\")\n\n    def text =\n        \"Smart Alarm version ${getVersion()} is not backward compatible \" +\n        \"with the currently installed version. Please uninstall the \" +\n        \"current version by tapping the Uninstall button below, then \" +\n        \"re-install Smart Alarm from the Dashboard. We are sorry for the \" +\n        \"inconvenience.\"\n\n    def pageProperties = [\n        name:       \"pageUninstall\",\n        title:      \"Warning!\",\n        nextPage:   null,\n        uninstall:  true,\n        install:    false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Uninstall Required\") {\n            paragraph text\n        }\n    }\n}\n\n// Show \"Status\" page\ndef pageStatus() {\n    LOG(\"pageStatus()\")\n\n    def pageProperties = [\n        name:       \"pageStatus\",\n        //title:      \"Status\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Status\") {\n            paragraph \"Alarm is ${getAlarmStatus()}\"\n        }\n\n        if (settings.z_contact) {\n            section(\"Contact Sensors\") {\n                settings.z_contact.each() {\n                    def text = getZoneStatus(it, \"contact\")\n                    if (text) {\n                        paragraph text\n                    }\n                }\n            }\n        }\n\n        if (settings.z_motion) {\n            section(\"Motion Sensors\") {\n                settings.z_motion.each() {\n                    def text = getZoneStatus(it, \"motion\")\n                    if (text) {\n                        paragraph text\n                    }\n                }\n            }\n        }\n\n        if (settings.z_movement) {\n            section(\"Movement Sensors\") {\n                settings.z_movement.each() {\n                    def text = getZoneStatus(it, \"acceleration\")\n                    if (text) {\n                        paragraph text\n                    }\n                }\n            }\n        }\n\n        if (settings.z_smoke) {\n            section(\"Smoke & CO Sensors\") {\n                settings.z_smoke.each() {\n                    def text = getZoneStatus(it, \"smoke\")\n                    if (text) {\n                        paragraph text\n                    }\n                }\n            }\n        }\n\n        if (settings.z_water) {\n            section(\"Moisture Sensors\") {\n                settings.z_water.each() {\n                    def text = getZoneStatus(it, \"water\")\n                    if (text) {\n                        paragraph text\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Show \"History\" page\ndef pageHistory() {\n    LOG(\"pageHistory()\")\n\n    def pageProperties = [\n        name:       \"pageHistory\",\n        //title:      \"Event History\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    def history = atomicState.history\n\n    return dynamicPage(pageProperties) {\n        section(\"Event History\") {\n            if (history.size() == 0) {\n                paragraph \"No history available.\"\n            } else {\n                paragraph \"Not implemented\"\n            }\n        }\n    }\n}\n\n// Show \"Add/Remove Zones\" page\ndef pageSelectZones() {\n    LOG(\"pageSelectZones()\")\n\n    def helpPage =\n        \"A security zone is an area of your property protected by a sensor \" +\n        \"(contact, motion, movement, moisture or smoke).\"\n\n    def inputContact = [\n        name:       \"z_contact\",\n        type:       \"capability.contactSensor\",\n        title:      \"Which contact sensors?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMotion = [\n        name:       \"z_motion\",\n        type:       \"capability.motionSensor\",\n        title:      \"Which motion sensors?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMovement = [\n        name:       \"z_movement\",\n        type:       \"capability.accelerationSensor\",\n        title:      \"Which movement sensors?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputSmoke = [\n        name:       \"z_smoke\",\n        type:       \"capability.smokeDetector\",\n        title:      \"Which smoke & CO sensors?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMoisture = [\n        name:       \"z_water\",\n        type:       \"capability.waterSensor\",\n        title:      \"Which moisture sensors?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def pageProperties = [\n        name:       \"pageSelectZones\",\n        //title:      \"Add/Remove Zones\",\n        nextPage:   \"pageConfigureZones\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Add/Remove Zones\") {\n            paragraph helpPage\n            input inputContact\n            input inputMotion\n            input inputMovement\n            input inputSmoke\n            input inputMoisture\n        }\n    }\n}\n\n// Show \"Configure Zones\" page\ndef pageConfigureZones() {\n    LOG(\"pageConfigureZones()\")\n\n    def helpZones =\n        \"Security zones can be configured as either Exterior, Interior, \" +\n        \"Alert or Bypass. Exterior zones are armed in both Away and Stay \" +\n        \"modes, while Interior zones are armed only in Away mode, allowing \" +\n        \"you to move freely inside the premises while the alarm is armed \" +\n        \"in Stay mode. Alert zones are always armed and are typically used \" +\n        \"for smoke and flood alarms. Bypass zones are never armed. This \" +\n        \"allows you to temporarily exclude a zone from your security \" +\n        \"system.\\n\\n\" +\n        \"You can disable Entry and Exit Delays for individual zones.\"\n\n    def zoneTypes = [\"exterior\", \"interior\", \"alert\", \"bypass\"]\n\n    def pageProperties = [\n        name:       \"pageConfigureZones\",\n        //title:      \"Configure Zones\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Configure Zones\") {\n            paragraph helpZones\n        }\n\n        if (settings.z_contact) {\n            def devices = settings.z_contact.sort {it.displayName}\n            devices.each() {\n                def devId = it.id\n                section(\"${it.displayName} (contact)\") {\n                    input \"type_${devId}\", \"enum\", title:\"Zone Type\", metadata:[values:zoneTypes], defaultValue:\"exterior\"\n                    input \"delay_${devId}\", \"bool\", title:\"Entry/Exit Delays\", defaultValue:true\n                }\n            }\n        }\n\n        if (settings.z_motion) {\n            def devices = settings.z_motion.sort {it.displayName}\n            devices.each() {\n                def devId = it.id\n                section(\"${it.displayName} (motion)\") {\n                    input \"type_${devId}\", \"enum\", title:\"Zone Type\", metadata:[values:zoneTypes], defaultValue:\"interior\"\n                    input \"delay_${devId}\", \"bool\", title:\"Entry/Exit Delays\", defaultValue:false\n                }\n            }\n        }\n\n        if (settings.z_movement) {\n            def devices = settings.z_movement.sort {it.displayName}\n            devices.each() {\n                def devId = it.id\n                section(\"${it.displayName} (movement)\") {\n                    input \"type_${devId}\", \"enum\", title:\"Zone Type\", metadata:[values:zoneTypes], defaultValue:\"interior\"\n                    input \"delay_${devId}\", \"bool\", title:\"Entry/Exit Delays\", defaultValue:false\n                }\n            }\n        }\n\n        if (settings.z_smoke) {\n            def devices = settings.z_smoke.sort {it.displayName}\n            devices.each() {\n                def devId = it.id\n                section(\"${it.displayName} (smoke)\") {\n                    input \"type_${devId}\", \"enum\", title:\"Zone Type\", metadata:[values:zoneTypes], defaultValue:\"alert\"\n                    input \"delay_${devId}\", \"bool\", title:\"Entry/Exit Delays\", defaultValue:false\n                }\n            }\n        }\n\n        if (settings.z_water) {\n            def devices = settings.z_water.sort {it.displayName}\n            devices.each() {\n                def devId = it.id\n                section(\"${it.displayName} (moisture)\") {\n                    input \"type_${devId}\", \"enum\", title:\"Zone Type\", metadata:[values:zoneTypes], defaultValue:\"alert\"\n                    input \"delay_${devId}\", \"bool\", title:\"Entry/Exit Delays\", defaultValue:false\n                }\n            }\n        }\n    }\n}\n\n// Show \"Arming/Disarming Options\" page\ndef pageArmingOptions() {\n    LOG(\"pageArmingOptions()\")\n\n    def helpArming =\n        \"Smart Alarm can be armed and disarmed by setting the home Mode. \" +\n        \"There are two arming modes - Stay and Away. Interior zones are \" +\n        \"not armed in Stay mode, allowing you to move freely inside your \" +\n        \"home.\"\n\n    def helpDelay =\n        \"Exit and entry delay allows you to exit the premises after arming \" +\n        \"your alarm system and enter the premises while the alarm system \" +\n        \"is armed without setting off an alarm. You can optionally disable \" +\n        \"entry and exit delay when the alarm is armed in Stay mode.\"\n\n    def inputAwayModes = [\n        name:       \"awayModes\",\n        type:       \"mode\",\n        title:      \"Arm 'Away' in these Modes\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputStayModes = [\n        name:       \"stayModes\",\n        type:       \"mode\",\n        title:      \"Arm 'Stay' in these Modes\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputDisarmModes = [\n        name:       \"disarmModes\",\n        type:       \"mode\",\n        title:      \"Disarm in these Modes\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputDelay = [\n        name:       \"delay\",\n        type:       \"enum\",\n        metadata:   [values:[\"30\",\"45\",\"60\",\"90\"]],\n        title:      \"Delay (in seconds)\",\n        defaultValue: \"30\",\n        required:   true\n    ]\n\n    def inputDelayStay = [\n        name:       \"stayDelayOff\",\n        type:       \"bool\",\n        title:      \"Disable delays in Stay mode\",\n        defaultValue: false,\n        required:   true\n    ]\n\n    def pageProperties = [\n        name:       \"pageArmingOptions\",\n        //title:      \"Arming/Disarming Options\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Arming/Disarming Options\") {\n            paragraph helpArming\n        }\n\n        section(\"Modes\") {\n            input inputAwayModes\n            input inputStayModes\n            input inputDisarmModes\n        }\n\n        section(\"Exit and Entry Delay\") {\n            paragraph helpDelay\n            input inputDelay\n            input inputDelayStay\n        }\n    }\n}\n\n// Show \"Alarm Options\" page\ndef pageAlarmOptions() {\n    LOG(\"pageAlarmOptions()\")\n\n    def helpAlarm =\n        \"You can configure Smart Alarm to take several actions when an \" +\n        \"alarm is set off, such as turning on sirens and light switches, \" +\n        \"taking camera snapshots and executing a 'Hello, Home' action.\"\n\n    def inputAlarms = [\n        name:           \"alarms\",\n        type:           \"capability.alarm\",\n        title:          \"Which sirens?\",\n        multiple:       true,\n        required:       false\n    ]\n\n    def inputSirenMode = [\n        name:           \"sirenMode\",\n        type:           \"enum\",\n        metadata:       [values:[\"Off\",\"Siren\",\"Strobe\",\"Both\"]],\n        title:          \"Choose siren mode\",\n        defaultValue:   \"Both\"\n    ]\n\n    def inputSwitches = [\n        name:           \"switches\",\n        type:           \"capability.switch\",\n        title:          \"Which switches?\",\n        multiple:       true,\n        required:       false\n    ]\n\n    def inputCameras = [\n        name:           \"cameras\",\n        type:           \"capability.imageCapture\",\n        title:          \"Which cameras?\",\n        multiple:       true,\n        required:       false\n    ]\n\n    def hhActions = getHelloHomeActions()\n    def inputHelloHome = [\n        name:           \"helloHomeAction\",\n        type:           \"enum\",\n        title:          \"Which 'Hello, Home' action?\",\n        metadata:       [values: hhActions],\n        required:       false\n    ]\n\n    def pageProperties = [\n        name:       \"pageAlarmOptions\",\n        //title:      \"Alarm Options\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Alarm Options\") {\n            paragraph helpAlarm\n        }\n        section(\"Sirens\") {\n            input inputAlarms\n            input inputSirenMode\n        }\n        section(\"Switches\") {\n            input inputSwitches\n        }\n        section(\"Cameras\") {\n            input inputCameras\n        }\n        section(\"'Hello, Home' Actions\") {\n            input inputHelloHome\n        }\n    }\n}\n\n// Show \"Notification Options\" page\ndef pageNotifications() {\n    LOG(\"pageNotifications()\")\n\n    def helpAbout =\n        \"You can configure Smart Alarm to notify you when it is armed, \" +\n        \"disarmed or when an alarm is set off. Notifications can be send \" +\n        \"using either Push messages, SMS (text) messages and Pushbullet \" +\n        \"messaging service. Smart Alarm can also notify you with sounds or \" +\n        \"voice alerts using compatible audio devices, such as Sonos.\"\n\n    def inputPushAlarm = [\n        name:           \"pushMessage\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   true\n    ]\n\n    def inputPushStatus = [\n        name:           \"pushStatusMessage\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   true\n    ]\n\n    def inputPhone1 = [\n        name:           \"phone1\",\n        type:           \"phone\",\n        title:          \"Send to this number\",\n        required:       false\n    ]\n\n    def inputPhone1Alarm = [\n        name:           \"smsAlarmPhone1\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   false\n    ]\n\n    def inputPhone1Status = [\n        name:           \"smsStatusPhone1\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   false\n    ]\n\n    def inputPhone2 = [\n        name:           \"phone2\",\n        type:           \"phone\",\n        title:          \"Send to this number\",\n        required:       false\n    ]\n\n    def inputPhone2Alarm = [\n        name:           \"smsAlarmPhone2\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   false\n    ]\n\n    def inputPhone2Status = [\n        name:           \"smsStatusPhone2\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   false\n    ]\n\n    def inputPhone3 = [\n        name:           \"phone3\",\n        type:           \"phone\",\n        title:          \"Send to this number\",\n        required:       false\n    ]\n\n    def inputPhone3Alarm = [\n        name:           \"smsAlarmPhone3\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   false\n    ]\n\n    def inputPhone3Status = [\n        name:           \"smsStatusPhone3\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   false\n    ]\n\n    def inputPhone4 = [\n        name:           \"phone4\",\n        type:           \"phone\",\n        title:          \"Send to this number\",\n        required:       false\n    ]\n\n    def inputPhone4Alarm = [\n        name:           \"smsAlarmPhone4\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   false\n    ]\n\n    def inputPhone4Status = [\n        name:           \"smsStatusPhone4\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   false\n    ]\n\n    def inputPushbulletDevice = [\n        name:           \"pushbullet\",\n        type:           \"device.pushbullet\",\n        title:          \"Which Pushbullet devices?\",\n        multiple:       true,\n        required:       false\n    ]\n\n    def inputPushbulletAlarm = [\n        name:           \"pushbulletAlarm\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   true\n    ]\n\n    def inputPushbulletStatus = [\n        name:           \"pushbulletStatus\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   true\n    ]\n\n    def inputAudioPlayers = [\n        name:           \"audioPlayer\",\n        type:           \"capability.musicPlayer\",\n        title:          \"Which audio players?\",\n        multiple:       true,\n        required:       false\n    ]\n\n    def inputSpeechOnAlarm = [\n        name:           \"speechOnAlarm\",\n        type:           \"bool\",\n        title:          \"Notify on Alarm\",\n        defaultValue:   true\n    ]\n\n    def inputSpeechOnStatus = [\n        name:           \"speechOnStatus\",\n        type:           \"bool\",\n        title:          \"Notify on Status Change\",\n        defaultValue:   true\n    ]\n\n    def inputSpeechTextAlarm = [\n        name:           \"speechText\",\n        type:           \"text\",\n        title:          \"Alarm Phrase\",\n        required:       false\n    ]\n\n    def inputSpeechTextArmedAway = [\n        name:           \"speechTextArmedAway\",\n        type:           \"text\",\n        title:          \"Armed Away Phrase\",\n        required:       false\n    ]\n\n    def inputSpeechTextArmedStay = [\n        name:           \"speechTextArmedStay\",\n        type:           \"text\",\n        title:          \"Armed Stay Phrase\",\n        required:       false\n    ]\n\n    def inputSpeechTextDisarmed = [\n        name:           \"speechTextDisarmed\",\n        type:           \"text\",\n        title:          \"Disarmed Phrase\",\n        required:       false\n    ]\n\n    def pageProperties = [\n        name:       \"pageNotifications\",\n        //title:      \"Notification Options\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Notification Options\") {\n            paragraph helpAbout\n        }\n        section(\"Push Notifications\") {\n            input inputPushAlarm\n            input inputPushStatus\n        }\n        section(\"Text Message (SMS) #1\") {\n            input inputPhone1\n            input inputPhone1Alarm\n            input inputPhone1Status\n        }\n        section(\"Text Message (SMS) #2\") {\n            input inputPhone2\n            input inputPhone2Alarm\n            input inputPhone2Status\n        }\n        section(\"Text Message (SMS) #3\") {\n            input inputPhone3\n            input inputPhone3Alarm\n            input inputPhone3Status\n        }\n        section(\"Text Message (SMS) #4\") {\n            input inputPhone4\n            input inputPhone4Alarm\n            input inputPhone4Status\n        }\n        section(\"Pushbullet Notifications\") {\n            input inputPushbulletDevice\n            input inputPushbulletAlarm\n            input inputPushbulletStatus\n        }\n        section(\"Audio Notifications\") {\n            input inputAudioPlayers\n            input inputSpeechOnAlarm\n            input inputSpeechOnStatus\n            input inputSpeechTextAlarm\n            input inputSpeechTextArmedAway\n            input inputSpeechTextArmedStay\n            input inputSpeechTextDisarmed\n        }\n    }\n}\n\n// Show \"Remote Control Options\" page\ndef pageRemoteOptions() {\n    LOG(\"pageRemoteOptions()\")\n\n    def helpRemote =\n        \"You can arm and disarm Smart Alarm using any compatible remote \" +\n        \"control, for example Aeon Labs Minimote.\"\n\n    def inputRemotes = [\n        name:       \"remotes\",\n        type:       \"capability.button\",\n        title:      \"Which remote controls?\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputArmAwayButton = [\n        name:       \"buttonArmAway\",\n        type:       \"number\",\n        title:      \"Which button?\",\n        required:   false\n    ]\n\n    def inputArmAwayHold = [\n        name:       \"holdArmAway\",\n        type:       \"bool\",\n        title:      \"Hold to activate\",\n        defaultValue: false,\n        required:   true\n    ]\n\n    def inputArmStayButton = [\n        name:       \"buttonArmStay\",\n        type:       \"number\",\n        title:      \"Which button?\",\n        required:    false\n    ]\n\n    def inputArmStayHold = [\n        name:       \"holdArmStay\",\n        type:       \"bool\",\n        title:      \"Hold to activate\",\n        defaultValue: false,\n        required:   true\n    ]\n\n    def inputDisarmButton = [\n        name:       \"buttonDisarm\",\n        type:       \"number\",\n        title:      \"Which button?\",\n        required:   false\n    ]\n\n    def inputDisarmHold = [\n        name:       \"holdDisarm\",\n        type:       \"bool\",\n        title:      \"Hold to activate\",\n        defaultValue: false,\n        required:   true\n    ]\n\n    def inputPanicButton = [\n        name:       \"buttonPanic\",\n        type:       \"number\",\n        title:      \"Which button?\",\n        required:   false\n    ]\n\n    def inputPanicHold = [\n        name:       \"holdPanic\",\n        type:       \"bool\",\n        title:      \"Hold to activate\",\n        defaultValue: false,\n        required:   true\n    ]\n\n    def pageProperties = [\n        name:       \"pageRemoteOptions\",\n        //title:      \"Remote Control Options\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Remote Control Options\") {\n            paragraph helpRemote\n            input inputRemotes\n        }\n\n        section(\"Arm Away Button\") {\n            input inputArmAwayButton\n            input inputArmAwayHold\n        }\n\n        section(\"Arm Stay Button\") {\n            input inputArmStayButton\n            input inputArmStayHold\n        }\n\n        section(\"Disarm Button\") {\n            input inputDisarmButton\n            input inputDisarmHold\n        }\n\n        section(\"Panic Button\") {\n            input inputPanicButton\n            input inputPanicHold\n        }\n    }\n}\n\n// Show \"REST API Options\" page\ndef pageRestApiOptions() {\n    LOG(\"pageRestApiOptions()\")\n\n    def textHelp =\n        \"Smart Alarm can be controlled remotely by any Web client using \" +\n        \"REST API. Please refer to Smart Alarm documentation for more \" +\n        \"information.\"\n\n    def textPincode =\n        \"You can specify optional PIN code to protect arming and disarming \" +\n        \"Smart Alarm via REST API from unauthorized access. If set, the \" +\n        \"PIN code is always required for disarming Smart Alarm, however \" +\n        \"you can optionally turn it off for arming Smart Alarm.\"\n\n    def inputRestApi = [\n        name:           \"restApiEnabled\",\n        type:           \"bool\",\n        title:          \"Enable REST API\",\n        defaultValue:   false\n    ]\n\n    def inputPincode = [\n        name:           \"pincode\",\n        type:           \"number\",\n        title:          \"PIN Code\",\n        required:       false\n    ]\n\n    def inputArmWithPin = [\n        name:           \"armWithPin\",\n        type:           \"bool\",\n        title:          \"Require PIN code to arm\",\n        defaultValue:   true\n    ]\n\n    def pageProperties = [\n        name:       \"pageRestApiOptions\",\n        //title:      \"REST API Options\",\n        nextPage:   \"pageSetup\",\n        uninstall:  false\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"REST API Options\") {\n            paragraph textHelp\n            input inputRestApi\n        }\n\n        section(\"PIN Code\") {\n            paragraph textPincode\n            input inputPincode\n            input inputArmWithPin\n        }\n\n        if (isRestApiEnabled()) {\n            section(\"REST API Info\") {\n                paragraph \"App ID:\\n${app.id}\"\n                paragraph \"Access Token:\\n${state.accessToken}\"\n            }\n        }\n    }\n}\n\ndef installed() {\n    LOG(\"installed()\")\n\n    initialize()\n    state.installed = true\n}\n\ndef updated() {\n    LOG(\"updated()\")\n\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\nprivate def setupInit() {\n    LOG(\"setupInit()\")\n\n    if (state.installed == null) {\n        state.installed = false\n        state.armed = false\n        state.zones = []\n        state.alarms = []\n        state.history = []\n    } else {\n        def version = state.version as String\n        if (version == null || version.startsWith('1')) {\n            return false\n        }\n    }\n\n    state.version = getVersion()\n    return true\n}\n\nprivate def initialize() {\n    log.debug \"Smart Alarm. Version ${getVersion()}. ${textCopyright()}\"\n    LOG(\"settings: ${settings}\")\n\n    clearAlarm()\n    state.delay = settings.delay?.toInteger() ?: 30\n    state.offSwitches = []\n    state.history = []\n\n    if (settings.awayModes?.contains(location.mode)) {\n        state.armed = true\n        state.stay = false\n    } else if (settings.stayModes?.contains(location.mode)) {\n        state.armed = true\n        state.stay = true\n    } else {\n        state.armed = false\n        state.stay = false\n    }\n\n    initZones()\n    initButtons()\n    initRestApi()\n    subscribe(location, onLocation)\n\n    STATE()\n}\n\nprivate def clearAlarm() {\n    LOG(\"clearAlarm()\")\n\n    state.alarms = []\n    settings.alarms*.off()\n\n    // Turn off only those switches that we've turned on\n    def switchesOff = state.offSwitches\n    if (switchesOff) {\n        LOG(\"switchesOff: ${switchesOff}\")\n        settings.switches.each() {\n            if (switchesOff.contains(it.id)) {\n                it.off()\n            }\n        }\n        state.offSwitches = []\n    }\n}\n\nprivate def initZones() {\n    LOG(\"initZones()\")\n\n    state.zones = []\n\n    state.zones << [\n        deviceId:   null,\n        sensorType: \"panic\",\n        zoneType:   \"alert\",\n        delay:      false\n    ]\n\n    if (settings.z_contact) {\n        settings.z_contact.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"contact\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"exterior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_contact, \"contact.open\", onContact)\n    }\n\n    if (settings.z_motion) {\n        settings.z_motion.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"motion\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"interior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_motion, \"motion.active\", onMotion)\n    }\n\n    if (settings.z_movement) {\n        settings.z_movement.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"acceleration\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"interior\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_movement, \"acceleration.active\", onMovement)\n    }\n\n    if (settings.z_smoke) {\n        settings.z_smoke.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"smoke\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"alert\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_smoke, \"smoke.detected\", onSmoke)\n        subscribe(settings.z_smoke, \"smoke.tested\", onSmoke)\n        subscribe(settings.z_smoke, \"carbonMonoxide.detected\", onSmoke)\n        subscribe(settings.z_smoke, \"carbonMonoxide.tested\", onSmoke)\n    }\n\n    if (settings.z_water) {\n        settings.z_water.each() {\n            state.zones << [\n                deviceId:   it.id,\n                sensorType: \"water\",\n                zoneType:   settings[\"type_${it.id}\"] ?: \"alert\",\n                delay:      settings[\"delay_${it.id}\"]\n            ]\n        }\n        subscribe(settings.z_water, \"water.wet\", onWater)\n    }\n\n    state.zones.each() {\n        def zoneType = it.zoneType\n\n        if (zoneType == \"alert\") {\n            it.armed = true\n        } else if (zoneType == \"exterior\") {\n            it.armed = state.armed\n        } else if (zoneType == \"interior\") {\n            it.armed = state.armed && !state.stay\n        } else {\n            it.armed = false\n        }\n    }\n}\n\nprivate def initButtons() {\n    LOG(\"initButtons()\")\n\n    state.buttonActions = []\n    if (settings.remotes) {\n        if (settings.buttonArmAway) {\n            def button = settings.buttonArmAway.toInteger()\n            def event = settings.holdArmAway ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"armAway\"]\n        }\n\n        if (settings.buttonArmStay) {\n            def button = settings.buttonArmStay.toInteger()\n            def event = settings.holdArmStay ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"armStay\"]\n        }\n\n        if (settings.buttonDisarm) {\n            def button = settings.buttonDisarm.toInteger()\n            def event = settings.holdDisarm ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"disarm\"]\n        }\n\n        if (settings.buttonPanic) {\n            def button = settings.buttonPanic.toInteger()\n            def event = settings.holdPanic ? \"held\" : \"pushed\"\n            state.buttonActions << [button:button, event:event, action:\"panic\"]\n        }\n\n        if (state.buttonActions) {\n            subscribe(settings.remotes, \"button\", onButtonEvent)\n        }\n    }\n}\n\nprivate def initRestApi() {\n    if (settings.restApiEnabled) {\n        if (!state.accessToken) {\n            def token = createAccessToken()\n            LOG(\"Created new access token: ${token})\")\n        }\n        state.url = \"https://graph.api.smartthings.com/api/smartapps/installations/${app.id}/\"\n        log.debug \"REST API enabled\"\n    } else {\n        state.url = \"\"\n        log.debug \"REST API disabled\"\n    }\n}\n\nprivate def isRestApiEnabled() {\n    return settings.restApiEnabled && state.accessToken\n}\n\ndef onContact(evt)  { onZoneEvent(evt, \"contact\") }\ndef onMotion(evt)   { onZoneEvent(evt, \"motion\") }\ndef onMovement(evt) { onZoneEvent(evt, \"acceleration\") }\ndef onSmoke(evt)    { onZoneEvent(evt, \"smoke\") }\ndef onWater(evt)    { onZoneEvent(evt, \"water\") }\n\nprivate def onZoneEvent(evt, sensorType) {\n    LOG(\"onZoneEvent(${evt.displayName}, ${sensorType})\")\n\n    def zone = getZoneForDevice(evt.deviceId, sensorType)\n    if (!zone) {\n        log.warn \"Cannot find zone for device ${evt.deviceId}\"\n        return\n    }\n\n    if (zone.armed) {\n        state.alarms << evt.displayName\n        if (zone.zoneType == \"alert\" || !zone.delay || (state.stay && settings.stayDelayOff)) {\n            activateAlarm()\n        } else {\n            myRunIn(state.delay, activateAlarm)\n        }\n    }\n}\n\ndef onLocation(evt) {\n    LOG(\"onLocation(${evt.value})\")\n\n    String mode = evt.value\n    if (settings.awayModes?.contains(mode)) {\n        armAway()\n    } else if (settings.stayModes?.contains(mode)) {\n        armStay()\n    } else if (settings.disarmModes?.contains(mode)) {\n        disarm()\n    }\n}\n\ndef onButtonEvent(evt) {\n    LOG(\"onButtonEvent(${evt.displayName})\")\n\n    if (!state.buttonActions || !evt.data) {\n        return\n    }\n\n    def slurper = new JsonSlurper()\n    def data = slurper.parseText(evt.data)\n    def button = data.buttonNumber?.toInteger()\n    if (button) {\n        LOG(\"Button '${button}' was ${evt.value}.\")\n        def item = state.buttonActions.find {\n            it.button == button && it.event == evt.value\n        }\n\n        if (item) {\n            LOG(\"Executing '${item.action}' button action\")\n            \"${item.action}\"()\n        }\n    }\n}\n\ndef armAway() {\n    LOG(\"armAway()\")\n\n    if (!atomicState.armed || atomicState.stay) {\n        armPanel(false)\n    }\n}\n\ndef armStay() {\n    LOG(\"armStay()\")\n\n    if (!atomicState.armed || !atomicState.stay) {\n        armPanel(true)\n    }\n}\n\ndef disarm() {\n    LOG(\"disarm()\")\n\n    if (atomicState.armed) {\n        state.armed = false\n        state.zones.each() {\n            if (it.zoneType != \"alert\") {\n                it.armed = false\n            }\n        }\n\n        reset()\n    }\n}\n\ndef panic() {\n    LOG(\"panic()\")\n\n    state.alarms << \"Panic\"\n    activateAlarm()\n}\n\ndef reset() {\n    LOG(\"reset()\")\n\n    unschedule()\n    clearAlarm()\n\n    // Send notification\n    def msg = \"${location.name} is \"\n    if (state.armed) {\n        msg += \"ARMED \"\n        msg += state.stay ? \"STAY\" : \"AWAY\"\n    } else {\n        msg += \"DISARMED.\"\n    }\n\n    notify(msg)\n    notifyVoice()\n}\n\ndef exitDelayExpired() {\n    LOG(\"exitDelayExpired()\")\n\n    def armed = atomicState.armed\n    def stay = atomicState.stay\n    if (!armed) {\n        log.warn \"exitDelayExpired: unexpected state!\"\n        STATE()\n        return\n    }\n\n    state.zones.each() {\n        def zoneType = it.zoneType\n        if (zoneType == \"exterior\" || (zoneType == \"interior\" && !stay)) {\n            it.armed = true\n        }\n    }\n\n    def msg = \"${location.name}: all \"\n    if (stay) {\n        msg += \"exterior \"\n    }\n    msg += \"zones are armed.\"\n\n    notify(msg)\n}\n\nprivate def armPanel(stay) {\n    LOG(\"armPanel(${stay})\")\n\n    unschedule()\n    clearAlarm()\n\n    state.armed = true\n    state.stay = stay\n\n    def armDelay = false\n    state.zones.each() {\n        def zoneType = it.zoneType\n        if (zoneType == \"exterior\") {\n            if (it.delay) {\n                it.armed = false\n                armDelay = true\n            } else {\n                it.armed = true\n            }\n        } else if (zoneType == \"interior\") {\n            if (stay) {\n                it.armed = false\n            } else if (it.delay) {\n                it.armed = false\n                armDelay = true\n            } else {\n                it.armed = true\n            }\n        }\n    }\n\n    def delay = armDelay && !(stay && settings.stayDelayOff) ? atomicState.delay : 0\n    if (delay) {\n        myRunIn(delay, exitDelayExpired)\n    }\n\n    def mode = stay ? \"STAY\" : \"AWAY\"\n    def msg = \"${location.name} \"\n    if (delay) {\n        msg += \"will arm ${mode} in ${state.delay} seconds.\"\n    } else {\n        msg += \"is ARMED ${mode}.\"\n    }\n\n    notify(msg)\n    notifyVoice()\n}\n\n// .../armaway REST API endpoint\ndef apiArmAway() {\n    LOG(\"apiArmAway()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && settings.armWithPin && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    armAway()\n    return apiStatus()\n}\n\n// .../armstay REST API endpoint\ndef apiArmStay() {\n    LOG(\"apiArmStay()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && settings.armWithPin && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    armStay()\n    return apiStatus()\n}\n\n// .../disarm REST API endpoint\ndef apiDisarm() {\n    LOG(\"apiDisarm()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    if (settings.pincode && (params.pincode != settings.pincode.toString())) {\n        log.error \"Invalid PIN code '${params.pincode}'\"\n        return httpError(403, \"Access denied\")\n    }\n\n    disarm()\n    return apiStatus()\n}\n\n// .../panic REST API endpoint\ndef apiPanic() {\n    LOG(\"apiPanic()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    panic()\n    return apiStatus()\n}\n\n// .../status REST API endpoint\ndef apiStatus() {\n    LOG(\"apiStatus()\")\n\n    if (!isRestApiEnabled()) {\n        log.error \"REST API disabled\"\n        return httpError(403, \"Access denied\")\n    }\n\n    def status = [\n        status: state.armed ? (state.stay ? \"armed stay\" : \"armed away\") : \"disarmed\",\n        alarms: state.alarms\n    ]\n\n    return status\n}\n\ndef activateAlarm() {\n    LOG(\"activateAlarm()\")\n\n    if (state.alarms.size() == 0) {\n        log.warn \"activateAlarm: false alarm\"\n        return\n    }\n\n    switch (settings.sirenMode) {\n    case \"Siren\":\n        settings.alarms*.siren()\n        break\n\n    case \"Strobe\":\n        settings.alarms*.strobe()\n        break\n\n    case \"Both\":\n        settings.alarms*.both()\n        break\n    }\n\n    // Only turn on those switches that are currently off\n    def switchesOn = settings.switches?.findAll { it?.currentSwitch == \"off\" }\n    LOG(\"switchesOn: ${switchesOn}\")\n    if (switchesOn) {\n        switchesOn*.on()\n        state.offSwitches = switchesOn.collect { it.id }\n    }\n\n    settings.cameras*.take()\n\n    if (settings.helloHomeAction) {\n        log.debug \"Executing HelloHome action '${settings.helloHomeAction}'\"\n        location.helloHome.execute(settings.helloHomeAction)\n    }\n\n    def msg = \"Alarm at ${location.name}!\"\n    state.alarms.each() {\n        msg += \"\\n${it}\"\n    }\n\n    notify(msg)\n    notifyVoice()\n\n    myRunIn(180, reset)\n}\n\nprivate def notify(msg) {\n    LOG(\"notify(${msg})\")\n\n    log.debug msg\n\n    if (state.alarms.size()) {\n        // Alarm notification\n        if (settings.pushMessage) {\n            mySendPush(msg)\n        } else {\n            sendNotificationEvent(msg)\n        }\n\n        if (settings.smsAlarmPhone1 && settings.phone1) {\n            sendSms(phone1, msg)\n        }\n\n        if (settings.smsAlarmPhone2 && settings.phone2) {\n            sendSms(phone2, msg)\n        }\n\n        if (settings.smsAlarmPhone3 && settings.phone3) {\n            sendSms(phone3, msg)\n        }\n\n        if (settings.smsAlarmPhone4 && settings.phone4) {\n            sendSms(phone4, msg)\n        }\n\n        if (settings.pushbulletAlarm && settings.pushbullet) {\n            settings.pushbullet*.push(location.name, msg)\n        }\n    } else {\n        // Status change notification\n        if (settings.pushStatusMessage) {\n            mySendPush(msg)\n        } else {\n            sendNotificationEvent(msg)\n        }\n\n        if (settings.smsStatusPhone1 && settings.phone1) {\n            sendSms(phone1, msg)\n        }\n\n        if (settings.smsStatusPhone2 && settings.phone2) {\n            sendSms(phone2, msg)\n        }\n\n        if (settings.smsStatusPhone3 && settings.phone3) {\n            sendSms(phone3, msg)\n        }\n\n        if (settings.smsStatusPhone4 && settings.phone4) {\n            sendSms(phone4, msg)\n        }\n\n        if (settings.pushbulletStatus && settings.pushbullet) {\n            settings.pushbullet*.push(location.name, msg)\n        }\n    }\n}\n\nprivate def notifyVoice() {\n    LOG(\"notifyVoice()\")\n\n    if (!settings.audioPlayer) {\n        return\n    }\n\n    def phrase = null\n    if (state.alarms.size()) {\n        // Alarm notification\n        if (settings.speechOnAlarm) {\n            phrase = settings.speechText ?: getStatusPhrase()\n        }\n    } else {\n        // Status change notification\n        if (settings.speechOnStatus) {\n            if (state.armed) {\n                if (state.stay) {\n                    phrase = settings.speechTextArmedStay ?: getStatusPhrase()\n                } else {\n                    phrase = settings.speechTextArmedAway ?: getStatusPhrase()\n                }\n            } else {\n                phrase = settings.speechTextDisarmed ?: getStatusPhrase()\n            }\n        }\n    }\n\n    if (phrase) {\n        settings.audioPlayer*.playText(phrase)\n    }\n}\n\nprivate def history(String event, String description = \"\") {\n    LOG(\"history(${event}, ${description})\")\n\n    def history = atomicState.history\n    history << [time: now(), event: event, description: description]\n    if (history.size() > 10) {\n        history = history.sort{it.time}\n        history = history[1..-1]\n    }\n\n    LOG(\"history: ${history}\")\n    state.history = history\n}\n\nprivate def getStatusPhrase() {\n    LOG(\"getStatusPhrase()\")\n\n    def phrase = \"\"\n    if (state.alarms.size()) {\n        phrase = \"Alarm at ${location.name}!\"\n        state.alarms.each() {\n            phrase += \" ${it}.\"\n        }\n    } else {\n        phrase = \"${location.name} security is \"\n        if (state.armed) {\n            def mode = state.stay ? \"stay\" : \"away\"\n            phrase += \"armed in ${mode} mode.\"\n        } else {\n            phrase += \"disarmed.\"\n        }\n    }\n\n    return phrase\n}\n\nprivate def getHelloHomeActions() {\n    def actions = location.helloHome?.getPhrases().collect() { it.label }\n    return actions.sort()\n}\n\nprivate def getAlarmStatus() {\n    def alarmStatus\n\n    if (atomicState.armed) {\n        alarmStatus = \"ARMED \"\n        alarmStatus += atomicState.stay ? \"STAY\" : \"AWAY\"\n    } else {\n        alarmStatus = \"DISARMED\"\n    }\n\n    return alarmStatus\n}\n\nprivate def getZoneStatus(device, sensorType) {\n\n    def zone = getZoneForDevice(device.id, sensorType)\n    if (!zone) {\n        return null\n    }\n\n    def str = \"${device.displayName}: ${zone.zoneType}, \"\n    str += zone.armed ? \"armed, \" : \"disarmed, \"\n    str += device.currentValue(sensorType)\n\n    return str\n}\n\nprivate def getZoneForDevice(id, sensorType) {\n    return state.zones.find() { it.deviceId == id && it.sensorType == sensorType }\n}\n\nprivate def isZoneReady(device, sensorType) {\n    def ready\n\n    switch (sensorType) {\n    case \"contact\":\n        ready = \"closed\".equals(device.currentValue(\"contact\"))\n        break\n\n    case \"motion\":\n        ready = \"inactive\".equals(device.currentValue(\"motion\"))\n        break\n\n    case \"acceleration\":\n        ready = \"inactive\".equals(device.currentValue(\"acceleration\"))\n        break\n\n    case \"smoke\":\n        ready = \"clear\".equals(device.currentValue(\"smoke\"))\n        break\n\n    case \"water\":\n        ready = \"dry\".equals(device.currentValue(\"water\"))\n        break\n\n    default:\n        ready = false\n    }\n\n    return ready\n}\n\nprivate def getDeviceById(id, sensorType) {\n    switch (sensorType) {\n    case \"contact\":\n        return settings.z_contact?.find() { it.id == id }\n\n    case \"motion\":\n        return settings.z_motion?.find() { it.id == id }\n\n    case \"acceleration\":\n        return settings.z_movement?.find() { it.id == id }\n\n    case \"smoke\":\n        return settings.z_smoke?.find() { it.id == id }\n\n    case \"water\":\n        return settings.z_water?.find() { it.id == id }\n    }\n\n    return null\n}\n\nprivate def getNumZones() {\n    def numZones = 0\n\n    numZones += settings.z_contact?.size() ?: 0\n    numZones += settings.z_motion?.size() ?: 0\n    numZones += settings.z_movement?.size() ?: 0\n    numZones += settings.z_smoke?.size() ?: 0\n    numZones += settings.z_water?.size() ?: 0\n\n    return numZones\n}\n\nprivate def myRunIn(delay_s, func) {\n    if (delay_s > 0) {\n        def date = new Date(now() + (delay_s * 1000))\n        runOnce(date, func)\n        LOG(\"scheduled '${func}' to run at ${date}\")\n    }\n}\n\nprivate def mySendPush(msg) {\n    // sendPush can throw an exception\n    try {\n        sendPush(msg)\n    } catch (e) {\n        log.error e\n    }\n}\n\nprivate def getVersion() {\n    return \"2.4.3\"\n}\n\nprivate def textCopyright() {\n    def text = \"Copyright © 2014 Statusbits.com\"\n}\n\nprivate def textLicense() {\n    def text =\n        \"This program is free software: you can redistribute it and/or \" +\n        \"modify it under the terms of the GNU General Public License as \" +\n        \"published by the Free Software Foundation, either version 3 of \" +\n        \"the License, or (at your option) any later version.\\n\\n\" +\n        \"This program is distributed in the hope that it will be useful, \" +\n        \"but WITHOUT ANY WARRANTY; without even the implied warranty of \" +\n        \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU \" +\n        \"General Public License for more details.\\n\\n\" +\n        \"You should have received a copy of the GNU General Public License \" +\n        \"along with this program. If not, see <http://www.gnu.org/licenses/>.\"\n}\n\nprivate def LOG(message) {\n    //log.trace message\n}\n\nprivate def STATE() {\n    //log.trace \"state: ${state}\"\n}",
        "docstring": "Tap for more information"
    },
    {
        "code": "section(\"Choose the Stelpro thermostats that will receive the remote device's temperature... \") {\n\t\tinput \"thermostats\", \"capability.thermostat\", title: \"Select Stelpro Thermostats\", multiple: true, required: true\n\t}\n}\n\ndef installed()\n{\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n\tlog.debug \"enter installed, state: $state\"\n}\n\ndef updated()\n{\n\tlog.debug \"enter updated, state: $state\"\n\tunsubscribe()\n\tsubscribe(sensor, \"temperature\", temperatureHandler)\n}\n\ndef temperatureHandler(event)\n{\n\tlog.debug \"temperature received from remote device: ${event?.value}\"\n\tif (event?.value) {\n\t\tthermostats?.setOutdoorTemperature(event.value)\n\t}\n}",
        "docstring": "Retrieves the temperature from a sensor and sends it to a specific Stelpro thermostat."
    },
    {
        "code": "section(\"Zip code (for sunrise/sunset)\") {\n       \t\tinput \"zip\", \"decimal\", required: true\n      \t}\n    \n          section(\"Notifications\") {\n            input \"sendPushMessage\", \"enum\", title: \"Send a push notification when house is empty?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n            input \"sendPushMessageHome\", \"enum\", title: \"Send a push notification when home is occupied?\", metadata:[values:[\"Yes\",\"No\"]], required:false\n      \t}\n    \n        section(title: \"More options\", hidden: hideOptionsSection(), hideable: true) {\n        \t\tlabel title: \"Assign a name\", required: false\n    \t\t\tinput \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n    \t\t\t\toptions: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    \t\t\tinput \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n    \t\t}\n      }\n    }\n    \n    def selectPhrases() {\n    \tdef configured = (settings.awayDay && settings.awayNight && settings.homeDay && settings.homeNight)\n        dynamicPage(name: \"selectPhrases\", title: \"Configure\", nextPage:\"Settings\", uninstall: true) {\t\t\n    \t\tsection(\"Who?\") {\n    \t\t\tinput \"people\", \"capability.presenceSensor\", title: \"Monitor These Presences\", required: true, multiple: true,  submitOnChange:true\n    \t\t}\n            \n    \t\tdef phrases = location.helloHome?.getPhrases()*.label\n    \t\tif (phrases) {\n            \tphrases.sort()\n    \t\t\tsection(\"Run This Phrase When...\") {\n    \t\t\t\tlog.trace phrases\n    \t\t\t\tinput \"awayDay\", \"enum\", title: \"Everyone Is Away And It's Day\", required: true, options: phrases,  submitOnChange:true\n    \t\t\t\tinput \"awayNight\", \"enum\", title: \"Everyone Is Away And It's Night\", required: true, options: phrases,  submitOnChange:true\n                    input \"homeDay\", \"enum\", title: \"At Least One Person Is Home And It's Day\", required: true, options: phrases,  submitOnChange:true\n                    input \"homeNight\", \"enum\", title: \"At Least One Person Is Home And It's Night\", required: true, options: phrases,  submitOnChange:true\n    \t\t\t}\n                section(\"Select modes used for each condition. (Needed for better app logic)\") {\n            input \"homeModeDay\", \"mode\", title: \"Select Mode Used for 'Home Day'\", required: true\n            input \"homeModeNight\", \"mode\", title: \"Select Mode Used for 'Home Night'\", required: true\n      \t}\n    \t\t}\n        }\n    }\n    \n    def installed() {\n      initialize()\n    \n    }\n    \n    def updated() {\n      unsubscribe()\n      initialize()\n    }\n    \n    def initialize() {\n    \tsubscribe(people, \"presence\", presence)\n        runIn(60, checkSun)\n    \tsubscribe(location, \"sunrise\", setSunrise)\n    \tsubscribe(location, \"sunset\", setSunset)\n    }\n    \n    //check current sun state when installed.\n    def checkSun() {\n      def zip     = settings.zip as String\n      def sunInfo = getSunriseAndSunset(zipCode: zip)\n     def current = now()\n    \n    if (sunInfo.sunrise.time < current && sunInfo.sunset.time > current) {\n        state.sunMode = \"sunrise\"\n       setSunrise()\n      }\n      \n    else {\n       state.sunMode = \"sunset\"\n        setSunset()\n      }\n    }\n    \n    //change to sunrise mode on sunrise event\n    def setSunrise(evt) {\n      state.sunMode = \"sunrise\";\n      changeSunMode(newMode);\n    }\n    \n    //change to sunset mode on sunset event\n    def setSunset(evt) {\n      state.sunMode = \"sunset\";\n      changeSunMode(newMode)\n    }\n    \n    //change mode on sun event\n    def changeSunMode(newMode) {\n      if(allOk) {\n    \n      if(everyoneIsAway() && (state.sunMode == \"sunrise\")) {\n        log.debug(\"Home is Empty  Setting New Away Mode\")\n        def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n        runIn(delay, \"setAway\")\n      }\n    \n      if(everyoneIsAway() && (state.sunMode == \"sunset\")) {\n        log.debug(\"Home is Empty  Setting New Away Mode\")\n        def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n        runIn(delay, \"setAway\")\n      }\n      \n      else {\n      log.debug(\"Home is Occupied Setting New Home Mode\")\n      setHome()\n    \n    \n      }\n    }\n    }\n    \n    //presence change run logic based on presence state of home\n    def presence(evt) {\n      if(allOk) {\n      if(evt.value == \"not present\") {\n        log.debug(\"Checking if everyone is away\")\n    \n        if(everyoneIsAway()) {\n          log.debug(\"Nobody is home, running away sequence\")\n          def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60 \n          runIn(delay, \"setAway\")\n        }\n      }\n    \n    else {\n    \tdef lastTime = state[evt.deviceId]\n        if (lastTime == null || now() - lastTime >= 1 * 60000) {\n      \t\tlog.debug(\"Someone is home, running home sequence\")\n      \t\tsetHome()\n        }    \n    \tstate[evt.deviceId] = now()\n    \n      }\n    }\n    }\n    \n    //if empty set home to one of the away modes\n    def setAway() {\n      if(everyoneIsAway()) {\n        if(state.sunMode == \"sunset\") {\n          def message = \"Performing \\\"${awayNight}\\\" for you as requested.\"\n          log.debug(message)\n          sendAway(message)\n          location.helloHome.execute(settings.awayNight)\n        }\n        \n        else if(state.sunMode == \"sunrise\") {\n          def message = \"Performing \\\"${awayDay}\\\" for you as requested.\"\n          log.debug(message)\n          sendAway(message)\n          location.helloHome.execute(settings.awayDay)\n          }\n        else {\n          log.debug(\"Mode is the same, not evaluating\")\n        }\n      }\n    \n      else {\n        log.debug(\"Somebody returned home before we set to '${newAwayMode}'\")\n      }\n    }\n    \n    //set home mode when house is occupied\n    def setHome() {\n    sendOutOfDateNotification()\n    log.debug(\"Setting Home Mode!!\")\n    if(anyoneIsHome()) {\n          if(state.sunMode == \"sunset\"){\n          if (location.mode != \"${homeModeNight}\"){\n          def message = \"Performing \\\"${homeNight}\\\" for you as requested.\"\n            log.debug(message)\n            sendHome(message)\n            location.helloHome.execute(settings.homeNight)\n            }\n           }\n           \n          if(state.sunMode == \"sunrise\"){\n          if (location.mode != \"${homeModeDay}\"){\n          def message = \"Performing \\\"${homeDay}\\\" for you as requested.\"\n            log.debug(message)\n            sendHome(message)\n            location.helloHome.execute(settings.homeDay)\n                }\n          }      \n        }\n        \n    }\n    \n    private everyoneIsAway() {\n      def result = true\n    \n      if(people.findAll { it?.currentPresence == \"present\" }) {\n        result = false\n      }\n    \n      log.debug(\"everyoneIsAway: ${result}\")\n    \n      return result\n    }\n    \n    private anyoneIsHome() {\n      def result = false\n    \n      if(people.findAll { it?.currentPresence == \"present\" }) {\n        result = true\n      }\n    \n      log.debug(\"anyoneIsHome: ${result}\")\n    \n      return result\n    }\n    \n    def sendAway(msg) {\n      if(sendPushMessage != \"No\") {\n        log.debug(\"Sending push message\")\n        sendPush(msg)\n      }\n    \n      log.debug(msg)\n    }\n    \n    def sendHome(msg) {\n      if(sendPushMessageHome != \"No\") {\n        log.debug(\"Sending push message\")\n        sendPush(msg)\n      }\n    \n      log.debug(msg)\n    }\n    \n    private getAllOk() {\n    \tmodeOk && daysOk && timeOk\n    }\n    \n    private getModeOk() {\n    \tdef result = !modes || modes.contains(location.mode)\n    \tlog.trace \"modeOk = $result\"\n    \tresult\n    }\n    \n    private getDaysOk() {\n    \tdef result = true\n    \tif (days) {\n    \t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n    \t\tif (location.timeZone) {\n    \t\t\tdf.setTimeZone(location.timeZone)\n    \t\t}\n    \t\telse {\n    \t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n    \t\t}\n    \t\tdef day = df.format(new Date())\n    \t\tresult = days.contains(day)\n    \t}\n    \tlog.trace \"daysOk = $result\"\n    \tresult\n    }\n    \n    private getTimeOk() {\n    \tdef result = true\n    \tif (starting && ending) {\n    \t\tdef currTime = now()\n    \t\tdef start = timeToday(starting, location?.timeZone).time\n    \t\tdef stop = timeToday(ending, location?.timeZone).time\n    \t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n    \t}\n    \tlog.trace \"timeOk = $result\"\n    \tresult\n    }\n    \n    private hhmm(time, fmt = \"h:mm a\")\n    {\n    \tdef t = timeToday(time, location.timeZone)\n    \tdef f = new java.text.SimpleDateFormat(fmt)\n    \tf.setTimeZone(location.timeZone ?: timeZone(time))\n    \tf.format(t)\n    }\n    \n    private getTimeIntervalLabel()\n    {\n    \t(starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\") : \"\"\n    }\n    \n    private hideOptionsSection() {\n    \t(starting || ending || days || modes) ? false : true\n    }\n    \n    def sendOutOfDateNotification(){\n    \tif(!state.lastTime){\n    \t\tstate.lastTime = (new Date() + 31).getTime()\n            sendNotification(\"Your version of Hello, Home Phrase Director is currently out of date. Please look for the new version of Hello, Home Phrase Director now called 'Routine Director' in the marketplace.\")\n        }\n        else if (((new Date()).getTime()) >= state.lastTime){\n        \tsendNotification(\"Your version of Hello, Home Phrase Director is currently out of date. Please look for the new version of Hello, Home Phrase Director now called 'Routine Director' in the marketplace.\")\n        \tstate.lastTime = (new Date() + 31).getTime()\n        }\n    }",
        "docstring": "Monitor a set of presence sensors and activate Hello, Home phrases based on whether your home is empty or occupied.  Each presence status change will check against the current 'sun state' to run phrases based on occupancy and whether the sun is up or down."
    },
    {
        "code": "section([title:\"Options\", mobileOnly:true]) {\n            label title:\"Assign a name\", required:false\n        }\n    }\n}\n\n// Show \"pageSetupScenarioA\" page\ndef pageSetupScenarioA() {\n\n    def inputLightsA = [\n        name:       \"A_switches\",\n        type:       \"capability.switch\",\n        title:      \"Control the following switches...\",\n        multiple:   true,\n        required:   false\n    ]\n    def inputDimmersA = [\n        name:       \"A_dimmers\",\n        type:       \"capability.switchLevel\",\n        title:      \"Dim the following...\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMotionA = [\n        name:       \"A_motion\",\n        type:       \"capability.motionSensor\",\n        title:      \"Using these motion sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n\tdef inputAccelerationA = [\n\t\tname:       \"A_acceleration\",\n\t\ttype:       \"capability.accelerationSensor\",\n\t\ttitle:      \"Or using these acceleration sensors...\",\n\t\tmultiple:   true,\n\t\trequired:   false\n\t]\n    def inputContactA = [\n        name:       \"A_contact\",\n        type:       \"capability.contactSensor\",\n        title:      \"Or using these contact sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputTriggerOnceA = [\n    \tname:       \"A_triggerOnce\",\n        type:       \"bool\",\n        title:      \"Trigger only once per day...\",\n        defaultValue:false\n    ]\n    \n    def inputSwitchDisableA = [\n    \tname:       \"A_switchDisable\",\n        type:       \"bool\",\n        title:      \"Stop triggering if physical switches/dimmers are turned off...\",\n        defaultValue:false\n    ]\n    \n    def inputLockA = [\n        name:       \"A_lock\",\n        type:       \"capability.lock\",\n        title:      \"Or using these locks...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputModeA = [\n        name:       \"A_mode\",\n        type:       \"mode\",\n        title:      \"Only during the following modes...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputDayA = [\n        name:       \"A_day\",\n        type:       \"enum\",\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        title:      \"Only on certain days of the week...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    \n    def inputLevelA = [\n        name:       \"A_level\",\n        type:       \"enum\",\n        options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],\n        title:      \"Set dimmers to this level\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputTurnOnLuxA = [\n        name:       \"A_turnOnLux\",\n        type:       \"number\",\n        title:      \"Only run this scenario if lux is below...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputLuxSensorsA = [\n        name:       \"A_luxSensors\",\n        type:       \"capability.illuminanceMeasurement\",\n        title:      \"On these lux sensors\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputTurnOffA = [\n        name:       \"A_turnOff\",\n        type:       \"number\",\n        title:      \"Turn off this scenario after motion stops or doors close/lock (minutes)...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputScenarioNameA = [\n        name:       \"ScenarioNameA\",\n        type:       \"text\",\n        title:      \"Scenario Name\",\n        multiple:   false,\n        required:   false,\n        defaultValue: empty\n    ]\n    \n    def pageProperties = [\n        name:       \"pageSetupScenarioA\",\n    ]\n\n    return dynamicPage(pageProperties) {\nsection(\"Name your scenario\") {\n            input inputScenarioNameA\n        }\n\nsection(\"Devices included in the scenario\") {\n            input inputMotionA\n\t\t\tinput inputAccelerationA\n            input inputContactA\n            input inputLockA\n            input inputLightsA\n            input inputDimmersA\n            }\n\nsection(\"Scenario settings\") {\n            input inputLevelA\n            input inputTurnOnLuxA\n            input inputLuxSensorsA\n            input inputTurnOffA\n            }\n            \nsection(\"Scenario restrictions\") {            \n            input inputTriggerOnceA\n            input inputSwitchDisableA\n            href \"timeIntervalInputA\", title: \"Only during a certain time...\", description: getTimeLabel(A_timeStart, A_timeEnd), state: greyedOutTime(A_timeStart, A_timeEnd), refreshAfterSelection:true\n            input inputDayA\n            input inputModeA\n            }\n\nsection(\"Help\") {\n            paragraph helpText()\n            }\n    }\n    \n}\n\ndef pageSetupScenarioB() {\n\n    def inputLightsB = [\n        name:       \"B_switches\",\n        type:       \"capability.switch\",\n        title:      \"Control the following switches...\",\n        multiple:   true,\n        required:   false\n    ]\n    def inputDimmersB = [\n        name:       \"B_dimmers\",\n        type:       \"capability.switchLevel\",\n        title:      \"Dim the following...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputTurnOnLuxB = [\n        name:       \"B_turnOnLux\",\n        type:       \"number\",\n        title:      \"Only run this scenario if lux is below...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputLuxSensorsB = [\n        name:       \"B_luxSensors\",\n        type:       \"capability.illuminanceMeasurement\",\n        title:      \"On these lux sensors\",\n        multiple:   false,\n        required:   false\n    ]\n\n    def inputMotionB = [\n        name:       \"B_motion\",\n        type:       \"capability.motionSensor\",\n        title:      \"Using these motion sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n\tdef inputAccelerationB = [\n\t\tname:       \"B_acceleration\",\n\t\ttype:       \"capability.accelerationSensor\",\n\t\ttitle:      \"Or using these acceleration sensors...\",\n\t\tmultiple:   true,\n\t\trequired:   false\n\t]\n    def inputContactB = [\n        name:       \"B_contact\",\n        type:       \"capability.contactSensor\",\n        title:      \"Or using these contact sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputTriggerOnceB = [\n    \tname:       \"B_triggerOnce\",\n        type:       \"bool\",\n        title:      \"Trigger only once per day...\",\n        defaultValue:false\n    ]\n    \n    def inputSwitchDisableB = [\n    \tname:       \"B_switchDisable\",\n        type:       \"bool\",\n        title:      \"Stop triggering if physical switches/dimmers are turned off...\",\n        defaultValue:false\n    ]\n    \n    def inputLockB = [\n        name:       \"B_lock\",\n        type:       \"capability.lock\",\n        title:      \"Or using these locks...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputModeB = [\n        name:       \"B_mode\",\n        type:       \"mode\",\n        title:      \"Only during the following modes...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputDayB = [\n        name:       \"B_day\",\n        type:       \"enum\",\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        title:      \"Only on certain days of the week...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputLevelB = [\n        name:       \"B_level\",\n        type:       \"enum\",\n        options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],\n        title:      \"Set dimmers to this level\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputTurnOffB = [\n        name:       \"B_turnOff\",\n        type:       \"number\",\n        title:      \"Turn off this scenario after motion stops or doors close/lock (minutes)...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputScenarioNameB = [\n        name:       \"ScenarioNameB\",\n        type:       \"text\",\n        title:      \"Scenario Name\",\n        multiple:   false,\n        required:   false,\n        defaultValue: empty\n    ]\n    \n    def pageProperties = [\n        name:       \"pageSetupScenarioB\",\n    ]\n\n    return dynamicPage(pageProperties) {\nsection(\"Name your scenario\") {\n            input inputScenarioNameB\n        }\n\nsection(\"Devices included in the scenario\") {\n            input inputMotionB\n\t\t\tinput inputAccelerationB\n\t\t\tinput inputContactB\n            input inputLockB\n            input inputLightsB\n            input inputDimmersB\n            }\n\nsection(\"Scenario settings\") {\n            input inputLevelB\n            input inputTurnOnLuxB\n            input inputLuxSensorsB\n            input inputTurnOffB\n            }\n            \nsection(\"Scenario restrictions\") {    \n\t\t\tinput inputTriggerOnceB\n            input inputSwitchDisableB\n            href \"timeIntervalInputB\", title: \"Only during a certain time...\", description: getTimeLabel(B_timeStart, B_timeEnd), state: greyedOutTime(B_timeStart, B_timeEnd), refreshAfterSelection:true\n            input inputDayB\n            input inputModeB\n            }\n\nsection(\"Help\") {\n            paragraph helpText()\n            }\n    }\n}\n\ndef pageSetupScenarioC() {\n\n    def inputLightsC = [\n        name:       \"C_switches\",\n        type:       \"capability.switch\",\n        title:      \"Control the following switches...\",\n        multiple:   true,\n        required:   false\n    ]\n    def inputDimmersC = [\n        name:       \"C_dimmers\",\n        type:       \"capability.switchLevel\",\n        title:      \"Dim the following...\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMotionC = [\n        name:       \"C_motion\",\n        type:       \"capability.motionSensor\",\n        title:      \"Using these motion sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n\tdef inputAccelerationC = [\n\t\tname:       \"C_acceleration\",\n\t\ttype:       \"capability.accelerationSensor\",\n\t\ttitle:      \"Or using these acceleration sensors...\",\n\t\tmultiple:   true,\n\t\trequired:   false\n\t]\n    def inputContactC = [\n        name:       \"C_contact\",\n        type:       \"capability.contactSensor\",\n        title:      \"Or using these contact sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputTriggerOnceC = [\n    \tname:       \"C_triggerOnce\",\n        type:       \"bool\",\n        title:      \"Trigger only once per day...\",\n        defaultValue:false\n    ]\n    \n    def inputSwitchDisableC = [\n    \tname:       \"C_switchDisable\",\n        type:       \"bool\",\n        title:      \"Stop triggering if physical switches/dimmers are turned off...\",\n        defaultValue:false\n    ]\n    \n    def inputLockC = [\n        name:       \"C_lock\",\n        type:       \"capability.lock\",\n        title:      \"Or using these locks...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputModeC = [\n        name:       \"C_mode\",\n        type:       \"mode\",\n        title:      \"Only during the following modes...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputDayC = [\n        name:       \"C_day\",\n        type:       \"enum\",\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        title:      \"Only on certain days of the week...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputLevelC = [\n        name:       \"C_level\",\n        type:       \"enum\",\n        options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],\n        title:      \"Set dimmers to this level\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputTurnOffC = [\n        name:       \"C_turnOff\",\n        type:       \"number\",\n        title:      \"Turn off this scenario after motion stops or doors close/lock (minutes)...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputScenarioNameC = [\n        name:       \"ScenarioNameC\",\n        type:       \"text\",\n        title:      \"Scenario Name\",\n        multiple:   false,\n        required:   false,\n        defaultValue: empty\n    ]\n    \n    def inputTurnOnLuxC = [\n        name:       \"C_turnOnLux\",\n        type:       \"number\",\n        title:      \"Only run this scenario if lux is below...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputLuxSensorsC = [\n        name:       \"C_luxSensors\",\n        type:       \"capability.illuminanceMeasurement\",\n        title:      \"On these lux sensors\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def pageProperties = [\n        name:       \"pageSetupScenarioC\",\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Name your scenario\") {\n            input inputScenarioNameC\n        }\n\nsection(\"Devices included in the scenario\") {\n            input inputMotionC\n\t\t\tinput inputAccelerationC\n            input inputContactC\n            input inputLockC\n            input inputLightsC\n            input inputDimmersC\n            }\n\nsection(\"Scenario settings\") {\n            input inputLevelC\n            input inputTurnOnLuxC\n            input inputLuxSensorsC\n            input inputTurnOffC\n\t\t\t}\n            \nsection(\"Scenario restrictions\") { \n\t\t\tinput inputTriggerOnceC\n            input inputSwitchDisableC\n            href \"timeIntervalInputC\", title: \"Only during a certain time...\", description: getTimeLabel(C_timeStart, C_timeEnd), state: greyedOutTime(C_timeStart, C_timeEnd), refreshAfterSelection:true\n            input inputDayC\n            input inputModeC\n            }\n\nsection(\"Help\") {\n            paragraph helpText()\n            }\n    }\n}\n\ndef pageSetupScenarioD() {\n\n    def inputLightsD = [\n        name:       \"D_switches\",\n        type:       \"capability.switch\",\n        title:      \"Control the following switches...\",\n        multiple:   true,\n        required:   false\n    ]\n    def inputDimmersD = [\n        name:       \"D_dimmers\",\n        type:       \"capability.switchLevel\",\n        title:      \"Dim the following...\",\n        multiple:   true,\n        required:   false\n    ]\n\n    def inputMotionD = [\n        name:       \"D_motion\",\n        type:       \"capability.motionSensor\",\n        title:      \"Using these motion sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n\tdef inputAccelerationD = [\n\t\tname:       \"D_acceleration\",\n\t\ttype:       \"capability.accelerationSensor\",\n\t\ttitle:      \"Or using these acceleration sensors...\",\n\t\tmultiple:   true,\n\t\trequired:   false\n\t]\n    def inputContactD = [\n        name:       \"D_contact\",\n        type:       \"capability.contactSensor\",\n        title:      \"Or using these contact sensors...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputLockD = [\n        name:       \"D_lock\",\n        type:       \"capability.lock\",\n        title:      \"Or using these locks...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputModeD = [\n        name:       \"D_mode\",\n        type:       \"mode\",\n        title:      \"Only during the following modes...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    def inputTriggerOnceD = [\n    \tname:       \"D_triggerOnce\",\n        type:       \"bool\",\n        title:      \"Trigger only once per day...\",\n        defaultValue:false\n    ]\n    \n    def inputSwitchDisableD = [\n    \tname:       \"D_switchDisable\",\n        type:       \"bool\",\n        title:      \"Stop triggering if physical switches/dimmers are turned off...\",\n        defaultValue:false\n    ]\n    \n    def inputDayD = [\n        name:       \"D_day\",\n        type:       \"enum\",\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        title:      \"Only on certain days of the week...\",\n        multiple:   true,\n        required:   false\n    ]\n    \n    \n    def inputLevelD = [\n        name:       \"D_level\",\n        type:       \"enum\",\n        options: [[10:\"10%\"],[20:\"20%\"],[30:\"30%\"],[40:\"40%\"],[50:\"50%\"],[60:\"60%\"],[70:\"70%\"],[80:\"80%\"],[90:\"90%\"],[100:\"100%\"]],\n        title:      \"Set dimmers to this level\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputTurnOffD = [\n        name:       \"D_turnOff\",\n        type:       \"number\",\n        title:      \"Turn off this scenario after motion stops, doors close or close/lock (minutes)...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputScenarioNameD = [\n        name:       \"ScenarioNameD\",\n        type:       \"text\",\n        title:      \"Scenario Name\",\n        multiple:   false,\n        required:   false,\n        defaultValue: empty\n    ]\n    \n    def inputTurnOnLuxD = [\n        name:       \"D_turnOnLux\",\n        type:       \"number\",\n        title:      \"Only run this scenario if lux is below...\",\n        multiple:   false,\n        required:   false\n    ]\n    \n    def inputLuxSensorsD = [\n        name:       \"D_luxSensors\",\n        type:       \"capability.illuminanceMeasurement\",\n        title:      \"On these lux sensors\",\n        multiple:   false,\n        required:   false\n    ]\n\n    def pageProperties = [\n        name:       \"pageSetupScenarioD\",\n    ]\n\n    return dynamicPage(pageProperties) {\n        section(\"Name your scenario\") {\n            input inputScenarioNameD\n        }\n\nsection(\"Devices included in the scenario\") {\n            input inputMotionD\n\t\t\tinput inputAccelerationD\n          \tinput inputContactD\n            input inputLockD\n            input inputLightsD\n            input inputDimmersD\n            }\n\nsection(\"Scenario settings\") {\n            input inputLevelD\n            input inputTurnOnLuxD\n            input inputLuxSensorsD\n            input inputTurnOffD\n\t\t\t}\n            \nsection(\"Scenario restrictions\") {    \n\t\t\tinput inputTriggerOnceD\n            input inputSwitchDisableD\n            href \"timeIntervalInputD\", title: \"Only during a certain time\", description: getTimeLabel(D_timeStart, D_timeEnd), state: greyedOutTime(D_timeStart, D_timeEnd), refreshAfterSelection:true\n            input inputDayD\n            input inputModeD\n            }\n\nsection(\"Help\") {\n            paragraph helpText()\n            }\n    }\n}\n\ndef installed() {\n    initialize()\n}\n\ndef updated() {\n    unschedule()\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n\nmidNightReset()\n\nif(A_motion) {\n\tsubscribe(settings.A_motion, \"motion\", onEventA)\n}\n\nif(A_acceleration) {\n\tsubscribe(settings.A_acceleration, \"acceleration\", onEventA)\n}\n\nif(A_contact) {\n\tsubscribe(settings.A_contact, \"contact\", onEventA)\n}\n\nif(A_lock) {\n\tsubscribe(settings.A_lock, \"lock\", onEventA)\n}\n\nif(A_switchDisable) {\n\tsubscribe(A_switches, \"switch.off\", onPressA)\n    subscribe(A_dimmers, \"switch.off\", onPressA)\n}\n\nif(A_mode) {\n    subscribe(location, onEventA)\n}\n\nif(B_motion) {\n\tsubscribe(settings.B_motion, \"motion\", onEventB)\n}\n\nif(B_acceleration) {\n\tsubscribe(settings.B_acceleration, \"acceleration\", onEventB)\n}\n\nif(B_contact) {\n\tsubscribe(settings.B_contact, \"contact\", onEventB)\n}\n\nif(B_lock) {\n\tsubscribe(settings.B_lock, \"lock\", onEventB)\n}\n\nif(B_switchDisable) {\n\tsubscribe(B_switches, \"switch.off\", onPressB)\n    subscribe(B_dimmers, \"switch.off\", onPressB)\n}\n\nif(B_mode) {\n    subscribe(location, onEventB)\n}\n\nif(C_motion) {\n\tsubscribe(settings.C_motion, \"motion\", onEventC)\n}\n\nif(C_acceleration) {\n\tsubscribe(settings.C_acceleration, \"acceleration\", onEventC)\n}\n\nif(C_contact) {\n\tsubscribe(settings.C_contact, \"contact\", onEventC)\n}\n\nif(C_lock) {\n\tsubscribe(settings.C_lock, \"lock\", onEventC)\n}\n\nif(C_switchDisable) {\n\tsubscribe(C_switches, \"switch.off\", onPressC)\n    subscribe(C_dimmers, \"switch.off\", onPressC)\n}\n\nif(C_mode) {\n    subscribe(location, onEventC)\n}\n\nif(D_motion) {\n\tsubscribe(settings.D_motion, \"motion\", onEventD)\n}\n\nif(D_acceleration) {\n\tsubscribe(settings.D_acceleration, \"acceleration\", onEventD)\n}\n\nif(D_contact) {\n\tsubscribe(settings.D_contact, \"contact\", onEventD)\n}\n\nif(D_lock) {\n\tsubscribe(settings.D_lock, \"lock\", onEventD)\n}\n\nif(D_switchDisable) {\n\tsubscribe(D_switches, \"switch.off\", onPressD)\n    subscribe(D_dimmers, \"switch.off\", onPressD)\n}\n\nif(D_mode) {\n    subscribe(location, onEventD)\n}\n\n}\n\ndef onEventA(evt) {\n\nif ((!A_triggerOnce || (A_triggerOnce && !state.A_triggered)) && (!A_switchDisable || (A_switchDisable && !state.A_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!A_mode || A_mode.contains(location.mode)) && getTimeOk (A_timeStart, A_timeEnd) && getDayOk(A_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!A_luxSensors) || (A_luxSensors.latestValue(\"illuminance\") <= A_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef A_levelOn = A_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(A_motion, A_contact, A_lock, A_acceleration)) {\n        \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameA}'\")\n            settings.A_dimmers?.setLevel(A_levelOn)\n            settings.A_switches?.on()\n            if (A_triggerOnce){\n            \tstate.A_triggered = true\n                if (!A_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.A_timerStart){\n            \tunschedule(delayTurnOffA)\n            \tstate.A_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n\t\t\n    \tif (settings.A_turnOff) {\n\t\t\trunIn(A_turnOff * 60, \"delayTurnOffA\")\n        \tstate.A_timerStart = true\n        }\n        else {\n        \tsettings.A_switches?.off()\n\t\t\tsettings.A_dimmers?.setLevel(0)\n        \tif (state.A_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffA(){\n\tsettings.A_switches?.off()\n\tsettings.A_dimmers?.setLevel(0)\n\tstate.A_timerStart = false\n\tif (state.A_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressA(evt) {\nif ((!A_mode || A_mode.contains(location.mode)) && getTimeOk (A_timeStart, A_timeEnd) && getDayOk(A_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!A_luxSensors) || (A_luxSensors.latestValue(\"illuminance\") <= A_turnOnLux)){ \nif ((!A_triggerOnce || (A_triggerOnce && !state.A_triggered)) && (!A_switchDisable || (A_switchDisable && !state.A_triggered))) {    \n    if (evt.physical){\n    \tstate.A_triggered = true\n        unschedule(delayTurnOffA)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameA}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventB(evt) {\n\nif ((!B_triggerOnce || (B_triggerOnce && !state.B_triggered)) && (!B_switchDisable || (B_switchDisable && !state.B_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!B_mode ||B_mode.contains(location.mode)) && getTimeOk (B_timeStart, B_timeEnd) && getDayOk(B_day)) { //checks to make sure we are not opperating outside of set restrictions.\nif ((!B_luxSensors) || (B_luxSensors.latestValue(\"illuminance\") <= B_turnOnLux)) { //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef B_levelOn = B_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(B_motion, B_contact, B_lock, B_acceleration)) {\n\t\t\n        \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameB}'\")\n\t\t\tsettings.B_dimmers?.setLevel(B_levelOn)\n            settings.B_switches?.on()\n            if (B_triggerOnce){\n            \tstate.B_triggered = true\n                if (!B_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.B_timerStart) {\n            \tunschedule(delayTurnOffB)\n            \tstate.B_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.B_turnOff) {\n\t\t\trunIn(B_turnOff * 60, \"delayTurnOffB\")\n        \tstate.B_timerStart = true\n        }\n        \n        else {\n        \tsettings.B_switches?.off()\n\t\t\tsettings.B_dimmers?.setLevel(0)\n            if (state.B_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n\t\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffB(){\n\tsettings.B_switches?.off()\n\tsettings.B_dimmers?.setLevel(0)\n\tstate.B_timerStart = false\n    if (state.B_triggered) {\n    \trunOnce (getMidnight(), midNightReset) \n\t}\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressB(evt) {\nif ((!B_mode ||B_mode.contains(location.mode)) && getTimeOk (B_timeStart, B_timeEnd) && getDayOk(B_day)) {  //checks to make sure we are not opperating outside of set restrictions.\nif ((!B_luxSensors) || (B_luxSensors.latestValue(\"illuminance\") <= B_turnOnLux)) {\nif ((!B_triggerOnce || (B_triggerOnce && !state.B_triggered)) && (!B_switchDisable || (B_switchDisable && !state.B_triggered))) {\n\tif (evt.physical){\n    \tstate.B_triggered = true\n        unschedule(delayTurnOffB)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameB}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventC(evt) {\n\nif ((!C_triggerOnce || (C_triggerOnce && !state.C_triggered)) && (!C_switchDisable || (C_switchDisable && !state.C_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!C_mode || C_mode.contains(location.mode)) && getTimeOk (C_timeStart, C_timeEnd) && getDayOk(C_day) && !state.C_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!C_luxSensors) || (C_luxSensors.latestValue(\"illuminance\") <= C_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef C_levelOn = settings.C_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(C_motion, C_contact, C_lock, C_acceleration)) {\n           \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameC}'\")\n            settings.C_dimmers?.setLevel(C_levelOn)\n            settings.C_switches?.on()\n            if (C_triggerOnce){\n            \tstate.C_triggered = true\n                if (!C_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.C_timerStart){\n            \tunschedule(delayTurnOffC)\n            \tstate.C_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.C_turnOff) {\n\t\trunIn(C_turnOff * 60, \"delayTurnOffC\")\n        state.C_timerStart = true\n        }\n        else {\n        settings.C_switches?.off()\n\t\tsettings.C_dimmers?.setLevel(0)\n        \tif (state.C_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n\t\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffC(){\n\tsettings.C_switches?.off()\n\tsettings.C_dimmers?.setLevel(0)\n\tstate.C_timerStart = false\n\tif (state.C_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressC(evt) {\nif ((!C_mode || C_mode.contains(location.mode)) && getTimeOk (C_timeStart, C_timeEnd) && getDayOk(C_day) && !state.C_triggered){\nif ((!C_luxSensors) || (C_luxSensors.latestValue(\"illuminance\") <= C_turnOnLux)){\nif ((!C_triggerOnce || (C_triggerOnce && !state.C_triggered)) && (!C_switchDisable || (C_switchDisable && !state.C_triggered))) {\n\tif (evt.physical){\n    \tstate.C_triggered = true\n        unschedule(delayTurnOffC)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameC}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\ndef onEventD(evt) {\n\nif ((!D_triggerOnce || (D_triggerOnce && !state.D_triggered)) && (!D_switchDisable || (D_switchDisable && !state.D_triggered))) { //Checks to make sure this scenario should be triggered more then once in a day\nif ((!D_mode || D_mode.contains(location.mode)) && getTimeOk (D_timeStart, D_timeEnd) && getDayOk(D_day) && !state.D_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!D_luxSensors) || (D_luxSensors.latestValue(\"illuminance\") <= D_turnOnLux)){ //checks to make sure illimunance is either not cared about or if the value is within the restrictions\ndef D_levelOn = D_level as Integer\n\n//Check states of each device to see if they are to be ignored or if they meet the requirments of the app to produce an action.\nif (getInputOk(D_motion, D_contact, D_lock, D_acceleration)) {\n           \tlog.debug(\"Motion, Door Open or Unlock Detected Running '${ScenarioNameD}'\")\n            settings.D_dimmers?.setLevel(D_levelOn)\n            settings.D_switches?.on()\n            if (D_triggerOnce){\n            \tstate.D_triggered = true\n                if (!D_turnOff) {\n\t\t\t\t\trunOnce (getMidnight(), midNightReset)\n                }\n            }\n        \tif (state.D_timerStart){\n            \tunschedule(delayTurnOffD)\n            \tstate.D_timerStart = false\n        \t}\n}\n\n//if none of the above paramenters meet the expectation of the app then turn off\nelse {\n    \tif (settings.D_turnOff) {\n\t\trunIn(D_turnOff * 60, \"delayTurnOffD\")\n        state.D_timerStart = true\n        }\n        else {\n        settings.D_switches?.off()\n\t\tsettings.D_dimmers?.setLevel(0)\n        \tif (state.D_triggered) {\n    \t\t\trunOnce (getMidnight(), midNightReset)\n    \t\t}\n        }\n}\n}\n}\nelse{\nlog.debug(\"Motion, Contact or Unlock detected outside of mode or time/day restriction.  Not running scenario.\")\n}\n}\n}\n\ndef delayTurnOffD(){\n\tsettings.D_switches?.off()\n\tsettings.D_dimmers?.setLevel(0)\n\tstate.D_timerStart = false\n\tif (state.D_triggered) {\n    \trunOnce (getMidnight(), midNightReset)\n    }\n\n}\n\n//when physical switch is actuated disable the scenario\ndef onPressD(evt) {\nif ((!D_mode || D_mode.contains(location.mode)) && getTimeOk (D_timeStart, D_timeEnd) && getDayOk(D_day) && !state.D_triggered){ //checks to make sure we are not opperating outside of set restrictions.\nif ((!D_luxSensors) || (D_luxSensors.latestValue(\"illuminance\") <= D_turnOnLux)){\nif ((!D_triggerOnce || (D_triggerOnce && !state.D_triggered)) && (!D_switchDisable || (D_switchDisable && !state.D_triggered))) {  \n\tif (evt.physical){\n    \tstate.D_triggered = true\n        unschedule(delayTurnOffD)\n        runOnce (getMidnight(), midNightReset)\n        log.debug \"Physical switch in '${ScenarioNameD}' pressed. Triggers for this scenario disabled.\"\n\t}\n}\n}}}\n\n//Common Methods\n\n//resets once a day trigger at midnight so trigger can be ran again the next day.\ndef midNightReset() {\n\tstate.A_triggered = false\n    state.B_triggered = false\n    state.C_triggered = false\n    state.D_triggered = false\n}\n\nprivate def helpText() {\n\tdef text =\n\t\t\"Select motion sensors, acceleration sensors, contact sensors or locks to control a set of lights. \" +\n        \"Each scenario can control dimmers and switches but can also be \" +\n        \"restricted to modes or between certain times and turned off after \" +\n        \"motion stops, doors close or lock. Scenarios can also be limited to  \" +\n        \"running once or to stop running if the physical switches are turned off.\"\n\ttext\n}\n\n//should scenario be marked complete or not\ndef greyOut(scenario){\n\tdef result = \"\"\n    if (scenario) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n//should i mark the time restriction green or grey\ndef greyedOutTime(start, end){\n\tdef result = \"\"\n    if (start || end) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n\ndef getTitle(scenario) {\n\tdef title = \"Empty\"\n\tif (scenario) {\n\t\ttitle = scenario\n    }\n\ttitle\n}\n\n//recursively applies label to each scenario depending on if the scenario has deatils inside it or not\ndef getDesc(scenario) {\n\tdef desc = \"Tap to create a scenario\"\n\tif (scenario) {\n\t\tdesc = \"Tap to edit scenario\"\n    }\n\tdesc\t\n}\n\n\ndef getMidnight() {\n\tdef midnightToday = timeToday(\"2000-01-01T23:59:59.999-0000\", location.timeZone)\n\tmidnightToday\n}\n\n//used to recursively check device states when methods are triggered \nprivate getInputOk(motion, contact, lock, acceleration) {\n\ndef motionDetected = false\ndef accelerationDetected = false\ndef contactDetected = false\ndef unlockDetected = false\ndef result = false\n\nif (motion) {\n\tif (motion.latestValue(\"motion\").contains(\"active\")) {\n\t\tmotionDetected = true\n\t}\n}\n\nif (acceleration) {\n\tif (acceleration.latestValue(\"acceleration\").contains(\"active\")) {\n\t\taccelerationDetected = true\n\t}\n}\n\nif (contact) {\n\tif (contact.latestValue(\"contact\").contains(\"open\")) {\n\t\tcontactDetected = true\n\t}\n}\n\nif (lock) {\n\tif (lock.latestValue(\"lock\").contains(\"unlocked\")) {\n\t\tunlockDetected = true\n\t}\n}\n\nresult = motionDetected || contactDetected || unlockDetected || accelerationDetected\nresult\n\n}\n\nprivate getTimeOk(starting, ending) {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n    \n    else if (starting){\n    \tresult = currTime >= start\n    }\n    else if (ending){\n    \tresult = currTime <= stop\n    }\n    \n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\ndef getTimeLabel(start, end){\n\tdef timeLabel = \"Tap to set\"\n\t\n    if(start && end){\n    \ttimeLabel = \"Between\" + \" \" + hhmm(start) + \" \"  + \"and\" + \" \" +  hhmm(end)\n    }\n    else if (start) {\n\t\ttimeLabel = \"Start at\" + \" \" + hhmm(start)\n    }\n    else if(end){\n    timeLabel = \"End at\" + hhmm(end)\n    }\n\ttimeLabel\t\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate getDayOk(dayList) {\n\tdef result = true\n    if (dayList) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = dayList.contains(day)\n\t}\n    result\n}\n\n\npage(name: \"timeIntervalInputA\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"A_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"A_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }  \npage(name: \"timeIntervalInputB\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"B_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"B_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }  \npage(name: \"timeIntervalInputC\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"C_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"C_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }         \npage(name: \"timeIntervalInputD\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n\t\tsection {\n\t\t\tinput \"D_timeStart\", \"time\", title: \"Starting\", required: false, refreshAfterSelection:true\n\t\t\tinput \"D_timeEnd\", \"time\", title: \"Ending\", required: false, refreshAfterSelection:true\n\t\t}\n        }",
        "docstring": "Control up to 4 sets (scenarios) of lights based on motion, door contacts and illuminance levels."
    },
    {
        "code": "section(\"Zip code (for sunrise/sunset)\") {\n            input \"zip\", \"text\", required: true\n        }\n\n        section(\"Notifications\") {\n            input \"sendPushMessage\", \"bool\", title: \"Send notifications when house is empty?\"\n            input \"sendPushMessageHome\", \"bool\", title: \"Send notifications when home is occupied?\"\n        }\n        section(\"Send Notifications?\") {\n            input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n                input \"phone\", \"phone\", title: \"Send an SMS to this number?\", required:false\n            }\n        }\n\n        section(title: \"More options\", hidden: hideOptionsSection(), hideable: true) {\n            label title: \"Assign a name\", required: false\n            input \"days\", \"enum\", title: \"Only on certain days of the week\", multiple: true, required: false,\n                options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n            input \"modes\", \"mode\", title: \"Only when mode is\", multiple: true, required: false\n        }\n    }\n}\n\ndef selectRoutines() {\n    def configured = (settings.awayDay && settings.awayNight && settings.homeDay && settings.homeNight)\n    dynamicPage(name: \"selectRoutines\", title: \"Configure\", nextPage: \"Settings\", uninstall: true) {\n        section(\"Who?\") {\n            input \"people\", \"capability.presenceSensor\", title: \"Monitor These Presences\", required: true, multiple: true, submitOnChange: true\n        }\n\n        def routines = location.helloHome?.getPhrases()*.label\n        if (routines) {\n            routines.sort()\n            section(\"Run This Routine When...\") {\n                    log.trace routines\n                    input \"awayDay\", \"enum\", title: \"Everyone Is Away And It's Day\", required: true, options: routines, submitOnChange: true\n                    input \"awayNight\", \"enum\", title: \"Everyone Is Away And It's Night\", required: true, options: routines, submitOnChange: true\n                    input \"homeDay\", \"enum\", title: \"At Least One Person Is Home And It's Day\", required: true, options: routines, submitOnChange: true\n                    input \"homeNight\", \"enum\", title: \"At Least One Person Is Home And It's Night\", required: true, options: routines, submitOnChange: true\n                }\n                /*    section(\"Select modes used for each condition.\") { This allows the director to know which rotuine has already been ran so it does not run again if someone else comes home. \n        input \"homeModeDay\", \"mode\", title: \"Select Mode Used for 'Home Day'\", required: true\n        input \"homeModeNight\", \"mode\", title: \"Select Mode Used for 'Home Night'\", required: true\n    }*/\n        }\n    }\n}\n\ndef installed() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    initialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    unsubscribe()\n    initialize()\n}\n\ndef initialize() {\n    subscribe(people, \"presence\", presence)\n    checkSun()\n    subscribe(location, \"sunrise\", setSunrise)\n    subscribe(location, \"sunset\", setSunset)\n    state.homestate = null\n}\n\n//check current sun state when installed.\ndef checkSun() {\n    def zip = settings.zip as String\n    def sunInfo = getSunriseAndSunset(zipCode: zip)\n    def current = now()\n\n    if (sunInfo.sunrise.time < current && sunInfo.sunset.time > current) {\n        state.sunMode = \"sunrise\"\n        runIn(60,\"setSunrise\")\n    }\n    else {\n        state.sunMode = \"sunset\"\n        runIn(60,\"setSunset\")\n    }\n}\n\n//change to sunrise mode on sunrise event\ndef setSunrise(evt) {\n    state.sunMode = \"sunrise\";\n    changeSunMode(newMode);\n    log.debug \"Current sun mode is ${state.sunMode}\"\n}\n\n//change to sunset mode on sunset event\ndef setSunset(evt) {\n    state.sunMode = \"sunset\";\n    changeSunMode(newMode)\n    log.debug \"Current sun mode is ${state.sunMode}\"\n}\n\n//change mode on sun event\ndef changeSunMode(newMode) {\n    if (allOk) {\n\n        if (everyoneIsAway()) /*&& (state.sunMode == \"sunrise\")*/ {\n            log.debug(\"Home is Empty  Setting New Away Mode\")\n            def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n            setAway()\n        }\n/*\n        else if (everyoneIsAway() && (state.sunMode == \"sunset\")) {\n            log.debug(\"Home is Empty  Setting New Away Mode\")\n            def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n            setAway()\n        }*/\n        else if (anyoneIsHome()) {\n            log.debug(\"Home is Occupied Setting New Home Mode\")\n            setHome()\n\n\n        }\n    }\n}\n\n//presence change run logic based on presence state of home\ndef presence(evt) {\n    if (allOk) {\n        if (evt.value == \"not present\") {\n            log.debug(\"Checking if everyone is away\")\n\n            if (everyoneIsAway()) {\n                log.debug(\"Nobody is home, running away sequence\")\n                def delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 10 * 60\n                runIn(delay, \"setAway\")\n            }\n        }\n        else {\n            def lastTime = state[evt.deviceId]\n            if (lastTime == null || now() - lastTime >= 1 * 60000) {\n                log.debug(\"Someone is home, running home sequence\")\n                setHome()\n            }\n            state[evt.deviceId] = now()\n\n        }\n    }\n}\n\n//if empty set home to one of the away modes\ndef setAway() {\n    if (everyoneIsAway()) {\n        if (state.sunMode == \"sunset\") {\n            def message = \"Performing \\\"${awayNight}\\\" for you as requested.\"\n            log.debug(message)\n            sendAway(message)\n            location.helloHome.execute(settings.awayNight)\n            state.homestate = \"away\"\n\n        }\n        else if (state.sunMode == \"sunrise\") {\n            def message = \"Performing \\\"${awayDay}\\\" for you as requested.\"\n            log.debug(message)\n            sendAway(message)\n            location.helloHome.execute(settings.awayDay)\n            state.homestate = \"away\"\n        }\n        else {\n            log.debug(\"Mode is the same, not evaluating\")\n        }\n    }\n}\n\n//set home mode when house is occupied\ndef setHome() {\n    log.debug(\"Setting Home Mode!!\")\n    if (anyoneIsHome()) {\n        if (state.sunMode == \"sunset\") {\n            if (state.homestate != \"homeNight\") {\n                def message = \"Performing \\\"${homeNight}\\\" for you as requested.\"\n                log.debug(message)\n                sendHome(message)\n                location.helloHome.execute(settings.homeNight)\n                state.homestate = \"homeNight\"\n            }\n        }\n\n        if (state.sunMode == \"sunrise\") {\n            if (state.homestate != \"homeDay\") {\n                def message = \"Performing \\\"${homeDay}\\\" for you as requested.\"\n                log.debug(message)\n                sendHome(message)\n                location.helloHome.execute(settings.homeDay)\n                state.homestate = \"homeDay\"\n            }\n        }\n    }\n}\n\nprivate everyoneIsAway() {\n  def result = true\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"everyoneIsAway: ${result}\")\n\n  return result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\ndef sendAway(msg) {\n    if (sendPushMessage) {\n    \tif (recipients) {\n        \tsendNotificationToContacts(msg, recipients)\n        }\n        else {\n        \tsendPush(msg)\n        \tif(phone){\n            \t\tsendSms(phone, msg)\n        \t}\n        }\n    }\n\n    log.debug(msg)\n}\n\ndef sendHome(msg) {\n    if (sendPushMessageHome) {\n    \tif (recipients) {\n        \tsendNotificationToContacts(msg, recipients)\n        }\n        else {\n        \tsendPush(msg)\n                if(phone){\n            \t\tsendSms(phone, msg)\n        \t}\n        }\n    }\n\n    log.debug(msg)\n}\n\nprivate getAllOk() {\n    modeOk && daysOk && timeOk\n}\n\nprivate getModeOk() {\n    def result = !modes || modes.contains(location.mode)\n    log.trace \"modeOk = $result\"\n    result\n}\n\nprivate getDaysOk() {\n    def result = true\n    if (days) {\n        def df = new java.text.SimpleDateFormat(\"EEEE\")\n        if (location.timeZone) {\n            df.setTimeZone(location.timeZone)\n        }\n        else {\n            df.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n        }\n        def day = df.format(new Date())\n        result = days.contains(day)\n    }\n    log.trace \"daysOk = $result\"\n    result\n}\n\nprivate getTimeOk() {\n    def result = true\n    if (starting && ending) {\n        def currTime = now()\n        def start = timeToday(starting, location?.timeZone).time\n        def stop = timeToday(ending, location?.timeZone).time\n        result = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n    }\n    log.trace \"timeOk = $result\"\n    result\n}\n\nprivate hhmm(time, fmt = \"h:mm a\") {\n    def t = timeToday(time, location.timeZone)\n    def f = new java.text.SimpleDateFormat(fmt)\n    f.setTimeZone(location.timeZone?:timeZone(time))\n    f.format(t)\n}\n\nprivate getTimeIntervalLabel() {\n    (starting && ending) ? hhmm(starting) + \"-\" + hhmm(ending, \"h:mm a z\"): \"\"\n}\n\nprivate hideOptionsSection() {\n    (starting || ending || days || modes) ? false: true\n}",
        "docstring": "Monitor a set of presence sensors and activate routines based on whether your home is empty or occupied.  Each presence status change will check against the current 'sun state' to run routines based on occupancy and whether the sun is up or down."
    },
    {
        "code": "section(\"Setup Menu\") {\n            href \"directorSettings\", title: \"Director Settings\", description: \"\", state:greyedOut()\n            href \"ThermostatandDoors\", title: \"Thermostat and Doors\", description: \"\", state: greyedOutTherm()\n            href \"ThermostatBoost\", title: \"Thermostat Boost\", description: \"\", state: greyedOutTherm1()\n            href \"Settings\", title: \"Settings\", description: \"\", state: greyedOutSettings()\n            }\n        section([title:\"Options\", mobileOnly:true]) {\n            label title:\"Assign a name\", required:false\n        }\n    }\n}\n\n// Show \"Setup\" page\ndef directorSettings() {\n\n    def sensor = [\n        name:       \"sensor\",\n        type:       \"capability.temperatureMeasurement\",\n        title:      \"Which?\",\n        multiple:   false,\n        required:   true\n    ]\n    def setLow = [\n        name:       \"setLow\",\n        type:       \"decimal\",\n        title:      \"Low temp?\",\n        required:   true\n    ]\n\n    def cold = [\n        name:       \"cold\",\n        type:       \"enum\",\n        title:\t\t\"Mode?\",\n        metadata:   [values:[\"auto\", \"heat\", \"cool\", \"off\"]]\n    ]\n\n    def setHigh = [\n        name:       \"setHigh\",\n        type:       \"decimal\",\n        title:      \"High temp?\",\n        required:   true\n    ]\n\n    def hot = [\n        name:       \"hot\",\n        type:       \"enum\",\n        title:\t\t\"Mode?\",\n        metadata:   [values:[\"auto\", \"heat\", \"cool\", \"off\"]]\n    ]\n\n    def neutral = [\n        name:       \"neutral\",\n        type:       \"enum\",\n        title:\t\t\"Mode?\",\n        metadata:   [values:[\"auto\", \"heat\", \"cool\", \"off\"]]\n    ]\n\n    def pageName = \"Setup\"\n\n    def pageProperties = [\n        name:       \"directorSettings\",\n        title:      \"Setup\",\n        nextPage:   \"pageSetup\"\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\t\tsection(\"Which temperature sensor will control your thermostat?\"){\n\t\t\tinput sensor\n\t\t}\n        section(\"\"){\n        \tparagraph \"Here you will setup the upper and lower thresholds for the temperature sensor that will send commands to your thermostat.\"\n        }\n\t\tsection(\"When the temperature falls below this tempurature set mode to...\"){\n\t\t\tinput setLow\n\t\t\tinput cold\n\t\t}\n        section(\"When the temperature goes above this tempurature set mode to...\"){\n\t\t\tinput setHigh\n\t\t\tinput hot\n\t\t}\n        section(\"When temperature is between the previous temperatures, change mode to...\"){\n\t\t\tinput neutral\n\t\t}\n    }\n\n}\n\ndef ThermostatandDoors() {\n\n    def thermostat = [\n        name:       \"thermostat\",\n        type:       \"capability.thermostat\",\n        title:      \"Which?\",\n        multiple:   true,\n        required:   true\n    ]\n    def doors = [\n        name:       \"doors\",\n        type:       \"capability.contactSensor\",\n        title:      \"Low temp?\",\n        multiple:\ttrue,\n        required:   true\n    ]\n\n    def turnOffDelay = [\n        name:       \"turnOffDelay\",\n        type:       \"decimal\",\n        title:\t\t\"Number of minutes\",\n        required:\tfalse\n    ]\n\n    def pageName = \"Thermostat and Doors\"\n\n    def pageProperties = [\n        name:       \"ThermostatandDoors\",\n        title:      \"Thermostat and Doors\",\n        nextPage:   \"pageSetup\"\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\t\tsection(\"\"){\n        \tparagraph \"If any of the doors selected here are open the thermostat will automatically be turned off and this app will be 'disabled' until all the doors are closed. (This is optional)\"\n        }\n        section(\"Choose thermostat...\") {\n\t\t\tinput thermostat\n\t\t}\n        section(\"If these doors/windows are open turn off thermostat regardless of outdoor temperature\") {\n\t\t\tinput doors\n\t\t}\n\t\tsection(\"Wait this long before turning the thermostat off (defaults to 1 minute)\") {\n\t\t\tinput turnOffDelay\n\t\t}\n    }\n\n}\n\ndef ThermostatBoost() {\n\n    def thermostat1 = [\n        name:       \"thermostat1\",\n        type:       \"capability.thermostat\",\n        title:      \"Which?\",\n        multiple:   true,\n        required:   true\n    ]\n    def turnOnTherm = [\n        name: \t\t\"turnOnTherm\",\n        type:\t\t\"enum\",\n        metadata: \t[values: [\"cool\", \"heat\"]],\n        required: \tfalse\n    ]\n\n    def modes1 = [\n        name:\t\t\"modes1\",\n        type:\t\t\"mode\",\n        title: \t\t\"Put thermostat into boost mode when mode is...\",\n        multiple: \ttrue,\n        required: \tfalse\n    ]\n\n    def coolingTemp = [\n        name:       \"coolingTemp\",\n        type:       \"decimal\",\n        title:\t\t\"Cooling Temp?\",\n        required:\tfalse\n    ]\n\n    def heatingTemp = [\n        name:       \"heatingTemp\",\n        type:       \"decimal\",\n        title:\t\t\"Heating Temp?\",\n        required:\tfalse\n    ]\n\n    def turnOffDelay2 = [\n        name:       \"turnOffDelay2\",\n        type:       \"decimal\",\n        title:\t\t\"Number of minutes\",\n        required:\tfalse,\n        defaultValue:30\n    ]\n\n    def pageName = \"Thermostat Boost\"\n\n    def pageProperties = [\n        name:       \"ThermostatBoost\",\n        title:      \"Thermostat Boost\",\n        nextPage:   \"pageSetup\"\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\t\tsection(\"\"){\n        \tparagraph \"Here you can setup the ability to 'boost' your thermostat. In the event that your thermostat is 'off' and you need to heat or cool your home for a little bit you can 'touch' the app in the 'My Apps' section to boost your thermostat.\"\n        }\n\t\tsection(\"Choose a thermostats to boost\") {\n   \t\t\tinput thermostat1\n        }\n        section(\"If thermostat is off switch to which mode?\") {\n    \t\tinput turnOnTherm\n  \t\t}\n        section(\"Set the thermostat to the following temps\") {\n    \t\tinput coolingTemp\n    \t\tinput heatingTemp\n  \t\t}\n  \t\tsection(\"For how long?\") {\n    \t\tinput turnOffDelay2\n  \t\t}\n        section(\"In addtion to 'app touch' the following modes will also boost the thermostat\") {\n   \t\t\tinput modes1\n        }\n    }\n\n}\n\n// Show \"Setup\" page\ndef Settings() {\n\n    def sendPushMessage = [\n        name: \t\t\"sendPushMessage\",\n        type: \t\t\"enum\",\n        title: \t\t\"Send a push notification?\",\n        metadata:\t[values:[\"Yes\",\"No\"]],\n        required:\ttrue,\n        defaultValue: \"Yes\"\n    ]\n\n    def phoneNumber = [\n        name: \t\t\"phoneNumber\",\n        type:\t\t\"phone\",\n        title: \t\t\"Send SMS notifications to?\",\n        required: \tfalse\n    ]\n\n    def days = [\n        name:       \"days\",\n        type:       \"enum\",\n        title:      \"Only on certain days of the week\",\n        multiple:   true,\n        required:   false,\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    ]\n\n    def modes = [\n        name:\t\t\"modes\",\n        type:\t\t\"mode\",\n        title: \t\t\"Only when mode is\",\n        multiple: \ttrue,\n        required: \tfalse\n    ]\n\n    def pageName = \"Settings\"\n\n    def pageProperties = [\n        name:       \"Settings\",\n        title:      \"Settings\",\n        nextPage:   \"pageSetup\"\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\n\t\tsection( \"Notifications\" ) {\n\t\t\tinput sendPushMessage\n\t\t\tif (settings.phoneNumber) {\n\t\t\t\tinput phoneNumber\n\t\t\t}\n\t\t}\n\t\tsection(title: \"More options\", hideable: true) {\n\t\t\thref \"timeIntervalInput\", title: \"Only during a certain time\", description: getTimeLabel(starting, ending), state: greyedOutTime(starting, ending), refreshAfterSelection:true\n\t\t\tinput days\n\t\t\tinput modes\n\t\t}\n    }\n\n}\n\ndef installed(){\n\tinit()\n}\n\ndef updated(){\n\tunsubscribe()\n\tinit()\n}\n\ndef init(){\n\tstate.lastStatus = null\n\tsubscribe(app, appTouch)\n    runIn(60, \"temperatureHandler\")\n    subscribe(sensor, \"temperature\", temperatureHandler)\n    if(modes1){\n    \tsubscribe(location, modeBoostChange)\n    }\n\tif(doors){\n\t\tsubscribe(doors, \"contact.open\", temperatureHandler)\n        subscribe(doors, \"contact.closed\", doorCheck)\n\t}\n}\n\ndef temperatureHandler(evt) {\n\tif(modeOk && daysOk && timeOk) {\n\t\tif(setLow > setHigh){\n\t\t\tdef temp = setLow\n\t\t\tsetLow = setHigh\n\t\t\tsetHigh = temp\n\t\t}\n\t\tif (doorsOk) {\n\t\t\tdef currentTemp = sensor.latestValue(\"temperature\")\n\t\t\tif (currentTemp < setLow) {\n            \tif (state.lastStatus == \"two\" || state.lastStatus == \"three\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${cold}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${cold} because temperature is below ${setLow}\"\n\t\t\t\t\tthermostat?.\"${cold}\"()\n                    sendMessage(msg)\n                    }\n\t\t\t\tstate.lastStatus = \"one\"\n\t\t\t}\n\t\t\tif (currentTemp > setHigh) {\n            \tif (state.lastStatus == \"one\" || state.lastStatus == \"three\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${hot}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${hot} because temperature is above ${setHigh}\"\n\t\t\t\t\tthermostat?.\"${hot}\"()\n\t\t\t\t\tsendMessage(msg)\n\t\t\t\t}\n\t\t\t\tstate.lastStatus = \"two\"\n\t\t\t}\n\t\t\tif (currentTemp > setLow && currentTemp < setHigh) {\n            \tif (state.lastStatus == \"two\" || state.lastStatus == \"one\" || state.lastStatus == null){\n\t\t\t\t\t//log.info \"Setting thermostat mode to ${neutral}\"\n\t\t\t\t\tdef msg = \"I changed your thermostat mode to ${neutral} because temperature is neutral\"\n\t\t\t\t\tthermostat?.\"${neutral}\"()\n\t\t\t\t\tsendMessage(msg)\n\t\t\t\t}\n\t\t\t\tstate.lastStatus = \"three\"\n\t\t\t}\n\t\t}\n        else{\n\t\t\tdef delay = (turnOffDelay != null && turnOffDelay != \"\") ? turnOffDelay * 60 : 60\n\t\t\tlog.debug(\"Detected open doors.  Checking door states again\")\n\t\t\trunIn(delay, \"doorCheck\")\n\t\t}\n\t}\n}\n\ndef appTouch(evt) {\nif(thermostat1){\n\tstate.lastStatus = \"disabled\"\n\tdef currentCoolSetpoint = thermostat1.latestValue(\"coolingSetpoint\") as String\n    def currentHeatSetpoint = thermostat1.latestValue(\"heatingSetpoint\") as String\n    def currentMode = thermostat1.latestValue(\"thermostatMode\") as String\n\tdef mode = turnOnTherm\n    state.currentCoolSetpoint1 = currentCoolSetpoint\n    state.currentHeatSetpoint1 = currentHeatSetpoint\n    state.currentMode1 = currentMode\n\n    \tthermostat1.\"${mode}\"()\n    \tthermostat1.setCoolingSetpoint(coolingTemp)\n    \tthermostat1.setHeatingSetpoint(heatingTemp)\n\n    thermoShutOffTrigger()\n    //log.debug(\"current coolingsetpoint is ${state.currentCoolSetpoint1}\")\n    //log.debug(\"current heatingsetpoint is ${state.currentHeatSetpoint1}\")\n    //log.debug(\"current mode is ${state.currentMode1}\")\n}\n}\n\ndef modeBoostChange(evt) {\n\tif(thermostat1 && modes1.contains(location.mode)){\n\t\tstate.lastStatus = \"disabled\"\n\t\tdef currentCoolSetpoint = thermostat1.latestValue(\"coolingSetpoint\") as String\n    \tdef currentHeatSetpoint = thermostat1.latestValue(\"heatingSetpoint\") as String\n    \tdef currentMode = thermostat1.latestValue(\"thermostatMode\") as String\n\t\tdef mode = turnOnTherm\n    \tstate.currentCoolSetpoint1 = currentCoolSetpoint\n    \tstate.currentHeatSetpoint1 = currentHeatSetpoint\n    \tstate.currentMode1 = currentMode\n\n    \t\tthermostat1.\"${mode}\"()\n    \t\tthermostat1.setCoolingSetpoint(coolingTemp)\n    \t\tthermostat1.setHeatingSetpoint(heatingTemp)\n\n    \tlog.debug(\"current coolingsetpoint is ${state.currentCoolSetpoint1}\")\n    \tlog.debug(\"current heatingsetpoint is ${state.currentHeatSetpoint1}\")\n    \tlog.debug(\"current mode is ${state.currentMode1}\")\n\t}\n\telse{\n\t\tthermoShutOff()\n    }\n}\n\ndef thermoShutOffTrigger() {\n    //log.info(\"Starting timer to turn off thermostat\")\n    def delay = (turnOffDelay2 != null && turnOffDelay2 != \"\") ? turnOffDelay2 * 60 : 60\n    state.turnOffTime = now()\n\tlog.debug (\"Turn off delay is ${delay}\")\n    runIn(delay, \"thermoShutOff\")\n  }\n\ndef thermoShutOff(){\n\tif(state.lastStatus == \"disabled\"){\n\t\tdef coolSetpoint = state.currentCoolSetpoint1\n    \tdef heatSetpoint = state.currentHeatSetpoint1\n\t\tdef mode = state.currentMode1\n    \tdef coolSetpoint1 = coolSetpoint.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n    \tdef heatSetpoint1 = heatSetpoint.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n    \tdef mode1 = mode.replaceAll(\"\\\\]\", \"\").replaceAll(\"\\\\[\", \"\")\n\n\t\tstate.lastStatus = null\n\t\t//log.info(\"Returning thermostat back to normal\")\n\t\tthermostat1.setCoolingSetpoint(\"${coolSetpoint1}\")\n    \tthermostat1.setHeatingSetpoint(\"${heatSetpoint1}\")\n    \tthermostat1.\"${mode1}\"()\n    \ttemperatureHandler()\n    }\n}\n\ndef doorCheck(evt){\n\tif (!doorsOk){\n\t\tlog.debug(\"doors still open turning off ${thermostat}\")\n\t\tdef msg = \"I changed your thermostat mode to off because some doors are open\"\n\n        if (state.lastStatus != \"off\"){\n        \tthermostat?.off()\n\t\t\tsendMessage(msg)\n\t\t}\n\t\tstate.lastStatus = \"off\"\n\t}\n\n\telse{\n    \tif (state.lastStatus == \"off\"){\n\t\t\tstate.lastStatus = null\n        }\n        temperatureHandler()\n\t}\n}\n\nprivate sendMessage(msg){\n\tif (sendPushMessage == \"Yes\") {\n\t\tsendPush(msg)\n\t}\n\tif (phoneNumber != null) {\n\t\tsendSms(phoneNumber, msg)\n\t}\n}\n\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk && doorsOk\n}\n\nprivate getModeOk() {\n\tdef result = !modes || modes.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDoorsOk() {\n\tdef result = !doors || !doors.latestValue(\"contact\").contains(\"open\")\n\tlog.trace \"doorsOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tif (starting && ending) {\n\t\tdef currTime = now()\n\t\tdef start = timeToday(starting).time\n\t\tdef stop = timeToday(ending).time\n\t\tresult = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start\n\t}\n\n    else if (starting){\n    \tresult = currTime >= start\n    }\n    else if (ending){\n    \tresult = currTime <= stop\n    }\n\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\ndef getTimeLabel(starting, ending){\n\n\tdef timeLabel = \"Tap to set\"\n\n    if(starting && ending){\n    \ttimeLabel = \"Between\" + \" \" + hhmm(starting) + \" \"  + \"and\" + \" \" +  hhmm(ending)\n    }\n    else if (starting) {\n\t\ttimeLabel = \"Start at\" + \" \" + hhmm(starting)\n    }\n    else if(ending){\n    timeLabel = \"End at\" + hhmm(ending)\n    }\n\ttimeLabel\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\ndef greyedOut(){\n\tdef result = \"\"\n    if (sensor) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTherm(){\n\tdef result = \"\"\n    if (thermostat) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTherm1(){\n\tdef result = \"\"\n    if (thermostat1) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutSettings(){\n\tdef result = \"\"\n    if (starting || ending || days || modes || sendPushMessage) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\ndef greyedOutTime(starting, ending){\n\tdef result = \"\"\n    if (starting || ending) {\n    \tresult = \"complete\"\n    }\n    result\n}\n\nprivate anyoneIsHome() {\n  def result = false\n\n  if(people.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\ndef timeIntervalInput() {\n    dynamicPage(name: \"timeIntervalInput\", title: \"Only during a certain time\", refreshAfterSelection:true) {\n        section(\"\") {\n\t\t\tinput \"starting\", \"time\", title: \"Starting\", multiple: false, required: ending != null, submitOnChange: true\n\t\t\tinput \"ending\", \"time\", title: \"Ending\", multiple: false, required: starting != null, submitOnChange: true\n\t\t}\n    }\n}",
        "docstring": "Changes mode of your thermostat based on the temperature range of a specified temperature sensor and shuts off the thermostat if any windows/doors are open."
    },
    {
        "code": "section(\"Setup Menu\") {\n            href \"Setup\", title: \"Setup\", description: \"\", state:greyedOut()\n            href \"Settings\", title: \"Settings\", description: \"\", state: greyedOutSettings()\n            }\n        section([title:\"Options\", mobileOnly:true]) {\n            label title:\"Assign a name\", required:false\n        }\n    }\n}\n\n// Show \"Setup\" page\ndef Setup() {\n\n    def newMode = [\n        name:       \t\"newMode\",\n        type:       \t\"mode\",\n        title:      \t\"Modes\",\n        multiple:   \ttrue,\n        required:   \ttrue\n    ]\n    def switches = [\n        name:       \t\"switches\",\n        type:       \t\"capability.switch\",\n        title:      \t\"Switches\",\n        multiple:   \ttrue,\n        required:   \ttrue\n    ]\n    \n    def frequency_minutes = [\n        name:       \t\"frequency_minutes\",\n        type:       \t\"number\",\n        title:      \t\"Minutes?\",\n        required:\ttrue\n    ]\n    \n    def number_of_active_lights = [\n        name:       \t\"number_of_active_lights\",\n        type:       \t\"number\",\n        title:      \t\"Number of active lights\",\n        required:\ttrue,\n    ]\n    \n    def pageName = \"Setup\"\n    \n    def pageProperties = [\n        name:       \"Setup\",\n        title:      \"Setup\",\n        nextPage:   \"pageSetup\"\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\t\tsection(\"\"){            \n                    paragraph \"In this section you need to setup the deatils of how you want your lighting to be affected while \" +\n                    \"you are away.  All of these settings are required in order for the simulator to run correctly.\"\n        }\n        section(\"Simulator Triggers\") {\n                    input newMode  \n                    href \"timeIntervalInput\", title: \"Times\", description: timeIntervalLabel(), refreshAfterSelection:true\n        }\n        section(\"Light switches to turn on/off\") {\n                    input switches           \n        }\n        section(\"How often to cycle the lights\") {\n                    input frequency_minutes            \n        }\n        section(\"Number of active lights at any given time\") {\n                    input number_of_active_lights           \n        }    \n    }\n    \n}\n\n// Show \"Setup\" page\ndef Settings() {\n\n    def falseAlarmThreshold = [\n        name:       \"falseAlarmThreshold\",\n        type:       \"decimal\",\n        title:      \"Default is 2 minutes\",\n        required:\tfalse\n    ]\n    def days = [\n        name:       \"days\",\n        type:       \"enum\",\n        title:      \"Only on certain days of the week\",\n        multiple:   true,\n        required:   false,\n        options: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    ]\n    \n    def pageName = \"Settings\"\n    \n    def pageProperties = [\n        name:       \"Settings\",\n        title:      \"Settings\",\n        nextPage:   \"pageSetup\"\n    ]\n    \n    def people = [\n        name:       \"people\",\n        type:       \"capability.presenceSensor\",\n        title:      \"If these people are home do not change light status\",\n        required:\tfalse,\n        multiple:\ttrue\n    ]\n\n    return dynamicPage(pageProperties) {\n\n\t\tsection(\"\"){              \n                    paragraph \"In this section you can restrict how your simulator runs.  For instance you can restrict on which days it will run \" +\n                    \"as well as a delay for the simulator to start after it is in the correct mode.  Delaying the simulator helps with false starts based on a incorrect mode change.\"\n        }\n        section(\"Delay to start simulator\") {\n                    input falseAlarmThreshold\n        }\n        section(\"People\") {\n        \t\t\tparagraph \"Not using this setting may cause some lights to remain on when you arrive home\"\n                    input people            \n        }\n        section(\"More options\") {\n                    input days\n        } \n    }   \n}\n\ndef timeIntervalInput() {\n\tdynamicPage(name: \"timeIntervalInput\") {\n\t\tsection {\n\t\t\tinput \"startTimeType\", \"enum\", title: \"Starting at\", options: [[\"time\": \"A specific time\"], [\"sunrise\": \"Sunrise\"], [\"sunset\": \"Sunset\"]], defaultValue: \"time\", submitOnChange: true\n\t\t\tif (startTimeType in [\"sunrise\",\"sunset\"]) {\n\t\t\t\tinput \"startTimeOffset\", \"number\", title: \"Offset in minutes (+/-)\", range: \"*..*\", required: false\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinput \"starting\", \"time\", title: \"Start time\", required: false\n\t\t\t}\n\t\t}\n\t\tsection {\n\t\t\tinput \"endTimeType\", \"enum\", title: \"Ending at\", options: [[\"time\": \"A specific time\"], [\"sunrise\": \"Sunrise\"], [\"sunset\": \"Sunset\"]], defaultValue: \"time\", submitOnChange: true\n\t\t\tif (endTimeType in [\"sunrise\",\"sunset\"]) {\n\t\t\t\tinput \"endTimeOffset\", \"number\", title: \"Offset in minutes (+/-)\", range: \"*..*\", required: false\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinput \"ending\", \"time\", title: \"End time\", required: false\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ndef installed() {\ninitialize()\n}\n\ndef updated() {\n  unsubscribe();\n  unschedule();\n  initialize()\n}\n\ndef initialize(){\n\n\tif (newMode != null) {\n\t\tsubscribe(location, modeChangeHandler)\n    }\n    if (starting != null) {\n    \tschedule(starting, modeChangeHandler)\n    }\n    log.debug \"Installed with settings: ${settings}\"\n}\n\ndef modeChangeHandler(evt) {\n\t\tdef delay = (falseAlarmThreshold != null && falseAlarmThreshold != \"\") ? falseAlarmThreshold * 60 : 2 * 60  \n    \trunIn(delay, scheduleCheck)\n}\n\n\n//Main logic to pick a random set of lights from the large set of lights to turn on and then turn the rest off\ndef scheduleCheck(evt) {\n    if(allOk){\n        log.debug(\"Running\")\n        // turn off all the switches\n        switches.off()\n        \n        // grab a random switch\n        def random = new Random()\n        def inactive_switches = switches\n        for (int i = 0 ; i < number_of_active_lights ; i++) {\n            // if there are no inactive switches to turn on then let's break\n            if (inactive_switches.size() == 0){\n                break\n            }\n            \n            // grab a random switch and turn it on\n            def random_int = random.nextInt(inactive_switches.size())\n            inactive_switches[random_int].on()\n            \n            // then remove that switch from the pool off switches that can be turned on\n            inactive_switches.remove(random_int)\n        }\n        \n        // re-run again when the frequency demands it\n        schedule(\"0 0/${frequency_minutes} * 1/1 * ? *\", scheduleCheck)\n    }\n    //Check to see if mode is ok but not time/day.  If mode is still ok, check again after frequency period.\n    else if (modeOk) {\n        log.debug(\"mode OK.  Running again\")\n        switches.off()\n    }\n    //if none is ok turn off frequency check and turn off lights.\n    else {\n    \tif(people){\n        \t//don't turn off lights if anyone is home\n        \tif(someoneIsHome){\n        \t    log.debug(\"Stopping Check for Light\")\n        \t    unschedule()\n        \t}\n        \telse{\n        \t    log.debug(\"Stopping Check for Light and turning off all lights\")\n        \t    switches.off()\n        \t    unschedule()\n        \t}\n    \t}\n        else if (!modeOk) {\n        \tunschedule()\n        }\n    }\n}      \n\n\n//below is used to check restrictions\nprivate getAllOk() {\n\tmodeOk && daysOk && timeOk && homeIsEmpty\n}\n\n\nprivate getModeOk() {\n\tdef result = !newMode || newMode.contains(location.mode)\n\tlog.trace \"modeOk = $result\"\n\tresult\n}\n\nprivate getDaysOk() {\n\tdef result = true\n\tif (days) {\n\t\tdef df = new java.text.SimpleDateFormat(\"EEEE\")\n\t\tif (location.timeZone) {\n\t\t\tdf.setTimeZone(location.timeZone)\n\t\t}\n\t\telse {\n\t\t\tdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"))\n\t\t}\n\t\tdef day = df.format(new Date())\n\t\tresult = days.contains(day)\n\t}\n\tlog.trace \"daysOk = $result\"\n\tresult\n}\n\nprivate getHomeIsEmpty() {\n  def result = true\n\n  if(people?.findAll { it?.currentPresence == \"present\" }) {\n    result = false\n  }\n\n  log.debug(\"homeIsEmpty: ${result}\")\n\n  return result\n}\n\nprivate getSomeoneIsHome() {\n  def result = false\n\n  if(people?.findAll { it?.currentPresence == \"present\" }) {\n    result = true\n  }\n\n  log.debug(\"anyoneIsHome: ${result}\")\n\n  return result\n}\n\nprivate getTimeOk() {\n\tdef result = true\n\tdef start = timeWindowStart()\n\tdef stop = timeWindowStop()\n\tif (start && stop && location.timeZone) {\n\t\tresult = timeOfDayIsBetween(start, stop, new Date(), location.timeZone)\n\t}\n\tlog.trace \"timeOk = $result\"\n\tresult\n}\n\nprivate timeWindowStart() {\n\tdef result = null\n\tif (startTimeType == \"sunrise\") {\n\t\tresult = location.currentState(\"sunriseTime\")?.dateValue\n\t\tif (result && startTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(startTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (startTimeType == \"sunset\") {\n\t\tresult = location.currentState(\"sunsetTime\")?.dateValue\n\t\tif (result && startTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(startTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (starting && location.timeZone) {\n\t\tresult = timeToday(starting, location.timeZone)\n\t}\n\tlog.trace \"timeWindowStart = ${result}\"\n\tresult\n}\n\nprivate timeWindowStop() {\n\tdef result = null\n\tif (endTimeType == \"sunrise\") {\n\t\tresult = location.currentState(\"sunriseTime\")?.dateValue\n\t\tif (result && endTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(endTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (endTimeType == \"sunset\") {\n\t\tresult = location.currentState(\"sunsetTime\")?.dateValue\n\t\tif (result && endTimeOffset) {\n\t\t\tresult = new Date(result.time + Math.round(endTimeOffset * 60000))\n\t\t}\n\t}\n\telse if (ending && location.timeZone) {\n\t\tresult = timeToday(ending, location.timeZone)\n\t}\n\tlog.trace \"timeWindowStop = ${result}\"\n\tresult\n}\n\nprivate hhmm(time, fmt = \"h:mm a\")\n{\n\tdef t = timeToday(time, location.timeZone)\n\tdef f = new java.text.SimpleDateFormat(fmt)\n\tf.setTimeZone(location.timeZone ?: timeZone(time))\n\tf.format(t)\n}\n\nprivate timeIntervalLabel() {\n\tdef start = \"\"\n\tswitch (startTimeType) {\n\t\tcase \"time\":\n\t\t\tif (ending) {\n            \tstart += hhmm(starting)\n            }\n\t\t\tbreak\n\t\tcase \"sunrise\":\n\t\tcase \"sunset\":\n        \tstart += startTimeType[0].toUpperCase() + startTimeType[1..-1]\n\t\t\tif (startTimeOffset) {\n\t\t\t\tstart += startTimeOffset > 0 ? \"+${startTimeOffset} min\" : \"${startTimeOffset} min\"\n\t\t\t}\n\t\t\tbreak\n\t}\n\n    def finish = \"\"\n\tswitch (endTimeType) {\n\t\tcase \"time\":\n\t\t\tif (ending) {\n            \tfinish += hhmm(ending)\n            }\n\t\t\tbreak\n\t\tcase \"sunrise\":\n\t\tcase \"sunset\":\n        \tfinish += endTimeType[0].toUpperCase() + endTimeType[1..-1]\n\t\t\tif (endTimeOffset) {\n\t\t\t\tfinish += endTimeOffset > 0 ? \"+${endTimeOffset} min\" : \"${endTimeOffset} min\"\n\t\t\t}\n\t\t\tbreak\n\t}\n\tstart && finish ? \"${start} to ${finish}\" : \"\"\n}\n\n//sets complete/not complete for the setup section on the main dynamic page\ndef greyedOut(){\n\tdef result = \"\"\n    if (switches) {\n    \tresult = \"complete\"\t\n    }\n    result\n}\n\n//sets complete/not complete for the settings section on the main dynamic page\ndef greyedOutSettings(){\n\tdef result = \"\"\n    if (people || days || falseAlarmThreshold ) {\n    \tresult = \"complete\"\t\n    }\n    result\n}",
        "docstring": "Randomly turn on/off lights to simulate the appearance of a occupied home while you are away."
    },
    {
        "code": "section(\"Make sure this is locked\") {\n    input \"lock\",\"capability.lock\"\n  }\n  section(\"Make sure it's closed first...\"){\n    input \"contact\", \"capability.contactSensor\", title: \"Which contact sensor?\", required: false\n  }\n  section( \"Notifications\" ) {\n    input \"sendPushMessage\", \"enum\", title: \"Send a push notification?\", metadata:[values:[\"Yes\", \"No\"]], required: false\n    input \"phone\", \"phone\", title: \"Send a text message?\", required: false\n  }\n}\ndef installed() {\n  schedule(time, \"setTimeCallback\")\n\n}\n\ndef updated(settings) {\n  unschedule()\n  schedule(time, \"setTimeCallback\")\n}\n\ndef setTimeCallback() {\n  if (contact) {\n    doorOpenCheck()\n  } else {\n    lockMessage()\n    lock.lock()\n  }\n}\ndef doorOpenCheck() {\n  def currentState = contact.contactState\n  if (currentState?.value == \"open\") {\n    def msg = \"${contact.displayName} is open.  Scheduled lock failed.\"\n    log.debug msg\n    if (sendPushMessage) {\n      sendPush msg\n    }\n    if (phone) {\n      sendSms phone, msg\n    }\n  } else {\n    lockMessage()\n    lock.lock()\n  }\n}\n\ndef lockMessage() {\n  def msg = \"Locking ${lock.displayName} due to scheduled lock.\"\n  log.debug msg\n  if (sendPushMessage) {\n    sendPush msg\n  }\n  if (phone) {\n    sendSms phone, msg\n  }\n}",
        "docstring": "Make sure a door is locked at a specific time.  Option to add door contact sensor to only lock if closed."
    },
    {
        "code": "}\n\nmappings {\n\tpath(\"/switches\") {\n\t\taction: [\n\t\t\tGET: \"listSwitches\",\n\t\t\tPUT: \"updateSwitches\"\n\t\t]\n\t}\n\tpath(\"/switches/:id\") {\n\t\taction: [\n\t\t\tGET: \"showSwitch\",\n\t\t\tPUT: \"updateSwitch\"\n\t\t]\n\t}\n    path(\"/locks\") {\n\t\taction: [\n\t\t\tGET: \"listLocks\",\n\t\t\tPUT: \"updateLocks\"\n\t\t]\n\t}\n\tpath(\"/locks/:id\") {\n\t\taction: [\n\t\t\tGET: \"showLock\",\n\t\t\tPUT: \"updateLock\"\n\t\t]\n\t}\n}\n\ndef installed() {}\n\ndef updated() {}\n\ndef listSwitches() {\n\tswitches.collect { device(it,\"switch\") }\n}\nvoid updateSwitches() {\n\tupdateAll(switches)\n}\ndef showSwitch() {\n\tshow(switches, \"switch\")\n}\nvoid updateSwitch() {\n\tupdate(switches)\n}\n\ndef listLocks() {\n\tlocks.collect { device(it, \"lock\") }\n}\nvoid updateLocks() {\n\tupdateAll(locks)\n}\ndef showLock() {\n\tshow(locks, \"lock\")\n}\nvoid updateLock() {\n\tupdate(locks)\n}\n\nprivate void updateAll(devices) {\n\tdef command = request.JSON?.command\n\tdef type = params.param1\n\tif (!devices) {\n\t\thttpError(404, \"Devices not found\")\n\t}\n\t\n\tif (command){\n\t\tdevices.each { device ->\n\t\t\texecuteCommand(device, type, command)\n\t\t}\n\t}\n}\n\nprivate void update(devices) {\n\tlog.debug \"update, request: ${request.JSON}, params: ${params}, devices: $devices.id\"\n\tdef command = request.JSON?.command\n\tdef type = params.param1\n\tdef device = devices?.find { it.id == params.id }\n\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\n\tif (command) {\n\t\texecuteCommand(device, type, command)\n\t}\n}\n\n/**\n * Validating the command passed by the user based on capability.\n * @return boolean\n */\ndef validateCommand(device, deviceType, command) {\n\tdef capabilityCommands = getDeviceCapabilityCommands(device.capabilities)\n\tdef currentDeviceCapability = getCapabilityName(deviceType)\n\tif (capabilityCommands[currentDeviceCapability]) {\n\t\treturn command in capabilityCommands[currentDeviceCapability] ? true : false\n\t} else {\n\t\t// Handling other device types here, which don't accept commands\n\t\thttpError(400, \"Bad request.\")\n\t}\n}\n\n/**\n * Need to get the attribute name to do the lookup. Only\n * doing it for the device types which accept commands\n * @return attribute name of the device type\n */\ndef getCapabilityName(type) {\n    switch(type) {\n\t\tcase \"switches\":\n\t\t\treturn \"Switch\"\n\t\tcase \"locks\":\n\t\t\treturn \"Lock\"\n\t\tdefault:\n\t\t\treturn type\n\t}\n}\n\n/**\n * Constructing the map over here of\n * supported commands by device capability\n * @return a map of device capability -> supported commands\n */\ndef getDeviceCapabilityCommands(deviceCapabilities) {\n\tdef map = [:]\n\tdeviceCapabilities.collect {\n\t\tmap[it.name] = it.commands.collect{ it.name.toString() }\n\t}\n\treturn map\n}\n\n/**\n * Validates and executes the command\n * on the device or devices\n */\ndef executeCommand(device, type, command) {\n\tif (validateCommand(device, type, command)) {\n\t\tdevice.\"$command\"()\n\t} else {\n\t\thttpError(403, \"Access denied. This command is not supported by current capability.\")\n\t}\t\n}\n\nprivate show(devices, name) {\n\tdef device = devices.find { it.id == params.id }\n\tif (!device) {\n\t\thttpError(404, \"Device not found\")\n\t}\n\telse {\n\t\tdef s = device.currentState(name)\n\t\t[id: device.id, label: device.displayName, name: device.displayName, state: s]\n\t}\n}\n\nprivate device(it, name) {\n\tif (it) {\n\t\tdef s = it.currentState(name)\n\t\t[id: it.id, label: it.displayName, name: it.displayName, state: s]\n    }\n}",
        "docstring": "This SmartApp allows you to interact with the things in your physical graph through Alfred."
    },
    {
        "code": "section(hidden: true, hideable: true, title: \"Other Options\") {\n\t\t\tlabel(title: \"Label this Notification\", required: false)\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tsubscribe(location, modeChangeHandler)\n}\n\ndef modeChangeHandler(evt) {\n\tdef newMode = evt.value\n\tlog.debug \"evt: ${newMode}\"\n\tif (modes && modes.contains(newMode))\n\t{\n\t\tdef message = customMessage ?: \"SmartThings mode has changed to: \\\"${newMode}\\\"\"\n\t\tchatMessageToMC(message)\n\t}\n}\n\ndef chatMessageToMC(message) {\n\n\tdef parent = app.getParent()\n\n\tdef url = \"${parent.getServerURL()}/chat?message=${message.encodeAsURL()}\"\n\n\tif (username)\n\t{\n\t\turl += \"&username=${username.encodeAsURL()}\"\n\t}\n\tlog.debug \"POST to ${url}\"\n\n\thttpPost(url, \"foo=bar\") { response ->\n\t\tcontent = response.data\n\t\tlog.debug \"response: ${content}\"\n\t}\n\n}",
        "docstring": "Send chat messages into Minecraft via the SmartBlock mod"
    },
    {
        "code": "\"\n\n\tdynamicPage(name: \"linkerPage\", title: \"Link your SmartBlock to a physical device\", install: true, uninstall: false) {\n\n\t\tsection {\n\t\t\tinput(\n\t\t\t\tname: \"linkedSmartBlock\",\n\t\t\t\ttype: \"capability.switch\",\n//\t\t\t\ttype: \"device.SmartBlock\",\n\t\t\t\ttitle: \"Linked SmartBlock\",\n\t\t\t\trequired: true,\n\t\t\t\tmultiple: false\n\t\t\t)\n\t\t\tinput(\n\t\t\t\tname: \"switchUpdatesBlock\",\n\t\t\t\ttype: \"bool\",\n\t\t\t\ttitle: \"Update this SmartBlock when the switch below changes state\",\n\t\t\t\tdescription: \"\",\n\t\t\t\tdefaultValue: \"false\"\n\t\t\t)\n\t\t}\n\t\tsection {\n\t\t\tinput(\n\t\t\t\tname: \"linkedSwitch\",\n\t\t\t\ttype: \"capability.switch\",\n\t\t\t\ttitle: \"Linked Switch\",\n\t\t\t\trequired: true,\n\t\t\t\tmultiple: false\n\t\t\t)\n\t\t\tinput(\n\t\t\t\tname: \"blockUpdatesSwitch\",\n\t\t\t\ttype: \"bool\",\n\t\t\t\ttitle: \"Update this switch when the SmartBlock above changes state\",\n\t\t\t\tdescription: \"\",\n\t\t\t\tdefaultValue: \"true\"\n\t\t\t)\n\t\t}\n\n\t\tsection {\n\t\t\tlabel(\n\t\t\t\ttitle: \"Label this Link\",\n\t\t\t\trequired: false\n\t\t\t)\n\t\t\tmode(\n\t\t\t\ttitle: \"Only link these devices when in one of these modes\",\n\t\t\t\tdescription: \"All modes\"\n\t\t\t)\n\t\t}\n\n\t\tsection(\"When \\\"Update this SmartBlock...\\\" is on\") {\n\t\t\tparagraph \"If you place a Redstone Lamp next to your SmartBlock, it will turn on/off when \\\"Linked Switch\\\" turns on/off\"\n\t\t}\n\n\t\tsection(\"When \\\"Update this switch...\\\" is on\") {\n\t\t\tparagraph \"If you place a lever on your Minecraft SmartBlock, it will control \\\"Linked Switch\\\"\"\n\t\t}\n\n\t\tsection(\"Why turning both on can be bad\") {\n\t\t\tparagraph \"Because there can be latency.\"\n\t\t\tparagraph \"Flipping the lever will send a signal from Minecraft to SmartThings. SmartThings will then send the signal back when the light has turned on.\"\n\t\t\tparagraph \"If you flip the lever again before that round trip is complete, you can get into an infinite loop of signals being sent back and forth.\"\n\t\t\tparagraph \"You've been warned ;)\"\n\t\t}\n\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\n\tif (blockUpdatesSwitch)\n\t{\n\t\tsubscribe(linkedSmartBlock, \"level\", updateSwitchLevel)\n\t\tsubscribe(linkedSmartBlock, \"switch\", updateSwitchState)\n\t}\n\n\tif (switchUpdatesBlock)\n\t{\n\t\tsubscribe(linkedSwitch, \"level\", updateBlockLevel)\n\t\tsubscribe(linkedSwitch, \"switch\", updateBlockState)\n\t}\n\n}\n\ndef updateSwitchLevel(evt) {\n\tint level = evt.value as int\n\tlog.debug \"matching level: ${level}\"\n\tlinkedSwitch.setLevel(level)\n}\n\ndef updateBlockLevel(evt) {\n\tint level = evt.value as int\n\tlog.debug \"matching level: ${level}\"\n\tlinkedSmartBlock.setLevel(level)\n}\n\ndef updateSwitchState(evt) {\n\tlog.debug \"setting linkedSwitch to ${evt.value}\"\n\tlinkedSwitch.\"${evt.value}\"()\n}\n\ndef updateBlockState(evt) {\n\tlog.debug \"setting linkedSmartBlock to ${evt.value}\"\n\tlinkedSmartBlock.\"${evt.value}\"()\n}\n\ndef getBlockId() {\n\treturn linkedSmartBlock.id\n}\n\ndef getLinkerDescription() {\n\n\tdef left = linkedSmartBlock ? \"${linkedSmartBlock.label ?: linkedSmartBlock.name}\" : \"\"\n\tdef right = linkedSwitch ? \"${linkedSwitch.label ?: linkedSwitch.name}\" : \"\"\n\n\tlog.debug \"left: ${left}, right: ${right}\"\n\n\tdef leftLink = switchUpdatesBlock ? \"<\" : \"\"\n\tdef rightLink = blockUpdatesSwitch ? \">\" : \"\"\n\n\tlog.debug \"leftLink: ${leftLink}, rightLink: ${rightLink}\"\n\n\tlog.debug \"switchUpdatesBlock: ${switchUpdatesBlock}\"\n\tlog.debug \"blockUpdatesSwitch: ${blockUpdatesSwitch}\"\n\n\tif (leftLink == \"\" && rightLink == \"\")\n\t{\n\t\treturn null\n\t}\n\n\t\"${left} ${leftLink}--${rightLink} ${right}\"\n}",
        "docstring": "A SmartApp that links SmartBlocks to switches"
    },
    {
        "code": "}\n\ndef listPage() {\n\n\tlog.debug \"listPage\"\n\n\tdef linkerApps = findAllChildAppsByName(\"SmartBlock Linker\")\n\tdef linkerState = linkerApps ? \"complete\" : \"\"\n\tdef linkerDescription = linkerApps.collect { it.label ?: it.name }.sort().join(\"\\n\")\n\n\tdef notifierApps = findAllChildAppsByName(\"SmartBlock Notifier\")\n\tdef notifierState = notifierApps ? \"complete\" : \"\"\n\tdef notifierDescription = notifierApps.collect { it.label ?: it.name }.sort().join(\"\\n\")\n\n\tdef chatApps = findAllChildAppsByName(\"SmartBlock Chat Sender\")\n\tdef chatState = chatApps ? \"complete\" : \"\"\n\tdef chatDescription = chatApps.collect { it.label ?: it.name }.sort().join(\"\\n\")\n\n\treturn dynamicPage(name: \"listPage\", title: \"Configure Your SmartBlocks\", install: true, uninstall: true) {\n\t\tsection {\n\t\t\thref(\n\t\t\t\tname: \"toLinkerPage\",\n\t\t\t\ttitle: \"Link SmartBlocks To Switches\",\n\t\t\t\tdescription: linkerDescription,\n\t\t\t\tpage: \"linkerPage\",\n\t\t\t\tstate: linkerState\n\t\t\t)\n\t\t\thref(\n\t\t\t\tname: \"toNotifierPage\",\n\t\t\t\ttitle: \"Get Notified When a SmartBlock updates\",\n\t\t\t\tdescription: notifierDescription,\n\t\t\t\tpage: \"notifierPage\",\n\t\t\t\tstate: notifierState\n\t\t\t)\n\t\t\thref(\n\t\t\t\tname: \"toChatPage\",\n\t\t\t\ttitle: \"Send Notifications into Minecraft\",\n\t\t\t\tdescription: chatDescription,\n\t\t\t\tpage: \"chatPage\",\n\t\t\t\tstate: chatState\n\t\t\t)\n\t\t}\n\n\t\tsection {\n\t\t\tinput(\n\t\t\t\tname: \"serverIp\",\n\t\t\t\ttitle: \"In order for SmartThings to send commands back to the SmartBlocks on your Minecraft server, you will have to enter your Server Address\",\n\t\t\t\ttype: \"text\",\n\t\t\t\trequired: false\n\t\t\t)\n\t\t}\n\t}\n}\n\ndef serverPage() {\n\tlog.debug \"serverPage\"\n\tdynamicPage(name: \"serverPage\", title: \"Connect SmartThings To Your Minecraft Server\") {\n\t\tsection {\n\t\t\tinput(\n\t\t\t\tname: \"serverIp\",\n\t\t\t\ttitle: \"In order for SmartThings to send commands back to the SmartBlocks on your Minecraft server, you will have to enter your Server Address\",\n\t\t\t\ttype: \"text\",\n\t\t\t\trequired: false\n\t\t\t)\n\t\t}\n\t}\n}\n\n\ndef linkerPage() {\n\tdynamicPage(name: \"linkerPage\", title: \"Link SmartBlocks To Switches\") {\n\t\tsection {\n\t\t\tapp(\n\t\t\t\ttitle: \"Link a SmartBlock to a switch\",\n\t\t\t\tname: \"blockLinker-new\",\n\t\t\t\tnamespace: \"vlaminck/Minecraft\",\n\t\t\t\tappName: \"SmartBlock Linker\",\n\t\t\t\tpage: \"linkerPage\",\n\t\t\t\tmultiple: true,\n\t\t\t\tparams: [\"blocks\": getChildDevices()]\n\t\t\t)\n\t\t}\n\t}\n\n}\n\ndef notifierPage() {\n\treturn dynamicPage(name: \"notifierPage\", title: \"Get Notified When a SmartBlock is updated\") {\n\t\tsection {\n\t\t\tapp(\n\t\t\t\ttitle: \"Get Notified\",\n\t\t\t\tname: \"blockNotifier-new\",\n\t\t\t\tnamespace: \"vlaminck/Minecraft\",\n\t\t\t\tappName: \"SmartBlock Notifier\",\n\t\t\t\tmultiple: true\n\t\t\t)\n\t\t}\n\t}\n}\n\ndef chatPage() {\n\treturn dynamicPage(name: \"chatPage\", title: \"Send Notifications into Minecraft\") {\n\t\tsection {\n\t\t\tapp(\n\t\t\t\ttitle: \"Send Notifications\",\n\t\t\t\tname: \"chatSender-new\",\n\t\t\t\tnamespace: \"vlaminck/Minecraft\",\n\t\t\t\tappName: \"SmartBlock Chat Sender\",\n\t\t\t\tmultiple: true\n\t\t\t)\n\t\t}\n\t}\n}\n\nmappings {\n\tpath(\"/block\") { // any need for GET?\n\t\taction:\n\t\t[\n\t\t\tPOST  : \"createBlock\",\n\t\t\tPUT   : \"updateBlock\",\n\t\t\tDELETE: \"deleteBlock\"\n\t\t]\n\t}\n\tpath(\"/ack\") {\n\t\taction:\n\t\t[\n\t\t\tPOST: \"ack\"\n\t\t]\n\t}\n}\n\ndef createBlock() {\n\tdef data = request.JSON\n\tdef blockCoordinates = blockCoordinates(data)\n\tdef blockDNI = blockDNI(data)\n\tdef block = block(data)\n\n\tif (block) {\n\t\tlog.debug \"Block ${block?.label} with id $blockDNI already exists\"\n\t} else {\n\t\tblock = addChildDevice(\"vlaminck/Minecraft\", \"Smart Block\", blockDNI, null, [name: \"SmartBlock\", label: \"SmartBlock $blockCoordinates\"])\n\t}\n\n\tblock?.setCoordinates(data.x, data.y, data.z)\n\tblock?.setDestroyed(false)\n\tblock?.setWorldSeed(data?.worldSeed)\n\tblock?.setDimensionName(data?.dimensionName)\n\tblock?.setPlacedBy(data?.placedBy)\n\n\tif (serverIp) {\n\t\tblock.setServerIp(serverIp)\n\t}\n\n\tlog.debug \"created ${block?.label} with id $blockDNI\"\n}\n\ndef ack() {\n\tlog.debug \"ack params : $params\"\n\tlog.debug \"ack JSON : ${request.JSON}\"\n\n\tsendDataToBlock(request?.JSON, false)\n}\n\ndef updateBlock() {\n\tsendDataToBlock(request?.JSON, true)\n}\n\ndef sendDataToBlock(data, isStateChange) {\n\n\tdef blockCoordinates = blockCoordinates(data)\n\tdef blockDNI = blockDNI(data)\n\tdef block = block(data)\n\tlog.debug \"updating Block ${block?.label} with id $blockDNI\"\n\n\tblock?.neighborBlockChange(data)\n\n\tif (data.worldSeed) {\n\t\tblock.setWorldSeed(data.worldSeed)\n\t}\n\n\tif (data.dimensionName) {\n\t\tblock.setDimensionName(data.dimensionName)\n\t}\n\n\tif (data.placedBy) {\n\t\tblock.setPlacedBy(data.placedBy)\n\t}\n\n\tblock.setServerIp(serverIp)\n\n}\n\ndef deleteBlock() {\n\tdef data = request.JSON\n\tdef blockDNI = blockDNI(data)\n\tdef block = block(data)\n\n\tblock?.setDestroyed(true)\n\n\n\n\tlog.debug \"attempting to delete Block ${block?.label} with id $blockDNI\"\n\tdeleteChildDevice(blockDNI)\n}\n\nprivate blockCoordinates(data) {\n\treturn \"(${data?.x},${data?.y},${data?.z})\"\n}\n\nprivate blockDNI(data) {\n\t\"${data.worldSeed}|${data.dimensionName}|${blockCoordinates(data)}\".encodeAsMD5()\n}\n\nprivate block(data) {\n\treturn getChildDevice(blockDNI(data))\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\t// update all children with serverIp.\n\tif (serverIp) {\n\t\tgetChildDevices().each { block ->\n\t\t\tblock.setServerIp(serverIp)\n\t\t}\n\t}\n\n}\n\npublic getServerURL() {\n\treturn \"http://${serverIp}:3333\"\n}",
        "docstring": "A SmartApp for managing SmartBlocks"
    },
    {
        "code": "section(\"Why would you like to be notified?\") {\n\t\t\thref(name: \"toDestroyedPage\", page: destroyedPageName, title: \"Because it was destroyed\", description: destroyedDescription, state: destroyedState)\n\n\t\t\thref(name: \"toRedstonePage\", page: redstonePageName, title: \"Because its redstone signal changed\", description: redstoneDescription, state: redstoneState)\n\t\t\thref(name: \"toNeighborPage\", page: neighborPageName, title: \"Because a block next to it changed\", description: neighborDescription, state: neighborState)\n\t\t}\n\n\t\tsection(\"Other Options\") {\n\t\t\tlabel(title: \"Label this notification\", description: app.name, required: false, defaultValue: defaultLabelValue)\n\t\t\tmode(title: \"Only send notifications when in one of these modes\", description: \"All modes\")\n\t\t}\n\t}\n}\n\ndef destroyedPage() {\n\tdef pageName = \"destroyedPage\"\n\tdynamicPage(name: pageName, title: \"For when your block is destroyed\") {\n\t\tsmartPhoneNotificationSection(pageName)\n\t\tchatSection(pageName)\n\t\tmessageBuilderSection(pageName)\n\t\tchatClosestPlayerSection(pageName)\n\t}\n}\n\ndef redstonePage() {\n\tdef pageName = \"redstonePage\"\n\tdynamicPage(name: pageName, title: \"Get Notified For Redstone Changes\") {\n\t\tsection(\"When Redstone Is\") {\n\t\t\tinput(name: \"redstoneGreaterThan\", type: \"enum\", required: false, title: \"Greater Than\", options: (0..15).collect {\n\t\t\t\t\"${it}\"\n\t\t\t})\n\t\t\tinput(name: \"redstoneLessThan\", type: \"enum\", required: false, title: \"Less than\", options: (0..15).collect {\n\t\t\t\t\"${it}\"\n\t\t\t})\n\t\t\tinput(name: \"redstoneEqualTo\", type: \"enum\", required: false, title: \"Equal to\", options: (0..15).collect {\n\t\t\t\t\"${it}\"\n\t\t\t})\n\t\t}\n\t\tsmartPhoneNotificationSection(pageName)\n\t\tchatSection(pageName)\n\t\tmessageBuilderSection(pageName)\n\t}\n}\n\ndef neighborBlockPage() {\n\tdef pageName = \"neighborBlockPage\"\n\tdynamicPage(name: pageName, title: \"Get Notified When a neighbor block updates\") {\n\t\tsection(\"Not all blocks send updates, but Chests definitely do\") {\n\t\t\tinput(type: \"enum\", name: \"neighborBlockParsed\", title: \"When any of these blocks are updated\", required: false, multiple: true, options: allBlocksParsed())\n\t\t}\n\n\t\tsmartPhoneNotificationSection(pageName)\n\t\tchatSection(pageName)\n\t\tmessageBuilderSection(pageName)\n\t\tchatClosestPlayerSection(pageName)\n\n\t\tsection(title: \"More Info\", hideable: true, hidden: true) {\n\t\t\thref(name: \"allIds\", title: \"A full list of blocks and items can be found here\", url: \"http://minecraft.gamepedia.com/Ids\", style: \"external\", description: null)\n\t\t}\n\t}\n}\n\ndef messageBuilderPage(params) {\n\n\tdef pageName = params.pageName\n\tdef size = messageBuilderOptions().size() * 2\n\n\tdynamicPage(name: \"messageBuilderPage\", title: \"Build your message\") {\n\t\tsection(\"These will be combined to form the final message.\") {\n\t\t\t(0..size).each {\n\t\t\t\tinput(\n\t\t\t\t\tname: \"${pageName}MessagePart${it}\",\n\t\t\t\t\ttype: (it % 2) ? \"enum\" : \"text\",\n\t\t\t\t\tdefaultValue: messagePartDefaultValue(pageName, it),\n\t\t\t\t\toptions: (it % 2) ? messageBuilderOptions() : null,\n\t\t\t\t\ttitle: null, description: null, required: false, multiple: false\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef smartPhoneNotificationSection(pageName) {\n\tsection(\"SmartPhone notifications\") {\n        input(\"recipients\", \"contact\", title: \"Send notifications to\") {\n            input(name: \"${pageName}WantsPush\", title: \"Push Notification\", description: null, type: \"bool\", required: false, defaultValue: \"false\")\n            input(name: \"${pageName}WantsSms\", title: \"Text Message\", description: \"phone number\", type: \"phone\", required: false)\n        }\n\t\tinput(name: \"${pageName}WantsHH\", title: \"Hello Home only\", description: null, type: \"bool\", required: false)\n\t}\n}\n\ndef chatSection(pageName) {\n\tsection(\"Minecraft Chat Message\") {\n\t\tinput(name: \"${pageName}ChatAllUsers\", title: \"Chat all users\", type: \"bool\", required: false)\n\t\tinput(name: \"${pageName}ChatUsername\", title: \"Or chat to a specific username\", type: \"text\", required: false)\n\t}\n}\n\ndef messageBuilderSection(pageName) {\n\tsection(\"What should your message say?\") {\n\t\tmessageBuilderHref(pageName)\n\t}\n}\n\ndef messageBuilderHref(pageName) {\n\tdef partsAreSet = messagePartsSet(pageName)\n\tdef messageState = partsAreSet ? \"complete\" : \"\"\n\tdef messageDescription = partsAreSet ? messageDescriptionForPage(pageName) : defaultMessageDescription(pageName)\n\n\thref(\n\t\tname: \"toBuilder\",\n\t\tpage: \"messageBuilderPage\",\n\t\ttitle: null,\n\t\tdescription: messageDescription ?: \"Construct your message\",\n\t\tstate: messageState,\n\t\tparams: [pageName: pageName]\n\t)\n}\n\ndef chatClosestPlayerSection(pageName) {\n\tsection(\"Chat the closest player to the block. (usually the player that destroyed it)\") {\n\t\tmessageBuilderHref(\"${pageName}ClosestPlayer\")\n\t}\n}\n\ndef pageStateComplete(pageName) {\n\n\tif (pageName == \"redstonePage\") {\n\t\tif (redstoneGreaterThan) return true\n\t\tif (redstoneLessThan) return true\n\t\tif (redstoneEqualTo) return true\n\t\treturn false\n\t}\n\n\tif (pageName == \"neighborBlockPage\") {\n\t\tif (neighborBlockParsed) return true\n\t\treturn false\n\t}\n\n\tif (app.\"${pageName}WantsPush\") return true\n\tif (app.\"${pageName}WantsSms\") return true\n\tif (app.\"${pageName}WantsHH\") return true\n\tif (app.\"${pageName}ChatAllUsers\") return true\n\tif (app.\"${pageName}ChatUsername\") return true\n\tif (app.\"${pageName}ClosestPlayer\") return true\n\n\treturn false\n}\n\n/*\n* INITIALIZE\n*/\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\tinitialize()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\tunsubscribe()\n\tinitialize()\n}\n\ndef initialize() {\n\tlog.debug \"initializing\"\n\tsubscribe(smartBlock, \"redstoneSignalStrength\", redstoneSignalStrengthHandler)\n\tsubscribe(smartBlock, \"smartBlockNeighborChanged\", smartBlockNeighborChangedHandler, [filterEvents: false])\n\tsubscribe(smartBlock, \"smartBlockNeighborChanged\", smartBlockNeighborChangedHandler, [filterEvents: false])\n\tsubscribe(smartBlock, \"blockDestroyed.true\", smartBlockDestroyedHandler, [filterEvents: false])\n}\n\n/*\n* EVENT HANDLERS\n*/\n\ndef smartBlockDestroyedHandler(evt) {\n\tlog.debug \"smartBlockDestroyedHandler evt.value: ${evt.value}\"\n\n\tdef pageName = \"destroyedPage\"\n\tdef message = message(pageName)\n\tnotifyUser(pageName, message)\n}\n\ndef smartBlockNeighborChangedHandler(evt) {\n\tlog.debug \"smartBlockNeighborChangedHandler evt.value: ${evt.value}\"\n\tlog.debug \"neighborBlockParsed: ${neighborBlockParsed}\"\n\n\tif (neighborBlockParsed?.contains(evt.value)) {\n\t\tnotifyUserOfNeighborChange(evt.value)\n\t}\n}\n\ndef redstoneSignalStrengthHandler(evt) {\n\tlog.debug \"redstoneSignalStrengthHandler: ${evt.value}\"\n\n\tint newValue = evt.value as int\n\tint lastValue = smartBlock.latestState(\"redstoneSignalStrength\").value as int\n\n\tif (redstoneGreaterThan) {\n\t\tint gt = redstoneGreaterThan as int\n//\t\tlog.debug \"$newValue > $gt\"\n\t\tif (newValue > gt) {\n\t\t\tlog.debug \"greater than ${gt}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n\tif (redstoneLessThan) {\n\t\tint lt = redstoneLessThan as int\n//\t\tlog.debug \"$newValue < $lt\"\n\t\tif (newValue < lt) {\n\t\t\tlog.debug \"less than ${lt}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n\tif (redstoneEqualTo) {\n\t\tint et = redstoneEqualTo as int\n//\t\tlog.debug \"$newValue == $et\"\n\t\tif (newValue == et) {\n\t\t\tlog.debug \"equal to ${et}. send notification\"\n\t\t\tnotifyUserOfRedstoneChange(newValue)\n\t\t}\n\t}\n\n}\n\n/*\n* NOTIFICATIONS\n*/\n\ndef notifyUserOfRedstoneChange(value) {\n\tdef msg = message(\"redstonePage\")\n\tlog.debug \"message: ${msg}\"\n\tdef notificationMessage = msg ?: \"${smartBlock} redstone signal is ${value}\"\n\tnotifyUser(notificationMessage)\n}\n\ndef notifyUserOfNeighborChange(value) {\n\tdef msg = message(\"neighborPage\")\n\tlog.debug \"message: ${msg}\"\n\tdef notificationMessage = msg ?: \"${smartBlock} was updated by ${value}\"\n\tnotifyUser(notificationMessage)\n}\n\ndef notifyUser(pageName, messageToSend) {\n\tlog.debug \"notifyUser pageName: ${pageName}\"\n\n\tdef closestPlayerMessage = message(\"${pageName}ClosestPlayer\")\n\tlog.debug \"closestPlayerMessage = ${closestPlayerMessage}\"\n\tdef latestClosePlayer = getLatestClosePlayer()\n\tlog.debug \"latestClosePlayer = ${latestClosePlayer}\"\n\tif (closestPlayerMessage && latestClosePlayer != \"unknown\") {\n\t\tlog.debug \"chatting closestPlayer\"\n\t\tchatMessageToMC(closestPlayerMessage, latestClosePlayer)\n\t}\n\n\n\tdef wantsHH = app.\"${pageName}WantsHH\"\n\tlog.debug \"wantsHH = ${wantsHH}\"\n\tif (wantsHH) {\n\n\t\tlog.debug \"sending HH\"\n\t\tsendNotificationEvent(messageToSend)\n\n\t} else {\n        if (location.contactBookEnabled) {\n            sendNotificationToContacts(messageToSend, recipients)\n        }\n        else {\n\n            def wantsPush = app.\"${pageName}WantsPush\"\n            log.debug \"wantsPush = ${wantsPush}\"\n            if (wantsPush && wantsPush != \"false\") {\n                log.debug \"sending push\"\n                sendPush(messageToSend)\n            }\n\n            def wantsSms = app.\"${pageName}WantsSms\"\n            log.debug \"wantsSms = ${wantsSms}\"\n            if (wantsSms) {\n                log.debug \"sending sms to: ${wantsSms}\"\n                sendSms(wantsSms, messageToSend)\n            }\n        }\n\t}\n\n\tdef username = app.\"${pageName}ChatUsername\"\n\tdef allUsers = app.\"${pageName}ChatAllUsers\"\n\n\tlog.debug \"username = ${username}\"\n\tlog.debug \"allUsers = ${allUsers}\"\n\n\tif (username && username != \"\") {\n\t\tlog.debug \"chatting username: ${username}\"\n\t\tchatMessageToMC(messageToSend, username)\n\t} else if (allUsers) {\n\t\tlog.debug \"chatting all users\"\n\t\tchatMessageToMC(messageToSend, null)\n\t}\n\n}\n\ndef chatMessageToMC(message, username) {\n\tlog.debug \"chatMessageToMC\"\n\n\tdef url = \"${app.getParent().getServerURL()}/chat?message=${message.encodeAsURL()}\"\n\tif (username) {\n\t\turl = \"${url}&username=${username.encodeAsURL()}\"\n\t}\n\n\tlog.debug \"POST to ${url}\"\n\n\thttpPost(url, \"foo=bar\") {}\n}\n\ndef messageDescriptionPartsForPage(pageName) {\n\tdef size = messageBuilderOptions().size() * 2\n\t(0..size).collect { app.\"${pageName}MessagePart${it}\" }\n}\n\ndef messagePartsSet(pageName) { // are any set?\n\tmessageDescriptionPartsForPage(pageName).collect { !it }.unique().contains(false)\n}\n\ndef defaultMessageDescription(pageName) {\n\tdef description = \"\"\n\n\tif (pageName == \"destroyedPage\" || pageName == \"redstonePage\" || pageName == \"neighborBlockPage\") {\n\t\tdef second = messageBuilderOptions()[messagePartDefaultValue(pageName, 1)]\n\t\tif (second) description = \"\\${${second}}\"\n\n\t\tdef third = messagePartDefaultValue(pageName, 2)\n\t\tif (third) description = \"${description} ${third}\"\n\n\t\tdef fourth = messageBuilderOptions()[messagePartDefaultValue(pageName, 3)]\n\t\tif (fourth) description = \"${description} \\${${fourth}}\"\n\t}\n\n\treturn description\n}\n\ndef messageDescriptionForPage(pageName) {\n\n\tdef parts = messageDescriptionPartsForPage(pageName)\n\tdef messageParts = []\n\tparts.eachWithIndex { part, idx ->\n\t\tif (part != null && part != \"null\") {\n\t\t\tif (idx % 2) {\n\t\t\t\tmessageParts << \"\\${${messageBuilderOptions()[part]}}\"\n\t\t\t} else {\n\t\t\t\tmessageParts << part\n\t\t\t}\n\t\t}\n\t}\n\n\tif (messageParts) {\n\t\treturn messageParts.join(\" \").trim()\n\t} else {\n\t\treturn defaultMessageDescription()\n\t}\n}\n\ndef messagePartDefaultValue(pageName, part) {\n\tif (pageName == \"destroyedPage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"was destroyed by\"\n\t\tif (part == 3) return \"closestPlayer\"\n\t}\n\n\tif (pageName == \"neighborBlockPage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"has a redstone signal of\"\n\t\tif (part == 3) return \"redstoneSignalStrength\"\n\t}\n\n\tif (pageName == \"redstonePage\") {\n\t\tif (part == 1) return \"name\"\n\t\tif (part == 2) return \"was updated by\"\n\t\tif (part == 3) return \"closestPlayer\"\n\t}\n\n\treturn null\n}\n\ndef message(pageName) {\n\tlog.debug \"building message\"\n\tdef messageParts = []\n\n\tmessageDescriptionPartsForPage(pageName).eachWithIndex { part, idx ->\n\t\tif (idx % 2) {\n//\t\t\tdef option = messageBuilderOptions()[part]\n\t\t\tdef optionPart = getMessagePartFromOption(part)\n\t\t\tif (optionPart) messageParts << optionPart\n\t\t} else {\n\t\t\tif (part) messageParts << part\n\t\t}\n\t}\n\n\tdef message = messageParts.join(\" \").trim()\n\tlog.debug \"message: ${message}\"\n\treturn message\n}\n\ndef messageBuilderOptions() {\n\treturn [\n\t\t\"name\": \"SmartBlock name\",\n\t\t\"neighborBlockName\": \"Neighbor block name\",\n\t\t\"blockDestroyed\": \"Destroyed State ('destroyed' / 'OK')\",\n\t\t\"redstoneSignalStrength\": \"Redstone signal strength\",\n\t\t\"worldSeed\": \"World seed\",\n\t\t\"dimensionName\": \"Dimension name (World, Nether, End)\",\n\t\t\"coordinates\": \"Block coordinates\",\n\t\t\"closestPlayer\": \"Username of Closest player (within the past minute)\",\n\t\t\"placedBy\": \"Username of who placed the block\"\n\t]\n}\n\ndef getMessagePartFromOption(optionKey) {\n\tlog.debug \"optionKey: ${optionKey}\"\n\tif (optionKey == \"name\") return smartBlock.label ?: smartBlock.name\n\tif (optionKey == \"closestPlayer\") return getLatestClosePlayer()\n\tif (optionKey == \"blockDestroyed\") return smartBlock.latestValue(\"blockDestroyed\") ? \"OK\" : \"destroyed\"\n\treturn smartBlock.latestValue(optionKey)\n}\n\ndef getLatestClosePlayer() {\n\tdef now = new Date()\n\tdef minusOne = new Date(minutes: now.minutes - 1)\n\tdef latestStates = smartBlock.statesSince(\"closestPlayer\", minusOne)\n\tif (latestStates.size) {\n\t\treturn latestStates[0].value\n\t}\n\treturn \"unknown\"\n}\n\n/*\n* BLOCKS\n*/\n\ndef settingsAsIds() {\n\tlog.debug \"settingsAsIds\"\n\tlog.debug \"neighborBlockParsed: $neighborBlockParsed\"\n\n\tdef subscribedIds = []\n\n\tneighborBlockParsed.each {\n\t\tsubscribedIds << convertBlockSettingToBlockId(it)\n\t}\n\n\treturn subscribedIds\n}\n\ndef convertBlockSettingToBlockId(setting) {\n\tdef id = setting.substring(0, setting.indexOf(\" \"))\n\tdef name = allBlocks()[id]\n\tlog.debug \"id: $id, name:${name}\"\n\treturn id\n}\n\ndef allBlocksParsed() {\n\tallBlocks().collect { k, v -> \"${k} ${v}\" }\n}\n\ndef allBlocks() {\n\t[\n\t\t\"0\": \"Air\",\n\t\t\"1\": \"Stone\",\n\t\t\"2\": \"Grass\",\n\t\t\"3\": \"Dirt\",\n\t\t\"4\": \"Cobblestone\",\n\t\t\"5\": \"Oak Wood Plank\",\n\t\t\"5:1\": \"Spruce Wood Plank\",\n\t\t\"5:2\": \"Birch Wood Plank\",\n\t\t\"5:3\": \"Jungle Wood Plank\",\n\t\t\"6\": \"Oak Sapling\",\n\t\t\"6:1\": \"Spruce Sapling\",\n\t\t\"6:2\": \"Birch Sapling\",\n\t\t\"6:3\": \"Jungle Sapling\",\n\t\t\"7\": \"Bedrock\",\n\t\t\"8\": \"Water\",\n\t\t\"9\": \"Stationary Water\",\n\t\t\"10\": \"Lava\",\n\t\t\"11\": \"Stationary Lava\",\n\t\t\"12\": \"Sand\",\n\t\t\"13\": \"Gravel\",\n\t\t\"14\": \"Gold Ore\",\n\t\t\"15\": \"Iron Ore\",\n\t\t\"16\": \"Coal Ore\",\n\t\t\"17\": \"Oak Wood\",\n\t\t\"17:1\": \"Spruce Wood\",\n\t\t\"17:2\": \"Birch Wood\",\n\t\t\"17:3\": \"Jungle Wood\",\n\t\t\"18\": \"Oak Leaves\",\n\t\t\"18:1\": \"Spruce Leaves\",\n\t\t\"18:2\": \"Birch Leaves\",\n\t\t\"18:3\": \"Jungle Leaves\",\n\t\t\"19\": \"Sponge\",\n\t\t\"20\": \"Glass\",\n\t\t\"21\": \"Lapis Lazuli Ore\",\n\t\t\"22\": \"Lapis Lazuli Block\",\n\t\t\"23\": \"Dispenser\",\n\t\t\"24\": \"Sandstone\",\n\t\t\"24:1\": \"Chiseled Sandstone\",\n\t\t\"24:2\": \"Smooth Sandstone\",\n\t\t\"25\": \"Note Block\",\n\t\t\"26\": \"Bed Block\",\n\t\t\"27\": \"Powered Rail\",\n\t\t\"28\": \"Detector Rail\",\n\t\t\"29\": \"Sticky Piston\",\n\t\t\"30\": \"Web\",\n\t\t\"31\": \"Dead Shrub\",\n\t\t\"31:1\": \"Grass\",\n\t\t\"31:2\": \"Fern\",\n\t\t\"32\": \"Dead Shrub\",\n\t\t\"33\": \"Piston\",\n\t\t\"34\": \"Piston Head\",\n\t\t\"35\": \"White Wool\",\n\t\t\"35:1\": \"Orange Wool\",\n\t\t\"35:2\": \"Magenta Wool\",\n\t\t\"35:3\": \"Light Blue Wool\",\n\t\t\"35:4\": \"Yellow Wool\",\n\t\t\"35:5\": \"Lime Wool\",\n\t\t\"35:6\": \"Pink Wool\",\n\t\t\"35:7\": \"Gray Wool\",\n\t\t\"35:8\": \"Light Gray Wool\",\n\t\t\"35:9\": \"Cyan Wool\",\n\t\t\"35:10\": \"Purple Wool\",\n\t\t\"35:11\": \"Blue Wool\",\n\t\t\"35:12\": \"Brown Wool\",\n\t\t\"35:13\": \"Green Wool\",\n\t\t\"35:14\": \"Red Wool\",\n\t\t\"35:15\": \"Black Wool\",\n\t\t\"37\": \"Dandelion\",\n\t\t\"38\": \"Rose\",\n\t\t\"39\": \"Brown Mushroom\",\n\t\t\"40\": \"Red Mushroom\",\n\t\t\"41\": \"Gold Block\",\n\t\t\"42\": \"Iron Block\",\n\t\t\"43\": \"Double Stone Slab\",\n\t\t\"43:1\": \"Double Sandstone Slab\",\n\t\t\"43:2\": \"Double Wooden Slab\",\n\t\t\"43:3\": \"Double Cobblestone Slab\",\n\t\t\"43:4\": \"Double Brick Slab\",\n\t\t\"43:5\": \"Double Stone Brick Slab\",\n\t\t\"43:6\": \"Double Nether Brick Slab\",\n\t\t\"43:7\": \"Double Quartz Slab\",\n\t\t\"44\": \"Stone Slab\",\n\t\t\"44:1\": \"Sandstone Slab\",\n\t\t\"44:2\": \"Wooden Slab\",\n\t\t\"44:3\": \"Cobblestone Slab\",\n\t\t\"44:4\": \"Brick Slab\",\n\t\t\"44:5\": \"Stone Brick Slab\",\n\t\t\"44:6\": \"Nether Brick Slab\",\n\t\t\"44:7\": \"Quartz Slab\",\n\t\t\"45\": \"Brick\",\n\t\t\"46\": \"TNT\",\n\t\t\"47\": \"Bookshelf\",\n\t\t\"48\": \"Mossy Cobblestone\",\n\t\t\"49\": \"Obsidian\",\n\t\t\"50\": \"Torch\",\n\t\t\"51\": \"Fire\",\n\t\t\"52\": \"Monster Spawner\",\n\t\t\"53\": \"Oak Wood Stairs\",\n\t\t\"54\": \"Chest\",\n\t\t\"55\": \"Redstone Wire\",\n\t\t\"56\": \"Diamond Ore\",\n\t\t\"57\": \"Diamond Block\",\n\t\t\"58\": \"Workbench\",\n\t\t\"59\": \"Wheat Crops\",\n\t\t\"60\": \"Soil\",\n\t\t\"61\": \"Furnace\",\n\t\t\"62\": \"Burning Furnace\",\n\t\t\"63\": \"Sign Post\",\n\t\t\"64\": \"Wooden Door Block\",\n\t\t\"65\": \"Ladder\",\n\t\t\"66\": \"Rails\",\n\t\t\"67\": \"Cobblestone Stairs\",\n\t\t\"68\": \"Wall Sign\",\n\t\t\"69\": \"Lever\",\n\t\t\"70\": \"Stone Pressure Plate\",\n\t\t\"71\": \"Iron Door Block\",\n\t\t\"72\": \"Wooden Pressure Plate\",\n\t\t\"73\": \"Redstone Ore\",\n\t\t\"74\": \"Glowing Redstone Ore\",\n\t\t\"75\": \"Redstone Torch(off)\",\n\t\t\"76\": \"Redstone Torch(on)\",\n\t\t\"77\": \"Stone Button\",\n\t\t\"78\": \"Snow\",\n\t\t\"79\": \"Ice\",\n\t\t\"80\": \"Snow Block\",\n\t\t\"81\": \"Cactus\",\n\t\t\"82\": \"Clay\",\n\t\t\"83\": \"Sugar Cane\",\n\t\t\"84\": \"Jukebox\",\n\t\t\"85\": \"Fence\",\n\t\t\"86\": \"Pumpkin\",\n\t\t\"87\": \"Netherrack\",\n\t\t\"88\": \"Soul Sand\",\n\t\t\"89\": \"Glowstone\",\n\t\t\"90\": \"Portal\",\n\t\t\"91\": \"Jack - O - Lantern\",\n\t\t\"92\": \"Cake Block\",\n\t\t\"93\": \"Redstone Repeater Block(off)\",\n\t\t\"94\": \"Redstone Repeater Block(on)\",\n\t\t\"95\": \"Locked Chest\",\n\t\t\"96\": \"Trapdoor\",\n\t\t\"97\": \"Stone(Silverfish)\",\n\t\t\"97:1\": \"Cobblestone(Silverfish)\",\n\t\t\"97:2\": \"Stone Brick(Silverfish)\",\n\t\t\"98\": \"Stone Brick\",\n\t\t\"98:1\": \"Mossy Stone Brick\",\n\t\t\"98:2\": \"Cracked Stone Brick\",\n\t\t\"98:3\": \"Chiseled Stone Brick\",\n\t\t\"99\": \"Red Mushroom Cap\",\n\t\t\"100\": \"Brown Mushroom Cap\",\n\t\t\"101\": \"Iron Bars\",\n\t\t\"102\": \"Glass Pane\",\n\t\t\"103\": \"Melon Block\",\n\t\t\"104\": \"Pumpkin Stem\",\n\t\t\"105\": \"Melon Stem\",\n\t\t\"106\": \"Vines\",\n\t\t\"107\": \"Fence Gate\",\n\t\t\"108\": \"Brick Stairs\",\n\t\t\"109\": \"Stone Brick Stairs\",\n\t\t\"110\": \"Mycelium\",\n\t\t\"111\": \"Lily Pad\",\n\t\t\"112\": \"Nether Brick\",\n\t\t\"113\": \"Nether Brick Fence\",\n\t\t\"114\": \"Nether Brick Stairs\",\n\t\t\"115\": \"Nether Wart\",\n\t\t\"116\": \"Enchantment Table\",\n\t\t\"117\": \"Brewing Stand\",\n\t\t\"118\": \"Cauldron\",\n\t\t\"119\": \"End Portal\",\n\t\t\"120\": \"End Portal Frame\",\n\t\t\"121\": \"End Stone\",\n\t\t\"122\": \"Dragon Egg\",\n\t\t\"123\": \"Redstone Lamp(inactive)\",\n\t\t\"124\": \"Redstone Lamp(active)\",\n\t\t\"125\": \"Double Oak Wood Slab\",\n\t\t\"125:1\": \"Double Spruce Wood Slab\",\n\t\t\"125:2\": \"Double Birch Wood Slab\",\n\t\t\"125:3\": \"Double Jungle Wood Slab\",\n\t\t\"126\": \"Oak Wood Slab\",\n\t\t\"126:1\": \"Spruce Wood Slab\",\n\t\t\"126:2\": \"Birch Wood Slab\",\n\t\t\"126:3\": \"Jungle Wood Slab\",\n\t\t\"127\": \"Cocoa Plant\",\n\t\t\"128\": \"Sandstone Stairs\",\n\t\t\"129\": \"Emerald Ore\",\n\t\t\"130\": \"Ender Chest\",\n\t\t\"131\": \"Tripwire Hook\",\n\t\t\"132\": \"Tripwire\",\n\t\t\"133\": \"Emerald Block\",\n\t\t\"134\": \"Spruce Wood Stairs\",\n\t\t\"135\": \"Birch Wood Stairs\",\n\t\t\"136\": \"Jungle Wood Stairs\",\n\t\t\"137\": \"Command Block\",\n\t\t\"138\": \"Beacon Block\",\n\t\t\"139\": \"Cobblestone Wall\",\n\t\t\"139:1\": \"Mossy Cobblestone Wall\",\n\t\t\"140\": \"Flower Pot\",\n\t\t\"141\": \"Carrots\",\n\t\t\"142\": \"Potatoes\",\n\t\t\"143\": \"Wooden Button\",\n\t\t\"144\": \"Mob Head\",\n\t\t\"145\": \"Anvil\",\n\t\t\"146\": \"Trapped Chest\",\n\t\t\"147\": \"Weighted Pressure Plate(light)\",\n\t\t\"148\": \"Weighted Pressure Plate(heavy)\",\n\t\t\"149\": \"Redstone Comparator(inactive)\",\n\t\t\"150\": \"Redstone Comparator(active)\",\n\t\t\"151\": \"Daylight Sensor\",\n\t\t\"152\": \"Redstone Block\",\n\t\t\"153\": \"Nether Quartz Ore\",\n\t\t\"154\": \"Hopper\",\n\t\t\"155\": \"Quartz Block\",\n\t\t\"155:1\": \"Chiseled Quartz Block\",\n\t\t\"155:2\": \"Pillar Quartz Block\",\n\t\t\"156\": \"Quartz Stairs\",\n\t\t\"157\": \"Activator Rail\",\n\t\t\"158\": \"Dropper\",\n\t\t\"159\": \"White Stained Clay\",\n\t\t\"159:1\": \"Orange Stained Clay\",\n\t\t\"159:2\": \"Magenta Stained Clay\",\n\t\t\"159:3\": \"Light Blue Stained Clay\",\n\t\t\"159:4\": \"Yellow Stained Clay\",\n\t\t\"159:5\": \"Lime Stained Clay\",\n\t\t\"159:6\": \"Pink Stained Clay\",\n\t\t\"159:7\": \"Gray Stained Clay\",\n\t\t\"159:8\": \"Light Gray Stained Clay\",\n\t\t\"159:9\": \"Cyan Stained Clay\",\n\t\t\"159:10\": \"Purple Stained Clay\",\n\t\t\"159:11\": \"Blue Stained Clay\",\n\t\t\"159:12\": \"Brown Stained Clay\",\n\t\t\"159:13\": \"Green Stained Clay\",\n\t\t\"159:14\": \"Red Stained Clay\",\n\t\t\"159:15\": \"Black Stained Clay\",\n\t\t\"170\": \"Hay Bale\",\n\t\t\"171\": \"White Carpet\",\n\t\t\"171:1\": \"Orange Carpet\",\n\t\t\"171:2\": \"Magenta Carpet\",\n\t\t\"171:3\": \"Light Blue Carpet\",\n\t\t\"171:4\": \"Yellow Carpet\",\n\t\t\"171:5\": \"Lime Carpet\",\n\t\t\"171:6\": \"Pink Carpet\",\n\t\t\"171:7\": \"Gray Carpet\",\n\t\t\"171:8\": \"Light Gray Carpet\",\n\t\t\"171:9\": \"Cyan Carpet\",\n\t\t\"171:10\": \"Purple Carpet\",\n\t\t\"171:11\": \"Blue Carpet\",\n\t\t\"171:12\": \"Brown Carpet\",\n\t\t\"171:13\": \"Green Carpet\",\n\t\t\"171:14\": \"Red Carpet\",\n\t\t\"171:15\": \"Black Carpet\",\n\t\t\"172\": \"Hardened Clay\",\n\t\t\"173\": \"Block of Coal\",\n\t\t\"256\": \"Iron Shovel\",\n\t\t\"257\": \"Iron Pickaxe\",\n\t\t\"258\": \"Iron Axe\",\n\t\t\"259\": \"Flint and Steel\",\n\t\t\"260\": \"Apple\",\n\t\t\"261\": \"Bow\",\n\t\t\"262\": \"Arrow\",\n\t\t\"263\": \"Coal\",\n\t\t\"263:1\": \"Charcoal\",\n\t\t\"264\": \"Diamond\",\n\t\t\"265\": \"Iron Ingot\",\n\t\t\"266\": \"Gold Ingot\",\n\t\t\"267\": \"Iron Sword\",\n\t\t\"268\": \"Wooden Sword\",\n\t\t\"269\": \"Wooden Shovel\",\n\t\t\"270\": \"Wooden Pickaxe\",\n\t\t\"271\": \"Wooden Axe\",\n\t\t\"272\": \"Stone Sword\",\n\t\t\"273\": \"Stone Shovel\",\n\t\t\"274\": \"Stone Pickaxe\",\n\t\t\"275\": \"Stone Axe\",\n\t\t\"276\": \"Diamond Sword\",\n\t\t\"277\": \"Diamond Shovel\",\n\t\t\"278\": \"Diamond Pickaxe\",\n\t\t\"279\": \"Diamond Axe\",\n\t\t\"280\": \"Stick\",\n\t\t\"281\": \"Bowl\",\n\t\t\"282\": \"Mushroom Soup\",\n\t\t\"283\": \"Gold Sword\",\n\t\t\"284\": \"Gold Shovel\",\n\t\t\"285\": \"Gold Pickaxe\",\n\t\t\"286\": \"Gold Axe\",\n\t\t\"287\": \"String\",\n\t\t\"288\": \"Feather\",\n\t\t\"289\": \"Sulphur\",\n\t\t\"290\": \"Wooden Hoe\",\n\t\t\"291\": \"Stone Hoe\",\n\t\t\"292\": \"Iron Hoe\",\n\t\t\"293\": \"Diamond Hoe\",\n\t\t\"294\": \"Gold Hoe\",\n\t\t\"295\": \"Wheat Seeds\",\n\t\t\"296\": \"Wheat\",\n\t\t\"297\": \"Bread\",\n\t\t\"298\": \"Leather Helmet\",\n\t\t\"299\": \"Leather Chestplate\",\n\t\t\"300\": \"Leather Leggings\",\n\t\t\"301\": \"Leather Boots\",\n\t\t\"302\": \"Chainmail Helmet\",\n\t\t\"303\": \"Chainmail Chestplate\",\n\t\t\"304\": \"Chainmail Leggings\",\n\t\t\"305\": \"Chainmail Boots\",\n\t\t\"306\": \"Iron Helmet\",\n\t\t\"307\": \"Iron Chestplate\",\n\t\t\"308\": \"Iron Leggings\",\n\t\t\"309\": \"Iron Boots\",\n\t\t\"310\": \"Diamond Helmet\",\n\t\t\"311\": \"Diamond Chestplate\",\n\t\t\"312\": \"Diamond Leggings\",\n\t\t\"313\": \"Diamond Boots\",\n\t\t\"314\": \"Gold Helmet\",\n\t\t\"315\": \"Gold Chestplate\",\n\t\t\"316\": \"Gold Leggings\",\n\t\t\"317\": \"Gold Boots\",\n\t\t\"318\": \"Flint\",\n\t\t\"319\": \"Raw Porkchop\",\n\t\t\"320\": \"Cooked Porkchop\",\n\t\t\"321\": \"Painting\",\n\t\t\"322\": \"Golden Apple\",\n\t\t\"322:1\": \"Enchanted Golden Apple\",\n\t\t\"323\": \"Sign\",\n\t\t\"324\": \"Wooden Door\",\n\t\t\"325\": \"Bucket\",\n\t\t\"326\": \"Water Bucket\",\n\t\t\"327\": \"Lava Bucket\",\n\t\t\"328\": \"Minecart\",\n\t\t\"329\": \"Saddle\",\n\t\t\"330\": \"Iron Door\",\n\t\t\"331\": \"Redstone\",\n\t\t\"332\": \"Snowball\",\n\t\t\"333\": \"Boat\",\n\t\t\"334\": \"Leather\",\n\t\t\"335\": \"Milk Bucket\",\n\t\t\"336\": \"Clay Brick\",\n\t\t\"337\": \"Clay Balls\",\n\t\t\"338\": \"Sugarcane\",\n\t\t\"339\": \"Paper\",\n\t\t\"340\": \"Book\",\n\t\t\"341\": \"Slimeball\",\n\t\t\"342\": \"Storage Minecart\",\n\t\t\"343\": \"Powered Minecart\",\n\t\t\"344\": \"Egg\",\n\t\t\"345\": \"Compass\",\n\t\t\"346\": \"Fishing Rod\",\n\t\t\"347\": \"Clock\",\n\t\t\"348\": \"Glowstone Dust\",\n\t\t\"349\": \"Raw Fish\",\n\t\t\"350\": \"Cooked Fish\",\n\t\t\"351\": \"Ink Sack\",\n\t\t\"351:1\": \"Rose Red\",\n\t\t\"351:2\": \"Cactus Green\",\n\t\t\"351:3\": \"Coco Beans\",\n\t\t\"351:4\": \"Lapis Lazuli\",\n\t\t\"351:5\": \"Purple Dye\",\n\t\t\"351:6\": \"Cyan Dye\",\n\t\t\"351:7\": \"Light Gray Dye\",\n\t\t\"351:8\": \"Gray Dye\",\n\t\t\"351:9\": \"Pink Dye\",\n\t\t\"351:10\": \"Lime Dye\",\n\t\t\"351:11\": \"Dandelion Yellow\",\n\t\t\"351:12\": \"Light Blue Dye\",\n\t\t\"351:13\": \"Magenta Dye\",\n\t\t\"351:14\": \"Orange Dye\",\n\t\t\"351:15\": \"Bone Meal\",\n\t\t\"352\": \"Bone\",\n\t\t\"353\": \"Sugar\",\n\t\t\"354\": \"Cake\",\n\t\t\"355\": \"Bed\",\n\t\t\"356\": \"Redstone Repeater\",\n\t\t\"357\": \"Cookie\",\n\t\t\"358\": \"Map\",\n\t\t\"359\": \"Shears\",\n\t\t\"360\": \"Melon\",\n\t\t\"361\": \"Pumpkin Seeds\",\n\t\t\"362\": \"Melon Seeds\",\n\t\t\"363\": \"Raw Beef\",\n\t\t\"364\": \"Steak\",\n\t\t\"365\": \"Raw Chicken\",\n\t\t\"366\": \"Cooked Chicken\",\n\t\t\"367\": \"Rotten Flesh\",\n\t\t\"368\": \"Ender Pearl\",\n\t\t\"369\": \"Blaze Rod\",\n\t\t\"370\": \"Ghast Tear\",\n\t\t\"371\": \"Gold Nugget\",\n\t\t\"372\": \"Nether Wart Seeds\",\n\t\t\"373\": \"Potion\",\n\t\t\"374\": \"Glass Bottle\",\n\t\t\"375\": \"Spider Eye\",\n\t\t\"376\": \"Fermented Spider Eye\",\n\t\t\"377\": \"Blaze Powder\",\n\t\t\"378\": \"Magma Cream\",\n\t\t\"379\": \"Brewing Stand\",\n\t\t\"380\": \"Cauldron\",\n\t\t\"381\": \"Eye of Ender\",\n\t\t\"382\": \"Glistering Melon\",\n\t\t\"383:50\": \"Spawn Creeper\",\n\t\t\"383:51\": \"Spawn Skeleton\",\n\t\t\"383:52\": \"Spawn Spider\",\n\t\t\"383:54\": \"Spawn Zombie\",\n\t\t\"383:55\": \"Spawn Slime\",\n\t\t\"383:56\": \"Spawn Ghast\",\n\t\t\"383:57\": \"Spawn Pigman\",\n\t\t\"383:58\": \"Spawn Enderman\",\n\t\t\"383:59\": \"Spawn Cave Spider\",\n\t\t\"383:60\": \"Spawn Silverfish \",\n\t\t\"383:61\": \"Spawn Blaze\",\n\t\t\"383:62\": \"Spawn Magma Cube \",\n\t\t\"383:65\": \"Spawn Bat\",\n\t\t\"383:66\": \"Spawn Witch\",\n\t\t\"383:90\": \"Spawn Pig\",\n\t\t\"383:91\": \"Spawn Sheep\",\n\t\t\"383:92\": \"Spawn Cow\",\n\t\t\"383:93\": \"Spawn Chicken\",\n\t\t\"383:94\": \"Spawn Squid\",\n\t\t\"383:95\": \"Spawn Wolf\",\n\t\t\"383:96\": \"Spawn Mooshroom\",\n\t\t\"383:98\": \"Spawn Ocelot\",\n\t\t\"383:100\": \"Spawn Horse\",\n\t\t\"383:120\": \"Spawn Villager\",\n\t\t\"384\": \"Bottle o' Enchanting\",\n\t\t\"385\": \"Fire Charge\",\n\t\t\"386\": \"Book and Quill\",\n\t\t\"387\": \"Written Book\",\n\t\t\"388\": \"Emerald\",\n\t\t\"389\": \"Item Frame\",\n\t\t\"390\": \"Flower Pot\",\n\t\t\"391\": \"Carrots\",\n\t\t\"392\": \"Potato\",\n\t\t\"393\": \"Baked Potato\",\n\t\t\"394\": \"Poisonous Potato\",\n\t\t\"395\": \"Map\",\n\t\t\"396\": \"Golden Carrot\",\n\t\t\"397\": \"Mob Head (Skeleton)\",\n\t\t\"397:1\": \"Mob Head (Wither Skeleton)\",\n\t\t\"397:2\": \"Mob Head (Zombie)\",\n\t\t\"397:3\": \"Mob Head (Human)\",\n\t\t\"397:4\": \"Mob Head (Creeper)\",\n\t\t\"398\": \"Carrot on a Stick\",\n\t\t\"399\": \"Nether Star\",\n\t\t\"400\": \"Pumpkin Pie\",\n\t\t\"401\": \"Firework Rocket\",\n\t\t\"402\": \"Firework Star\",\n\t\t\"403\": \"Enchanted Book\",\n\t\t\"404\": \"Redstone Comparator\",\n\t\t\"405\": \"Nether Brick\",\n\t\t\"406\": \"Nether Quartz\",\n\t\t\"407\": \"Minecart with TNT\",\n\t\t\"408\": \"Minecart with Hopper\",\n\t\t\"417\": \"Iron Horse Armor\",\n\t\t\"418\": \"Gold Horse Armor\",\n\t\t\"419\": \"Diamond Horse Armor\",\n\t\t\"420\": \"Lead\",\n\t\t\"421\": \"Name Tag\"\n\t]\n}",
        "docstring": "A SmartApp that notifies you when things are happening around your SmartBlocks"
    },
    {
        "code": "preferences {\n\tpage(name: \"Credentials\", title: \"Fetch OAuth2 Credentials\", content: \"authPage\", install: false)\n\tpage(name: \"listDevices\", title: \"Quirky Devices\", content: \"listDevices\", install: false)\n}\n\nmappings {\n\tpath(\"/receivedToken\") \t\t{ action:[ POST: \"receivedToken\", \t\t\tGET: \"receivedToken\"] }\n\tpath(\"/receiveToken\") \t\t{ action:[ POST: \"receiveToken\", \t\t\tGET: \"receiveToken\"] }\n\tpath(\"/powerstripCallback\")\t{ action:[ POST: \"powerstripEventHandler\",\tGET: \"subscriberIdentifyVerification\"]}\n\tpath(\"/sensor_podCallback\") { action:[ POST: \"sensor_podEventHandler\",\tGET: \"subscriberIdentifyVerification\"]}\n\tpath(\"/piggy_bankCallback\") { action:[ POST: \"piggy_bankEventHandler\",\tGET: \"subscriberIdentifyVerification\"]}\n\tpath(\"/eggtrayCallback\") \t{ action:[ POST: \"eggtrayEventHandler\",\t\tGET: \"subscriberIdentifyVerification\"]}\n\tpath(\"/cloud_clockCallback\"){ action:[ POST: \"cloud_clockEventHandler\", GET: \"subscriberIdentifyVerification\"]}\n}\n\ndef authPage() {\n\tlog.debug \"In authPage\"\n\tif(canInstallLabs()) {\n\t\tdef description = null\n\n\t\tif (state.vendorAccessToken == null) {\n\t\t\tlog.debug \"About to create access token.\"\n\n\t\t\tcreateAccessToken()\n\t\t\tdescription = \"Tap to enter Credentials.\"\n\n\t\t\tdef redirectUrl = oauthInitUrl()\n\n\n\t\t\treturn dynamicPage(name: \"Credentials\", title: \"Authorize Connection\", nextPage:\"listDevices\", uninstall: true, install:false) {\n\t\t\t\tsection { href url:redirectUrl, style:\"embedded\", required:false, title:\"Connect to ${getVendorName()}:\", description:description }\n\t\t\t}\n\t\t} else {\n\t\t\tdescription = \"Tap 'Next' to proceed\"\n\n\t\t\treturn dynamicPage(name: \"Credentials\", title: \"Credentials Accepted!\", nextPage:\"listDevices\", uninstall: true, install:false) {\n\t\t\t\tsection { href url: buildRedirectUrl(\"receivedToken\"), style:\"embedded\", required:false, title:\"${getVendorName()} is now connected to SmartThings!\", description:description }\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tdef upgradeNeeded = \"\"\"To use SmartThings Labs, your Hub should be completely up to date.\n\nTo update your Hub, access Location Settings in the Main Menu (tap the gear next to your location name), select your Hub, and choose \"Update Hub\".\"\"\"\n\n\n\t\treturn dynamicPage(name:\"Credentials\", title:\"Upgrade needed!\", nextPage:\"\", install:false, uninstall: true) {\n\t\t\tsection {\n\t\t\t\tparagraph \"$upgradeNeeded\"\n\t\t\t}\n\t\t}\n\n\t}\n}\n\ndef oauthInitUrl() {\n\tlog.debug \"In oauthInitUrl\"\n\n\t/* OAuth Step 1: Request access code with our client ID */\n\n\tstate.oauthInitState = UUID.randomUUID().toString()\n\n\tdef oauthParams = [ response_type: \"code\",\n\t\tclient_id: getClientId(),\n\t\tstate: state.oauthInitState,\n\t\tredirect_uri: buildRedirectUrl(\"receiveToken\") ]\n\n\treturn getVendorAuthPath() + toQueryString(oauthParams)\n}\n\ndef buildRedirectUrl(endPoint) {\n\tlog.debug \"In buildRedirectUrl\"\n\n\treturn getServerUrl() + \"/api/token/${state.accessToken}/smartapps/installations/${app.id}/${endPoint}\"\n}\n\ndef receiveToken() {\n\tlog.debug \"In receiveToken\"\n\n\tdef oauthParams = [ client_secret: getClientSecret(),\n\t\tgrant_type: \"authorization_code\",\n\t\tcode: params.code ]\n\n\tdef tokenUrl = getVendorTokenPath() + toQueryString(oauthParams)\n\tdef params = [\n\t\turi: tokenUrl,\n\t]\n\n\t/* OAuth Step 2: Request access token with our client Secret and OAuth \"Code\" */\n\thttpPost(params) { response ->\n\n\t\tdef data = response.data.data\n\n\t\tstate.vendorRefreshToken = data.refresh_token //these may need to be adjusted depending on depth of returned data\n\t\tstate.vendorAccessToken = data.access_token\n\t}\n\n\tif ( !state.vendorAccessToken ) {  //We didn't get an access token, bail on install\n\t\treturn\n\t}\n\n\t/* OAuth Step 3: Use the access token to call into the vendor API throughout your code using state.vendorAccessToken. */\n\n\tdef html = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta name=\"viewport\" content=\"width=50%,height=50%,  user-scalable = yes\">\n        <title>${getVendorName()} Connection</title>\n        <style type=\"text/css\">\n            @font-face {\n                font-family: 'Swiss 721 W01 Thin';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'Swiss 721 W01 Light';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            .container {\n                width: 560px;\n                padding: 40px;\n                /*background: #eee;*/\n                text-align: center;\n            }\n            img {\n                vertical-align: middle;\n            }\n            img:nth-child(2) {\n                margin: 0 30px;\n            }\n            p {\n                font-size: 2.2em;\n                font-family: 'Swiss 721 W01 Thin';\n                text-align: center;\n                color: #666666;\n                padding: 0 40px;\n                margin-bottom: 0;\n            }\n        /*\n            p:last-child {\n                margin-top: 0px;\n            }\n        */\n            span {\n                font-family: 'Swiss 721 W01 Light';\n            }\n        </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <img src=\"\"\" + getVendorIcon() + \"\"\" alt=\"Vendor icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n                <p>We have located your \"\"\" + getVendorName() + \"\"\" account.</p>\n                <p>Tap 'Done' to process your credentials.</p>\n\t\t\t</div>\n        </body>\n        </html>\n        \"\"\"\n\trender contentType: 'text/html', data: html\n}\n\ndef receivedToken() {\n\tlog.debug \"In receivedToken\"\n\n\tdef html = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n        <meta name=\"viewport\" content=\"width=50%,height=50%,  user-scalable = yes\">\n        <title>Withings Connection</title>\n        <style type=\"text/css\">\n            @font-face {\n                font-family: 'Swiss 721 W01 Thin';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-thin-webfont.svg#swis721_th_btthin') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'Swiss 721 W01 Light';\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot');\n                src: url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.eot?#iefix') format('embedded-opentype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.woff') format('woff'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.ttf') format('truetype'),\n                     url('https://s3.amazonaws.com/smartapp-icons/Partner/fonts/swiss-721-light-webfont.svg#swis721_lt_btlight') format('svg');\n                font-weight: normal;\n                font-style: normal;\n            }\n            .container {\n                width: 560px;\n                padding: 40px;\n                /*background: #eee;*/\n                text-align: center;\n            }\n            img {\n                vertical-align: middle;\n            }\n            img:nth-child(2) {\n                margin: 0 30px;\n            }\n            p {\n                font-size: 2.2em;\n                font-family: 'Swiss 721 W01 Thin';\n                text-align: center;\n                color: #666666;\n                padding: 0 40px;\n                margin-bottom: 0;\n            }\n        /*\n            p:last-child {\n                margin-top: 0px;\n            }\n        */\n            span {\n                font-family: 'Swiss 721 W01 Light';\n            }\n        </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <img src=\"\"\" + getVendorIcon() + \"\"\" alt=\"Vendor icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/connected-device-icn%402x.png\" alt=\"connected device icon\" />\n                <img src=\"https://s3.amazonaws.com/smartapp-icons/Partner/support/st-logo%402x.png\" alt=\"SmartThings logo\" />\n                <p>Tap 'Done' to continue to Devices.</p>\n\t\t\t</div>\n        </body>\n        </html>\n        \"\"\"\n\trender contentType: 'text/html', data: html\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\n\ndef subscriberIdentifyVerification()\n{\n\tlog.debug \"In subscriberIdentifyVerification\"\n\n\tdef challengeToken = params.hub.challenge\n\n\trender contentType: 'text/plain', data: challengeToken\n}\n\ndef initialize()\n{\n\tlog.debug \"Initialized with settings: ${settings}\"\n\n\t//createAccessToken()\n\n\t//state.oauthInitState = UUID.randomUUID().toString()\n\n\tsettings.devices.each {\n\t\tdef deviceId = it\n\n\t\tstate.deviceDataArr.each {\n\t\t\tif ( it.id == deviceId ) {\n\t\t\t\tswitch(it.type) {\n\n\t\t\t\t\tcase \"powerstrip\":\n\t\t\t\t\t\tlog.debug \"we have a Pivot Power Genius\"\n\t\t\t\t\t\tcreatePowerstripChildren(it.data) //has sub-devices, so we call out to create kids\n\t\t\t\t\t\tcreateWinkSubscription( it.subsPath, it.subsSuff )\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"sensor_pod\":\n\t\t\t\t\t\tlog.debug \"we have a Spotter\"\n\t\t\t\t\t\taddChildDevice(\"wackford\", \"Quirky Wink Spotter\", deviceId, null, [name: it.name, label: it.label, completedSetup: true])\n\t\t\t\t\t\tcreateWinkSubscription( it.subsPath, it.subsSuff )\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"piggy_bank\":\n\t\t\t\t\t\tlog.debug \"we have a Piggy Bank\"\n\t\t\t\t\t\taddChildDevice(\"wackford\", \"Quirky Wink Porkfolio\", deviceId, null, [name: it.name, label: it.label, completedSetup: true])\n\t\t\t\t\t\tcreateWinkSubscription( it.subsPath, it.subsSuff )\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"eggtray\":\n\t\t\t\t\t\tlog.debug \"we have a Egg Minder\"\n\t\t\t\t\t\taddChildDevice(\"wackford\", \"Quirky Wink Eggtray\", deviceId, null, [name: it.name, label: it.label, completedSetup: true])\n\t\t\t\t\t\tcreateWinkSubscription( it.subsPath, it.subsSuff )\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"cloud_clock\":\n\t\t\t\t\t\tlog.debug \"we have a Nimbus\"\n\t\t\t\t\t\tcreateNimbusChildren(it.data) //has sub-devices, so we call out to create kids\n\t\t\t\t\t\tcreateWinkSubscription( it.subsPath, it.subsSuff )\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef getDeviceList()\n{\n\tlog.debug \"In getDeviceList\"\n\n\tdef deviceList = [:]\n\tstate.deviceDataArr = []\n\n\tapiGet(\"/users/me/wink_devices\") { response ->\n\t\tresponse.data.data.each() {\n\t\t\tif ( it.powerstrip_id ) {\n\t\t\t\tdeviceList[\"${it.powerstrip_id}\"] = it.name\n\t\t\t\tstate.deviceDataArr.push(['name'    : it.name,\n\t\t\t\t\t'id'      : it.powerstrip_id,\n\t\t\t\t\t'type'    : \"powerstrip\",\n\t\t\t\t\t'serial'  : it.serial,\n\t\t\t\t\t'data'    : it,\n\t\t\t\t\t'subsSuff': \"/powerstripCallback\",\n\t\t\t\t\t'subsPath': \"/powerstrips/${it.powerstrip_id}/subscriptions\"\n\t\t\t\t])\n\t\t\t}\n\n\t\t\t/* stubbing out these out for later release\n\t\t\tif ( it.sensor_pod_id ) {\n\t\t\t\tdeviceList[\"${it.sensor_pod_id}\"] = it.name\n\t\t\t\tstate.deviceDataArr.push(['name'   : it.name,\n\t\t\t\t\t'id'     : it.sensor_pod_id,\n\t\t\t\t\t'type'   : \"sensor_pod\",\n\t\t\t\t\t'serial' : it.serial,\n\t\t\t\t\t'data'   : it,\n\t\t\t\t\t'subsSuff': \"/sensor_podCallback\",\n\t\t\t\t\t'subsPath': \"/sensor_pods/${it.sensor_pod_id}/subscriptions\"\n\n\t\t\t\t])\n\t\t\t}\n\n\t\t\tif ( it.piggy_bank_id ) {\n\t\t\t\tdeviceList[\"${it.piggy_bank_id}\"] = it.name\n\t\t\t\tstate.deviceDataArr.push(['name'   : it.name,\n\t\t\t\t\t\t\t\t\t\t  'id'     : it.piggy_bank_id,\n\t\t\t\t\t\t\t\t\t\t  'type'   : \"piggy_bank\",\n\t\t\t\t\t\t\t\t\t\t  'serial' : it.serial,\n\t\t\t\t\t\t\t\t\t\t  'data'   : it,\n\t\t\t\t\t\t\t\t\t\t  'subsSuff': \"/piggy_bankCallback\",\n\t\t\t\t\t\t\t\t\t\t  'subsPath': \"/piggy_banks/${it.piggy_bank_id}/subscriptions\"\n\t\t\t\t])\n\t\t\t}\n\t\t\tif ( it.cloud_clock_id ) {\n\t\t\t\tdeviceList[\"${it.cloud_clock_id}\"] = it.name\n\t\t\t\tstate.deviceDataArr.push(['name'   : it.name,\n\t\t\t\t\t\t\t\t\t\t  'id'     : it.cloud_clock_id,\n\t\t\t\t\t\t\t\t\t\t  'type'   : \"cloud_clock\",\n\t\t\t\t\t\t\t\t\t\t  'serial' : it.serial,\n\t\t\t\t\t\t\t\t\t\t  'data'   : it,\n\t\t\t\t\t\t\t\t\t\t  'subsSuff': \"/cloud_clockCallback\",\n\t\t\t\t\t\t\t\t\t\t  'subsPath': \"/cloud_clocks/${it.cloud_clock_id}/subscriptions\"\n\t\t\t\t])\n\t\t\t}\n\t\t\tif ( it.eggtray_id ) {\n\t\t\t\tdeviceList[\"${it.eggtray_id}\"] = it.name\n\t\t\t\tstate.deviceDataArr.push(['name'   : it.name,\n\t\t\t\t\t\t\t\t\t\t  'id'     : it.eggtray_id,\n\t\t\t\t\t\t\t\t\t\t  'type'   : \"eggtray\",\n\t\t\t\t\t\t\t\t\t\t  'serial' : it.serial,\n\t\t\t\t\t\t\t\t\t\t  'data'   : it,\n\t\t\t\t\t\t\t\t\t\t  'subsSuff': \"/eggtrayCallback\",\n\t\t\t\t\t\t\t\t\t\t  'subsPath': \"/eggtrays/${it.eggtray_id}/subscriptions\"\n\t\t\t\t])\n\t\t\t} */\n\n\n\t\t}\n\t}\n\treturn deviceList\n}\n\nprivate removeChildDevices(delete)\n{\n\tlog.debug \"In removeChildDevices\"\n\n\tlog.debug \"deleting ${delete.size()} devices\"\n\n\tdelete.each {\n\t\tdeleteChildDevice(it.deviceNetworkId)\n\t}\n}\n\ndef uninstalled()\n{\n\tlog.debug \"In uninstalled\"\n\n\tremoveWinkSubscriptions()\n\n\tremoveChildDevices(getChildDevices())\n}\n\ndef updateWinkSubscriptions()\n{\t//since we don't know when wink subscription dies, we'll delete and recreate on every poll\n\tlog.debug \"In updateWinkSubscriptions\"\n\n\tstate.deviceDataArr.each() {\n\t\tif (it.subsPath) {\n\t\t\tdef path = it.subsPath\n\t\t\tdef suffix = it.subsSuff\n\t\t\tapiGet(it.subsPath) { response ->\n\t\t\t\tresponse.data.data.each {\n\t\t\t\t\tif ( it.subscription_id ) {\n\t\t\t\t\t\tdeleteWinkSubscription(path + \"/\", it.subscription_id)\n\t\t\t\t\t\tcreateWinkSubscription(path, suffix)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndef createWinkSubscription(path, suffix)\n{\n\tlog.debug \"In createWinkSubscription\"\n\n\tdef callbackUrl = buildCallbackUrl(suffix)\n\n\thttpPostJson([\n\t\turi : apiUrl(),\n\t\tpath: path,\n\t\tbody: ['callback': callbackUrl],\n\t\theaders : ['Authorization' : 'Bearer ' + state.vendorAccessToken]\n\t],)\n\t\t{ \tresponse ->\n\t\t\tlog.debug \"Created subscription ID ${response.data.data.subscription_id}\"\n\t\t}\n}\n\ndef deleteWinkSubscription(path, subscriptionId)\n{\n\tlog.debug \"Deleting the wink subscription ${subscriptionId}\"\n\n\thttpDelete([\n\t\turi : apiUrl(),\n\t\tpath: path + subscriptionId,\n\t\theaders : [ 'Authorization' : 'Bearer ' + state.vendorAccessToken ]\n\t],)\n\t\t{\tresponse ->\n\t\t\tlog.debug \"Subscription ${subscriptionId} deleted\"\n\t\t}\n}\n\n\ndef removeWinkSubscriptions()\n{\n\tlog.debug \"In removeSubscriptions\"\n\n\ttry {\n\t\tstate.deviceDataArr.each() {\n\t\t\tif (it.subsPath) {\n\t\t\t\tdef path = it.subsPath\n\t\t\t\tapiGet(it.subsPath) { response ->\n\t\t\t\t\tresponse.data.data.each {\n\t\t\t\t\t\tif ( it.subscription_id ) {\n\t\t\t\t\t\t\tdeleteWinkSubscription(path + \"/\", it.subscription_id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (groovyx.net.http.HttpResponseException e) {\n\t\tlog.warn \"Caught HttpResponseException: $e, with status: ${e.statusCode}\"\n\t}\n}\n\ndef buildCallbackUrl(suffix)\n{\n\tlog.debug \"In buildRedirectUrl\"\n\n\tdef serverUrl = getServerUrl()\n\treturn serverUrl + \"/api/token/${state.accessToken}/smartapps/installations/${app.id}\" + suffix\n}\n\ndef createChildDevice(deviceFile, dni, name, label)\n{\n\tlog.debug \"In createChildDevice\"\n\n\ttry {\n\t\tdef existingDevice = getChildDevice(dni)\n\t\tif(!existingDevice) {\n\t\t\tlog.debug \"Creating child\"\n\t\t\tdef childDevice = addChildDevice(\"wackford\", deviceFile, dni, null, [name: name, label: label, completedSetup: true])\n\t\t} else {\n\t\t\tlog.debug \"Device $dni already exists\"\n\t\t}\n\t} catch (e) {\n\t\tlog.error \"Error creating device: ${e}\"\n\t}\n\n}\n\ndef listDevices()\n{\n\tlog.debug \"In listDevices\"\n\n\t//login()\n\n\tdef devices = getDeviceList()\n\tlog.debug \"Device List = ${devices}\"\n\n\tdynamicPage(name: \"listDevices\", title: \"Choose devices\", install: true) {\n\t\tsection(\"Devices\") {\n\t\t\tinput \"devices\", \"enum\", title: \"Select Device(s)\", required: false, multiple: true, options: devices\n\t\t}\n\t}\n}\n\ndef apiGet(String path, Closure callback)\n{\n\thttpGet([\n\t\turi : apiUrl(),\n\t\tpath : path,\n\t\theaders : [ 'Authorization' : 'Bearer ' + state.vendorAccessToken ]\n\t],)\n\t\t{\n\t\t\tresponse ->\n\t\t\t\tcallback.call(response)\n\t\t}\n}\n\ndef apiPut(String path, cmd, Closure callback)\n{\n\thttpPutJson([\n\t\turi : apiUrl(),\n\t\tpath: path,\n\t\tbody: cmd,\n\t\theaders : [ 'Authorization' : 'Bearer ' + state.vendorAccessToken ]\n\t],)\n\n\t\t{\n\t\t\tresponse ->\n\t\t\t\tcallback.call(response)\n\t\t}\n}\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\n\t//initialize()\n\tlistDevices()\n}\n\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n\n\t//unsubscribe()\n\t//unschedule()\n\tinitialize()\n\n\tlistDevices()\n}\n\n\ndef poll(childDevice)\n{\n\tlog.debug \"In poll\"\n\tlog.debug childDevice\n\n\t//login()\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tlog.debug dni\n\n\tdef deviceType = null\n\n\tstate.deviceDataArr.each() {\n\t\tif (it.id == dni) {\n\t\t\tdeviceType = it.type\n\t\t}\n\t}\n\n\tlog.debug \"device type is: ${deviceType}\"\n\n\tswitch(deviceType) {\t//outlets are polled in unique method not here\n\n\t\tcase \"sensor_pod\":\n\t\t\tlog.debug \"Polling sensor_pod\"\n\t\t\tgetSensorPodUpdate(childDevice)\n\t\t\tlog.debug \"sensor pod status updated\"\n\t\t\tbreak\n\n\t\tcase \"piggy_bank\":\n\t\t\tlog.debug \"Polling piggy_bank\"\n\t\t\tgetPiggyBankUpdate(childDevice)\n\t\t\tlog.debug \"piggy bank status updated\"\n\t\t\tbreak\n\n\t\tcase \"eggtray\":\n\t\t\tlog.debug \"Polling eggtray\"\n\t\t\tgetEggtrayUpdate(childDevice)\n\t\t\tlog.debug \"eggtray status updated\"\n\t\t\tbreak\n\n\t}\n\tupdateWinkSubscriptions()\n}\n\ndef cToF(temp) {\n\treturn temp * 1.8 + 32\n}\n\ndef fToC(temp) {\n\treturn (temp - 32) / 1.8\n}\n\ndef dollarize(int money)\n{\n\tdef value = money.toString()\n\n\tif ( value.length() == 1 ) {\n\t\tvalue = \"00\" + value\n\t}\n\n\tif ( value.length() == 2 ) {\n\t\tvalue = \"0\" + value\n\t}\n\n\tdef newval = value.substring(0, value.length() - 2) + \".\" + value.substring(value.length()-2, value.length())\n\tvalue = newval\n\n\tdef pattern = \"\\$0.00\"\n\tdef moneyform = new DecimalFormat(pattern)\n\tString output = moneyform.format(value.toBigDecimal())\n\n\treturn output\n}\n\ndef debugEvent(message, displayEvent) {\n\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent (results)\n\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START NIMBUS SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef createNimbusChildren(deviceData)\n{\n\tlog.debug \"In createNimbusChildren\"\n\n\tdef nimbusName = deviceData.name\n\tdef deviceFile = \"Quirky-Wink-Nimbus\"\n\tdef index = 1\n\tdeviceData.dials.each {\n\t\tlog.debug \"creating dial device for ${it.dial_id}\"\n\t\tdef dialName = \"Dial ${index}\"\n\t\tdef dialLabel = \"${nimbusName} ${dialName}\"\n\t\tcreateChildDevice( deviceFile, it.dial_id, dialName, dialLabel )\n\t\tindex++\n\t}\n}\n\ndef cloud_clockEventHandler()\n{\n\tlog.debug \"In Nimbus Event Handler...\"\n\n\tdef json = request.JSON\n\tdef dials = json.dials\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n\n\tif ( dials ) {\n\t\tdials.each() {\n\t\t\tdef childDevice = getChildDevice(it.dial_id)\n\t\t\tchildDevice?.sendEvent( name : \"dial\", value : it.label , unit : \"\" )\n\t\t\tchildDevice?.sendEvent( name : \"info\", value : it.name , unit : \"\" )\n\t\t}\n\t}\n}\n\ndef pollNimbus(dni)\n{\n\n\tlog.debug \"In pollNimbus using dni # ${dni}\"\n\n\t//login()\n\n\tdef dials = null\n\n\tapiGet(\"/users/me/wink_devices\") { response ->\n\n\t\tresponse.data.data.each() {\n\t\t\tif (it.cloud_clock_id  ) {\n\t\t\t\tlog.debug \"Found Nimbus #\" + it.cloud_clock_id\n\t\t\t\tdials   = it.dials\n\t\t\t\t//log.debug dials\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( dials ) {\n\t\tdials.each() {\n\t\t\tdef childDevice = getChildDevice(it.dial_id)\n\n\t\t\tchildDevice?.sendEvent( name : \"dial\", value : it.label , unit : \"\" )\n\t\t\tchildDevice?.sendEvent( name : \"info\", value : it.name , unit : \"\" )\n\n\t\t\t//Change the tile/icon to what info is being displayed\n\t\t\tswitch(it.name) {\n\t\t\t\tcase \"Weather\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-weather\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Traffic\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-traffic\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Time\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-time\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Twitter\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-twitter\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Calendar\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-calendar\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Email\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-mail\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Facebook\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-facebook\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Instagram\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-instagram\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Fitbit\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.nimbus.quirky-nimbus-fitbit\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Egg Minder\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.egg-minder.quirky-egg-device\")\n\t\t\t\t\tbreak\n\t\t\t\tcase \"Porkfolio\":\n\t\t\t\t\tchildDevice?.setIcon(\"dial\", \"dial\",  \"st.quirky.porkfolio.quirky-porkfolio-side\")\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t\tchildDevice.save()\n\t\t}\n\t}\n\treturn\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START EGG TRAY SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getEggtrayUpdate(childDevice)\n{\n\tlog.debug \"In getEggtrayUpdate\"\n\n\tapiGet(\"/eggtrays/\" + childDevice.device.deviceNetworkId) { response ->\n\n\t\tdef data = response.data.data\n\t\tdef freshnessPeriod = data.freshness_period\n\t\tdef trayName = data.name\n\t\tlog.debug data\n\n\t\tint totalEggs = 0\n\t\tint oldEggs = 0\n\n\t\tdef now = new Date()\n\t\tdef nowUnixTime = now.getTime()/1000\n\n\t\tdata.eggs.each() { it ->\n\t\t\tif (it != 0)\n\t\t\t{\n\t\t\t\ttotalEggs++\n\n\t\t\t\tdef eggArriveDate = it\n\t\t\t\tdef eggStaleDate = eggArriveDate + freshnessPeriod\n\t\t\t\tif ( nowUnixTime > eggStaleDate ){\n\t\t\t\t\toldEggs++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint freshEggs = totalEggs - oldEggs\n\n\t\tif ( oldEggs > 0 ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"haveBadEgg\")\n\t\t\tdef msg = \"${trayName} says: \"\n\t\t\tmsg+= \"Did you know that all it takes is one bad egg? \"\n\t\t\tmsg+= \"And it looks like I found one.\\n\\n\"\n\t\t\tmsg+= \"You should probably run an Egg Report before you use any eggs.\"\n\t\t\tsendNotificationEvent(msg)\n\t\t}\n\t\tif ( totalEggs == 0 ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"noEggs\")\n\t\t\tsendNotificationEvent(\"${trayName} says:\\n'Oh no, I'm out of eggs!'\")\n\t\t\tsendNotificationEvent(msg)\n\t\t}\n\t\tif ( (freshEggs == totalEggs) && (totalEggs != 0) ) {\n\t\t\tchildDevice?.sendEvent(name:\"inventory\",value:\"goodEggs\")\n\t\t}\n\t\tchildDevice?.sendEvent( name : \"totalEggs\", value : totalEggs , unit : \"\" )\n\t\tchildDevice?.sendEvent( name : \"freshEggs\", value : freshEggs , unit : \"\" )\n\t\tchildDevice?.sendEvent( name : \"oldEggs\", value : oldEggs , unit : \"\" )\n\t}\n}\n\ndef runEggReport(childDevice)\n{\n\tapiGet(\"/eggtrays/\" + childDevice.device.deviceNetworkId) { response ->\n\n\t\tdef data = response.data.data\n\t\tdef trayName = data.name\n\t\tdef freshnessPeriod = data.freshness_period\n\t\tdef now = new Date()\n\t\tdef nowUnixTime = now.getTime()/1000\n\n\t\tdef eggArray = []\n\n\t\tdef i = 0\n\n\t\tdata.eggs.each()  { it ->\n\t\t\tif (it != 0 ) {\n\t\t\t\tdef eggArriveDate = it\n\t\t\t\tdef eggStaleDate = eggArriveDate + freshnessPeriod\n\t\t\t\tif ( nowUnixTime > eggStaleDate ){\n\t\t\t\t\teggArray.push(\"Bad  \")\n\t\t\t\t} else {\n\t\t\t\t\teggArray.push(\"Good \")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teggArray.push(\"Empty\")\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tdef msg = \" Egg Report for ${trayName}\\n\\n\"\n\t\tmsg+= \"#7:${eggArray[6]}    #14:${eggArray[13]}\\n\"\n\t\tmsg+= \"#6:${eggArray[5]}    #13:${eggArray[12]}\\n\"\n\t\tmsg+= \"#5:${eggArray[4]}    #12:${eggArray[11]}\\n\"\n\t\tmsg+= \"#4:${eggArray[3]}    #11:${eggArray[10]}\\n\"\n\t\tmsg+= \"#3:${eggArray[2]}    #10:${eggArray[9]}\\n\"\n\t\tmsg+= \"#2:${eggArray[1]}      #9:${eggArray[8]}\\n\"\n\t\tmsg+= \"#1:${eggArray[0]}      #8:${eggArray[7]}\\n\"\n\t\tmsg+= \"                 +\\n\"\n\t\tmsg+= \"              ===\\n\"\n\t\tmsg+= \"              ===\"\n\n\t\tsendNotificationEvent(msg)\n\t}\n}\n\ndef eggtrayEventHandler()\n{\n\tlog.debug \"In  eggtrayEventHandler...\"\n\n\tdef json = request.JSON\n\tdef dni = getChildDevice(json.eggtray_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni) //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START PIGGY BANK SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getPiggyBankUpdate(childDevice)\n{\n\tapiGet(\"/piggy_banks/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef status = response.data.data\n\t\tdef alertData = status.triggers\n\n\t\tif (( alertData.enabled ) && ( state.lastCheckTime )) {\n\t\t\tif ( alertData.triggered_at[0].toInteger() > state.lastCheckTime ) {\n\t\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"active\",unit:\"\")\n\t\t\t} else {\n\t\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"inactive\",unit:\"\")\n\t\t\t}\n\t\t}\n\n\t\tchildDevice?.sendEvent(name:\"goal\",value:dollarize(status.savings_goal),unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"balance\",value:dollarize(status.balance),unit:\"\")\n\n\t\tdef now = new Date()\n\t\tdef longTime = now.getTime()/1000\n\t\tstate.lastCheckTime = longTime.toInteger()\n\t}\n}\n\ndef piggy_bankEventHandler()\n{\n\tlog.debug \"In  piggy_bankEventHandler...\"\n\n\tdef json = request.JSON\n\tdef dni = getChildDevice(json.piggy_bank_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni) //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START SENSOR POD SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\ndef getSensorPodUpdate(childDevice)\n{\n\tapiGet(\"/sensor_pods/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef status = response.data.data.last_reading\n\n\t\tstatus.loudness ? childDevice?.sendEvent(name:\"sound\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"sound\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.brightness ? childDevice?.sendEvent(name:\"light\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"light\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.vibration ? childDevice?.sendEvent(name:\"acceleration\",value:\"active\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"acceleration\",value:\"inactive\",unit:\"\")\n\n\t\tstatus.external_power ? childDevice?.sendEvent(name:\"powerSource\",value:\"powered\",unit:\"\") :\n\t\t\tchildDevice?.sendEvent(name:\"powerSource\",value:\"battery\",unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"humidity\",value:status.humidity,unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"battery\",value:(status.battery * 100).toInteger(),unit:\"\")\n\n\t\tchildDevice?.sendEvent(name:\"temperature\",value:cToF(status.temperature),unit:\"F\")\n\t}\n}\n\ndef sensor_podEventHandler()\n{\n\tlog.debug \"In  sensor_podEventHandler...\"\n\n\tdef json = request.JSON\n\t//log.debug json\n\tdef dni = getChildDevice(json.sensor_pod_id)\n\n\tlog.debug \"event received from ${dni}\"\n\n\tpoll(dni)   //sometimes events are stale, poll for all latest states\n\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\n/////////////////////////////////////////////////////////////////////////\n//\t                 START POWERSTRIP SPECIFIC CODE HERE\n/////////////////////////////////////////////////////////////////////////\n\ndef powerstripEventHandler()\n{\n\tlog.debug \"In Powerstrip Event Handler...\"\n\n\tdef json = request.JSON\n\tdef outlets = json.outlets\n\n\toutlets.each() {\n\t\tdef dni = getChildDevice(it.outlet_id)\n\t\tpollOutlet(dni)   //sometimes events are stale, poll for all latest states\n\t}\n\n\tdef html = \"\"\"{\"code\":200,\"message\":\"OK\"}\"\"\"\n\trender contentType: 'application/json', data: html\n}\n\ndef pollOutlet(childDevice)\n{\n\tlog.debug \"In pollOutlet\"\n\n\t//login()\n\n\tlog.debug \"Polling powerstrip\"\n\tapiGet(\"/outlets/\" + childDevice.device.deviceNetworkId) { response ->\n\t\tdef data = response.data.data\n\t\tdata.powered ? childDevice?.sendEvent(name:\"switch\",value:\"on\") :\n\t\t\tchildDevice?.sendEvent(name:\"switch\",value:\"off\")\n\t}\n}\n\ndef on(childDevice)\n{\n\t//login()\n\n\tapiPut(\"/outlets/\" + childDevice.device.deviceNetworkId, [powered : true]) { response ->\n\t\tdef data = response.data.data\n\t\tlog.debug \"Sending 'on' to device\"\n\t}\n}\n\ndef off(childDevice)\n{\n\t//login()\n\n\tapiPut(\"/outlets/\" + childDevice.device.deviceNetworkId, [powered : false]) { response ->\n\t\tdef data = response.data.data\n\t\tlog.debug \"Sending 'off' to device\"\n\t}\n}\n\ndef createPowerstripChildren(deviceData)\n{\n\tlog.debug \"In createPowerstripChildren\"\n\n\tdef powerstripName = deviceData.name\n\tdef deviceFile = \"Quirky Wink Powerstrip\"\n\n\tdeviceData.outlets.each {\n\t\tcreateChildDevice( deviceFile, it.outlet_id, it.name, \"$powerstripName ${it.name}\" )\n\t}\n}\n\nprivate Boolean canInstallLabs()\n{\n\treturn hasAllHubsOver(\"000.011.00603\")\n}\n\nprivate Boolean hasAllHubsOver(String desiredFirmware)\n{\n\treturn realHubFirmwareVersions.every { fw -> fw >= desiredFirmware }\n}\n\nprivate List getRealHubFirmwareVersions()\n{\n\treturn location.hubs*.firmwareVersionString.findAll { it }\n}",
        "docstring": "Connect your Quirky to SmartThings."
    },
    {
        "code": "}\n\n\tpage(name: \"chooseBulbs\", title: \"Choose Bulbs to Control With SmartThings\", content: \"initialize\")\n}\n\ndef installed() {\n\tdebugOut \"Installed with settings: ${settings}\"\n\n\tunschedule()\n\tunsubscribe()\n\n\tsetupBulbs()\n\n\tdef cron = \"0 11 23 * * ?\"\n\tlog.debug \"schedule('$cron', syncronizeDevices)\"\n\tschedule(cron, syncronizeDevices)\n}\n\ndef updated() {\n\tdebugOut \"Updated with settings: ${settings}\"\n\n\tunschedule()\n\n\tsetupBulbs()\n\n\tdef cron = \"0 11 23 * * ?\"\n\tlog.debug \"schedule('$cron', syncronizeDevices)\"\n\tschedule(cron, syncronizeDevices)\n}\n\ndef uninstalled()\n{\n\tunschedule() //in case we have hanging runIn()'s\n}\n\nprivate removeChildDevices(delete)\n{\n\tdebugOut \"deleting ${delete.size()} bulbs\"\n\tdebugOut \"deleting ${delete}\"\n\tdelete.each {\n\t\tdeleteChildDevice(it.device.deviceNetworkId)\n\t}\n}\n\ndef uninstallFromChildDevice(childDevice)\n{\n\tdef errorMsg = \"uninstallFromChildDevice was called and \"\n\tif (!settings.selectedBulbs) {\n\t\tdebugOut errorMsg += \"had empty list passed in\"\n\t\treturn\n\t}\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tif ( !dni ) {\n\t\tdebugOut errorMsg += \"could not find dni of device\"\n\t\treturn\n\t}\n\n\tdef newDeviceList = settings.selectedBulbs - dni\n\tapp.updateSetting(\"selectedBulbs\", newDeviceList)\n\n\tdebugOut errorMsg += \"completed succesfully\"\n}\n\n\ndef setupBulbs() {\n\tdebugOut \"In setupBulbs\"\n\n\tdef bulbs = state.devices\n\tdef deviceFile = \"TCP Bulb\"\n\n\tselectedBulbs.each { did ->\n\t\t//see if this is a selected bulb and install it if not already\n\t\tdef d = getChildDevice(did)\n\n\t\tif(!d) {\n\t\t\tdef newBulb = bulbs.find { (it.did) == did }\n\t\t\td = addChildDevice(\"wackford\", deviceFile, did, null, [name: \"${newBulb?.name}\", label: \"${newBulb?.name}\", completedSetup: true])\n\n\t\t\t/*if ( isRoom(did) ) { //change to the multi light group icon for a room device\n\t\t\t\td.setIcon(\"switch\", \"on\",  \"st.lights.multi-light-bulb-on\")\n\t\t\t\td.setIcon(\"switch\", \"off\",  \"st.lights.multi-light-bulb-off\")\n\t\t\t\td.save()\n\t\t\t}*/\n\n\t\t} else {\n\t\t\tdebugOut \"We already added this device\"\n\t\t}\n\t}\n\n\t// Delete any that are no longer in settings\n\tdef delete = getChildDevices().findAll { !selectedBulbs?.contains(it.deviceNetworkId) }\n\tremoveChildDevices(delete)\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//syncronizeDevices()\n}\n\ndef initialize() {\n\n\tatomicState.token = \"\"\n\n\tgetToken()\n\n\tif ( atomicState.token == \"error\" ) {\n\t\treturn dynamicPage(name:\"chooseBulbs\", title:\"TCP Login Failed!\\r\\nTap 'Done' to try again\", nextPage:\"\", install:false, uninstall: false) {\n\t\t\tsection(\"\") {}\n\t\t}\n\t} else {\n\t\t\"we're good to go\"\n\t\tdebugOut \"We have Token.\"\n\t}\n\n\t//getGatewayData() //we really don't need anything from the gateway\n\n\tdeviceDiscovery()\n\n\tdef options = devicesDiscovered() ?: []\n\n\tdef msg = \"\"\"Tap 'Done' after you have selected the desired devices.\"\"\"\n\n\treturn dynamicPage(name:\"chooseBulbs\", title:\"TCP and SmartThings Connected!\", nextPage:\"\", install:true, uninstall: true) {\n\t\tsection(\"Tap Below to View Device List\") {\n\t\t\tinput \"selectedBulbs\", \"enum\", required:false, title:\"Select Bulb/Fixture\", multiple:true, options:options\n\t\t\tparagraph msg\n\t\t}\n\t}\n}\n\ndef deviceDiscovery() {\n\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token></gip>\"\n\n\tdef Params = [\n\t\tcmd: \"RoomGetCarousel\",\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tdef cmd = toQueryString(Params)\n\n\tdef rooms = \"\"\n\n\tapiPost(cmd) { response ->\n\t\trooms = response.data.gip.room\n\t}\n\n\tdebugOut \"rooms data = ${rooms}\"\n\n\tdef devices = []\n\tdef bulbIndex = 1\n\tdef lastRoomName = null\n\tdef deviceList = []\n\n\tif ( rooms[1] == null ) {\n\t\tdef roomId = rooms.rid\n\t\tdef roomName = rooms.name\n\t\tdevices  = rooms.device\n\t\tif ( devices[1] != null ) {\n\t\t\tdebugOut \"Room Device Data: did:${roomId} roomName:${roomName}\"\n\t\t\t//deviceList += [\"name\" : \"${roomName}\", \"did\" : \"${roomId}\", \"type\" : \"room\"]\n\t\t\tdevices.each({\n\t\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t\t})\n\t\t} else {\n\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t}\n\t} else {\n\t\trooms.each({\n\t\t\tdevices  = it.device\n\t\t\tdef roomName = it.name\n\t\t\tif ( devices[1] != null ) {\n\t\t\t\tdef roomId = it?.rid\n\t\t\t\tdebugOut \"Room Device Data: did:${roomId} roomName:${roomName}\"\n\t\t\t\t//deviceList += [\"name\" : \"${roomName}\", \"did\" : \"${roomId}\", \"type\" : \"room\"]\n\t\t\t\tdevices.each({\n\t\t\t\t\tdebugOut \"Bulb Device Data: did:${it?.did} room:${roomName} BulbName:${it?.name}\"\n\t\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${it?.name}\", \"did\" : \"${it?.did}\", \"type\" : \"bulb\"]\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tdebugOut \"Bulb Device Data: did:${devices?.did} room:${roomName} BulbName:${devices?.name}\"\n\t\t\t\tdeviceList += [\"name\" : \"${roomName} ${devices?.name}\", \"did\" : \"${devices?.did}\", \"type\" : \"bulb\"]\n\t\t\t}\n\t\t})\n\t}\n\tdevices = [\"devices\" : deviceList]\n\tstate.devices = devices.devices\n}\n\nMap devicesDiscovered() {\n\tdef devices =  state.devices\n\tdef map = [:]\n\tif (devices instanceof java.util.Map) {\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.did\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t} else { //backwards compatable\n\t\tdevices.each {\n\t\t\tdef value = \"${it?.name}\"\n\t\t\tdef key = it?.did\n\t\t\tmap[\"${key}\"] = value\n\t\t}\n\t}\n\tmap\n}\n\ndef getGatewayData() {\n\tdebugOut \"In getGatewayData\"\n\n\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token></gip>\"\n\n\tdef qParams = [\n\t\tcmd: \"GatewayGetInfo\",\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tdef cmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"the gateway reponse is ${response.data.gip.gateway}\"\n\t}\n\n}\n\ndef getToken() {\n\n\tatomicState.token = \"\"\n\n\tif (password) {\n\t\tdef hashedPassword = generateMD5(password)\n\n\t\tdef data = \"<gip><version>1</version><email>${username}</email><password>${hashedPassword}</password></gip>\"\n\n\t\tdef qParams = [\n\t\t\tcmd : \"GWRLogin\",\n\t\t\tdata: \"${data}\",\n\t\t\tfmt : \"json\"\n\t\t]\n\n\t\tdef cmd = toQueryString(qParams)\n\n\t\tapiPost(cmd) { response ->\n\t\t\tdef status = response.data.gip.rc\n\n\t\t\t//sendNotificationEvent(\"Get token status ${status}\")\n\n\t\t\tif (status != \"200\") {//success code = 200\n\t\t\t\tdef errorText = response.data.gip.error\n\t\t\t\tdebugOut \"Error logging into TCP Gateway. Error = ${errorText}\"\n\t\t\t\tatomicState.token = \"error\"\n\t\t\t} else {\n\t\t\t\tatomicState.token = response.data.gip.token\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.warn \"Unable to log into TCP Gateway. Error = Password is null\"\n\t\tatomicState.token = \"error\"\n\t}\n}\n\ndef apiPost(String data, Closure callback) {\n\t//debugOut \"In apiPost with data: ${data}\"\n\tdef params = [\n\t\turi: apiUrl(),\n\t\tbody: data\n\t]\n\n\thttpPost(params) {\n\t\tresponse ->\n\t\t\tdef rc = response.data.gip.rc\n\n\t\t\tif ( rc == \"200\" ) {\n\t\t\t\tdebugOut (\"Return Code = ${rc} = Command Succeeded.\")\n\t\t\t\tcallback.call(response)\n\n\t\t\t} else if ( rc == \"401\" ) {\n\t\t\t\tdebugOut \"Return Code = ${rc} = Error: User not logged in!\" //Error code from gateway\n\t\t\t\tlog.debug \"Refreshing Token\"\n\t\t\t\tgetToken()\n\t\t\t\t//callback.call(response) //stubbed out so getToken works (we had race issue)\n\n\t\t\t} else {\n\t\t\t\tlog.error \"Return Code = ${rc} = Error!\" //Error code from gateway\n\t\t\t\tsendNotificationEvent(\"TCP Lighting is having Communication Errors. Error code = ${rc}. Check that TCP Gateway is online\")\n\t\t\t\tcallback.call(response)\n\t\t\t}\n\t}\n}\n\n\n//this is not working. TCP power reporting is broken. Leave it here for future fix\ndef calculateCurrentPowerUse(deviceCapability, usePercentage) {\n\tdebugOut \"In calculateCurrentPowerUse()\"\n\n\tdebugOut \"deviceCapability: ${deviceCapability}\"\n\tdebugOut \"usePercentage: ${usePercentage}\"\n\n\tdef calcPower = usePercentage * 1000\n\tdef reportPower = calcPower.round(1) as String\n\n\tdebugOut \"report power = ${reportPower}\"\n\n\treturn reportPower\n}\n\ndef generateSha256(String s) {\n\n\tMessageDigest digest = MessageDigest.getInstance(\"SHA-256\")\n\tdigest.update(s.bytes)\n\tnew BigInteger(1, digest.digest()).toString(16).padLeft(40, '0')\n}\n\ndef generateMD5(String s) {\n\tMessageDigest digest = MessageDigest.getInstance(\"MD5\")\n\tdigest.update(s.bytes);\n\tnew BigInteger(1, digest.digest()).toString(16).padLeft(32, '0')\n}\n\nString toQueryString(Map m) {\n\treturn m.collect { k, v -> \"${k}=${URLEncoder.encode(v.toString())}\" }.sort().join(\"&\")\n}\n\ndef checkDevicesOnline(bulbs) {\n\tdebugOut \"In checkDevicesOnline()\"\n\n\tdef onlineBulbs = []\n\tdef thisBulb = []\n\n\tbulbs.each {\n\t\tdef dni = it?.did\n\t\tthisBulb = it\n\n\t\tdef data = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did></gip>\"\n\n\t\tdef qParams = [\n\t\t\tcmd: \"DeviceGetInfo\",\n\t\t\tdata: \"${data}\",\n\t\t\tfmt: \"json\"\n\t\t]\n\n\t\tdef cmd = toQueryString(qParams)\n\n\t\tdef bulbData = []\n\n\t\tapiPost(cmd) { response ->\n\t\t\tbulbData = response.data.gip\n\t\t}\n\n\t\tif ( bulbData?.offline == \"1\" ) {\n\t\t\tdebugOut \"${it?.name} is offline with offline value of ${bulbData?.offline}\"\n\n\t\t} else {\n\t\t\tdebugOut \"${it?.name} is online with offline value of ${bulbData?.offline}\"\n\t\t\tonlineBulbs += thisBulb\n\t\t}\n\t}\n\treturn onlineBulbs\n}\n\ndef syncronizeDevices() {\n\tdebugOut \"In syncronizeDevices\"\n\n\tdef update = getChildDevices().findAll { selectedBulbs?.contains(it.deviceNetworkId) }\n\n\tupdate.each {\n\t\tdef dni = getChildDevice( it.deviceNetworkId )\n\t\tdebugOut \"dni = ${dni}\"\n\n\t\tif (isRoom(dni)) {\n\t\t\tpollRoom(dni)\n\t\t} else {\n\t\t\tpoll(dni)\n\t\t}\n\t}\n}\n\nboolean isRoom(dni) {\n\tdef device = state.devices.find() {(( it.type == 'room') && (it.did == \"${dni}\"))}\n}\n\nboolean isBulb(dni) {\n\tdef device = state.devices.find() {(( it.type == 'bulb') && (it.did == \"${dni}\"))}\n}\n\ndef debugEvent(message, displayEvent) {\n\n\tdef results = [\n\t\tname: \"appdebug\",\n\t\tdescriptionText: message,\n\t\tdisplayed: displayEvent\n\t]\n\tlog.debug \"Generating AppDebug Event: ${results}\"\n\tsendEvent (results)\n\n}\n\ndef debugOut(msg) {\n\t//log.debug msg\n\t//sendNotificationEvent(msg) //Uncomment this for troubleshooting only\n}\n\n\n/**************************************************************************\n Child Device Call In Methods\n **************************************************************************/\ndef on(childDevice) {\n\tdebugOut \"On request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><rid>${dni}</rid><type>power</type><value>1</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><did>${dni}</did><type>power</type><value>1</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"ON result: ${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\ndef off(childDevice) {\n\tdebugOut \"Off request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><rid>${dni}</rid><type>power</type><value>0</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>$atomicState.token</token><did>${dni}</did><type>power</type><value>0</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\ndef setLevel(childDevice, value) {\n\tdebugOut \"setLevel request from child device\"\n\n\tdef dni = childDevice.device.deviceNetworkId\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><rid>${dni}</rid><type>level</type><value>${value}</value></gip>\"\n\t\tcmd = \"RoomSendCommand\"\n\t} else {\n\t\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did><type>level</type><value>${value}</value></gip>\"\n\t\tcmd = \"DeviceSendCommand\"\n\t}\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tdebugOut \"${response.data}\"\n\t}\n\n\t//we want to ensure syncronization between rooms and bulbs\n\t//runIn(2, \"syncronizeDevices\")\n}\n\n// Really not called from child, but called from poll() if it is a room\ndef pollRoom(dni) {\n\tdebugOut \"In pollRoom\"\n\tdef data = \"\"\n\tdef cmd = \"\"\n\tdef roomDeviceData = []\n\n\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><rid>${dni}</rid><fields>name,power,control,status,state</fields></gip>\"\n\tcmd = \"RoomGetDevices\"\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\troomDeviceData = response.data.gip\n\t}\n\n\tdebugOut \"Room Data: ${roomDeviceData}\"\n\n\tdef totalPower = 0\n\tdef totalLevel = 0\n\tdef cnt = 0\n\tdef onCnt = 0 //used to tally on/off states\n\n\troomDeviceData.device.each({\n\t\tif ( getChildDevice(it.did) ) {\n\t\t\ttotalPower += it.other.bulbpower.toInteger()\n\t\t\ttotalLevel += it.level.toInteger()\n\t\t\tonCnt += it.state.toInteger()\n\t\t\tcnt += 1\n\t\t}\n\t})\n\n\tdef avgLevel = totalLevel/cnt\n\tdef usingPower = totalPower * (avgLevel / 100) as float\n\tdef room = getChildDevice( dni )\n\n\t//the device is a room but we use same type file\n\tsendEvent( dni, [name: \"setBulbPower\",value:\"${totalPower}\"] ) //used in child device calcs\n\n\t//if all devices in room are on, room is on\n\tif ( cnt == onCnt ) { // all devices are on\n\t\tsendEvent( dni, [name: \"switch\",value:\"on\"] )\n\t\tsendEvent( dni, [name: \"power\",value:usingPower.round(1)] )\n\n\t} else { //if any device in room is off, room is off\n\t\tsendEvent( dni, [name: \"switch\",value:\"off\"] )\n\t\tsendEvent( dni, [name: \"power\",value:0.0] )\n\t}\n\n\tdebugOut \"Room Using Power: ${usingPower.round(1)}\"\n}\n\ndef poll(childDevice) {\n\tdebugOut \"In poll() with ${childDevice}\"\n\n\n\tdef dni = childDevice.device.deviceNetworkId\n\n\tdef bulbData = []\n\tdef data = \"\"\n\tdef cmd = \"\"\n\n\tif ( isRoom(dni) ) { // this is a room, not a bulb\n\t\tpollRoom(dni)\n\t\treturn\n\t}\n\n\tdata = \"<gip><version>1</version><token>${atomicState.token}</token><did>${dni}</did></gip>\"\n\tcmd = \"DeviceGetInfo\"\n\n\tdef qParams = [\n\t\tcmd: cmd,\n\t\tdata: \"${data}\",\n\t\tfmt: \"json\"\n\t]\n\n\tcmd = toQueryString(qParams)\n\n\tapiPost(cmd) { response ->\n\t\tbulbData = response.data.gip\n\t}\n\n\tdebugOut \"This Bulbs Data Return = ${bulbData}\"\n\n\tdef bulb = getChildDevice( dni )\n\n\t//set the devices power max setting to do calcs within the device type\n\tif ( bulbData.other.bulbpower )\n\t\tsendEvent( dni, [name: \"setBulbPower\",value:\"${bulbData.other.bulbpower}\"] )\n\n\tif (( bulbData.state == \"1\" ) && ( bulb?.currentValue(\"switch\") != \"on\" ))\n\t\tsendEvent( dni, [name: \"switch\",value:\"on\"] )\n\n\tif (( bulbData.state == \"0\" ) && ( bulb?.currentValue(\"switch\") != \"off\" ))\n\t\tsendEvent( dni, [name: \"switch\",value:\"off\"] )\n\n\t//if ( bulbData.level != bulb?.currentValue(\"level\")) {\n\t//\tsendEvent( dni, [name: \"level\",value: \"${bulbData.level}\"] )\n\t//    sendEvent( dni, [name: \"setLevel\",value: \"${bulbData.level}\"] )\n\t//}\n\n\tif (( bulbData.state == \"1\" ) && ( bulbData.other.bulbpower )) {\n\t\tdef levelSetting = bulbData.level as float\n\t\tdef bulbPowerMax = bulbData.other.bulbpower as float\n\t\tdef calculatedPower = bulbPowerMax * (levelSetting / 100)\n\t\tsendEvent( dni, [name: \"power\", value: calculatedPower.round(1)] )\n\t}\n\n\tif (( bulbData.state == \"0\" ) && ( bulbData.other.bulbpower ))\n\t\tsendEvent( dni, [name: \"power\", value: 0.0] )\n}",
        "docstring": "Connect your TCP bulbs to SmartThings using Cloud to Cloud integration. You must create a remote login acct on TCP Mobile App."
    },
    {
        "code": "}\n\nmappings {\n  path(\"/appInfo\") {    action: [      GET: \"getAppInfo\"    ]  }\n  path(\"/getLocation\") {    action: [      GET: \"getLoc\"    ]  }\n  path(\"/currentReport/:id\") {    action: [      GET: \"getCurrentReport\"    ]  }\n  path(\"/setTemp/:temp/:id\") {    action: [      POST: \"setTemperature\", GET: \"setTemperature\"    ]  }\n}\n\n/**\n * This API call will be leveraged by a WeatherBug Home Service to retrieve\n * data from the installed SmartApp, including the location data, and \n * a list of the devices that were authorized to be accessed.  The WeatherBug\n * Home Service will leverage this data to represent the connected devices as well as their\n * location and associated the data with a WeatherBug user account.\n * Privacy Policy: http://weatherbughome.com/privacy/\n * @return Location, including id, latitude, longitude, zip code, and name, and the list of devices\n */\ndef getAppInfo() {\n   def devices = thermostatDevice\n   def lat = location.latitude\n   def lon = location.longitude\n   if(!(devices instanceof Collection))\n   {\n     devices = [devices]\n   }\n   return [\n   \t\t\tId: UUID.randomUUID().toString(),\n            Code: 200,\n            ErrorMessage: null,\n   \t\t\tResult: [ \"Devices\": devices, \n   \t\t\t\"Location\":[\n            \t\"Id\": location.id, \n            \t\"Latitude\":lat,\n            \t\"Longitude\":lon,\n            \t\"ZipCode\":location.zipCode,\n            \t\"Name\":location.name\n                ]\n            ]\n         ]\n}\n\n/**\n * This API call will be leveraged by a WeatherBug Home Service to retrieve\n * location data from the installed SmartApp.  The WeatherBug\n * Home Service will leverage this data to associate the location to a WeatherBug Home account\n * Privacy Policy: http://weatherbughome.com/privacy/\n *\n * @return Location, including id, latitude, longitude, zip code, and name\n */\ndef getLoc() {\n   return [\n   \t\tId: UUID.randomUUID().toString(),\n        Code: 200,\n        ErrorMessage: null,\n        Result: [\n        \"Id\": location.id, \n        \"Latitude\":location.latitude,\n        \"Longitude\":location.longitude,\n        \"ZipCode\":location.zipCode,\n        \"Name\":location.name]\n    ]\n}\n\n/**\n * This API call will be leveraged by a WeatherBug Home Service to retrieve\n * thermostat data and store it for display to a WeatherBug user.\n * Privacy Policy: http://weatherbughome.com/privacy/\n *\n * @param id The id of the device to get data for\n * @return Thermostat data including temperature, set points, running modes, and operating states\n */\ndef getCurrentReport() {\n\tlog.debug \"device id parameter=\" + params.id\n    def unixTime = (int)((new Date().getTime() / 1000))\n    def device = thermostatDevice.find{ it.id == params.id}\n    \n    if(device == null)\n    {\n    \treturn [\n        \tId: UUID.randomUUID().toString(),\n            Code: 404,\n            ErrorMessage: \"Device not found. id=\" + params.id,\n            Result: null\n        ]\n    }\n    return [\n        \tId: UUID.randomUUID().toString(),\n            Code: 200,\n            ErrorMessage: null,\n            Result: [\n                DeviceId: device.id, \n                LocationId: location.id, \n                ReportType: 2, \n                ReportList: [ \n                    [Key: \"Temperature\", Value: GetOrDefault(device, \"temperature\")], \n                \t[Key: \"ThermostatSetpoint\", Value: GetOrDefault(device, \"thermostatSetpoint\")],\n                    [Key: \"CoolingSetpoint\", Value: GetOrDefault(device, \"coolingSetpoint\")],\n                    [Key: \"HeatingSetpoint\", Value: GetOrDefault(device, \"heatingSetpoint\")],\n                    [Key: \"ThermostatMode\", Value: GetOrDefault(device, \"thermostatMode\")],\n                    [Key: \"ThermostatFanMode\", Value: GetOrDefault(device, \"thermostatFanMode\")],\n                    [Key: \"ThermostatOperatingState\", Value: GetOrDefault(device, \"thermostatOperatingState\")]\n                ],\n                UnixTime: unixTime\n            ]\n        ]\n}\n\n/**\n * This API call will be leveraged by a WeatherBug Home Service to set\n * the thermostat setpoint.\n * Privacy Policy: http://weatherbughome.com/privacy/\n *\n * @param id The id of the device to set\n * @return Indication of whether the operation succeeded or failed\n \ndef setTemperature() {\n\tlog.debug \"device id parameter=\" + params.id\n\tdef device = thermostatDevice.find{ it.id == params.id}\n    if(device != null)\n    {\n        def mode = device.latestState('thermostatMode').stringValue\n        def value = params.temp as Integer\n        log.trace \"Suggested temperature: $value, $mode\"\n        if ( mode == \"cool\")\n            device.setCoolingSetpoint(value)\n        else if ( mode == \"heat\")\n            device.setHeatingSetpoint(value)           \n        return [\n        \tId: UUID.randomUUID().toString(),\n            Code: 200,\n            ErrorMessage: null,\n            Result: null\n        ]\n    }\n    return [\n        \tId: UUID.randomUUID().toString(),\n            Code : 404,\n            ErrorMessage: \"Device not found. id=\" + params.id,\n            Result: null\n        ]\n}\n*/\n\n\ndef installed() {\n\tlog.debug \"Installed with settings: ${settings}\"\n\tinitialize()\n}\n\n/**\n * The updated event will be pushed to a WeatherBug Home Service to notify the system to take appropriate action.\n * Data that will be sent includes the list of devices, and location data\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef updated() {\n\tlog.debug \"Updated with settings: ${settings}\"\n    log.debug \"Updated with state: ${state}\"\n\tlog.debug \"Updated with location ${location} ${location.id} ${location.name}\"\n    unsubscribe()\n    initialize()\n\tdef postParams = [\n\t\turi: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive/smartapp/update',\n\t\tbody:  [ \n\t\t\t\"Devices\": devices, \n\t\t\t\"Location\":[\n\t\t\t\t\"Id\": location.id, \n\t\t\t\t\"Latitude\":location.latitude,\n\t\t\t\t\"Longitude\":location.longitude,\n\t\t\t\t\"ZipCode\":location.zipCode,\n\t\t\t\t\"Name\":location.name\n\t\t\t]\n\t   ]\n    ]\n    sendToWeatherBug(postParams)\n}\n\n/*\n* Subscribe to changes on the thermostat attributes\n*/\ndef initialize() {\n\tlog.trace \"initialize enter\"\n    subscribe(thermostatDevice, \"heatingSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"coolingSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatSetpoint\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatMode\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatFanMode\", pushLatest)\n    subscribe(thermostatDevice, \"thermostatOperatingState\", pushLatest)\n    subscribe(thermostatDevice, \"temperature\", pushLatest)\n}\n\n/**\n * The uninstall event will be pushed to a WeatherBug Home Service to notify the system to take appropriate action.\n * Data that will be sent includes the list of devices, and location data\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef uninstalled() {\n\tlog.trace \"uninstall entered\"\n    def postParams = [\n    \turi: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive/smartapp/delete',\n        body:  [ \n        \t\"Devices\": devices, \n            \"Location\":[\n                \"Id\": location.id, \n                \"Latitude\":location.latitude,\n                \"Longitude\":location.longitude,\n                \"ZipCode\":location.zipCode,\n                \"Name\":location.name\n            ]\n       ]\n    ]\n    sendToWeatherBug(postParams)\n}\n\n/**\n * This method will push the latest thermostat data to the WeatherBug Home Service so it can store\n * and display the data to the WeatherBug user.  Data pushed includes the thermostat data as well\n * as location id.\n * Privacy Policy: http://weatherbughome.com/privacy/\n */\ndef pushLatest(evt) {\n\tdef unixTime = (int)((new Date().getTime() / 1000))\n    def device = thermostatDevice.find{ it.id == evt.deviceId}\n    def postParams = [\n        uri: 'https://smartthingsrec.api.earthnetworks.com/api/v1/receive',\n        body: [\n        \tDeviceId: evt.deviceId, \n            LocationId: location.id,\n            ReportType: 2, \n            ReportList: [ \n        \t\t[Key: \"Temperature\", Value: GetOrDefault(device, \"temperature\")], \n                [Key: \"ThermostatSetpoint\", Value: GetOrDefault(device, \"thermostatSetpoint\")],\n        \t\t[Key: \"CoolingSetpoint\", Value: GetOrDefault(device, \"coolingSetpoint\")],\n        \t\t[Key: \"HeatingSetpoint\", Value: GetOrDefault(device, \"heatingSetpoint\")],\n                [Key: \"ThermostatMode\", Value: GetOrDefault(device, \"thermostatMode\")],\n                [Key: \"ThermostatFanMode\", Value: GetOrDefault(device, \"thermostatFanMode\")],\n                [Key: \"ThermostatOperatingState\", Value: GetOrDefault(device, \"thermostatOperatingState\")]\n        \t], \n            UnixTime: unixTime\n        ]\n    ]\n    log.debug postParams\n    sendToWeatherBug(postParams)\n}\n\n/*\n* This method attempts to get the value of a device attribute, but if an error occurs null is returned\n* @return The device attribute value, or null\n*/\ndef GetOrDefault(device, attrib)\n{\n\tdef val\n \ttry{\n    \tval = device.latestValue(attrib)\n    \n    }catch(ex)\n    {\n        log.debug \"Failed to get attribute \" + attrib + \" from device \" + device\n        val = null\n    }\n    return val\n}\n\n/*\n* Convenience method that sends data to WeatherBug, logging any exceptions that may occur\n* Privacy Policy: http://weatherbughome.com/privacy/\n*/\ndef sendToWeatherBug(postParams)\n{\n \ttry{\n    \tlog.debug postParams\n        httpPostJson(postParams) { resp ->\n        \tresp.headers.each {\n           log.debug \"${it.name} : ${it.value}\"\n        }\n        log.debug \"response contentType: ${resp.contentType}\"\n        log.debug \"response data: ${resp.data}\"\n        }\n        log.debug \"Communication with WeatherBug succeeded\";\n    \n    }catch(ex)\n    {\n        log.debug \"Communication with WeatherBug failed.\\n${ex}\";\n    }\n}",
        "docstring": "WeatherBug Home"
    }
]